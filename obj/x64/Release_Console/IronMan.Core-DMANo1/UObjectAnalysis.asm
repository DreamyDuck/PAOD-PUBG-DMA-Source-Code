; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	?CopyMap2@Analysis@IronMan@@3PEAXEA		; IronMan::Analysis::CopyMap2
EXTRN	?x86RegData@asmjit@@3UX86RegData@1@B:BYTE	; asmjit::x86RegData
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
_BSS	SEGMENT
?CopyMap2@Analysis@IronMan@@3PEAXEA DQ 01H DUP (?)	; IronMan::Analysis::CopyMap2
_BSS	ENDS
CONST	SEGMENT
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
CONST	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z		; std::tuple<>::tuple<>
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Decref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Decwref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?Align@@YA_K_K0@Z				; Align
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?IsCondJump@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::IsCondJump
PUBLIC	?IsJump@Zydis@IronMan@@QEBA_NXZ			; IronMan::Zydis::IsJump
PUBLIC	?getArch@CodeGen@asmjit@@QEBAIXZ		; asmjit::CodeGen::getArch
PUBLIC	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z		; asmjit::IntUtil::pack32_4x8
PUBLIC	?pack64_2x32@IntUtil@asmjit@@SA_KII@Z		; asmjit::IntUtil::pack64_2x32
PUBLIC	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z	; asmjit::UInt64::setPacked_2x32
PUBLIC	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::Operand::Operand
PUBLIC	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id
PUBLIC	?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z	; asmjit::Operand::_init_packed_d2_d3
PUBLIC	?getRegIndex@Reg@asmjit@@QEBAIXZ		; asmjit::Reg::getRegIndex
PUBLIC	??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::BaseMem::BaseMem
PUBLIC	??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z	; asmjit::X86Mem::X86Mem
PUBLIC	?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z ; asmjit::X86Mem::_getGpdFlags
PUBLIC	?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z ; asmjit::X86Assembler::add
PUBLIC	?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::mov
PUBLIC	?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z ; asmjit::X86Assembler::mov
PUBLIC	?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z ; asmjit::X86Assembler::mov
PUBLIC	?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::rol
PUBLIC	?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::ror
PUBLIC	?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::shl
PUBLIC	?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::shr
PUBLIC	?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z ; asmjit::X86Assembler::sub
PUBLIC	?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::xor_
PUBLIC	??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z ; IronMan::AsmStackAllocator::AsmStackAllocator
PUBLIC	?getTotalSize@AsmStackAllocator@IronMan@@QEBA_JXZ ; IronMan::AsmStackAllocator::getTotalSize
PUBLIC	?assembler@IAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::assembler
PUBLIC	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
PUBLIC	?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ ; IronMan::AsmFactory::GetAssembler
PUBLIC	??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z ; std::default_delete<IronMan::IAsmHelper>::operator()
PUBLIC	??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >
PUBLIC	?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::get_deleter
PUBLIC	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
PUBLIC	??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator->
PUBLIC	?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Get_first
PUBLIC	??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::`scalar deleting destructor'
PUBLIC	??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><std::default_delete<IronMan::IAsmHelper>,0>
PUBLIC	??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ ; std::make_unique<IronMan::AsmHelper64,0>
PUBLIC	??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z ; std::default_delete<IronMan::AsmHelper64>::operator()
PUBLIC	??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::~unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >
PUBLIC	?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::get_deleter
PUBLIC	?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Get_first
PUBLIC	??$?0VAsmHelper64@IronMan@@$0A@@?$default_delete@VIAsmHelper@IronMan@@@std@@QEAA@AEBU?$default_delete@VAsmHelper64@IronMan@@@1@@Z ; std::default_delete<IronMan::IAsmHelper>::default_delete<IronMan::IAsmHelper><IronMan::AsmHelper64,0>
PUBLIC	??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64>,0>
PUBLIC	?GetEntryPoint@AnalysisBase@Analysis@IronMan@@UEBA?B_KXZ ; IronMan::Analysis::AnalysisBase::GetEntryPoint
PUBLIC	??0AnalysisBase@Analysis@IronMan@@IEAA@XZ	; IronMan::Analysis::AnalysisBase::AnalysisBase
PUBLIC	?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z ; IronMan::Analysis::AnalysisBase::inRange
PUBLIC	??0?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
PUBLIC	??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::push_back
PUBLIC	?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::empty
PUBLIC	?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
PUBLIC	?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::capacity
PUBLIC	?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@0@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first
PUBLIC	??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z	; IronMan::Analysis::AnalysisBase::`scalar deleting destructor'
PUBLIC	??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z		; std::_Func_class<void,void *>::operator()
PUBLIC	??1?$_Func_class@XPEAX@std@@QEAA@XZ		; std::_Func_class<void,void *>::~_Func_class<void,void *>
PUBLIC	?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ	; std::_Func_class<void,void *>::_Empty
PUBLIC	?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ		; std::_Func_class<void,void *>::_Tidy
PUBLIC	?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ	; std::_Func_class<void,void *>::_Local
PUBLIC	?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ ; std::_Func_class<void,void *>::_Getimpl
PUBLIC	?_Set@?$_Func_class@XPEAX@std@@AEAAXPEAV?$_Func_base@XPEAX@2@@Z ; std::_Func_class<void,void *>::_Set
PUBLIC	??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ	; std::function<void __cdecl(void *)>::operator bool
PUBLIC	??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ		; std::function<void __cdecl(void *)>::~function<void __cdecl(void *)>
PUBLIC	??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z ; IronMan::Analysis::UObjectAnalysis::InstructionInfo::InstructionInfo
PUBLIC	??0?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate
PUBLIC	?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA?AV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::select_on_container_copy_construction
PUBLIC	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::push_back
PUBLIC	??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator=
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Clear_and_reserve_geometric
PUBLIC	?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::clear
PUBLIC	?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::begin
PUBLIC	?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::end
PUBLIC	?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::empty
PUBLIC	?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::size
PUBLIC	?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
PUBLIC	?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::capacity
PUBLIC	??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator[]
PUBLIC	?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back
PUBLIC	?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back
PUBLIC	?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_nonzero
PUBLIC	?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Change_array
PUBLIC	?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Tidy
PUBLIC	?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
PUBLIC	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
PUBLIC	?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Make_iterator_offset
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@00@Z ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first
PUBLIC	??0?$allocator@W4ZydisRegister_@@@std@@QEAA@XZ	; std::allocator<enum ZydisRegister_>::allocator<enum ZydisRegister_>
PUBLIC	?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::deallocate
PUBLIC	?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA_KAEBV?$allocator@W4ZydisRegister_@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA?AV?$allocator@W4ZydisRegister_@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::select_on_container_copy_construction
PUBLIC	??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
PUBLIC	??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
PUBLIC	??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
PUBLIC	??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
PUBLIC	?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::push_back
PUBLIC	??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator=
PUBLIC	?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Clear_and_reserve_geometric
PUBLIC	?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::begin
PUBLIC	?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end
PUBLIC	?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::size
PUBLIC	?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size
PUBLIC	?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::capacity
PUBLIC	??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator[]
PUBLIC	?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_nonzero
PUBLIC	?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Change_array
PUBLIC	?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Tidy
PUBLIC	?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAXPEAW4ZydisRegister_@@0@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Orphan_range
PUBLIC	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
PUBLIC	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@00@Z ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first
PUBLIC	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
PUBLIC	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
PUBLIC	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo
PUBLIC	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
PUBLIC	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
PUBLIC	??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::operator=
PUBLIC	?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ ; IronMan::Analysis::UObjectAnalysis::Analyse
PUBLIC	?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z ; IronMan::Analysis::UObjectAnalysis::Build
PUBLIC	?GetEntryPoint@UObjectAnalysis@Analysis@IronMan@@UEBA?B_KXZ ; IronMan::Analysis::UObjectAnalysis::GetEntryPoint
PUBLIC	?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ ; IronMan::Analysis::UObjectAnalysis::analyseDecrypttions
PUBLIC	??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z	; IronMan::Analysis::UObjectAnalysis::UObjectAnalysis
PUBLIC	??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ	; IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis
PUBLIC	?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::begin
PUBLIC	?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::end
PUBLIC	?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::empty
PUBLIC	?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
PUBLIC	?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
PUBLIC	?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert
PUBLIC	??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::operator[]
PUBLIC	??0?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::deallocate
PUBLIC	?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
PUBLIC	??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::push_back
PUBLIC	?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::begin
PUBLIC	?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::end
PUBLIC	?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::empty
PUBLIC	?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::size
PUBLIC	?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
PUBLIC	?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::capacity
PUBLIC	??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[]
PUBLIC	?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Change_array
PUBLIC	?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Tidy
PUBLIC	?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@0@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Orphan_range
PUBLIC	?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
PUBLIC	?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first
PUBLIC	??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
PUBLIC	??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
PUBLIC	??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z ; IronMan::Analysis::UObjectAnalysis::`scalar deleting destructor'
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
PUBLIC	??1BaseProcessInfo@IronMan@@QEAA@XZ		; IronMan::BaseProcessInfo::~BaseProcessInfo
PUBLIC	?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
PUBLIC	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
PUBLIC	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ		; IronMan::GetDMA
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
PUBLIC	??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
PUBLIC	??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
PUBLIC	??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::`scalar deleting destructor'
PUBLIC	??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z ; std::operator!=<void __cdecl(void *)>
PUBLIC	??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > &>
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::max_size
PUBLIC	??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::~_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Unchecked_begin
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::max_size
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
PUBLIC	??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ; std::less<enum ZydisRegister_>::operator()
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Min
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Extract
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Insert_node
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Orphan_ptr
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Get_first
PUBLIC	??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
PUBLIC	??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::operator[]
PUBLIC	??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::~map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator!=
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator!=
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
PUBLIC	??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Eqrange<enum ZydisRegister_>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::operator==
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Compat
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Seek_to
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Unwrapped
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_>
PUBLIC	??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
PUBLIC	??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::operator()
PUBLIC	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
PUBLIC	?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Empty
PUBLIC	?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Tidy
PUBLIC	?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Local
PUBLIC	?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl
PUBLIC	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
PUBLIC	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::~function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Unwrapped
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
PUBLIC	??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,0>
PUBLIC	??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Try_emplace<enum ZydisRegister_ const &>
PUBLIC	??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find<enum ZydisRegister_>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1><>
PUBLIC	??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo><int,IronMan::Analysis::UObjectAnalysis::DecryptInfo,0>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
PUBLIC	??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_one_at_back<enum ZydisRegister_ const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
PUBLIC	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_one_at_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><>
PUBLIC	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z	; std::forward<void *>
PUBLIC	??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_one_at_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1><>
PUBLIC	??$forward@_N@std@@YA$$QEA_NAEA_N@Z		; std::forward<bool>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
PUBLIC	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
PUBLIC	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >
PUBLIC	??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1><std::less<enum ZydisRegister_> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	??$move@AEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> &>
PUBLIC	??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_one_at_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >
PUBLIC	??$addressof@$$CBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@YAPEBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > const >
PUBLIC	??$_Pocca@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXAEAV?$allocator@W4ZydisRegister_@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<enum ZydisRegister_> >
PUBLIC	??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Assign_counted_range<enum ZydisRegister_ *>
PUBLIC	??$addressof@$$CBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > const >
PUBLIC	??$_Pocca@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Assign_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$swap@D$0A@@std@@YAXAEAD0@Z			; std::swap<char,0>
PUBLIC	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z		; std::_Get_size_of_n<40>
PUBLIC	??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> ><std::default_delete<IronMan::AsmHelper64>,0>
PUBLIC	??$forward@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VAsmHelper64@IronMan@@@0@AEAU10@@Z ; std::forward<std::default_delete<IronMan::AsmHelper64> >
PUBLIC	??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *>
PUBLIC	??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>
PUBLIC	??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > &>
PUBLIC	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > const &>
PUBLIC	??$_Find_unchecked@PEAW4ZydisRegister_@@W41@@std@@YAPEAW4ZydisRegister_@@PEAW41@QEAW41@AEBW41@@Z ; std::_Find_unchecked<enum ZydisRegister_ *,enum ZydisRegister_>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_ *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > &>
PUBLIC	??$distance@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA_JPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ; std::distance<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find_lower_bound<enum ZydisRegister_>
PUBLIC	??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Lower_bound_duplicate<enum ZydisRegister_>
PUBLIC	??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &,bool,0>
PUBLIC	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
PUBLIC	??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z ; std::forward_as_tuple<enum ZydisRegister_ const &>
PUBLIC	??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &>
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > ><std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >
PUBLIC	??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool,0>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_back_with_unused_capacity<enum ZydisRegister_ const &>
PUBLIC	??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_reallocate<enum ZydisRegister_ const &>
PUBLIC	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back_with_unused_capacity<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
PUBLIC	??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_reallocate<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
PUBLIC	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_reallocate<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >
PUBLIC	??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> &>
PUBLIC	??$forward@AEBU?$less@W4ZydisRegister_@@@std@@@std@@YAAEBU?$less@W4ZydisRegister_@@@0@AEBU10@@Z ; std::forward<std::less<enum ZydisRegister_> const &>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z ; std::_Unfancy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::destroy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back_with_unused_capacity<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_reallocate<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
PUBLIC	??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
PUBLIC	??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ; std::_Copy_memmove_n<enum ZydisRegister_ *,enum ZydisRegister_ *>
PUBLIC	??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ; std::_Copy_n_unchecked4<enum ZydisRegister_ *,unsigned __int64,enum ZydisRegister_ *>
PUBLIC	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
PUBLIC	??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ; std::_Copy_memmove_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ; std::_Copy_n_unchecked4<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,unsigned __int64,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::destroy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
PUBLIC	??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z ; std::addressof<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
PUBLIC	??$destroy@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::destroy<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
PUBLIC	??$move@AEAD@std@@YA$$QEADAEAD@Z		; std::move<char &>
PUBLIC	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
PUBLIC	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::nullptr_t>
PUBLIC	??$_Unfancy_maybe_null@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy_maybe_null<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	??$_Unfancy_maybe_null@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy_maybe_null<enum ZydisRegister_>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > const >
PUBLIC	??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_> >
PUBLIC	??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Construct_n<enum ZydisRegister_ * const &,enum ZydisRegister_ * const &>
PUBLIC	??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Construct_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &,IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
PUBLIC	??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<IronMan::AsmHelper64 *,std::nullptr_t>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<enum ZydisRegister_> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1><IronMan::AsmHelper64 * &>
PUBLIC	??$forward@PEAVAsmHelper64@IronMan@@@std@@YA$$QEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z ; std::forward<IronMan::AsmHelper64 *>
PUBLIC	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
PUBLIC	??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::forward<enum ZydisRegister_ *>
PUBLIC	??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Move_backward_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard
PUBLIC	??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Move_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>
PUBLIC	??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><enum ZydisRegister_ const &,0>
PUBLIC	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$forward@V?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ; std::forward<std::tuple<enum ZydisRegister_ const &> >
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::construct<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
PUBLIC	??$forward@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
PUBLIC	??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z ; std::_Construct_in_place<enum ZydisRegister_,enum ZydisRegister_ const &>
PUBLIC	??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
PUBLIC	??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ const &>
PUBLIC	??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
PUBLIC	??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::_Construct_in_place<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
PUBLIC	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
PUBLIC	??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::construct<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z ; std::_Construct_in_place<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::construct<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Release
PUBLIC	??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_ &>
PUBLIC	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
PUBLIC	??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z ; std::_Copy_memmove_tail<enum ZydisRegister_ *>
PUBLIC	??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Release
PUBLIC	??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
PUBLIC	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z ; std::_Copy_memmove_tail<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
PUBLIC	??$forward@V?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ; std::forward<std::allocator<enum ZydisRegister_> >
PUBLIC	??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >::~_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >
PUBLIC	??$forward@AEBQEAW4ZydisRegister_@@@std@@YAAEBQEAW4ZydisRegister_@@AEBQEAW41@@Z ; std::forward<enum ZydisRegister_ * const &>
PUBLIC	??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_copy<enum ZydisRegister_ *,enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
PUBLIC	??$forward@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ; std::forward<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::~_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
PUBLIC	??$forward@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
PUBLIC	??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
PUBLIC	??$_Deallocate@$07@std@@YAXPEAX_K@Z		; std::_Deallocate<8>
PUBLIC	??$_Refancy_maybe_null@PEAW4ZydisRegister_@@$0A@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Refancy_maybe_null<enum ZydisRegister_ *,0>
PUBLIC	??$_Get_size_of_n@$03@std@@YA_K_K@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z		; std::_Get_size_of_n<1488>
PUBLIC	??$forward@AEAPEAVAsmHelper64@IronMan@@@std@@YAAEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z ; std::forward<IronMan::AsmHelper64 * &>
PUBLIC	??$_Get_unwrapped@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_TAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
PUBLIC	??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
PUBLIC	??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Copy_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Copy_backward_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><std::_Exact_args_t,enum ZydisRegister_ const &,0>
PUBLIC	??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><enum ZydisRegister_ const &>
PUBLIC	??$addressof@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@AEAW41@@Z ; std::addressof<enum ZydisRegister_>
PUBLIC	??$_Get_unwrapped@AEBQEAW4ZydisRegister_@@@std@@YA?A_TAEBQEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ * const &>
PUBLIC	??$move@AEAW4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::move<enum ZydisRegister_ &>
PUBLIC	??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z ; std::_Copy_memmove<enum ZydisRegister_ *,enum ZydisRegister_ *>
PUBLIC	??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_>
PUBLIC	??$addressof@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::addressof<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	??$addressof@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::addressof<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@@Z ; std::_Get_unwrapped<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Release
PUBLIC	??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
PUBLIC	??$addressof@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$_Get_unwrapped@AEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA?A_TAEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Get_unwrapped<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Release
PUBLIC	??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
PUBLIC	??$forward@AEAW4ZydisRegister_@@@std@@YAAEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_ &>
PUBLIC	??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ &>
PUBLIC	??$forward@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
PUBLIC	??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
PUBLIC	??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z		; std::_Get_size_of_n<88>
PUBLIC	??$move@AEAV?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ; std::move<std::allocator<enum ZydisRegister_> &>
PUBLIC	??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z ; std::exchange<enum ZydisRegister_ *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_>,enum ZydisRegister_ *,enum ZydisRegister_ *,enum ZydisRegister_ *>
PUBLIC	??$move@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ; std::move<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> &>
PUBLIC	??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z ; std::exchange<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$forward@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VIAsmHelper@IronMan@@@0@AEAU10@@Z ; std::forward<std::default_delete<IronMan::IAsmHelper> >
PUBLIC	??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *>
PUBLIC	??$forward@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z ; std::_Tuple_val<enum ZydisRegister_ const &>::_Tuple_val<enum ZydisRegister_ const &><enum ZydisRegister_ const &>
PUBLIC	??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><std::tuple<enum ZydisRegister_ const &>,std::tuple<>,0>
PUBLIC	??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_>
PUBLIC	??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_>
PUBLIC	??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
PUBLIC	??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<IronMan::IAsmHelper *,std::nullptr_t>
PUBLIC	??$forward@PEAVIAsmHelper@IronMan@@@std@@YA$$QEAPEAVIAsmHelper@IronMan@@AEAPEAV12@@Z ; std::forward<IronMan::IAsmHelper *>
PUBLIC	??$move@AEAV?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ; std::move<std::tuple<enum ZydisRegister_ const &> &>
PUBLIC	??$_Tuple_get@$0A@AEBW4ZydisRegister_@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@@Z ; std::_Tuple_get<0,enum ZydisRegister_ const &>
PUBLIC	?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_7AnalysisBase@Analysis@IronMan@@6B@		; IronMan::Analysis::AnalysisBase::`vftable'
PUBLIC	??_7UObjectAnalysis@Analysis@IronMan@@6B@	; IronMan::Analysis::UObjectAnalysis::`vftable'
PUBLIC	?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A ; IronMan::DMAHandler::UpdateStartTime
PUBLIC	?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterWriteArray
PUBLIC	?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterReadArray
PUBLIC	?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A ; IronMan::DMAHandler::processInfo
PUBLIC	??_C@_0BC@HNPCLLDA@address?5invalid?52@		; `string'
PUBLIC	??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ ; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4AnalysisBase@Analysis@IronMan@@6B@		; IronMan::Analysis::AnalysisBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAnalysisBase@Analysis@IronMan@@@8	; IronMan::Analysis::AnalysisBase `RTTI Type Descriptor'
PUBLIC	??_R3AnalysisBase@Analysis@IronMan@@8		; IronMan::Analysis::AnalysisBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AnalysisBase@Analysis@IronMan@@8		; IronMan::Analysis::AnalysisBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AnalysisBase@Analysis@IronMan@@8	; IronMan::Analysis::AnalysisBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4UObjectAnalysis@Analysis@IronMan@@6B@	; IronMan::Analysis::UObjectAnalysis::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUObjectAnalysis@Analysis@IronMan@@@8	; IronMan::Analysis::UObjectAnalysis `RTTI Type Descriptor'
PUBLIC	??_R3UObjectAnalysis@Analysis@IronMan@@8	; IronMan::Analysis::UObjectAnalysis::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UObjectAnalysis@Analysis@IronMan@@8	; IronMan::Analysis::UObjectAnalysis::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UObjectAnalysis@Analysis@IronMan@@8 ; IronMan::Analysis::UObjectAnalysis::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	_purecall:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	?_Xbad_function_call@std@@YAXXZ:PROC		; std::_Xbad_function_call
EXTRN	_Xtime_get_ticks:PROC
EXTRN	?Print@Console@IronMan@@YA_NPEBDZZ:PROC		; IronMan::Console::Print
EXTRN	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ:PROC ; IronMan::Utils::FormatString
EXTRN	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z:PROC	; IronMan::Utils::IsSafeReadPtr
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	??0Zydis@IronMan@@QEAA@XZ:PROC			; IronMan::Zydis::Zydis
EXTRN	??1Zydis@IronMan@@QEAA@XZ:PROC			; IronMan::Zydis::~Zydis
EXTRN	?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z:PROC	; IronMan::Zydis::Disassemble
EXTRN	?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ:PROC ; IronMan::Zydis::GetInstr
EXTRN	?Size@Zydis@IronMan@@QEBAHXZ:PROC		; IronMan::Zydis::Size
EXTRN	?Address@Zydis@IronMan@@QEBA_KXZ:PROC		; IronMan::Zydis::Address
EXTRN	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ:PROC ; IronMan::Zydis::GetId
EXTRN	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z:PROC ; IronMan::Zydis::operator[]
EXTRN	?IsBranchType@Zydis@IronMan@@QEBA_NI@Z:PROC	; IronMan::Zydis::IsBranchType
EXTRN	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z:PROC ; asmjit::Assembler::emit
EXTRN	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z:PROC ; asmjit::Assembler::emit
EXTRN	??0AsmHelper64@IronMan@@QEAA@XZ:PROC		; IronMan::AsmHelper64::AsmHelper64
EXTRN	??1AnalysisBase@Analysis@IronMan@@UEAA@XZ:PROC	; IronMan::Analysis::AnalysisBase::~AnalysisBase
EXTRN	?GpRegTo64@AnalysisBase@Analysis@IronMan@@IEAA?AW4ZydisRegister_@@W44@@Z:PROC ; IronMan::Analysis::AnalysisBase::GpRegTo64
EXTRN	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z:PROC ; IronMan::Analysis::AnalysisBase::ToGpReg
EXTRN	??_EAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z:PROC ; IronMan::Analysis::AnalysisBase::`vector deleting destructor'
EXTRN	??_EUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z:PROC ; IronMan::Analysis::UObjectAnalysis::`vector deleting destructor'
EXTRN	?Instance@DMAHandler@IronMan@@SAAEAV12@XZ:PROC	; IronMan::DMAHandler::Instance
EXTRN	?Read@DMAHandler@IronMan@@QEBAH_K00@Z:PROC	; IronMan::DMAHandler::Read
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
_BSS	ENDS
;	COMDAT ?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A
_BSS	SEGMENT
?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A DQ 01H DUP (?) ; IronMan::DMAHandler::UpdateStartTime
_BSS	ENDS
;	COMDAT ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A
_BSS	SEGMENT
?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A DB 038H DUP (?) ; IronMan::DMAHandler::processInfo
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decwref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Decwref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Align@@YA_K_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$?Align@@YA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_tree_length_error@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Throw_tree_length_error@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsCondJump@Zydis@IronMan@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?IsCondJump@Zydis@IronMan@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsJump@Zydis@IronMan@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?IsJump@Zydis@IronMan@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z DD imagerel ?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z
	DD	imagerel ?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z+55
	DD	imagerel $unwind$?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ DD imagerel $LN6
	DD	imagerel $LN6+90
	DD	imagerel $unwind$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA DD imagerel ?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA
	DD	imagerel ?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ DD imagerel $LN8
	DD	imagerel $LN8+113
	DD	imagerel $unwind$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA DD imagerel ?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA
	DD	imagerel ?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA DD imagerel ?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA
	DD	imagerel ?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA+38
	DD	imagerel $unwind$?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA DD imagerel ?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA DD imagerel ?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+242
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+205
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Func_class@XPEAX@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Func_class@XPEAX@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+173
	DD	imagerel $unwind$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+311
	DD	imagerel $unwind$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+154
	DD	imagerel $unwind$??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+264
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+260
	DD	imagerel $unwind$?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+211
	DD	imagerel $unwind$?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+311
	DD	imagerel $unwind$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+148
	DD	imagerel $unwind$??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+258
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+143
	DD	imagerel $unwind$?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+242
	DD	imagerel $unwind$?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+205
	DD	imagerel $unwind$?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA DD imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA DD imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA
	DD	imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z DD imagerel $LN5
	DD	imagerel $LN5+194
	DD	imagerel $unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA DD imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA DD imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA
	DD	imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z DD imagerel $LN5
	DD	imagerel $LN5+194
	DD	imagerel $unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA DD imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA DD imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA
	DD	imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+172
	DD	imagerel $unwind$??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ
$pdata$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z DD imagerel $LN35
	DD	imagerel $LN35+2927
	DD	imagerel $unwind$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA DD imagerel ?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
$pdata$?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA DD imagerel ?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
$pdata$?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA DD imagerel ?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
	DD	imagerel ?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ DD imagerel $LN51
	DD	imagerel $LN51+4131
	DD	imagerel $unwind$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$pdata$?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD imagerel ?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DD	imagerel ?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA DD imagerel ?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA
$pdata$?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA DD imagerel ?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA
$pdata$?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z DD imagerel $LN7
	DD	imagerel $LN7+141
	DD	imagerel $unwind$?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA DD imagerel ?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z DD imagerel $LN6
	DD	imagerel $LN6+166
	DD	imagerel $unwind$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA DD imagerel ?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA
	DD	imagerel ?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z DD imagerel $LN6
	DD	imagerel $LN6+160
	DD	imagerel $unwind$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA DD imagerel ?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA
	DD	imagerel ?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+254
	DD	imagerel $unwind$?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+211
	DD	imagerel $unwind$?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1BaseProcessInfo@IronMan@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1BaseProcessInfo@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ DD imagerel ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
	DD	imagerel ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD imagerel ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ+78
	DD	imagerel $unwind$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD imagerel ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA DD imagerel ?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+157
	DD	imagerel $unwind$?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+212
	DD	imagerel $unwind$?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+215
	DD	imagerel $unwind$?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN46
	DD	imagerel $LN46+1440
	DD	imagerel $unwind$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z DD imagerel $LN19
	DD	imagerel $LN19+744
	DD	imagerel $unwind$?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN7
	DD	imagerel $LN7+143
	DD	imagerel $unwind$??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z DD imagerel $LN14
	DD	imagerel $LN14+479
	DD	imagerel $unwind$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+134
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+60
	DD	imagerel $unwind$??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD imagerel ??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
	DD	imagerel ??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z+59
	DD	imagerel $unwind$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA DD imagerel ?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+60
	DD	imagerel $unwind$??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD imagerel ??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
	DD	imagerel ??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z+59
	DD	imagerel $unwind$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA DD imagerel ?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+93
	DD	imagerel $unwind$??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD imagerel ??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
	DD	imagerel ??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z+59
	DD	imagerel $unwind$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA DD imagerel ?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+59
	DD	imagerel $unwind$??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD imagerel ??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
	DD	imagerel ??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z+59
	DD	imagerel $unwind$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA DD imagerel ?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+86
	DD	imagerel $unwind$??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD imagerel ??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
	DD	imagerel ??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z+59
	DD	imagerel $unwind$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA DD imagerel ?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z DD imagerel $LN3
	DD	imagerel $LN3+242
	DD	imagerel $unwind$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+444
	DD	imagerel $unwind$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA DD imagerel ?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA DD imagerel ?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z DD imagerel $LN6
	DD	imagerel $LN6+134
	DD	imagerel $unwind$??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z DD imagerel $LN10
	DD	imagerel $LN10+685
	DD	imagerel $unwind$??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD imagerel $LN10
	DD	imagerel $LN10+714
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@D$0A@@std@@YAXAEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$swap@D$0A@@std@@YAXAEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD imagerel ??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
	DD	imagerel ??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z+105
	DD	imagerel $unwind$??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD imagerel ??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
	DD	imagerel ??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z+105
	DD	imagerel $unwind$??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD imagerel ??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
	DD	imagerel ??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z+105
	DD	imagerel $unwind$??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD imagerel ??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
	DD	imagerel ??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z+105
	DD	imagerel $unwind$??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD imagerel ??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
	DD	imagerel ??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z+105
	DD	imagerel $unwind$??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD imagerel $LN28
	DD	imagerel $LN28+1185
	DD	imagerel $unwind$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD imagerel ?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD imagerel ?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel ?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA+283
	DD	imagerel $unwind$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD imagerel ?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel ?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD imagerel ?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel ?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA+163
	DD	imagerel $unwind$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD imagerel ?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel ?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+282
	DD	imagerel $unwind$??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+287
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z DD imagerel $LN8
	DD	imagerel $LN8+642
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z DD imagerel $LN3
	DD	imagerel $LN3+153
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z DD imagerel $LN8
	DD	imagerel $LN8+686
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN8
	DD	imagerel $LN8+642
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z DD imagerel $LN8
	DD	imagerel $LN8+665
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+216
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+224
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+129
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z DD imagerel $LN5
	DD	imagerel $LN5+244
	DD	imagerel $unwind$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA DD imagerel ?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z DD imagerel $LN5
	DD	imagerel $LN5+244
	DD	imagerel $unwind$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA DD imagerel ?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+61
	DD	imagerel $unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+77
	DD	imagerel $unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+46
	DD	imagerel $unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
$pdata$?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
	DD	imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ+31
	DD	imagerel $unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
$pdata$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DD	imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z+43
	DD	imagerel $unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD imagerel ??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
	DD	imagerel ??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z+71
	DD	imagerel $unwind$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+61
	DD	imagerel $unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+77
	DD	imagerel $unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+46
	DD	imagerel $unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
$pdata$?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
	DD	imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ+31
	DD	imagerel $unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
$pdata$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DD	imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z+43
	DD	imagerel $unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD imagerel ??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
	DD	imagerel ??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z+71
	DD	imagerel $unwind$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+61
	DD	imagerel $unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+77
	DD	imagerel $unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+46
	DD	imagerel $unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
$pdata$?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
	DD	imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ+31
	DD	imagerel $unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
$pdata$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DD	imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z+43
	DD	imagerel $unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD imagerel ??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
	DD	imagerel ??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z+82
	DD	imagerel $unwind$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+61
	DD	imagerel $unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+77
	DD	imagerel $unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+46
	DD	imagerel $unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
$pdata$?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
	DD	imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ+31
	DD	imagerel $unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
$pdata$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DD	imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z+43
	DD	imagerel $unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD imagerel ??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
	DD	imagerel ??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z+71
	DD	imagerel $unwind$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+61
	DD	imagerel $unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DD	imagerel ?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z+77
	DD	imagerel $unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$pdata$?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+46
	DD	imagerel $unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
$pdata$?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
	DD	imagerel ?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ+31
	DD	imagerel $unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
$pdata$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DD	imagerel ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z+43
	DD	imagerel $unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD imagerel ??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
	DD	imagerel ??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z+82
	DD	imagerel $unwind$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+239
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD imagerel $LN5
	DD	imagerel $LN5+126
	DD	imagerel $unwind$??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD imagerel $LN6
	DD	imagerel $LN6+128
	DD	imagerel $unwind$??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+195
	DD	imagerel $unwind$??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+222
	DD	imagerel $unwind$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+164
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+164
	DD	imagerel $unwind$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+306
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+323
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$07@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$07@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+34
	DD	imagerel $unwind$??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD imagerel ??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
	DD	imagerel ??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z+82
	DD	imagerel $unwind$??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+34
	DD	imagerel $unwind$??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD imagerel ??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
	DD	imagerel ??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z+71
	DD	imagerel $unwind$??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+34
	DD	imagerel $unwind$??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD imagerel ??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
	DD	imagerel ??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z+82
	DD	imagerel $unwind$??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+34
	DD	imagerel $unwind$??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD imagerel ??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
	DD	imagerel ??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z+71
	DD	imagerel $unwind$??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel ??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel ??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z+34
	DD	imagerel $unwind$??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD imagerel ??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
	DD	imagerel ??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z+71
	DD	imagerel $unwind$??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$03@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$03@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z DD imagerel $LN3
	DD	imagerel $LN3+153
	DD	imagerel $unwind$??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcd'
	DB	'a686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@Iron'
	DB	'Man@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DD 01H ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	DD	imagerel ??_R4?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47'
	DB	'a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@Iron'
	DB	'Man@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DD 01H ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	DD	imagerel ??_R4?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5'
	DB	'd5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@Iron'
	DB	'Man@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DD 01H ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	DD	imagerel ??_R4?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65'
	DB	'b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@Iron'
	DB	'Man@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DD 01H ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	DD	imagerel ??_R4?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa23'
	DB	'8f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@Iron'
	DB	'Man@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DD 01H ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
	DD	imagerel ??_R3?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
	DD	imagerel ??_R4?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R0?AV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8 DD 00H ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analy'
	DB	'sis@IronMan@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@UObjectAnalysis@Analysis@IronMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UObjectAnalysis@Analysis@IronMan@@8 DD imagerel ??_R0?AVUObjectAnalysis@Analysis@IronMan@@@8 ; IronMan::Analysis::UObjectAnalysis::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UObjectAnalysis@Analysis@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R2UObjectAnalysis@Analysis@IronMan@@8
rdata$r	SEGMENT
??_R2UObjectAnalysis@Analysis@IronMan@@8 DD imagerel ??_R1A@?0A@EA@UObjectAnalysis@Analysis@IronMan@@8 ; IronMan::Analysis::UObjectAnalysis::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@AnalysisBase@Analysis@IronMan@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3UObjectAnalysis@Analysis@IronMan@@8
rdata$r	SEGMENT
??_R3UObjectAnalysis@Analysis@IronMan@@8 DD 00H		; IronMan::Analysis::UObjectAnalysis::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2UObjectAnalysis@Analysis@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUObjectAnalysis@Analysis@IronMan@@@8
data$rs	SEGMENT
??_R0?AVUObjectAnalysis@Analysis@IronMan@@@8 DQ FLAT:??_7type_info@@6B@ ; IronMan::Analysis::UObjectAnalysis `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUObjectAnalysis@Analysis@IronMan@@', 00H
data$rs	ENDS
;	COMDAT ??_R4UObjectAnalysis@Analysis@IronMan@@6B@
rdata$r	SEGMENT
??_R4UObjectAnalysis@Analysis@IronMan@@6B@ DD 01H	; IronMan::Analysis::UObjectAnalysis::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUObjectAnalysis@Analysis@IronMan@@@8
	DD	imagerel ??_R3UObjectAnalysis@Analysis@IronMan@@8
	DD	imagerel ??_R4UObjectAnalysis@Analysis@IronMan@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AnalysisBase@Analysis@IronMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AnalysisBase@Analysis@IronMan@@8 DD imagerel ??_R0?AVAnalysisBase@Analysis@IronMan@@@8 ; IronMan::Analysis::AnalysisBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3AnalysisBase@Analysis@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R2AnalysisBase@Analysis@IronMan@@8
rdata$r	SEGMENT
??_R2AnalysisBase@Analysis@IronMan@@8 DD imagerel ??_R1A@?0A@EA@AnalysisBase@Analysis@IronMan@@8 ; IronMan::Analysis::AnalysisBase::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3AnalysisBase@Analysis@IronMan@@8
rdata$r	SEGMENT
??_R3AnalysisBase@Analysis@IronMan@@8 DD 00H		; IronMan::Analysis::AnalysisBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2AnalysisBase@Analysis@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAnalysisBase@Analysis@IronMan@@@8
data$rs	SEGMENT
??_R0?AVAnalysisBase@Analysis@IronMan@@@8 DQ FLAT:??_7type_info@@6B@ ; IronMan::Analysis::AnalysisBase `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVAnalysisBase@Analysis@IronMan@@', 00H
data$rs	ENDS
;	COMDAT ??_R4AnalysisBase@Analysis@IronMan@@6B@
rdata$r	SEGMENT
??_R4AnalysisBase@Analysis@IronMan@@6B@ DD 01H		; IronMan::Analysis::AnalysisBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVAnalysisBase@Analysis@IronMan@@@8
	DD	imagerel ??_R3AnalysisBase@Analysis@IronMan@@8
	DD	imagerel ??_R4AnalysisBase@Analysis@IronMan@@6B@
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@8
data$r	SEGMENT
??_R0?AV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@8 DQ FLAT:??_7type_info@@6B@ ; <lambda_564f9749a9a51d2fffa238f6767f2a0a> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@8
data$r	SEGMENT
??_R0?AV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@8 DQ FLAT:??_7type_info@@6B@ ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@8
data$r	SEGMENT
??_R0?AV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@8 DQ FLAT:??_7type_info@@6B@ ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@8
data$r	SEGMENT
??_R0?AV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@8 DQ FLAT:??_7type_info@@6B@ ; <lambda_614ae9436da2bf9123d47a10e682c1dd> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV<lambda_35d54d29033b35d747bcda686a4dea49>@@@8
data$r	SEGMENT
??_R0?AV<lambda_35d54d29033b35d747bcda686a4dea49>@@@8 DQ FLAT:??_7type_info@@6B@ ; <lambda_35d54d29033b35d747bcda686a4dea49> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV<lambda_35d54d29033b35d747bcda686a4dea49>@@', 00H
data$r	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DQ FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`vftable'
	DQ	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DQ	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ
	DQ	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DQ	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DQ FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`vftable'
	DQ	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DQ	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ
	DQ	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DQ	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DQ FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`vftable'
	DQ	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DQ	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ
	DQ	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DQ	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DQ FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`vftable'
	DQ	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DQ	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ
	DQ	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DQ	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ DQ FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::`vftable'
	DQ	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	DQ	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DQ	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ
	DQ	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z
	DQ	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ DB '['
	DB	0e8H, 0beH, 093H, 0e5H, 087H, 0baH, 0e4H, 0bfH, 0a1H, 0e6H, 081H
	DB	0afH, '] %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HNPCLLDA@address?5invalid?52@
CONST	SEGMENT
??_C@_0BC@HNPCLLDA@address?5invalid?52@ DB 'address invalid 2', 00H ; `string'
CONST	ENDS
;	COMDAT ?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A
_DATA	SEGMENT
?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A DQ 0000000000000000H ; IronMan::DMAHandler::ScatterReadArray
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A
_DATA	SEGMENT
?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A DQ 0000000000000000H ; IronMan::DMAHandler::ScatterWriteArray
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_7UObjectAnalysis@Analysis@IronMan@@6B@
CONST	SEGMENT
??_7UObjectAnalysis@Analysis@IronMan@@6B@ DQ FLAT:??_R4UObjectAnalysis@Analysis@IronMan@@6B@ ; IronMan::Analysis::UObjectAnalysis::`vftable'
	DQ	FLAT:??_EUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z
	DQ	FLAT:?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ
	DQ	FLAT:?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z
	DQ	FLAT:?GetEntryPoint@UObjectAnalysis@Analysis@IronMan@@UEBA?B_KXZ
CONST	ENDS
;	COMDAT ??_7AnalysisBase@Analysis@IronMan@@6B@
CONST	SEGMENT
??_7AnalysisBase@Analysis@IronMan@@6B@ DQ FLAT:??_R4AnalysisBase@Analysis@IronMan@@6B@ ; IronMan::Analysis::AnalysisBase::`vftable'
	DQ	FLAT:??_EAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?GetEntryPoint@AnalysisBase@Analysis@IronMan@@UEBA?B_KXZ
CONST	ENDS
_DATA	SEGMENT
?rax@x86@asmjit@@3AEBUX86GpReg@2@EB DQ FLAT:?x86RegData@asmjit@@3UX86RegData@1@B+976 ; asmjit::x86::rax
?rcx@x86@asmjit@@3AEBUX86GpReg@2@EB DQ FLAT:?x86RegData@asmjit@@3UX86RegData@1@B+992 ; asmjit::x86::rcx
?rsp@x86@asmjit@@3AEBUX86GpReg@2@EB DQ FLAT:?x86RegData@asmjit@@3UX86RegData@1@B+1040 ; asmjit::x86::rsp
?r15@x86@asmjit@@3AEBUX86GpReg@2@EB DQ FLAT:?x86RegData@asmjit@@3UX86RegData@1@B+1216 ; asmjit::x86::r15
_DATA	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z DD 021801H
	DD	070147218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$03@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$07@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$07@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$07@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$07@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$07@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DD 011811H
	DD	0e218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z DD 011811H
	DD	0e218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z DB 040H
	DD	imagerel $ip2state$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD 031501H
	DD	070114215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z DD 031501H
	DD	070114215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z DB 06H
	DB	00H
	DB	00H
	DB	0eeH
	DB	02H
	DB	0c4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z
	DD	imagerel $ip2state$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z DB 06H
	DB	00H
	DB	00H
	DB	0eeH
	DB	02H
	DB	0c4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z
	DD	imagerel $ip2state$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z DD 031501H
	DD	070114215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0f1H, 04H
	DB	02H
	DB	01H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0bdH, 04H
	DB	02H
	DB	0d9H, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z DB 06H
	DB	00H
	DB	00H
	DB	09H, 05H
	DB	02H
	DB	'=', 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z DB 06H
	DB	00H
	DB	00H
	DB	0bdH, 04H
	DB	02H
	DB	0d9H, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	0b5H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	0fcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z DD 031501H
	DD	07011c215H
	DD	06010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DB 08H
	DB	00H
	DB	02H
	DB	01aH
	DB	02H
	DB	'^'
	DB	04H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DB 04H
	DB	08H
	DB	0eH
	DD	imagerel ?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DB 09H
	DD	imagerel $stateUnwindMap$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel $ip2state$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DB	'p'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DB 08H
	DB	00H
	DB	02H
	DB	01aH
	DB	02H
	DB	080H
	DB	04H
	DB	01H, 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DB 04H
	DB	08H
	DB	0eH
	DD	imagerel ?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DB 09H
	DD	imagerel $stateUnwindMap$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DD	imagerel $ip2state$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DB	'p'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DB 0eH
	DB	00H
	DB	00H
	DB	')', 07H
	DB	02H
	DB	0edH, 04H
	DB	00H
	DB	'Q', 03H
	DB	04H
	DB	'P'
	DB	00H
	DB	0acH
	DB	08H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DB 02H
	DB	00H
	DD	imagerel ?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DB 02H
	DB	00H
	DD	imagerel ?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DB 04H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
	DB	06H
	DB	06H
	DB	08H
	DD	imagerel $handlerMap$0$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DB	030H
	DB	03eH
	DD	imagerel ?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
	DB	060H
	DB	06eH
	DD	imagerel ?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DB 018H
	DD	imagerel $stateUnwindMap$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
	DD	imagerel $tryMap$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
	DD	imagerel $ip2state$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD 021b19H
	DD	023011bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@D$0A@@std@@YAXAEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DB 040H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD 041801H
	DD	0150118H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DB 040H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
	DD	imagerel $ip2state$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z DB 06H
	DB	00H
	DB	00H
	DB	0ddH, 04H
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z DD 041811H
	DD	0190118H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
	DD	imagerel $ip2state$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
	DD	imagerel $ip2state$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
	DD	imagerel $ip2state$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
	DD	imagerel $ip2state$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
	DD	imagerel $ip2state$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z DB 040H
	DD	imagerel $ip2state$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z DD 011319H
	DD	0e213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z DD 031001H
	DD	0700c8210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z DB 040H
	DD	imagerel $ip2state$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z DD 010e19H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z
	DD	imagerel $ip2state$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 06H
	DB	00H
	DB	00H
	DB	':'
	DB	02H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 08H
	DD	imagerel $stateUnwindMap$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel $ip2state$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD 020611H
	DD	070023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1BaseProcessInfo@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1BaseProcessInfo@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1BaseProcessInfo@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1BaseProcessInfo@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z DB 06H
	DB	00H
	DB	00H
	DB	0baH
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z DB 08H
	DD	imagerel $stateUnwindMap$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z
	DD	imagerel $ip2state$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z DD 021111H
	DD	0110111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z DB 06H
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z DB 08H
	DD	imagerel $stateUnwindMap$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z
	DD	imagerel $ip2state$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z DD 021611H
	DD	0150116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	01cH
	DB	02H
	DB	01dH, 02H
	DB	00H
	DB	'"'
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z
	DD	imagerel $ip2state$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ
	DD	01eH
	DD	01009H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z
	DD	01dH
	DD	0b55H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'M', 02H
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z
	DD	imagerel $ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'M', 02H
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z
	DD	imagerel $ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z DB 06H
	DB	00H
	DB	00H
	DB	0e6H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z DB 08H
	DD	imagerel $stateUnwindMap$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z
	DD	imagerel $ip2state$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z DD 011811H
	DD	04218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z DD 021101H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Func_class@XPEAX@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'T'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ
	DD	imagerel $ip2state$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0AnalysisBase@Analysis@IronMan@@IEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ DB 06H
	DB	00H
	DB	00H
	DB	'@'
	DB	04H
	DB	'X'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ
	DD	imagerel $ip2state$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ DB 06H
	DB	00H
	DB	00H
	DB	'T'
	DB	04H
	DB	'4'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ
	DD	imagerel $ip2state$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
xdata	SEGMENT
$unwind$?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z DD 011301H
	DD	04213H
$unwind$?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ DD 010901H
	DD	06209H
$unwind$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z DD 042519H
	DD	01f30113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z
	DD	0f82H
$cppxdata$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z
	DD	imagerel $ip2state$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z
$stateUnwindMap$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA
$ip2state$?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z DB 012H
	DB	00H
	DB	00H
	DB	'J'
	DB	02H
	DB	0c9H, 02H
	DB	04H
	DB	0adH, 0cH
	DB	06H
	DB	'X'
	DB	04H
	DB	'&'
	DB	06H
	DB	'Y', 0fH
	DB	04H
	DB	091H, 0bH
	DB	02H
	DB	090H
	DB	00H
$unwind$?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ DD 042619H
	DD	02dd0114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ
	DD	016d2H
$cppxdata$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ DB 08H
	DD	imagerel $stateUnwindMap$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ
	DD	imagerel $ip2state$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ
$stateUnwindMap$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ DB 012H
	DB	0eH
	DD	imagerel ?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	056H
	DD	imagerel ?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	07eH
	DD	imagerel ?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	0a6H
	DD	imagerel ?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	0ceH
	DD	imagerel ?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	0f6H
	DD	imagerel ?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
	DB	03dH
	DB	02H
	DD	imagerel ?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA
$ip2state$?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ DB 012H
	DB	00H
	DB	00H
	DB	0c5H, 05H
	DB	02H
	DB	01cH
	DB	04H
	DB	091H, 02H
	DB	06H
	DB	','
	DB	04H
	DB	0b9H, 09H
	DB	08H
	DB	'z'
	DB	04H
	DB	'%,'
	DB	02H
	DB	01cH
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z
$cppxdata$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z
	DD	imagerel $ip2state$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z
$stateUnwindMap$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA
$ip2state$??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z DB 08H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'F'
	DB	04H
	DB	08eH
	DB	00H
$ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 02H
	DB	00H
	DB	00H
$unwind$?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ
$cppxdata$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ
	DD	imagerel $ip2state$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ
$stateUnwindMap$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA
$ip2state$??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'0'
	DB	02H
	DB	'('
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0220eH
$unwind$??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0220eH
$unwind$??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0620eH
$unwind$??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0220eH
$unwind$??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0620eH
$unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 040H
	DD	imagerel $ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 02H
	DB	00H
	DB	00H
$unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
$unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD 010901H
	DD	04209H
$unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD 010d01H
	DD	0420dH
$unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 040H
	DD	imagerel $ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 02H
	DB	00H
	DB	00H
$unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
$unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD 010901H
	DD	04209H
$unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD 010d01H
	DD	0420dH
$unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 040H
	DD	imagerel $ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 02H
	DB	00H
	DB	00H
$unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
$unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD 010901H
	DD	04209H
$unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD 010d01H
	DD	0420dH
$unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 040H
	DD	imagerel $ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 02H
	DB	00H
	DB	00H
$unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
$unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD 010901H
	DD	04209H
$unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD 010d01H
	DD	0420dH
$unwind$?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
$cppxdata$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z DB 040H
	DD	imagerel $ip2state$?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z
	ORG $+3
$unwind$?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z DD 010e01H
	DD	0420eH
$unwind$?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ DD 010901H
	DD	04209H
$unwind$?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsJump@Zydis@IronMan@@QEBA_NXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsCondJump@Zydis@IronMan@@QEBA_NXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_tree_length_error@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Align@@YA_K_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decwref@_Ref_count_base@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??UpdateStartTime$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ ; IronMan::DMAHandler::pdateStartTime$initializer$::operator|
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ScatterWriteArray$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; IronMan::DMAHandler::catterWriteArray$initializer$::operator~
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ScatterReadArray$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; IronMan::DMAHandler::catterReadArray$initializer$::operator~
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??processInfo$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ; ??processInfo$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$_Tuple_get@$0A@AEBW4ZydisRegister_@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@AEBW4ZydisRegister_@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@@Z PROC ; std::_Tuple_get<0,enum ZydisRegister_ const &>, COMDAT

; 925  : _NODISCARD constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 926  :     // used by pair's piecewise constructor
; 927  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 928  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 929  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR _Tuple$[rsp]
	mov	rax, QWORD PTR [rax]

; 930  : }

	ret	0
??$_Tuple_get@$0A@AEBW4ZydisRegister_@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@@Z ENDP ; std::_Tuple_get<0,enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z PROC ; std::move<std::tuple<enum ZydisRegister_ const &> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ENDP ; std::move<std::tuple<enum ZydisRegister_ const &> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAVIAsmHelper@IronMan@@@std@@YA$$QEAPEAVIAsmHelper@IronMan@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVIAsmHelper@IronMan@@@std@@YA$$QEAPEAVIAsmHelper@IronMan@@AEAPEAV12@@Z PROC ; std::forward<IronMan::IAsmHelper *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAVIAsmHelper@IronMan@@@std@@YA$$QEAPEAVIAsmHelper@IronMan@@AEAPEAV12@@Z ENDP ; std::forward<IronMan::IAsmHelper *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<IronMan::IAsmHelper *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<IronMan::IAsmHelper *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z PROC ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ENDP ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 4
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z PROC ; std::forward<enum ZydisRegister_>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ENDP ; std::forward<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
__formal$ = 72
__formal$ = 80
??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><std::tuple<enum ZydisRegister_ const &>,std::tuple<>,0>, COMDAT

; 478  :         : first(_STD _Tuple_get<_Indices1>(_STD move(_Val1))...),

$LN3:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$move@AEAV?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ; std::move<std::tuple<enum ZydisRegister_ const &> &>
	mov	rcx, rax
	call	??$_Tuple_get@$0A@AEBW4ZydisRegister_@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@@Z ; std::_Tuple_get<0,enum ZydisRegister_ const &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 479  :           second(_STD _Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><std::tuple<enum ZydisRegister_ const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
this$ = 48
_Arg$ = 56
??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z PROC ; std::_Tuple_val<enum ZydisRegister_ const &>::_Tuple_val<enum ZydisRegister_ const &><enum ZydisRegister_ const &>, COMDAT

; 132  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Arg$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z ENDP ; std::_Tuple_val<enum ZydisRegister_ const &>::_Tuple_val<enum ZydisRegister_ const &><enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT

; 235  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 1488				; 000005d0H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z PROC ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ENDP ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
<_Val2_0>$ = 72
??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z PROC ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VIAsmHelper@IronMan@@@0@AEAU10@@Z ; std::forward<std::default_delete<IronMan::IAsmHelper> >
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@PEAVIAsmHelper@IronMan@@@std@@YA$$QEAPEAVIAsmHelper@IronMan@@AEAPEAV12@@Z ; std::forward<IronMan::IAsmHelper *>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z ENDP ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VIAsmHelper@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VIAsmHelper@IronMan@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<IronMan::IAsmHelper> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VIAsmHelper@IronMan@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<IronMan::IAsmHelper> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z
_TEXT	SEGMENT
tv86 = 32
tv84 = 40
tv82 = 48
tv88 = 56
this$ = 80
__formal$ = 88
_Val1$ = 96
<_Val2_0>$ = 104
<_Val2_1>$ = 112
<_Val2_2>$ = 120
??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z PROC ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ; std::forward<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	mov	rcx, QWORD PTR <_Val2_2>$[rsp]
	call	??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv86[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv82[rsp], rax
	mov	r9, QWORD PTR tv86[rsp]
	mov	r8, QWORD PTR tv84[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv88[rsp]
	call	??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@00@Z ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z ENDP ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z PROC ; std::exchange<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z ENDP ; std::exchange<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z PROC ; std::move<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z
_TEXT	SEGMENT
tv86 = 32
tv84 = 40
tv82 = 48
tv88 = 56
this$ = 80
__formal$ = 88
_Val1$ = 96
<_Val2_0>$ = 104
<_Val2_1>$ = 112
<_Val2_2>$ = 120
??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z PROC ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_>,enum ZydisRegister_ *,enum ZydisRegister_ *,enum ZydisRegister_ *>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ; std::forward<std::allocator<enum ZydisRegister_> >
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	mov	rcx, QWORD PTR <_Val2_2>$[rsp]
	call	??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::forward<enum ZydisRegister_ *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv86[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::forward<enum ZydisRegister_ *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::forward<enum ZydisRegister_ *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv82[rsp], rax
	mov	r9, QWORD PTR tv86[rsp]
	mov	r8, QWORD PTR tv84[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv88[rsp]
	call	??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@00@Z ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z ENDP ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_>,enum ZydisRegister_ *,enum ZydisRegister_ *,enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z PROC ; std::exchange<enum ZydisRegister_ *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z ENDP ; std::exchange<enum ZydisRegister_ *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z PROC ; std::move<std::allocator<enum ZydisRegister_> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<enum ZydisRegister_> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<88>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 88		; 00000058H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<88>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z PROC ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z ENDP ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z PROC ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z ENDP ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z PROC ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z ENDP ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z PROC ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z ENDP ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z PROC ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z ENDP ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 1488				; 000005d0H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z PROC ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ENDP ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 4
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAW4ZydisRegister_@@@std@@YAAEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_ &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAW4ZydisRegister_@@@std@@YAAEAW4ZydisRegister_@@AEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAW4ZydisRegister_@@@std@@YAAEAW4ZydisRegister_@@AEAW41@@Z PROC ; std::forward<enum ZydisRegister_ &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAW4ZydisRegister_@@@std@@YAAEAW4ZydisRegister_@@AEAW41@@Z ENDP ; std::forward<enum ZydisRegister_ &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z ; std::_Unfancy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::construct<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 88					; 00000058H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA?A_TAEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA?A_TAEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z PROC ; std::_Get_unwrapped<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA?A_TAEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ENDP ; std::_Get_unwrapped<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::construct<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z PROC ; std::addressof<IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ENDP ; std::addressof<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_>, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@W4ZydisRegister_@@W41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@$$QEAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_>

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 4
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z
_TEXT	SEGMENT
_First_ptr$ = 32
_Last_ptr$ = 40
_First_ch$ = 48
_Last_ch$ = 56
_Object_count$ = 64
_Byte_count$ = 72
_First$ = 96
_Last$ = 104
_Dest$ = 112
??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z PROC ; std::_Copy_memmove<enum ZydisRegister_ *,enum ZydisRegister_ *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
	mov	QWORD PTR _Last_ptr$[rsp], rax

; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	rcx, QWORD PTR _Last_ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 2
	mov	QWORD PTR _Object_count$[rsp], rax

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));

	mov	rax, QWORD PTR _Last_ptr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Byte_count$[rsp], rax

; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	r9, QWORD PTR _Object_count$[rsp]
	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _First_ch$[rsp]
	call	??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z ; std::_Copy_memmove_tail<enum ZydisRegister_ *>

; 4787 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z ENDP ; std::_Copy_memmove<enum ZydisRegister_ *,enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAW4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAW4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z PROC ; std::move<enum ZydisRegister_ &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAW4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ENDP ; std::move<enum ZydisRegister_ &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAW4ZydisRegister_@@@std@@YA?A_TAEBQEAW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAW4ZydisRegister_@@@std@@YA?A_TAEBQEAW4ZydisRegister_@@@Z PROC ; std::_Get_unwrapped<enum ZydisRegister_ * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAW4ZydisRegister_@@@std@@YA?A_TAEBQEAW4ZydisRegister_@@@Z ENDP ; std::_Get_unwrapped<enum ZydisRegister_ * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@AEAW41@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@AEAW41@@Z PROC ; std::addressof<enum ZydisRegister_>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@AEAW41@@Z ENDP ; std::addressof<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
this$ = 80
__formal$ = 88
_Val1$ = 96
_Val2$ = 104
??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><enum ZydisRegister_ const &>, COMDAT

; 331  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR $T1[rsp]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, QWORD PTR _Val2$[rsp]
	mov	rdx, QWORD PTR _Val1$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0V?$tuple@AEBW4ZydisRegister_@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEAA@AEAV?$tuple@AEBW4ZydisRegister_@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><std::tuple<enum ZydisRegister_ const &>,std::tuple<>,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
$T1 = 32
tv77 = 40
this$ = 64
__formal$ = 72
_This_arg$ = 80
??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z PROC ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><std::_Exact_args_t,enum ZydisRegister_ const &,0>, COMDAT

; 301  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _This_arg$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0AEBW4ZydisRegister_@@@?$_Tuple_val@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z ; std::_Tuple_val<enum ZydisRegister_ const &>::_Tuple_val<enum ZydisRegister_ const &><enum ZydisRegister_ const &>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z ENDP ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><std::_Exact_args_t,enum ZydisRegister_ const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
_TEXT	SEGMENT
_Count$ = 32
_First_ch$ = 40
_First_ptr$ = 48
_Last_ptr$ = 56
_Dest_ptr$ = 64
_Last_ch$ = 72
_Dest_ch$ = 80
_Result$ = 88
_First$ = 112
_Last$ = 120
_Dest$ = 128
??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z PROC ; std::_Copy_backward_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 5099 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 5100 :     // implement copy_backward-like function as memmove
; 5101 :     const auto _First_ptr = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 5102 :     const auto _Last_ptr  = _STD _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _Last_ptr$[rsp], rax

; 5103 :     const auto _Dest_ptr  = _STD _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _Dest_ptr$[rsp], rax

; 5104 :     const auto _First_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 5105 :     const auto _Last_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));

	mov	rax, QWORD PTR _Last_ptr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 5106 :     const auto _Dest_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));

	mov	rax, QWORD PTR _Dest_ptr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 5107 :     const auto _Count     = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 5108 :     const auto _Result    = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, rax
	call	memmove
	mov	QWORD PTR _Result$[rsp], rax

; 5109 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 5110 :         return static_cast<_CtgIt2>(_Result);

	mov	rax, QWORD PTR _Result$[rsp]

; 5111 :     } else {
; 5112 :         return _Dest - static_cast<_Iter_diff_t<_CtgIt2>>(_Last_ptr - _First_ptr);
; 5113 :     }
; 5114 : }

	add	rsp, 104				; 00000068H
	ret	0
??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ENDP ; std::_Copy_backward_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$QEAU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo>

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 1488				; 000005d0H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
_TEXT	SEGMENT
_First_ptr$ = 32
_Last_ptr$ = 40
_First_ch$ = 48
_Last_ch$ = 56
_Object_count$ = 64
_Byte_count$ = 72
_First$ = 96
_Last$ = 104
_Dest$ = 112
??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z PROC ; std::_Copy_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _Last_ptr$[rsp], rax

; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	rcx, QWORD PTR _Last_ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Object_count$[rsp], rax

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));

	mov	rax, QWORD PTR _Last_ptr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Byte_count$[rsp], rax

; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	r9, QWORD PTR _Object_count$[rsp]
	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _First_ch$[rsp]
	call	??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z ; std::_Copy_memmove_tail<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 4787 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ENDP ; std::_Copy_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z PROC ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ENDP ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_TAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_TAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_TAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAVAsmHelper64@IronMan@@@std@@YAAEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVAsmHelper64@IronMan@@@std@@YAAEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z PROC ; std::forward<IronMan::AsmHelper64 * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAVAsmHelper64@IronMan@@@std@@YAAEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z ENDP ; std::forward<IronMan::AsmHelper64 * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1488>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 12397005425880075			; 002c0b02c0b02c0bH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 12397005425880075			; 002c0b02c0b02c0bH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1488>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$03@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<4>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 2
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$03@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PEAW4ZydisRegister_@@$0A@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy_maybe_null@PEAW4ZydisRegister_@@$0A@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z PROC ; std::_Refancy_maybe_null<enum ZydisRegister_ *,0>, COMDAT

; 312  : _CONSTEXPR20 _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 313  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 314  : }

	ret	0
??$_Refancy_maybe_null@PEAW4ZydisRegister_@@$0A@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ENDP ; std::_Refancy_maybe_null<enum ZydisRegister_ *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a> const &,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z PROC ; std::move<<lambda_564f9749a9a51d2fffa238f6767f2a0a> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z ENDP ; std::move<<lambda_564f9749a9a51d2fffa238f6767f2a0a> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Obj$ = 48
_Arg1$ = 56
??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::invoke<<lambda_564f9749a9a51d2fffa238f6767f2a0a> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 1704 :         static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1705 :     if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
; 1706 :         return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);

	mov	rdx, QWORD PTR _Arg1$[rsp]
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; <lambda_564f9749a9a51d2fffa238f6767f2a0a>::operator()

; 1707 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
; 1708 :         return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1709 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
; 1710 :         return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1711 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
; 1712 :         return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1713 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
; 1714 :         return static_cast<_Ty1&&>(_Arg1).*_Obj;
; 1715 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
; 1716 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1956799
; 1717 :         return _Arg1.get().*_Obj;
; 1718 : #else // ^^^ no workaround / workaround vvv
; 1719 :         auto& _Ref = _Arg1.get();
; 1720 :         return _Ref.*_Obj;
; 1721 : #endif // ^^^ workaround ^^^
; 1722 :     } else {
; 1723 :         _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
; 1724 :         return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
; 1725 :     }
; 1726 : }

	add	rsp, 40					; 00000028H
	ret	0
??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::invoke<<lambda_564f9749a9a51d2fffa238f6767f2a0a> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAPEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAPEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z PROC ; std::addressof<<lambda_564f9749a9a51d2fffa238f6767f2a0a> const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAPEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z ENDP ; std::addressof<<lambda_564f9749a9a51d2fffa238f6767f2a0a> const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const &,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z PROC ; std::move<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z ENDP ; std::move<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Obj$ = 48
_Arg1$ = 56
??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::invoke<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 1704 :         static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1705 :     if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
; 1706 :         return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);

	mov	rdx, QWORD PTR _Arg1$[rsp]
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0>::operator()

; 1707 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
; 1708 :         return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1709 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
; 1710 :         return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1711 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
; 1712 :         return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1713 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
; 1714 :         return static_cast<_Ty1&&>(_Arg1).*_Obj;
; 1715 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
; 1716 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1956799
; 1717 :         return _Arg1.get().*_Obj;
; 1718 : #else // ^^^ no workaround / workaround vvv
; 1719 :         auto& _Ref = _Arg1.get();
; 1720 :         return _Ref.*_Obj;
; 1721 : #endif // ^^^ workaround ^^^
; 1722 :     } else {
; 1723 :         _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
; 1724 :         return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
; 1725 :     }
; 1726 : }

	add	rsp, 40					; 00000028H
	ret	0
??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::invoke<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAPEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAPEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z PROC ; std::addressof<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAPEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z ENDP ; std::addressof<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
_TEXT	SEGMENT
this$ = 64
_Val$ = 72
??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const &,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const &>
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+8]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z PROC ; std::move<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z ENDP ; std::move<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Obj$ = 48
_Arg1$ = 56
??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::invoke<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 1704 :         static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1705 :     if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
; 1706 :         return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);

	mov	rdx, QWORD PTR _Arg1$[rsp]
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f>::operator()

; 1707 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
; 1708 :         return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1709 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
; 1710 :         return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1711 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
; 1712 :         return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1713 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
; 1714 :         return static_cast<_Ty1&&>(_Arg1).*_Obj;
; 1715 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
; 1716 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1956799
; 1717 :         return _Arg1.get().*_Obj;
; 1718 : #else // ^^^ no workaround / workaround vvv
; 1719 :         auto& _Ref = _Arg1.get();
; 1720 :         return _Ref.*_Obj;
; 1721 : #endif // ^^^ workaround ^^^
; 1722 :     } else {
; 1723 :         _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
; 1724 :         return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
; 1725 :     }
; 1726 : }

	add	rsp, 40					; 00000028H
	ret	0
??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::invoke<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAPEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAPEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z PROC ; std::addressof<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAPEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z ENDP ; std::addressof<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd> const &,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z PROC ; std::move<<lambda_614ae9436da2bf9123d47a10e682c1dd> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z ENDP ; std::move<<lambda_614ae9436da2bf9123d47a10e682c1dd> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Obj$ = 48
_Arg1$ = 56
??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::invoke<<lambda_614ae9436da2bf9123d47a10e682c1dd> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 1704 :         static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1705 :     if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
; 1706 :         return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);

	mov	rdx, QWORD PTR _Arg1$[rsp]
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; <lambda_614ae9436da2bf9123d47a10e682c1dd>::operator()

; 1707 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
; 1708 :         return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1709 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
; 1710 :         return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1711 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
; 1712 :         return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1713 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
; 1714 :         return static_cast<_Ty1&&>(_Arg1).*_Obj;
; 1715 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
; 1716 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1956799
; 1717 :         return _Arg1.get().*_Obj;
; 1718 : #else // ^^^ no workaround / workaround vvv
; 1719 :         auto& _Ref = _Arg1.get();
; 1720 :         return _Ref.*_Obj;
; 1721 : #endif // ^^^ workaround ^^^
; 1722 :     } else {
; 1723 :         _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
; 1724 :         return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
; 1725 :     }
; 1726 : }

	add	rsp, 40					; 00000028H
	ret	0
??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::invoke<<lambda_614ae9436da2bf9123d47a10e682c1dd> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAPEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAPEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z PROC ; std::addressof<<lambda_614ae9436da2bf9123d47a10e682c1dd> const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAPEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z ENDP ; std::addressof<<lambda_614ae9436da2bf9123d47a10e682c1dd> const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
_TEXT	SEGMENT
this$ = 64
_Val$ = 72
??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49> const &,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> const &>
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+8]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z PROC ; std::move<<lambda_35d54d29033b35d747bcda686a4dea49> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z ENDP ; std::move<<lambda_35d54d29033b35d747bcda686a4dea49> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Obj$ = 48
_Arg1$ = 56
??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::invoke<<lambda_35d54d29033b35d747bcda686a4dea49> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 1704 :         static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1705 :     if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
; 1706 :         return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);

	mov	rdx, QWORD PTR _Arg1$[rsp]
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; <lambda_35d54d29033b35d747bcda686a4dea49>::operator()

; 1707 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
; 1708 :         return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1709 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
; 1710 :         return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1711 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
; 1712 :         return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1713 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
; 1714 :         return static_cast<_Ty1&&>(_Arg1).*_Obj;
; 1715 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
; 1716 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1956799
; 1717 :         return _Arg1.get().*_Obj;
; 1718 : #else // ^^^ no workaround / workaround vvv
; 1719 :         auto& _Ref = _Arg1.get();
; 1720 :         return _Ref.*_Obj;
; 1721 : #endif // ^^^ workaround ^^^
; 1722 :     } else {
; 1723 :         _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
; 1724 :         return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
; 1725 :     }
; 1726 : }

	add	rsp, 40					; 00000028H
	ret	0
??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::invoke<<lambda_35d54d29033b35d747bcda686a4dea49> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAPEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAPEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z PROC ; std::addressof<<lambda_35d54d29033b35d747bcda686a4dea49> const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAPEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z ENDP ; std::addressof<<lambda_35d54d29033b35d747bcda686a4dea49> const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$07@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$07@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<8>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$07@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
_TEXT	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
_ULast$ = 48
tv87 = 56
tv85 = 64
tv83 = 72
$T1 = 80
_Backout$ = 88
_First$ = 128
_Last$ = 136
_Dest$ = 144
_Al$ = 152
??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z PROC ; std::_Uninitialized_copy<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1824 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1825 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1826 :     // note: only called internally from elsewhere in the STL
; 1827 :     using _Ptrval = typename _Alloc::value_type*;
; 1828 : 
; 1829 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1830 :     _STD _Adl_verify_range(_First, _Last);
; 1831 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1832 : 
; 1833 : #if _HAS_CXX20
; 1834 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1835 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1836 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1837 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1838 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1839 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	rcx, rax
	call	??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1840 :     auto _ULast  = _STD _Get_unwrapped(_STD move(_Last));

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	rcx, rax
	call	??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _ULast$[rsp], rax

; 1841 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1842 : 
; 1843 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible

	mov	BYTE PTR _Can_memmove$[rsp], 1

; 1844 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1845 : 
; 1846 :     if constexpr (_Can_memmove) {
; 1847 : #if _HAS_CXX20
; 1848 :         if (!_STD is_constant_evaluated())
; 1849 : #endif // _HAS_CXX20
; 1850 :         {
; 1851 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1852 :                 _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	QWORD PTR tv87[rsp], rax
	lea	rcx, QWORD PTR _ULast$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR tv85[rsp], rax
	lea	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR tv83[rsp], rax
	mov	r8, QWORD PTR tv87[rsp]
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Copy_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1853 :                 _Dest += _ULast - _UFirst;

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	imul	rax, rax, 1488				; 000005d0H
	mov	rcx, QWORD PTR _Dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Dest$[rsp], rax

; 1854 :             } else {
; 1855 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1856 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1857 :                 _Dest += _Count;
; 1858 :             }
; 1859 :             return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
	jmp	SHORT $LN1@Uninitiali

; 1860 :         }
; 1861 :     }
; 1862 : 
; 1863 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1864 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1865 :         _Backout._Emplace_back(*_UFirst);

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	npad	1

; 1866 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1867 : 
; 1868 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1869 : }

	add	rsp, 120				; 00000078H
	ret	0
??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ENDP ; std::_Uninitialized_copy<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
_ULast$ = 48
tv87 = 56
tv85 = 64
tv83 = 72
$T1 = 80
_Backout$ = 88
_First$ = 128
_Last$ = 136
_Dest$ = 144
_Al$ = 152
?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@Z PROC ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@Z ENDP ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::~_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >, COMDAT

; 86   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 87   :         if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy_guard

; 88   :             _Target->_Tidy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Tidy
	npad	1
$LN2@Tidy_guard:

; 89   :         }
; 90   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::~_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z
_TEXT	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
_ULast$ = 48
tv87 = 56
tv85 = 64
tv83 = 72
$T1 = 80
_Backout$ = 88
_First$ = 128
_Last$ = 136
_Dest$ = 144
_Al$ = 152
??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z PROC ; std::_Uninitialized_copy<enum ZydisRegister_ *,enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >, COMDAT

; 1824 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1825 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1826 :     // note: only called internally from elsewhere in the STL
; 1827 :     using _Ptrval = typename _Alloc::value_type*;
; 1828 : 
; 1829 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1830 :     _STD _Adl_verify_range(_First, _Last);
; 1831 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1832 : 
; 1833 : #if _HAS_CXX20
; 1834 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1835 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1836 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1837 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1838 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1839 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	rcx, rax
	call	??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ *>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1840 :     auto _ULast  = _STD _Get_unwrapped(_STD move(_Last));

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	rcx, rax
	call	??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ *>
	mov	QWORD PTR _ULast$[rsp], rax

; 1841 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1842 : 
; 1843 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible

	mov	BYTE PTR _Can_memmove$[rsp], 1

; 1844 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1845 : 
; 1846 :     if constexpr (_Can_memmove) {
; 1847 : #if _HAS_CXX20
; 1848 :         if (!_STD is_constant_evaluated())
; 1849 : #endif // _HAS_CXX20
; 1850 :         {
; 1851 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1852 :                 _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
	mov	QWORD PTR tv87[rsp], rax
	lea	rcx, QWORD PTR _ULast$[rsp]
	call	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
	mov	QWORD PTR tv85[rsp], rax
	lea	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
	mov	QWORD PTR tv83[rsp], rax
	mov	r8, QWORD PTR tv87[rsp]
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z ; std::_Copy_memmove<enum ZydisRegister_ *,enum ZydisRegister_ *>

; 1853 :                 _Dest += _ULast - _UFirst;

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 2
	mov	rcx, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR _Dest$[rsp], rax

; 1854 :             } else {
; 1855 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1856 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1857 :                 _Dest += _Count;
; 1858 :             }
; 1859 :             return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
	jmp	SHORT $LN1@Uninitiali

; 1860 :         }
; 1861 :     }
; 1862 : 
; 1863 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >

; 1864 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 4
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1865 :         _Backout._Emplace_back(*_UFirst);

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_ &>
	npad	1

; 1866 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1867 : 
; 1868 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1869 : }

	add	rsp, 120				; 00000078H
	ret	0
??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z ENDP ; std::_Uninitialized_copy<enum ZydisRegister_ *,enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
_ULast$ = 48
tv87 = 56
tv85 = 64
tv83 = 72
$T1 = 80
_Backout$ = 88
_First$ = 128
_Last$ = 136
_Dest$ = 144
_Al$ = 152
?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<enum ZydisRegister_ *,enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<enum ZydisRegister_ *,enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAW4ZydisRegister_@@@std@@YAAEBQEAW4ZydisRegister_@@AEBQEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAW4ZydisRegister_@@@std@@YAAEBQEAW4ZydisRegister_@@AEBQEAW41@@Z PROC ; std::forward<enum ZydisRegister_ * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAW4ZydisRegister_@@@std@@YAAEBQEAW4ZydisRegister_@@AEBQEAW41@@Z ENDP ; std::forward<enum ZydisRegister_ * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >::~_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >, COMDAT

; 86   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 87   :         if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy_guard

; 88   :             _Target->_Tidy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Tidy
	npad	1
$LN2@Tidy_guard:

; 89   :         }
; 90   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >::~_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<enum ZydisRegister_> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z
_TEXT	SEGMENT
_Dest_ch$ = 32
_Dest_ptr$ = 40
_First_ch$ = 64
_Dest$ = 72
_Byte_count$ = 80
_Object_count$ = 88
??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z PROC ; std::_Copy_memmove_tail<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _Dest_ptr$[rsp], rax

; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));

	mov	rax, QWORD PTR _Dest_ptr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove
	npad	1

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

	mov	rax, QWORD PTR _Byte_count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z ENDP ; std::_Copy_memmove_tail<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 4641 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4642 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4643 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4644 : }

	ret	0
??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo &>

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 1488				; 000005d0H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z
_TEXT	SEGMENT
_Dest_ch$ = 32
_Dest_ptr$ = 40
_First_ch$ = 64
_Dest$ = 72
_Byte_count$ = 80
_Object_count$ = 88
??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z PROC ; std::_Copy_memmove_tail<enum ZydisRegister_ *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
	mov	QWORD PTR _Dest_ptr$[rsp], rax

; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));

	mov	rax, QWORD PTR _Dest_ptr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove
	npad	1

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

	mov	rax, QWORD PTR _Byte_count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z ENDP ; std::_Copy_memmove_tail<enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z PROC ; std::_To_address<enum ZydisRegister_ *>, COMDAT

; 4641 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4642 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4643 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4644 : }

	ret	0
??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ENDP ; std::_To_address<enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_ &>, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEAW4ZydisRegister_@@@std@@YAAEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_ &>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@W4ZydisRegister_@@AEAW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ &>

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 4
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_ &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z PROC ; std::_Get_unwrapped<enum ZydisRegister_ *>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z ENDP ; std::_Get_unwrapped<enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA?A_TAEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Get_unwrapped<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA?A_TAEBQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Get_unwrapped<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	mov	rax, QWORD PTR $T1[rsp]

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~_Uninitialized_backout_al<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::construct<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 88					; 00000058H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::construct<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z PROC ; std::_Construct_in_place<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	rdx, rax
	mov	ecx, 88					; 00000058H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
	npad	1

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z ENDP ; std::_Construct_in_place<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@@Z ; std::_Get_unwrapped<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@@Z ; std::_Get_unwrapped<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	npad	1

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	mov	rax, QWORD PTR $T1[rsp]

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::construct<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><std::default_delete<IronMan::IAsmHelper>,0>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::construct<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::addressof<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><std::default_delete<IronMan::IAsmHelper>,0>
	npad	1

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 1488				; 000005d0H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z PROC ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ENDP ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 80
<_Args_0>$ = 88
??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z PROC ; std::_Construct_in_place<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::addressof<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	rdx, rax
	mov	ecx, 1488				; 000005d0H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ENDP ; std::_Construct_in_place<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z PROC ; std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAW4ZydisRegister_@@@std@@YA?A_TAEBQEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAW4ZydisRegister_@@@std@@YA?A_TAEBQEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
	mov	r8, rax
	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@00@Z ; std::_Copy_memmove<enum ZydisRegister_ *,enum ZydisRegister_ *>

; 1956 :             return _Dest + (_ULast - _UFirst);

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 2
	mov	rcx, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN1@Uninitiali

; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 4
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAW4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::move<enum ZydisRegister_ &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@W4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAX$$QEAW4ZydisRegister_@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_>
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ENDP ; std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 4
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z PROC ; std::_Unfancy<enum ZydisRegister_>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ENDP ; std::_Unfancy<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z PROC ; std::_Construct_in_place<enum ZydisRegister_,enum ZydisRegister_ const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@AEAW41@@Z ; std::addressof<enum ZydisRegister_>
	mov	rdx, rax
	mov	ecx, 4
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z ENDP ; std::_Construct_in_place<enum ZydisRegister_,enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 40
$T6 = 48
tv128 = 56
tv93 = 64
$T7 = 72
$T8 = 80
__formal$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
<_Args_1>$ = 136
<_Args_2>$ = 144
??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::construct<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
	mov	rdx, rax
	mov	rcx, QWORD PTR $T5[rsp]
	call	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z	; std::tuple<>::tuple<>
	mov	QWORD PTR tv128[rsp], rax
	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T6[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@V?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ; std::forward<std::tuple<enum ZydisRegister_ const &> >
	mov	rdx, rax
	mov	rcx, QWORD PTR $T6[rsp]
	call	??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &>
	mov	QWORD PTR tv93[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	movzx	eax, BYTE PTR $T1[rsp]
	mov	BYTE PTR $T2[rsp], al
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T3[rsp], al
	mov	r9, QWORD PTR tv128[rsp]
	mov	r8, QWORD PTR tv93[rsp]
	movzx	edx, BYTE PTR $T3[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	call	??$?0AEBW4ZydisRegister_@@$$Z$$V@?$pair@$$CBW4ZydisRegister_@@W41@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@Z ; std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>::pair<enum ZydisRegister_ const ,enum ZydisRegister_><enum ZydisRegister_ const &>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::construct<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<enum ZydisRegister_ const &> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<enum ZydisRegister_ const &> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_This_arg$ = 72
??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z PROC ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><enum ZydisRegister_ const &,0>, COMDAT

; 340  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	r8, QWORD PTR _This_arg$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U_Exact_args_t@std@@AEBW4ZydisRegister_@@$$V$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@U_Exact_args_t@1@AEBW4ZydisRegister_@@@Z ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><std::_Exact_args_t,enum ZydisRegister_ const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z ENDP ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><enum ZydisRegister_ const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z PROC ; std::_Move_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 5152 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 5153 :     // move [_First, _Last) to [_Dest, ...)
; 5154 :     // note: _Move_unchecked has callers other than the move family
; 5155 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 5156 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 5157 :     } else {
; 5158 :         if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 5159 : #if _HAS_CXX20
; 5160 :             if (!_STD is_constant_evaluated())
; 5161 : #endif // _HAS_CXX20
; 5162 :             {
; 5163 :                 return _STD _Copy_memmove(_First, _Last, _Dest);

	mov	r8, QWORD PTR _Dest$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Copy_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	jmp	SHORT $LN1@Move_unche

; 5164 :             }
; 5165 :         }
; 5166 : 
; 5167 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

	jmp	SHORT $LN4@Move_unche
$LN2@Move_unche:
	mov	rax, QWORD PTR _Dest$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _Dest$[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _First$[rsp], rax
$LN4@Move_unche:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Move_unche

; 5168 :             *_Dest = _STD move(*_First);

	mov	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 5169 :         }

	jmp	SHORT $LN2@Move_unche
$LN3@Move_unche:

; 5170 : 
; 5171 :         return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
$LN1@Move_unche:

; 5172 :     }
; 5173 : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ENDP ; std::_Move_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Mylast$1 = 32
tv80 = 40
_Al$2 = 48
this$ = 80
??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard, COMDAT

; 637  :         ~_Vaporization_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 638  :             if (_Target != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Vaporizati

; 639  :                 auto& _Al     = _Target->_Getal();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 640  :                 auto& _Mylast = _Target->_Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	mov	QWORD PTR _Mylast$1[rsp], rax

; 641  : 
; 642  :                 _Target->_Orphan_range(_Vaporized_first, _Vaporized_last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv80[rsp]
	call	?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Orphan_range

; 643  :                 _STD _Destroy_range(_Destroyed_first, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$2[rsp]
	mov	rax, QWORD PTR _Mylast$1[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 644  :                 _Mylast = _Vaporized_first;

	mov	rax, QWORD PTR _Mylast$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx
$LN2@Vaporizati:

; 645  :             }
; 646  :         }

	add	rsp, 72					; 00000048H
	ret	0
??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z PROC ; std::_Move_backward_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 5198 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 5199 :     // move [_First, _Last) backwards to [..., _Dest)
; 5200 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 5201 :     if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 5202 : #if _HAS_CXX20
; 5203 :         if (!_STD is_constant_evaluated())
; 5204 : #endif // _HAS_CXX20
; 5205 :         {
; 5206 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

	mov	r8, QWORD PTR _Dest$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_backward_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Copy_backward_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	jmp	SHORT $LN1@Move_backw
$LN2@Move_backw:

; 5207 :         }
; 5208 :     }
; 5209 : 
; 5210 :     while (_First != _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Move_backw

; 5211 :         *--_Dest = _STD move(*--_Last);

	mov	rax, QWORD PTR _Last$[rsp]
	sub	rax, 1488				; 000005d0H
	mov	QWORD PTR _Last$[rsp], rax
	mov	rax, QWORD PTR _Dest$[rsp]
	sub	rax, 1488				; 000005d0H
	mov	QWORD PTR _Dest$[rsp], rax
	mov	rcx, QWORD PTR _Last$[rsp]
	call	??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 5212 :     }

	jmp	SHORT $LN2@Move_backw
$LN3@Move_backw:

; 5213 : 
; 5214 :     return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
$LN1@Move_backw:

; 5215 : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ENDP ; std::_Move_backward_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z PROC ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_TAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_TAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	r8, rax
	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Copy_memmove<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1956 :             return _Dest + (_ULast - _UFirst);

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	imul	rax, rax, 1488				; 000005d0H
	mov	rcx, QWORD PTR _Dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Uninitiali

; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAX$$QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ENDP ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
_TEXT	SEGMENT
this$ = 64
_Val$ = 72
??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49>,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> >
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+8]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
_Dealloc$ = 56
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this

; 899  :     void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 900  :         this->~_Func_impl_no_alloc();
; 901  :         if (_Dealloc) {

	movzx	eax, BYTE PTR _Dealloc$[rsp]
	test	eax, eax
	je	SHORT $LN2@Delete_thi

; 902  :             _STD _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));

	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Deallocate@$07@std@@YAXPEAX_K@Z	; std::_Deallocate<8>
	npad	1
$LN2@Delete_thi:

; 903  :         }
; 904  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get

; 895  :     const void* _Get() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 896  :         return _STD addressof(_Callee);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$addressof@$$CBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YAPEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBV1@@Z ; std::addressof<<lambda_35d54d29033b35d747bcda686a4dea49> const >

; 897  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 8
?_Target_type@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type

; 886  :     const type_info& _Target_type() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 887  :         return typeid(_Callable);

	lea	rax, OFFSET FLAT:??_R0?AV<lambda_35d54d29033b35d747bcda686a4dea49>@@@8

; 888  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
<_Args_0>$ = 56
?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call

; 877  :     _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 878  :         if constexpr (is_void_v<_Rx>) {
; 879  :             (void) _STD invoke(_Callee, _STD forward<_Types>(_Args)...);
; 880  :         } else {
; 881  :             return _STD invoke(_Callee, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	??$invoke@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::invoke<<lambda_35d54d29033b35d747bcda686a4dea49> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>

; 882  :         }
; 883  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_call@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
tv80 = 32
$T1 = 40
this$ = 64
_Where$ = 72
?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move

; 869  :     _Mybase* _Move(void* _Where) noexcept override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 870  :         if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 871  :             return nullptr;
; 872  :         } else {
; 873  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$move@AEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z ; std::move<<lambda_35d54d29033b35d747bcda686a4dea49> &>
	mov	QWORD PTR tv80[rsp], rax
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49>,0>
	npad	1

; 874  :         }
; 875  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Move@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Where$ = 72
?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy

; 859  :     _Mybase* _Copy(void* _Where) const override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 860  :         if constexpr (!is_copy_constructible_v<_Callable>) { // used exclusively for packaged_task
; 861  :             _CSTD abort(); // shouldn't be called, see GH-3888
; 862  :         } else if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 863  :             return _STD _Global_new<_Func_impl_no_alloc>(_Callee);
; 864  :         } else {
; 865  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49> const &,0>

; 866  :         }
; 867  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Copy@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Test_callable@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA_NAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Test_callable@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA_NAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z PROC ; std::_Test_callable<<lambda_35d54d29033b35d747bcda686a4dea49> >, COMDAT

; 713  : bool _Test_callable(const _Ty& _Arg) noexcept { // determine whether std::function must store _Arg

	mov	QWORD PTR [rsp+8], rcx

; 714  :     if constexpr (_Testable_callable_v<_Ty>) {
; 715  :         return !!_Arg;
; 716  :     } else {
; 717  :         return true;

	mov	al, 1

; 718  :     }
; 719  : }

	ret	0
??$_Test_callable@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA_NAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ENDP ; std::_Test_callable<<lambda_35d54d29033b35d747bcda686a4dea49> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
_Dealloc$ = 56
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this

; 899  :     void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 900  :         this->~_Func_impl_no_alloc();
; 901  :         if (_Dealloc) {

	movzx	eax, BYTE PTR _Dealloc$[rsp]
	test	eax, eax
	je	SHORT $LN2@Delete_thi

; 902  :             _STD _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));

	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Deallocate@$07@std@@YAXPEAX_K@Z	; std::_Deallocate<8>
	npad	1
$LN2@Delete_thi:

; 903  :         }
; 904  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get

; 895  :     const void* _Get() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 896  :         return _STD addressof(_Callee);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$addressof@$$CBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YAPEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBV1@@Z ; std::addressof<<lambda_614ae9436da2bf9123d47a10e682c1dd> const >

; 897  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 8
?_Target_type@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type

; 886  :     const type_info& _Target_type() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 887  :         return typeid(_Callable);

	lea	rax, OFFSET FLAT:??_R0?AV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@8

; 888  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
<_Args_0>$ = 56
?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call

; 877  :     _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 878  :         if constexpr (is_void_v<_Rx>) {
; 879  :             (void) _STD invoke(_Callee, _STD forward<_Types>(_Args)...);
; 880  :         } else {
; 881  :             return _STD invoke(_Callee, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	??$invoke@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::invoke<<lambda_614ae9436da2bf9123d47a10e682c1dd> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>

; 882  :         }
; 883  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_call@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
tv80 = 32
$T1 = 40
this$ = 64
_Where$ = 72
?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move

; 869  :     _Mybase* _Move(void* _Where) noexcept override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 870  :         if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 871  :             return nullptr;
; 872  :         } else {
; 873  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$move@AEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z ; std::move<<lambda_614ae9436da2bf9123d47a10e682c1dd> &>
	mov	QWORD PTR tv80[rsp], rax
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>
	npad	1

; 874  :         }
; 875  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Move@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Where$ = 72
?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy

; 859  :     _Mybase* _Copy(void* _Where) const override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 860  :         if constexpr (!is_copy_constructible_v<_Callable>) { // used exclusively for packaged_task
; 861  :             _CSTD abort(); // shouldn't be called, see GH-3888
; 862  :         } else if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 863  :             return _STD _Global_new<_Func_impl_no_alloc>(_Callee);
; 864  :         } else {
; 865  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd> const &,0>

; 866  :         }
; 867  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Copy@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Test_callable@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA_NAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Test_callable@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA_NAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z PROC ; std::_Test_callable<<lambda_614ae9436da2bf9123d47a10e682c1dd> >, COMDAT

; 713  : bool _Test_callable(const _Ty& _Arg) noexcept { // determine whether std::function must store _Arg

	mov	QWORD PTR [rsp+8], rcx

; 714  :     if constexpr (_Testable_callable_v<_Ty>) {
; 715  :         return !!_Arg;
; 716  :     } else {
; 717  :         return true;

	mov	al, 1

; 718  :     }
; 719  : }

	ret	0
??$_Test_callable@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA_NAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ENDP ; std::_Test_callable<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
_TEXT	SEGMENT
this$ = 64
_Val$ = 72
??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+8]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
_Dealloc$ = 56
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this

; 899  :     void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 900  :         this->~_Func_impl_no_alloc();
; 901  :         if (_Dealloc) {

	movzx	eax, BYTE PTR _Dealloc$[rsp]
	test	eax, eax
	je	SHORT $LN2@Delete_thi

; 902  :             _STD _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));

	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Deallocate@$07@std@@YAXPEAX_K@Z	; std::_Deallocate<8>
	npad	1
$LN2@Delete_thi:

; 903  :         }
; 904  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get

; 895  :     const void* _Get() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 896  :         return _STD addressof(_Callee);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$addressof@$$CBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YAPEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBV1@@Z ; std::addressof<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const >

; 897  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 8
?_Target_type@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type

; 886  :     const type_info& _Target_type() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 887  :         return typeid(_Callable);

	lea	rax, OFFSET FLAT:??_R0?AV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@8

; 888  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
<_Args_0>$ = 56
?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call

; 877  :     _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 878  :         if constexpr (is_void_v<_Rx>) {
; 879  :             (void) _STD invoke(_Callee, _STD forward<_Types>(_Args)...);
; 880  :         } else {
; 881  :             return _STD invoke(_Callee, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	??$invoke@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::invoke<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>

; 882  :         }
; 883  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_call@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
tv80 = 32
$T1 = 40
this$ = 64
_Where$ = 72
?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move

; 869  :     _Mybase* _Move(void* _Where) noexcept override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 870  :         if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 871  :             return nullptr;
; 872  :         } else {
; 873  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$move@AEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z ; std::move<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> &>
	mov	QWORD PTR tv80[rsp], rax
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>
	npad	1

; 874  :         }
; 875  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Move@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Where$ = 72
?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy

; 859  :     _Mybase* _Copy(void* _Where) const override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 860  :         if constexpr (!is_copy_constructible_v<_Callable>) { // used exclusively for packaged_task
; 861  :             _CSTD abort(); // shouldn't be called, see GH-3888
; 862  :         } else if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 863  :             return _STD _Global_new<_Func_impl_no_alloc>(_Callee);
; 864  :         } else {
; 865  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> const &,0>

; 866  :         }
; 867  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Copy@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Test_callable@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA_NAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Test_callable@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA_NAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z PROC ; std::_Test_callable<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >, COMDAT

; 713  : bool _Test_callable(const _Ty& _Arg) noexcept { // determine whether std::function must store _Arg

	mov	QWORD PTR [rsp+8], rcx

; 714  :     if constexpr (_Testable_callable_v<_Ty>) {
; 715  :         return !!_Arg;
; 716  :     } else {
; 717  :         return true;

	mov	al, 1

; 718  :     }
; 719  : }

	ret	0
??$_Test_callable@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA_NAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ENDP ; std::_Test_callable<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
_Dealloc$ = 56
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this

; 899  :     void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 900  :         this->~_Func_impl_no_alloc();
; 901  :         if (_Dealloc) {

	movzx	eax, BYTE PTR _Dealloc$[rsp]
	test	eax, eax
	je	SHORT $LN2@Delete_thi

; 902  :             _STD _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));

	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Deallocate@$07@std@@YAXPEAX_K@Z	; std::_Deallocate<8>
	npad	1
$LN2@Delete_thi:

; 903  :         }
; 904  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get

; 895  :     const void* _Get() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 896  :         return _STD addressof(_Callee);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$addressof@$$CBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YAPEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBV1@@Z ; std::addressof<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const >

; 897  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 8
?_Target_type@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type

; 886  :     const type_info& _Target_type() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 887  :         return typeid(_Callable);

	lea	rax, OFFSET FLAT:??_R0?AV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@8

; 888  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
<_Args_0>$ = 56
?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call

; 877  :     _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 878  :         if constexpr (is_void_v<_Rx>) {
; 879  :             (void) _STD invoke(_Callee, _STD forward<_Types>(_Args)...);
; 880  :         } else {
; 881  :             return _STD invoke(_Callee, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	??$invoke@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::invoke<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>

; 882  :         }
; 883  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_call@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
tv80 = 32
$T1 = 40
this$ = 64
_Where$ = 72
?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move

; 869  :     _Mybase* _Move(void* _Where) noexcept override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 870  :         if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 871  :             return nullptr;
; 872  :         } else {
; 873  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$move@AEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z ; std::move<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> &>
	mov	QWORD PTR tv80[rsp], rax
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>
	npad	1

; 874  :         }
; 875  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Move@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Where$ = 72
?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy

; 859  :     _Mybase* _Copy(void* _Where) const override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 860  :         if constexpr (!is_copy_constructible_v<_Callable>) { // used exclusively for packaged_task
; 861  :             _CSTD abort(); // shouldn't be called, see GH-3888
; 862  :         } else if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 863  :             return _STD _Global_new<_Func_impl_no_alloc>(_Callee);
; 864  :         } else {
; 865  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0> const &,0>

; 866  :         }
; 867  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Copy@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Test_callable@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA_NAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Test_callable@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA_NAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z PROC ; std::_Test_callable<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >, COMDAT

; 713  : bool _Test_callable(const _Ty& _Arg) noexcept { // determine whether std::function must store _Arg

	mov	QWORD PTR [rsp+8], rcx

; 714  :     if constexpr (_Testable_callable_v<_Ty>) {
; 715  :         return !!_Arg;
; 716  :     } else {
; 717  :         return true;

	mov	al, 1

; 718  :     }
; 719  : }

	ret	0
??$_Test_callable@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA_NAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ENDP ; std::_Test_callable<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>, COMDAT

; 854  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
_Dealloc$ = 56
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this

; 899  :     void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 900  :         this->~_Func_impl_no_alloc();
; 901  :         if (_Dealloc) {

	movzx	eax, BYTE PTR _Dealloc$[rsp]
	test	eax, eax
	je	SHORT $LN2@Delete_thi

; 902  :             _STD _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));

	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Deallocate@$07@std@@YAXPEAX_K@Z	; std::_Deallocate<8>
	npad	1
$LN2@Delete_thi:

; 903  :         }
; 904  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get

; 895  :     const void* _Get() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 896  :         return _STD addressof(_Callee);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$addressof@$$CBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YAPEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBV1@@Z ; std::addressof<<lambda_564f9749a9a51d2fffa238f6767f2a0a> const >

; 897  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 8
?_Target_type@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type

; 886  :     const type_info& _Target_type() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 887  :         return typeid(_Callable);

	lea	rax, OFFSET FLAT:??_R0?AV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@8

; 888  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAAEBVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
this$ = 48
<_Args_0>$ = 56
?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call

; 877  :     _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 878  :         if constexpr (is_void_v<_Rx>) {
; 879  :             (void) _STD invoke(_Callee, _STD forward<_Types>(_Args)...);
; 880  :         } else {
; 881  :             return _STD invoke(_Callee, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	??$invoke@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$$V@std@@YA_NAEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::invoke<<lambda_564f9749a9a51d2fffa238f6767f2a0a> &,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>

; 882  :         }
; 883  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_call@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
tv80 = 32
$T1 = 40
this$ = 64
_Where$ = 72
?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move

; 869  :     _Mybase* _Move(void* _Where) noexcept override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 870  :         if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 871  :             return nullptr;
; 872  :         } else {
; 873  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$move@AEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z ; std::move<<lambda_564f9749a9a51d2fffa238f6767f2a0a> &>
	mov	QWORD PTR tv80[rsp], rax
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>
	npad	1

; 874  :         }
; 875  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Move@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEAAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Where$ = 72
?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy

; 859  :     _Mybase* _Copy(void* _Where) const override {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 860  :         if constexpr (!is_copy_constructible_v<_Callable>) { // used exclusively for packaged_task
; 861  :             _CSTD abort(); // shouldn't be called, see GH-3888
; 862  :         } else if constexpr (_Is_large<_Func_impl_no_alloc>) {
; 863  :             return _STD _Global_new<_Func_impl_no_alloc>(_Callee);
; 864  :         } else {
; 865  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a> const &,0>

; 866  :         }
; 867  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Copy@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@EEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@PEAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Test_callable@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA_NAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Test_callable@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA_NAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z PROC ; std::_Test_callable<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >, COMDAT

; 713  : bool _Test_callable(const _Ty& _Arg) noexcept { // determine whether std::function must store _Arg

	mov	QWORD PTR [rsp+8], rcx

; 714  :     if constexpr (_Testable_callable_v<_Ty>) {
; 715  :         return !!_Arg;
; 716  :     } else {
; 717  :         return true;

	mov	al, 1

; 718  :     }
; 719  : }

	ret	0
??$_Test_callable@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA_NAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ENDP ; std::_Test_callable<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z PROC ; std::forward<enum ZydisRegister_ *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ENDP ; std::forward<enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAVAsmHelper64@IronMan@@@std@@YA$$QEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVAsmHelper64@IronMan@@@std@@YA$$QEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z PROC ; std::forward<IronMan::AsmHelper64 *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAVAsmHelper64@IronMan@@@std@@YA$$QEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z ENDP ; std::forward<IronMan::AsmHelper64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z PROC ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1><IronMan::AsmHelper64 * &>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@AEAPEAVAsmHelper64@IronMan@@@std@@YAAEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z ; std::forward<IronMan::AsmHelper64 * &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z ENDP ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1><IronMan::AsmHelper64 * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<enum ZydisRegister_> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<IronMan::AsmHelper64 *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<IronMan::AsmHelper64 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_Guard$1 = 48
_Alproxy$ = 56
_Al$ = 64
tv95 = 72
tv93 = 80
tv91 = 88
this$ = 112
_Count$ = 120
<_Val_0>$ = 128
<_Val_1>$ = 136
??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Construct_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &,IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>, COMDAT

; 2087 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2088 :         // Dispatches between the three sized constructions.
; 2089 :         // 1-arg -> value-construction, e.g. vector(5)
; 2090 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2091 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2092 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2093 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2094 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2095 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 2096 :         if (_Count != 0) {

	cmp	QWORD PTR _Count$[rsp], 0
	je	$LN2@Construct_

; 2097 :             _Buy_nonzero(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_nonzero

; 2098 :             _Tidy_guard<vector> _Guard{this};

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Guard$1[rsp], rax

; 2099 :             if constexpr (sizeof...(_Val) == 0) {
; 2100 :                 _My_data._Mylast = _STD _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
; 2101 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2102 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2103 :                 _My_data._Mylast = _STD _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2104 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2105 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv95[rsp], rax
	mov	rcx, QWORD PTR <_Val_1>$[rsp]
	call	??$forward@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv93[rsp], rax
	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR tv95[rsp]
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$_Uninitialized_copy@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 2106 :             } else {
; 2107 :                 _STL_INTERNAL_STATIC_ASSERT(false); // unexpected number of arguments
; 2108 :             }
; 2109 :             _ASAN_VECTOR_CREATE;
; 2110 :             _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$1[rsp], 0

; 2111 :         }

	lea	rcx, QWORD PTR _Guard$1[rsp]
	call	??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::~_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
	npad	1
$LN2@Construct_:

; 2112 : 
; 2113 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 2114 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Construct_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &,IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_Guard$1 = 48
_Alproxy$ = 56
_Al$ = 64
tv95 = 72
tv93 = 80
tv91 = 88
this$ = 112
_Count$ = 120
<_Val_0>$ = 128
<_Val_1>$ = 136
?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Construct_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &,IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$1[rbp]
	call	??1?$_Tidy_guard@V?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::~_Tidy_guard<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Construct_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &,IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ; std::forward<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_Guard$1 = 48
_Alproxy$ = 56
_Al$ = 64
tv95 = 72
tv93 = 80
tv91 = 88
this$ = 112
_Count$ = 120
<_Val_0>$ = 128
<_Val_1>$ = 136
??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Construct_n<enum ZydisRegister_ * const &,enum ZydisRegister_ * const &>, COMDAT

; 2087 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2088 :         // Dispatches between the three sized constructions.
; 2089 :         // 1-arg -> value-construction, e.g. vector(5)
; 2090 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2091 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2092 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2093 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2094 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2095 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 2096 :         if (_Count != 0) {

	cmp	QWORD PTR _Count$[rsp], 0
	je	$LN2@Construct_

; 2097 :             _Buy_nonzero(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_nonzero

; 2098 :             _Tidy_guard<vector> _Guard{this};

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Guard$1[rsp], rax

; 2099 :             if constexpr (sizeof...(_Val) == 0) {
; 2100 :                 _My_data._Mylast = _STD _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
; 2101 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2102 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2103 :                 _My_data._Mylast = _STD _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2104 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2105 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv95[rsp], rax
	mov	rcx, QWORD PTR <_Val_1>$[rsp]
	call	??$forward@AEBQEAW4ZydisRegister_@@@std@@YAAEBQEAW4ZydisRegister_@@AEBQEAW41@@Z ; std::forward<enum ZydisRegister_ * const &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv93[rsp], rax
	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBQEAW4ZydisRegister_@@@std@@YAAEBQEAW4ZydisRegister_@@AEBQEAW41@@Z ; std::forward<enum ZydisRegister_ * const &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR tv95[rsp]
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$_Uninitialized_copy@PEAW4ZydisRegister_@@PEAW41@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@00AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_copy<enum ZydisRegister_ *,enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 2106 :             } else {
; 2107 :                 _STL_INTERNAL_STATIC_ASSERT(false); // unexpected number of arguments
; 2108 :             }
; 2109 :             _ASAN_VECTOR_CREATE;
; 2110 :             _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$1[rsp], 0

; 2111 :         }

	lea	rcx, QWORD PTR _Guard$1[rsp]
	call	??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >::~_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >
	npad	1
$LN2@Construct_:

; 2112 : 
; 2113 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 2114 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Construct_n<enum ZydisRegister_ * const &,enum ZydisRegister_ * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_Guard$1 = 48
_Alproxy$ = 56
_Al$ = 64
tv95 = 72
tv93 = 80
tv91 = 88
this$ = 112
_Count$ = 120
<_Val_0>$ = 128
<_Val_1>$ = 136
?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA PROC ; `std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Construct_n<enum ZydisRegister_ * const &,enum ZydisRegister_ * const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$1[rbp]
	call	??1?$_Tidy_guard@V?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >::~_Tidy_guard<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z@4HA ENDP ; `std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Construct_n<enum ZydisRegister_ * const &,enum ZydisRegister_ * const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ; std::forward<std::allocator<enum ZydisRegister_> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z PROC ; std::_Unfancy_maybe_null<enum ZydisRegister_>, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ENDP ; std::_Unfancy_maybe_null<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z PROC ; std::_Unfancy_maybe_null<IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ENDP ; std::_Unfancy_maybe_null<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAD@std@@YA$$QEADAEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAD@std@@YA$$QEADAEAD@Z PROC			; std::move<char &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAD@std@@YA$$QEADAEAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::destroy<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	ret	0
??$destroy@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::destroy<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z PROC ; std::addressof<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::destroy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::destroy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z PROC ; std::_Unfancy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Dest$ = 80
??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z PROC ; std::_Copy_n_unchecked4<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,unsigned __int64,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 4813 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 4814 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4815 :     // note: has callers outside the copy family
; 4816 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4817 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 4818 : 
; 4819 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4820 : #if _HAS_CXX20
; 4821 :         if (!_STD is_constant_evaluated())
; 4822 : #endif // _HAS_CXX20
; 4823 :         {
; 4824 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);

	mov	r8, QWORD PTR _Dest$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ; std::_Copy_memmove_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	jmp	SHORT $LN1@Copy_n_unc

; 4825 :         }
; 4826 :     }
; 4827 : 
; 4828 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	jmp	SHORT $LN4@Copy_n_unc
$LN2@Copy_n_unc:
	mov	rax, QWORD PTR _Dest$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _Dest$[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _First$[rsp], rax
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN4@Copy_n_unc:
	cmp	QWORD PTR _Count$[rsp], 0
	je	SHORT $LN3@Copy_n_unc

; 4829 :         *_Dest = *_First;

	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, QWORD PTR _First$[rsp]
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 4830 :     }

	jmp	SHORT $LN2@Copy_n_unc
$LN3@Copy_n_unc:

; 4831 : 
; 4832 :     return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
$LN1@Copy_n_unc:

; 4833 : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ENDP ; std::_Copy_n_unchecked4<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,unsigned __int64,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z
_TEXT	SEGMENT
_First_ptr$ = 32
_Byte_count$ = 40
_First_ch$ = 48
_First$ = 80
_Object_count$ = 88
_Dest$ = 96
??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z PROC ; std::_Copy_memmove_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 4790 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4791 :     const auto _First_ptr  = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_PAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_To_address<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 4792 :     const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4793 :     const auto _Byte_count = _Object_count * sizeof(*_First_ptr);

	imul	rax, QWORD PTR _Object_count$[rsp], 1488 ; 000005d0H
	mov	QWORD PTR _Byte_count$[rsp], rax

; 4794 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	r9, QWORD PTR _Object_count$[rsp]
	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _First_ch$[rsp]
	call	??$_Copy_memmove_tail@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEBDQEAU1234@_K2@Z ; std::_Copy_memmove_tail<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 4795 : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ENDP ; std::_Copy_memmove_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
_TEXT	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z PROC ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1873 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1874 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1875 :     // note: only called internally from elsewhere in the STL
; 1876 :     using _Ptrval = typename _Alloc::value_type*;
; 1877 : 
; 1878 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1879 :     auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
; 1880 : #else // ^^^ Checking / No checking vvv
; 1881 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	rcx, rax
	call	??$_Get_unwrapped@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA?A_T$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1882 : #endif // ^^^ No checking ^^^
; 1883 : 
; 1884 :     constexpr bool _Can_memmove =

	mov	BYTE PTR _Can_memmove$[rsp], 1

; 1885 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1886 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1887 : 
; 1888 :     if constexpr (_Can_memmove) {
; 1889 : #if _HAS_CXX20
; 1890 :         if (!_STD is_constant_evaluated())
; 1891 : #endif // _HAS_CXX20
; 1892 :         {
; 1893 :             _STD _Copy_memmove_n(_UFirst, _Count, _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	r8, rax
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ; std::_Copy_memmove_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1894 :             _Dest += _Count;

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Dest$[rsp], rax

; 1895 :             return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
	jmp	SHORT $LN1@Uninitiali

; 1896 :         }
; 1897 :     }
; 1898 : 
; 1899 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _UFirst$[rsp], rax
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN4@Uninitiali:
	cmp	QWORD PTR _Count$[rsp], 0
	je	SHORT $LN3@Uninitiali

; 1901 :         _Backout._Emplace_back(*_UFirst);

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@AEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo &>
	npad	1

; 1902 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1903 : 
; 1904 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1905 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ENDP ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~_Uninitialized_backout_al<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z PROC ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ENDP ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z PROC ; std::_Copy_n_unchecked4<enum ZydisRegister_ *,unsigned __int64,enum ZydisRegister_ *>, COMDAT

; 4813 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4814 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4815 :     // note: has callers outside the copy family
; 4816 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4817 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 4818 : 
; 4819 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4820 : #if _HAS_CXX20
; 4821 :         if (!_STD is_constant_evaluated())
; 4822 : #endif // _HAS_CXX20
; 4823 :         {
; 4824 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);

	mov	r8, QWORD PTR _Dest$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ; std::_Copy_memmove_n<enum ZydisRegister_ *,enum ZydisRegister_ *>
	jmp	SHORT $LN1@Copy_n_unc

; 4825 :         }
; 4826 :     }
; 4827 : 
; 4828 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	jmp	SHORT $LN4@Copy_n_unc
$LN2@Copy_n_unc:
	mov	rax, QWORD PTR _Dest$[rsp]
	add	rax, 4
	mov	QWORD PTR _Dest$[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 4
	mov	QWORD PTR _First$[rsp], rax
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN4@Copy_n_unc:
	cmp	QWORD PTR _Count$[rsp], 0
	je	SHORT $LN3@Copy_n_unc

; 4829 :         *_Dest = *_First;

	mov	rax, QWORD PTR _Dest$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 4830 :     }

	jmp	SHORT $LN2@Copy_n_unc
$LN3@Copy_n_unc:

; 4831 : 
; 4832 :     return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
$LN1@Copy_n_unc:

; 4833 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ENDP ; std::_Copy_n_unchecked4<enum ZydisRegister_ *,unsigned __int64,enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z
_TEXT	SEGMENT
_First_ptr$ = 32
_Byte_count$ = 40
_First_ch$ = 48
_First$ = 80
_Object_count$ = 88
_Dest$ = 96
??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z PROC ; std::_Copy_memmove_n<enum ZydisRegister_ *,enum ZydisRegister_ *>, COMDAT

; 4790 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4791 :     const auto _First_ptr  = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAW4ZydisRegister_@@@std@@YA?A_PAEBQEAW4ZydisRegister_@@@Z ; std::_To_address<enum ZydisRegister_ *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 4792 :     const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4793 :     const auto _Byte_count = _Object_count * sizeof(*_First_ptr);

	mov	rax, QWORD PTR _Object_count$[rsp]
	shl	rax, 2
	mov	QWORD PTR _Byte_count$[rsp], rax

; 4794 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	r9, QWORD PTR _Object_count$[rsp]
	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _First_ch$[rsp]
	call	??$_Copy_memmove_tail@PEAW4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@QEBDQEAW41@_K2@Z ; std::_Copy_memmove_tail<enum ZydisRegister_ *>

; 4795 : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ENDP ; std::_Copy_memmove_n<enum ZydisRegister_ *,enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z
_TEXT	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z PROC ; std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >, COMDAT

; 1873 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1874 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1875 :     // note: only called internally from elsewhere in the STL
; 1876 :     using _Ptrval = typename _Alloc::value_type*;
; 1877 : 
; 1878 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1879 :     auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
; 1880 : #else // ^^^ Checking / No checking vvv
; 1881 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	rcx, rax
	call	??$_Get_unwrapped@PEAW4ZydisRegister_@@@std@@YA?A_T$$QEAPEAW4ZydisRegister_@@@Z ; std::_Get_unwrapped<enum ZydisRegister_ *>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1882 : #endif // ^^^ No checking ^^^
; 1883 : 
; 1884 :     constexpr bool _Can_memmove =

	mov	BYTE PTR _Can_memmove$[rsp], 1

; 1885 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1886 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1887 : 
; 1888 :     if constexpr (_Can_memmove) {
; 1889 : #if _HAS_CXX20
; 1890 :         if (!_STD is_constant_evaluated())
; 1891 : #endif // _HAS_CXX20
; 1892 :         {
; 1893 :             _STD _Copy_memmove_n(_UFirst, _Count, _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
	mov	r8, rax
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ; std::_Copy_memmove_n<enum ZydisRegister_ *,enum ZydisRegister_ *>

; 1894 :             _Dest += _Count;

	mov	rax, QWORD PTR _Dest$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR _Dest$[rsp], rax

; 1895 :             return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
	jmp	SHORT $LN1@Uninitiali

; 1896 :         }
; 1897 :     }
; 1898 : 
; 1899 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 4
	mov	QWORD PTR _UFirst$[rsp], rax
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN4@Uninitiali:
	cmp	QWORD PTR _Count$[rsp], 0
	je	SHORT $LN3@Uninitiali

; 1901 :         _Backout._Emplace_back(*_UFirst);

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@AEAW4ZydisRegister_@@@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEAW4ZydisRegister_@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Emplace_back<enum ZydisRegister_ &>
	npad	1

; 1902 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1903 : 
; 1904 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAPEAW4ZydisRegister_@@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1905 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z ENDP ; std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Can_memmove$ = 32
_UFirst$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >::~_Uninitialized_backout_al<std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z PROC ; std::move<enum ZydisRegister_ * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ENDP ; std::move<enum ZydisRegister_ * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_reallocate<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 88					; 00000058H
	idiv	rcx
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 88					; 00000058H
	idiv	rcx
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+88]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv132[rsp], rax
	imul	rax, QWORD PTR _Whereoff$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z ; std::_Unfancy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::construct<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+88]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> *,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_reallocate<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA PROC ; `std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_reallocate<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z@4HA ENDP ; `std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_reallocate<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv74 = 48
tv72 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back_with_unused_capacity<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??$_Construct_in_place@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@U12@@std@@YAXAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@$$QEAU10@@Z ; std::_Construct_in_place<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	npad	1

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@0@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 88					; 00000058H
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back_with_unused_capacity<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z PROC ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::destroy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::destroy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z PROC ; std::_Unfancy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z ENDP ; std::_Unfancy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBU?$less@W4ZydisRegister_@@@std@@@std@@YAAEBU?$less@W4ZydisRegister_@@@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBU?$less@W4ZydisRegister_@@@std@@@std@@YAAEBU?$less@W4ZydisRegister_@@@0@AEBU10@@Z PROC ; std::forward<std::less<enum ZydisRegister_> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBU?$less@W4ZydisRegister_@@@std@@@std@@YAAEBU?$less@W4ZydisRegister_@@@0@AEBU10@@Z ENDP ; std::forward<std::less<enum ZydisRegister_> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);

	mov	rax, QWORD PTR _It$[rsp]

; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_reallocate<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 3
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 3
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8+8]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	rcx, rax
	call	??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::construct<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8+8]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > *,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_reallocate<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_reallocate<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_reallocate<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv74 = 48
tv72 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??$_Construct_in_place@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	npad	1

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@0@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_reallocate<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1488]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	mov	QWORD PTR tv132[rsp], rax
	imul	rax, QWORD PTR _Whereoff$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::construct<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1488]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_reallocate<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_reallocate<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_reallocate<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv74 = 48
tv72 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back_with_unused_capacity<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??$_Construct_in_place@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@std@@YAXAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::_Construct_in_place<IronMan::Analysis::UObjectAnalysis::InstructionInfo,IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	npad	1

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 1488				; 000005d0H
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back_with_unused_capacity<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z PROC ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ENDP ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_reallocate<enum ZydisRegister_ const &>, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 2
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 2
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<enum ZydisRegister_> >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4+4]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	rcx, rax
	call	??$_Unfancy@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy<enum ZydisRegister_>
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@W4ZydisRegister_@@AEBW41@@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SAXAEAV?$allocator@W4ZydisRegister_@@@1@QEAW4ZydisRegister_@@AEBW43@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::construct<enum ZydisRegister_,enum ZydisRegister_ const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4+4]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@QEAW41@0PEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_move<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_reallocate<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA PROC ; `std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_reallocate<enum ZydisRegister_ const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z@4HA ENDP ; `std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_reallocate<enum ZydisRegister_ const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv74 = 48
tv72 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_back_with_unused_capacity<enum ZydisRegister_ const &>, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??$_Construct_in_place@W4ZydisRegister_@@AEBW41@@std@@YAXAEAW4ZydisRegister_@@AEBW41@@Z ; std::_Construct_in_place<enum ZydisRegister_,enum ZydisRegister_ const &>
	npad	1

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAXPEAW4ZydisRegister_@@0@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_back_with_unused_capacity<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 370  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 371  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 372  :         _Destroy_in_place(_Ptr->_Left);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>

; 373  :         _Destroy_in_place(_Ptr->_Parent);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>

; 374  :         _Destroy_in_place(_Ptr->_Right);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>

; 375  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::deallocate
	npad	1

; 376  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
tv141 = 48
tv139 = 56
tv137 = 64
tv135 = 72
tv133 = 80
this$ = 112
_Al_$ = 120
_Myhead$ = 128
<_Vals_0>$ = 136
<_Vals_1>$ = 144
<_Vals_2>$ = 152
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > ><std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >, COMDAT

; 819  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 820  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_2>$[rsp]
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@V?$tuple@AEBW4ZydisRegister_@@@std@@@std@@YA$$QEAV?$tuple@AEBW4ZydisRegister_@@@0@AEAV10@@Z ; std::forward<std::tuple<enum ZydisRegister_ const &> >
	mov	QWORD PTR tv139[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 28
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z ; std::addressof<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
	mov	QWORD PTR tv135[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv133[rsp], rax
	mov	rax, QWORD PTR tv141[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv139[rsp]
	mov	r8, QWORD PTR tv137[rsp]
	mov	rdx, QWORD PTR tv135[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	??$construct@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBW4ZydisRegister_@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::construct<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >

; 821  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	lea	rdx, QWORD PTR _Myhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>

; 822  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	lea	rdx, QWORD PTR _Myhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>

; 823  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	lea	rdx, QWORD PTR _Myhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>

; 824  :         this->_Ptr->_Color = _Red;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 825  :         this->_Ptr->_Isnil = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+25], 0

; 826  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > ><std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv141 = 48
tv139 = 56
tv137 = 64
tv135 = 72
tv133 = 80
this$ = 112
_Al_$ = 120
_Myhead$ = 128
<_Vals_0>$ = 136
<_Vals_1>$ = 144
<_Vals_2>$ = 152
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > ><std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > ><std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv146 = 32
tv144 = 40
this$ = 64
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 831  :     ~_Tree_temp_node() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         if (this->_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Tree_temp_

; 833  :             _Destroy_in_place(this->_Ptr->_Left);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>

; 834  :             _Destroy_in_place(this->_Ptr->_Parent);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>

; 835  :             _Destroy_in_place(this->_Ptr->_Right);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>

; 836  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 28
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z ; std::addressof<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
	mov	QWORD PTR tv146[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv144[rsp], rax
	mov	rdx, QWORD PTR tv146[rsp]
	mov	rcx, QWORD PTR tv144[rsp]
	call	??$destroy@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::destroy<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
	npad	1
$LN2@Tree_temp_:

; 837  :         }
; 838  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv146 = 32
tv144 = 40
this$ = 64
?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 798  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 799  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Allocate
	npad	1

; 800  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 1004 : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

	mov	QWORD PTR [rsp+8], rcx

; 1005 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1006 : }

	ret	0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &>, COMDAT

; 352  :     tuple(tuple&&)      = default;

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z	; std::tuple<>::tuple<>
	mov	rax, QWORD PTR __that$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
<_Args_0>$ = 56
??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z PROC ; std::forward_as_tuple<enum ZydisRegister_ const &>, COMDAT

; 1004 : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1005 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0AEBW4ZydisRegister_@@$0A@@?$tuple@AEBW4ZydisRegister_@@@std@@QEAA@AEBW4ZydisRegister_@@@Z ; std::tuple<enum ZydisRegister_ const &>::tuple<enum ZydisRegister_ const &><enum ZydisRegister_ const &,0>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1006 : }

	add	rsp, 40					; 00000028H
	ret	0
??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z ENDP ; std::forward_as_tuple<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z PROC ; std::forward<enum ZydisRegister_ const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ENDP ; std::forward<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
tv82 = 32
tv77 = 40
tv79 = 48
this$ = 80
_Bound$ = 88
_Keyval$ = 96
??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Lower_bound_duplicate<enum ZydisRegister_>, COMDAT

; 1613 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	rax, QWORD PTR _Bound$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@Lower_boun
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Bound$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv77[rsp]
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ; std::less<enum ZydisRegister_>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Lower_boun
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:
	mov	DWORD PTR tv82[rsp], 0
$LN4@Lower_boun:
	movzx	eax, BYTE PTR tv82[rsp]

; 1615 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Lower_bound_duplicate<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_Trynode$ = 32
_Scary$ = 40
tv82 = 48
tv84 = 56
_Result$ = 64
this$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find_lower_bound<enum ZydisRegister_>, COMDAT

; 1618 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 1619 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1620 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Result$[rsp], rax
	mov	DWORD PTR _Result$[rsp+8], 0
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp+16], rax

; 1621 :         _Nodeptr _Trynode = _Result._Location._Parent;

	mov	rax, QWORD PTR _Result$[rsp]
	mov	QWORD PTR _Trynode$[rsp], rax
$LN2@Find_lower:

; 1622 :         while (!_Trynode->_Isnil) {

	mov	rax, QWORD PTR _Trynode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	$LN3@Find_lower

; 1623 :             _Result._Location._Parent = _Trynode;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 1624 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Trynode$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>
	mov	QWORD PTR tv82[rsp], rax
	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ; std::less<enum ZydisRegister_>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Find_lower

; 1625 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Result$[rsp+8], 0

; 1626 :                 _Trynode                 = _Trynode->_Right;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Trynode$[rsp], rax

; 1627 :             } else {

	jmp	SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1628 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Result$[rsp+8], 1

; 1629 :                 _Result._Bound           = _Trynode;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	QWORD PTR _Result$[rsp+16], rax

; 1630 :                 _Trynode                 = _Trynode->_Left;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Trynode$[rsp], rax
$LN5@Find_lower:

; 1631 :             }
; 1632 :         }

	jmp	$LN2@Find_lower
$LN3@Find_lower:

; 1633 : 
; 1634 :         return _Result;

	lea	rax, QWORD PTR _Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1635 :     }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find_lower_bound<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
_TEXT	SEGMENT
_Whereptr$ = 32
_Oldlast$ = 40
_Al$ = 48
_Newvec$1 = 56
_Mylast$ = 64
_Oldfirst$ = 72
_Whereoff$2 = 80
_Relocated$3 = 88
_My_data$ = 96
_Newcapacity$4 = 104
_Oldsize$5 = 112
_Constructed_last$6 = 120
_Constructed_first$7 = 128
_Newsize$8 = 136
_Unused_capacity$ = 144
tv130 = 152
_Affected_elements$9 = 160
_Guard$10 = 168
_Guard$11 = 208
_Guard$12 = 240
this$ = 288
_Where$ = 296
_First$ = 304
_Count$ = 312
??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 1150 :     _CONSTEXPR20 void _Insert_counted_range(const_iterator _Where, _Iter _First, const size_type _Count) {

$LN28:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H

; 1151 :         // insert counted range _First + [0, _Count) at _Where
; 1152 :         const pointer _Whereptr = _Where._Ptr;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	QWORD PTR _Whereptr$[rsp], rax

; 1153 : 
; 1154 :         auto& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1155 :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1156 :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1157 : 
; 1158 :         const pointer _Oldfirst     = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Oldfirst$[rsp], rax

; 1159 :         const pointer _Oldlast      = _Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Oldlast$[rsp], rax

; 1160 :         const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Oldlast$[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Unused_capacity$[rsp], rax

; 1161 : 
; 1162 :         if (_Count == 0) { // nothing to do, avoid invalidating iterators

	cmp	QWORD PTR _Count$[rsp], 0
	jne	SHORT $LN2@Insert_cou
	jmp	$LN13@Insert_cou
$LN2@Insert_cou:

; 1163 :         } else if (_Count > _Unused_capacity) { // reallocate

	mov	rax, QWORD PTR _Unused_capacity$[rsp]
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	$LN4@Insert_cou

; 1164 :             const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

	mov	rax, QWORD PTR _Oldfirst$[rsp]
	mov	rcx, QWORD PTR _Oldlast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Oldsize$5[rsp], rax

; 1165 : 
; 1166 :             if (_Count > max_size() - _Oldsize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
	sub	rax, QWORD PTR _Oldsize$5[rsp]
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN6@Insert_cou

; 1167 :                 _Xlength();

	call	?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength
	npad	1
$LN6@Insert_cou:

; 1168 :             }
; 1169 : 
; 1170 :             const size_type _Newsize = _Oldsize + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Oldsize$5[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Newsize$8[rsp], rax

; 1171 :             size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$8[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$4[rsp], rax

; 1172 : 
; 1173 :             const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$4[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	QWORD PTR _Newvec$1[rsp], rax

; 1174 :             const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);

	mov	rax, QWORD PTR _Oldfirst$[rsp]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Whereoff$2[rsp], rax

; 1175 :             const pointer _Constructed_last = _Newvec + _Whereoff + _Count;

	imul	rax, QWORD PTR _Whereoff$2[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	imul	rcx, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	add	rax, rcx
	mov	QWORD PTR _Constructed_last$6[rsp], rax

; 1176 : 
; 1177 :             _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$10[rsp], rax
	mov	rax, QWORD PTR _Newvec$1[rsp]
	mov	QWORD PTR _Guard$10[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$4[rsp]
	mov	QWORD PTR _Guard$10[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$6[rsp]
	mov	QWORD PTR _Guard$10[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$6[rsp]
	mov	QWORD PTR _Guard$10[rsp+32], rax

; 1178 :             auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$10[rsp+24]
	mov	QWORD PTR _Constructed_first$7[rsp], rax

; 1179 : 
; 1180 :             _STD _Uninitialized_copy_n(_STD move(_First), _Count, _Newvec + _Whereoff, _Al);

	imul	rax, QWORD PTR _Whereoff$2[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv130[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	r9, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1181 :             _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$2[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$7[rsp]
	mov	QWORD PTR [rcx], rax

; 1182 : 
; 1183 :             if (_Count == 1 && _Whereptr == _Oldlast) { // one at back, provide strong guarantee

	cmp	QWORD PTR _Count$[rsp], 1
	jne	SHORT $LN7@Insert_cou
	mov	rax, QWORD PTR _Oldlast$[rsp]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN7@Insert_cou

; 1184 :                 if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1185 :                     _STD _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$1[rsp]
	mov	rdx, QWORD PTR _Oldlast$[rsp]
	mov	rcx, QWORD PTR _Oldfirst$[rsp]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 1186 :                 } else {
; 1187 :                     _STD _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
; 1188 :                 }
; 1189 :             } else { // provide basic guarantee

	jmp	SHORT $LN8@Insert_cou
$LN7@Insert_cou:

; 1190 :                 _STD _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$1[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rcx, QWORD PTR _Oldfirst$[rsp]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1191 :                 _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$7[rsp]
	mov	rcx, QWORD PTR _Newvec$1[rsp]
	mov	QWORD PTR [rax], rcx

; 1192 :                 _STD _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);

	imul	rax, QWORD PTR _Whereoff$2[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	imul	rcx, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	add	rax, rcx
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Oldlast$[rsp]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
$LN8@Insert_cou:

; 1193 :             }
; 1194 : 
; 1195 :             _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$10[rsp+8], 0

; 1196 :             _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$4[rsp]
	mov	r8, QWORD PTR _Newsize$8[rsp]
	mov	rdx, QWORD PTR _Newvec$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Change_array
	npad	1

; 1197 :         } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.

	lea	rcx, QWORD PTR _Guard$10[rsp]
	call	??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard
	npad	1
	jmp	$LN13@Insert_cou
$LN4@Insert_cou:

; 1198 :                  // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
; 1199 :                  // (For one-at-back, this provides the strong guarantee.)
; 1200 : 
; 1201 :             const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

	mov	rax, QWORD PTR _Whereptr$[rsp]
	mov	rcx, QWORD PTR _Oldlast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Affected_elements$9[rsp], rax

; 1202 : 
; 1203 :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Oldlast - _Oldfirst) + _Count);
; 1204 :             if (_Count < _Affected_elements) { // some affected elements must be assigned

	mov	rax, QWORD PTR _Affected_elements$9[rsp]
	cmp	QWORD PTR _Count$[rsp], rax
	jae	$LN9@Insert_cou

; 1205 :                 _Mylast = _STD _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Oldlast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Oldlast$[rsp]
	mov	rdx, QWORD PTR _Oldlast$[rsp]
	mov	rcx, rax
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1206 :                 _STD _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Oldlast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Oldlast$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Move_backward_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Move_backward_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1207 :                 _STD _Destroy_range(_Whereptr, _Whereptr + _Count, _Al);

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 1208 : 
; 1209 :                 _TRY_BEGIN
; 1210 :                 _STD _Uninitialized_copy_n(_STD move(_First), _Count, _Whereptr, _Al);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Whereptr$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	jmp	SHORT $LN21@Insert_cou
$LN22@Insert_cou:
$LN21@Insert_cou:

; 1211 :                 _CATCH_ALL
; 1212 :                 // glue the broken pieces back together
; 1213 : 
; 1214 :                 _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Whereptr + _Count};
; 1215 :                 _STD _Uninitialized_move(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr, _Al);
; 1216 :                 _Guard._Target = nullptr;
; 1217 : 
; 1218 :                 _STD _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
; 1219 :                 _STD _Destroy_range(_Oldlast, _Mylast, _Al);
; 1220 :                 _Mylast = _Oldlast;
; 1221 :                 _RERAISE;
; 1222 :                 _CATCH_END
; 1223 :             } else { // affected elements don't overlap before/after

	jmp	SHORT $LN10@Insert_cou
$LN9@Insert_cou:

; 1224 :                 const pointer _Relocated = _Whereptr + _Count;

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Relocated$3[rsp], rax

; 1225 :                 _Mylast                  = _STD _Uninitialized_move(_Whereptr, _Oldlast, _Relocated, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Relocated$3[rsp]
	mov	rdx, QWORD PTR _Oldlast$[rsp]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1226 :                 _STD _Destroy_range(_Whereptr, _Oldlast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Oldlast$[rsp]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 1227 : 
; 1228 :                 _TRY_BEGIN
; 1229 :                 _STD _Uninitialized_copy_n(_STD move(_First), _Count, _Whereptr, _Al);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Whereptr$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	jmp	SHORT $LN10@Insert_cou
$LN24@Insert_cou:
$LN10@Insert_cou:

; 1230 :                 _CATCH_ALL
; 1231 :                 // glue the broken pieces back together
; 1232 : 
; 1233 :                 _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Relocated};
; 1234 :                 _STD _Uninitialized_move(_Relocated, _Mylast, _Whereptr, _Al);
; 1235 :                 _Guard._Target = nullptr;
; 1236 : 
; 1237 :                 _STD _Destroy_range(_Relocated, _Mylast, _Al);
; 1238 :                 _Mylast = _Oldlast;
; 1239 :                 _RERAISE;
; 1240 :                 _CATCH_END
; 1241 :             }
; 1242 : 
; 1243 :             _Orphan_range(_Whereptr, _Oldlast);

	mov	r8, QWORD PTR _Oldlast$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Orphan_range
	npad	1
$LN13@Insert_cou:

; 1244 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1245 :         }
; 1246 :     }

	add	rsp, 280				; 00000118H
	ret	0
$LN25@Insert_cou:
??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Whereptr$ = 32
_Oldlast$ = 40
_Al$ = 48
_Newvec$1 = 56
_Mylast$ = 64
_Oldfirst$ = 72
_Whereoff$2 = 80
_Relocated$3 = 88
_My_data$ = 96
_Newcapacity$4 = 104
_Oldsize$5 = 112
_Constructed_last$6 = 120
_Constructed_first$7 = 128
_Newsize$8 = 136
_Unused_capacity$ = 144
tv130 = 152
_Affected_elements$9 = 160
_Guard$10 = 168
_Guard$11 = 208
_Guard$12 = 240
this$ = 288
_Where$ = 296
_First$ = 304
_Count$ = 312
?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$10[rbp]
	call	??1_Reallocation_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Whereptr$ = 32
_Oldlast$ = 40
_Al$ = 48
_Newvec$1 = 56
_Mylast$ = 64
_Oldfirst$ = 72
_Whereoff$2 = 80
_Relocated$3 = 88
_My_data$ = 96
_Newcapacity$4 = 104
_Oldsize$5 = 112
_Constructed_last$6 = 120
_Constructed_first$7 = 128
_Newsize$8 = 136
_Unused_capacity$ = 144
tv130 = 152
_Affected_elements$9 = 160
_Guard$10 = 168
_Guard$11 = 208
_Guard$12 = 240
this$ = 288
_Where$ = 296
_First$ = 304
_Count$ = 312
?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::catch$3

; 1211 :                 _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z$0:

; 1212 :                 // glue the broken pieces back together
; 1213 : 
; 1214 :                 _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Whereptr + _Count};

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _Guard$11[rbp], rax
	mov	rax, QWORD PTR _Whereptr$[rbp]
	mov	QWORD PTR _Guard$11[rbp+8], rax
	mov	rax, QWORD PTR _Oldlast$[rbp]
	mov	QWORD PTR _Guard$11[rbp+16], rax
	imul	rax, QWORD PTR _Count$[rbp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Whereptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Guard$11[rbp+24], rax

; 1215 :                 _STD _Uninitialized_move(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr, _Al);

	mov	rax, QWORD PTR _Count$[rbp]
	shl	rax, 1
	imul	rax, rax, 1488				; 000005d0H
	mov	rcx, QWORD PTR _Whereptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	imul	rcx, QWORD PTR _Count$[rbp], 1488	; 000005d0H
	mov	rdx, QWORD PTR _Whereptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, QWORD PTR _Al$[rbp]
	mov	r8, QWORD PTR _Whereptr$[rbp]
	mov	rdx, rax
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1216 :                 _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$11[rbp], 0

; 1217 : 
; 1218 :                 _STD _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);

	imul	rax, QWORD PTR _Count$[rbp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Whereptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Count$[rbp]
	shl	rcx, 1
	imul	rcx, rcx, 1488				; 000005d0H
	mov	rdx, QWORD PTR _Whereptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	call	??$_Move_unchecked@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@00@Z ; std::_Move_unchecked<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1219 :                 _STD _Destroy_range(_Oldlast, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Oldlast$[rbp]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1220 :                 _Mylast = _Oldlast;

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rcx, QWORD PTR _Oldlast$[rbp]
	mov	QWORD PTR [rax], rcx

; 1221 :                 _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1

; 1222 :                 _CATCH_END

	lea	rcx, QWORD PTR _Guard$11[rbp]
	call	??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard
	npad	1
	lea	rax, $LN22@catch$3
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$3@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::catch$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Whereptr$ = 32
_Oldlast$ = 40
_Al$ = 48
_Newvec$1 = 56
_Mylast$ = 64
_Oldfirst$ = 72
_Whereoff$2 = 80
_Relocated$3 = 88
_My_data$ = 96
_Newcapacity$4 = 104
_Oldsize$5 = 112
_Constructed_last$6 = 120
_Constructed_first$7 = 128
_Newsize$8 = 136
_Unused_capacity$ = 144
tv130 = 152
_Affected_elements$9 = 160
_Guard$10 = 168
_Guard$11 = 208
_Guard$12 = 240
this$ = 288
_Where$ = 296
_First$ = 304
_Count$ = 312
?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$11[rbp]
	call	??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Whereptr$ = 32
_Oldlast$ = 40
_Al$ = 48
_Newvec$1 = 56
_Mylast$ = 64
_Oldfirst$ = 72
_Whereoff$2 = 80
_Relocated$3 = 88
_My_data$ = 96
_Newcapacity$4 = 104
_Oldsize$5 = 112
_Constructed_last$6 = 120
_Constructed_first$7 = 128
_Newsize$8 = 136
_Unused_capacity$ = 144
tv130 = 152
_Affected_elements$9 = 160
_Guard$10 = 168
_Guard$11 = 208
_Guard$12 = 240
this$ = 288
_Where$ = 296
_First$ = 304
_Count$ = 312
?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::catch$4

; 1230 :                 _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z$2:

; 1231 :                 // glue the broken pieces back together
; 1232 : 
; 1233 :                 _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Relocated};

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _Guard$12[rbp], rax
	mov	rax, QWORD PTR _Whereptr$[rbp]
	mov	QWORD PTR _Guard$12[rbp+8], rax
	mov	rax, QWORD PTR _Oldlast$[rbp]
	mov	QWORD PTR _Guard$12[rbp+16], rax
	mov	rax, QWORD PTR _Relocated$3[rbp]
	mov	QWORD PTR _Guard$12[rbp+24], rax

; 1234 :                 _STD _Uninitialized_move(_Relocated, _Mylast, _Whereptr, _Al);

	mov	r9, QWORD PTR _Al$[rbp]
	mov	r8, QWORD PTR _Whereptr$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Relocated$3[rbp]
	call	??$_Uninitialized_move@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1235 :                 _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$12[rbp], 0

; 1236 : 
; 1237 :                 _STD _Destroy_range(_Relocated, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Relocated$3[rbp]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1238 :                 _Mylast = _Oldlast;

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rcx, QWORD PTR _Oldlast$[rbp]
	mov	QWORD PTR [rax], rcx

; 1239 :                 _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1

; 1240 :                 _CATCH_END

	lea	rcx, QWORD PTR _Guard$12[rbp]
	call	??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard
	npad	1
	lea	rax, $LN24@catch$4
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$4@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Whereptr$ = 32
_Oldlast$ = 40
_Al$ = 48
_Newvec$1 = 56
_Mylast$ = 64
_Oldfirst$ = 72
_Whereoff$2 = 80
_Relocated$3 = 88
_My_data$ = 96
_Newcapacity$4 = 104
_Oldsize$5 = 112
_Constructed_last$6 = 120
_Constructed_first$7 = 128
_Newsize$8 = 136
_Unused_capacity$ = 144
tv130 = 152
_Affected_elements$9 = 160
_Guard$10 = 168
_Guard$11 = 208
_Guard$12 = 240
this$ = 288
_Where$ = 296
_First$ = 304
_Count$ = 312
?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA PROC ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$12[rbp]
	call	??1_Vaporization_guard@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vaporization_guard::~_Vaporization_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z@4HA ENDP ; `std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$distance@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA_JPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA_JPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z PROC ; std::distance<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 1690 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1691 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1692 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx

; 1693 :     } else {
; 1694 :         _STD _Adl_verify_range(_First, _Last);
; 1695 :         auto _UFirst             = _STD _Get_unwrapped(_First);
; 1696 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1697 :         _Iter_diff_t<_InIt> _Off = 0;
; 1698 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1699 :             ++_Off;
; 1700 :         }
; 1701 : 
; 1702 :         return _Off;
; 1703 :     }
; 1704 : }

	ret	0
??$distance@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA_JPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ENDP ; std::distance<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
_TEXT	SEGMENT
tv85 = 32
$T1 = 40
this$ = 64
_Val$ = 72
??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_35d54d29033b35d747bcda686a4dea49> >, COMDAT

; 961  :     void _Reset(_Fx&& _Val) { // store copy of _Val

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 962  :         if (!_STD _Test_callable(_Val)) { // null member pointer/function pointer/std::function

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$_Test_callable@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA_NAEBV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ; std::_Test_callable<<lambda_35d54d29033b35d747bcda686a4dea49> >
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset

; 963  :             return; // already empty

	jmp	SHORT $LN1@Reset
$LN2@Reset:

; 964  :         }
; 965  : 
; 966  :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 967  :         if constexpr (_Is_large<_Impl>) {
; 968  :             // dynamically allocate _Val
; 969  :             _Set(_STD _Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 970  :         } else {
; 971  :             // store _Val in-situ
; 972  :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> >
	mov	QWORD PTR tv85[rsp], rax
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$_Func_impl_no_alloc@V<lambda_35d54d29033b35d747bcda686a4dea49>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ; std::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_35d54d29033b35d747bcda686a4dea49>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_35d54d29033b35d747bcda686a4dea49>,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1
$LN1@Reset:

; 973  :         }
; 974  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_35d54d29033b35d747bcda686a4dea49> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z PROC ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z ENDP ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
_TEXT	SEGMENT
tv85 = 32
$T1 = 40
this$ = 64
_Val$ = 72
??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_614ae9436da2bf9123d47a10e682c1dd> >, COMDAT

; 961  :     void _Reset(_Fx&& _Val) { // store copy of _Val

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 962  :         if (!_STD _Test_callable(_Val)) { // null member pointer/function pointer/std::function

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$_Test_callable@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA_NAEBV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ; std::_Test_callable<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset

; 963  :             return; // already empty

	jmp	SHORT $LN1@Reset
$LN2@Reset:

; 964  :         }
; 965  : 
; 966  :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 967  :         if constexpr (_Is_large<_Impl>) {
; 968  :             // dynamically allocate _Val
; 969  :             _Set(_STD _Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 970  :         } else {
; 971  :             // store _Val in-situ
; 972  :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
	mov	QWORD PTR tv85[rsp], rax
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$_Func_impl_no_alloc@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ; std::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_614ae9436da2bf9123d47a10e682c1dd>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1
$LN1@Reset:

; 973  :         }
; 974  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z PROC ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z ENDP ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
_TEXT	SEGMENT
tv85 = 32
$T1 = 40
this$ = 64
_Val$ = 72
??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >, COMDAT

; 961  :     void _Reset(_Fx&& _Val) { // store copy of _Val

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 962  :         if (!_STD _Test_callable(_Val)) { // null member pointer/function pointer/std::function

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$_Test_callable@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA_NAEBV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ; std::_Test_callable<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset

; 963  :             return; // already empty

	jmp	SHORT $LN1@Reset
$LN2@Reset:

; 964  :         }
; 965  : 
; 966  :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 967  :         if constexpr (_Is_large<_Impl>) {
; 968  :             // dynamically allocate _Val
; 969  :             _Set(_STD _Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 970  :         } else {
; 971  :             // store _Val in-situ
; 972  :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
	mov	QWORD PTR tv85[rsp], rax
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$_Func_impl_no_alloc@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ; std::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1
$LN1@Reset:

; 973  :         }
; 974  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z PROC ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z ENDP ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
_TEXT	SEGMENT
tv85 = 32
$T1 = 40
this$ = 64
_Val$ = 72
??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >, COMDAT

; 961  :     void _Reset(_Fx&& _Val) { // store copy of _Val

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 962  :         if (!_STD _Test_callable(_Val)) { // null member pointer/function pointer/std::function

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$_Test_callable@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA_NAEBV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ; std::_Test_callable<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset

; 963  :             return; // already empty

	jmp	SHORT $LN1@Reset
$LN2@Reset:

; 964  :         }
; 965  : 
; 966  :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 967  :         if constexpr (_Is_large<_Impl>) {
; 968  :             // dynamically allocate _Val
; 969  :             _Set(_STD _Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 970  :         } else {
; 971  :             // store _Val in-situ
; 972  :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
	mov	QWORD PTR tv85[rsp], rax
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$_Func_impl_no_alloc@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ; std::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1
$LN1@Reset:

; 973  :         }
; 974  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z PROC ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z ENDP ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
_TEXT	SEGMENT
tv85 = 32
$T1 = 40
this$ = 64
_Val$ = 72
??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >, COMDAT

; 961  :     void _Reset(_Fx&& _Val) { // store copy of _Val

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 962  :         if (!_STD _Test_callable(_Val)) { // null member pointer/function pointer/std::function

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$_Test_callable@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA_NAEBV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ; std::_Test_callable<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset

; 963  :             return; // already empty

	jmp	SHORT $LN1@Reset
$LN2@Reset:

; 964  :         }
; 965  : 
; 966  :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 967  :         if constexpr (_Is_large<_Impl>) {
; 968  :             // dynamically allocate _Val
; 969  :             _Set(_STD _Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 970  :         } else {
; 971  :             // store _Val in-situ
; 972  :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$forward@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
	mov	QWORD PTR tv85[rsp], rax
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$_Func_impl_no_alloc@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ; std::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_impl_no_alloc<<lambda_564f9749a9a51d2fffa238f6767f2a0a>,bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1
$LN1@Reset:

; 973  :         }
; 974  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z PROC ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z ENDP ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_It$ = 48
_UIt$ = 56
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_ *>, COMDAT

; 1507 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1508 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1509 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rcx, QWORD PTR _UIt$[rsp]
	call	??$forward@PEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::forward<enum ZydisRegister_ *>
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Seek_to
	npad	1

; 1510 :     } else {
; 1511 :         _It = _STD forward<_UIter>(_UIt);
; 1512 :     }
; 1513 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_unchecked@PEAW4ZydisRegister_@@W41@@std@@YAPEAW4ZydisRegister_@@PEAW41@QEAW41@AEBW41@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find_unchecked@PEAW4ZydisRegister_@@W41@@std@@YAPEAW4ZydisRegister_@@PEAW41@QEAW41@AEBW41@@Z PROC ; std::_Find_unchecked<enum ZydisRegister_ *,enum ZydisRegister_>, COMDAT

; 6130 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 6131 :     // find first matching _Val; choose optimization
; 6132 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 6133 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 6134 : #if _HAS_CXX20
; 6135 :         if (!_STD is_constant_evaluated())
; 6136 : #endif // _HAS_CXX20
; 6137 :         {
; 6138 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 6139 :                 return _Last;
; 6140 :             }
; 6141 : #if _USE_STD_VECTOR_ALGORITHMS
; 6142 :             const auto _First_ptr = _STD _To_address(_First);
; 6143 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);
; 6144 :             if constexpr (is_pointer_v<_InIt>) {
; 6145 :                 return _Result;
; 6146 :             } else {
; 6147 :                 return _First + (_Result - _First_ptr);
; 6148 :             }
; 6149 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 6150 :             if constexpr (sizeof(_Iter_value_t<_InIt>) <= 2) {
; 6151 :                 const auto _First_ptr = _STD _To_address(_First);
; 6152 :                 const auto _Count     = static_cast<size_t>(_Last - _First);
; 6153 : 
; 6154 :                 using _Ptr_t = remove_reference_t<_Iter_ref_t<_InIt>>*;
; 6155 :                 _Ptr_t _Result;
; 6156 : 
; 6157 :                 if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 6158 :                     _Result = static_cast<_Ptr_t>(_CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), _Count));
; 6159 :                 } else {
; 6160 :                     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_InIt>) == 2);
; 6161 :                     _Result = reinterpret_cast<_Ptr_t>(const_cast<wchar_t*>(_CSTD wmemchr(
; 6162 :                         reinterpret_cast<const wchar_t*>(_First_ptr), static_cast<wchar_t>(_Val), _Count)));
; 6163 :                 }
; 6164 : 
; 6165 :                 if constexpr (is_pointer_v<_InIt>) {
; 6166 :                     return _Result ? _Result : _Last;
; 6167 :                 } else {
; 6168 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 6169 :                 }
; 6170 :             }
; 6171 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 6172 :         }
; 6173 :     }
; 6174 : 
; 6175 :     for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Find_unche
$LN2@Find_unche:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 4
	mov	QWORD PTR _First$[rsp], rax
$LN4@Find_unche:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Find_unche

; 6176 :         if (*_First == _Val) {

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN5@Find_unche

; 6177 :             break;

	jmp	SHORT $LN3@Find_unche
$LN5@Find_unche:

; 6178 :         }
; 6179 :     }

	jmp	SHORT $LN2@Find_unche
$LN3@Find_unche:

; 6180 : 
; 6181 :     return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 6182 : }

	ret	0
??$_Find_unchecked@PEAW4ZydisRegister_@@W41@@std@@YAPEAW4ZydisRegister_@@PEAW41@QEAW41@AEBW41@@Z ENDP ; std::_Find_unchecked<enum ZydisRegister_ *,enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z PROC ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rax

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z ENDP ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z PROC ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>, COMDAT

; 66   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 67   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 68   :     }

	ret	0
??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ENDP ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
<_Val2_0>$ = 72
??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z PROC ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VAsmHelper64@IronMan@@@0@AEAU10@@Z ; std::forward<std::default_delete<IronMan::AsmHelper64> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0VAsmHelper64@IronMan@@$0A@@?$default_delete@VIAsmHelper@IronMan@@@std@@QEAA@AEBU?$default_delete@VAsmHelper64@IronMan@@@1@@Z ; std::default_delete<IronMan::IAsmHelper>::default_delete<IronMan::IAsmHelper><IronMan::AsmHelper64,0>
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@PEAVAsmHelper64@IronMan@@@std@@YA$$QEAPEAVAsmHelper64@IronMan@@AEAPEAV12@@Z ; std::forward<IronMan::AsmHelper64 *>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z ENDP ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VAsmHelper64@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VAsmHelper64@IronMan@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<IronMan::AsmHelper64> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VAsmHelper64@IronMan@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<IronMan::AsmHelper64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Ptr$ = 72
??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z PROC ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> ><std::default_delete<IronMan::AsmHelper64>,0>, COMDAT

; 3352 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	lea	r8, QWORD PTR _Ptr$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEAPEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVAsmHelper64@IronMan@@@Z ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1><IronMan::AsmHelper64 * &>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z ENDP ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> ><std::default_delete<IronMan::AsmHelper64>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<40>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<40>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@D$0A@@std@@YAXAEAD0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@D$0A@@std@@YAXAEAD0@Z PROC			; std::swap<char,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR _Tmp$[rsp], al

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	mov	rcx, QWORD PTR _Left$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@D$0A@@std@@YAXAEAD0@Z ENDP			; std::swap<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 379  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 380  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 381  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@YAPEAU?$pair@$$CBW4ZydisRegister_@@W41@@0@AEAU10@@Z ; std::addressof<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::destroy<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >

; 382  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 383  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
_Rootnode$ = 64
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 757  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
$LN2@Erase_tree:

; 758  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	mov	rax, QWORD PTR _Rootnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@Erase_tree

; 759  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	rax, QWORD PTR _Rootnode$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >

; 760  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

	mov	rax, QWORD PTR _Rootnode$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Rootnode$[rsp]
	call	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &>
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 761  :         }

	jmp	SHORT $LN2@Erase_tree
$LN3@Erase_tree:

; 762  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Al$ = 64
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 343  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 344  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 345  :         const auto _Pnode = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocate
	mov	QWORD PTR _Pnode$[rsp], rax

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	rax, QWORD PTR _Pnode$[rsp]
	lea	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	rax, QWORD PTR _Pnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	rax, QWORD PTR _Pnode$[rsp]
	add	rax, 16
	lea	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &>

; 349  :         _Pnode->_Color = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 1

; 350  :         _Pnode->_Isnil = true;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+25], 1

; 351  :         return _Pnode;

	mov	rax, QWORD PTR _Pnode$[rsp]

; 352  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 8
	mov	QWORD PTR _First$[rsp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Destroy_ra

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Unfancy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@1@QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::destroy<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	npad	1

; 1100 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1101 :     }
; 1102 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
_TEXT	SEGMENT
_Copied$1 = 32
_Nothrow_construct$ = 33
_Myfirst$ = 40
_Mylast$ = 48
_My_data$ = 56
_Mid$2 = 64
_Oldsize$ = 72
_Al$ = 80
_Newlast$3 = 88
_Myend$ = 96
_Oldcapacity$ = 104
tv91 = 112
tv89 = 120
tv149 = 128
tv147 = 136
tv161 = 144
tv159 = 152
this$ = 192
_First$ = 200
_Newsize$ = 208
??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Assign_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>, COMDAT

; 1405 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 1406 :         // assign elements from counted range _First + [0, _Newsize)
; 1407 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1408 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1409 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1410 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1411 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1412 : 
; 1413 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,

	mov	BYTE PTR _Nothrow_construct$[rsp], 1

; 1414 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1415 : 
; 1416 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1417 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1418 :         if (_Newsize > _Oldcapacity) {

	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	cmp	QWORD PTR _Newsize$[rsp], rax
	jbe	SHORT $LN5@Assign_cou

; 1419 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Clear_and_reserve_geometric
	npad	1

; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv89[rsp], rax
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR tv91[rsp]
	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR tv89[rsp]
	call	??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1422 :                 _ASAN_VECTOR_CREATE;
; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1426 :             }
; 1427 :             return;

	jmp	$LN1@Assign_cou
$LN5@Assign_cou:

; 1428 :         }
; 1429 : 
; 1430 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1431 :         if (_Newsize > _Oldsize) {

	mov	rax, QWORD PTR _Oldsize$[rsp]
	cmp	QWORD PTR _Newsize$[rsp], rax
	jbe	$LN6@Assign_cou

; 1432 :             bool _Copied = false;

	mov	BYTE PTR _Copied$1[rsp], 0

; 1433 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1434 : #if _HAS_CXX20
; 1435 :                 if (!_STD is_constant_evaluated())
; 1436 : #endif // _HAS_CXX20
; 1437 :                 {
; 1438 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR _Oldsize$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_memmove_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ; std::_Copy_memmove_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1439 :                     _First += _Oldsize;

	imul	rax, QWORD PTR _Oldsize$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _First$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _First$[rsp], rax

; 1440 :                     _Copied = true;

	mov	BYTE PTR _Copied$1[rsp], 1

; 1441 :                 }
; 1442 :             }
; 1443 : 
; 1444 :             if (!_Copied) {

	movzx	eax, BYTE PTR _Copied$1[rsp]
	test	eax, eax
	jne	SHORT $LN8@Assign_cou

; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Mid$2[rsp], rax
	jmp	SHORT $LN4@Assign_cou
$LN2@Assign_cou:
	mov	rax, QWORD PTR _Mid$2[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _Mid$2[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 1488				; 000005d0H
	mov	QWORD PTR _First$[rsp], rax
$LN4@Assign_cou:
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Mid$2[rsp], rax
	je	SHORT $LN3@Assign_cou

; 1446 :                     *_Mid = *_First;

	mov	rdi, QWORD PTR _Mid$2[rsp]
	mov	rsi, QWORD PTR _First$[rsp]
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 1447 :                 }

	jmp	SHORT $LN2@Assign_cou
$LN3@Assign_cou:
$LN8@Assign_cou:

; 1448 :             }
; 1449 : 
; 1450 :             if constexpr (_Nothrow_construct) {
; 1451 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1452 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv149[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv147[rsp], rax
	mov	rax, QWORD PTR _Oldsize$[rsp]
	mov	rcx, QWORD PTR _Newsize$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR tv149[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv147[rsp]
	call	??$_Uninitialized_copy_n@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Uninitialized_copy_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1453 :             } else {
; 1454 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1455 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1456 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1457 :             }
; 1458 :         } else {

	jmp	$LN7@Assign_cou
$LN6@Assign_cou:

; 1459 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR _Newlast$3[rsp], rax

; 1460 :             _STD _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv161[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Analysis::UObjectAnalysis::InstructionInfo * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv159[rsp], rax
	mov	r8, QWORD PTR tv161[rsp]
	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR tv159[rsp]
	call	??$_Copy_n_unchecked4@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_KPEAU1234@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@_K0@Z ; std::_Copy_n_unchecked4<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,unsigned __int64,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1461 :             _STD _Destroy_range(_Newlast, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newlast$3[rsp]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1462 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1463 :             _Mylast = _Newlast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Newlast$3[rsp]
	mov	QWORD PTR [rax], rcx
$LN7@Assign_cou:
$LN1@Assign_cou:

; 1464 :         }
; 1465 :     }

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Assign_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Pocca@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1071 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1072 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1073 :         _Left = _Right;
; 1074 :     }
; 1075 : }

	ret	0
??$_Pocca@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z
_TEXT	SEGMENT
_Copied$1 = 32
_Nothrow_construct$ = 33
_Myfirst$ = 40
_Mylast$ = 48
_My_data$ = 56
_Mid$2 = 64
_Oldsize$ = 72
_Al$ = 80
_Newlast$3 = 88
_Myend$ = 96
_Oldcapacity$ = 104
tv91 = 112
tv89 = 120
tv148 = 128
tv146 = 136
tv160 = 144
tv158 = 152
this$ = 176
_First$ = 184
_Newsize$ = 192
??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Assign_counted_range<enum ZydisRegister_ *>, COMDAT

; 1405 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1406 :         // assign elements from counted range _First + [0, _Newsize)
; 1407 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1408 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1409 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1410 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1411 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1412 : 
; 1413 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,

	mov	BYTE PTR _Nothrow_construct$[rsp], 1

; 1414 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1415 : 
; 1416 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1417 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 2
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1418 :         if (_Newsize > _Oldcapacity) {

	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	cmp	QWORD PTR _Newsize$[rsp], rax
	jbe	SHORT $LN5@Assign_cou

; 1419 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Clear_and_reserve_geometric
	npad	1

; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv89[rsp], rax
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR tv91[rsp]
	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR tv89[rsp]
	call	??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1422 :                 _ASAN_VECTOR_CREATE;
; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1426 :             }
; 1427 :             return;

	jmp	$LN1@Assign_cou
$LN5@Assign_cou:

; 1428 :         }
; 1429 : 
; 1430 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 2
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1431 :         if (_Newsize > _Oldsize) {

	mov	rax, QWORD PTR _Oldsize$[rsp]
	cmp	QWORD PTR _Newsize$[rsp], rax
	jbe	$LN6@Assign_cou

; 1432 :             bool _Copied = false;

	mov	BYTE PTR _Copied$1[rsp], 0

; 1433 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1434 : #if _HAS_CXX20
; 1435 :                 if (!_STD is_constant_evaluated())
; 1436 : #endif // _HAS_CXX20
; 1437 :                 {
; 1438 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR _Oldsize$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_memmove_n@PEAW4ZydisRegister_@@PEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ; std::_Copy_memmove_n<enum ZydisRegister_ *,enum ZydisRegister_ *>

; 1439 :                     _First += _Oldsize;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Oldsize$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR _First$[rsp], rax

; 1440 :                     _Copied = true;

	mov	BYTE PTR _Copied$1[rsp], 1

; 1441 :                 }
; 1442 :             }
; 1443 : 
; 1444 :             if (!_Copied) {

	movzx	eax, BYTE PTR _Copied$1[rsp]
	test	eax, eax
	jne	SHORT $LN8@Assign_cou

; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Mid$2[rsp], rax
	jmp	SHORT $LN4@Assign_cou
$LN2@Assign_cou:
	mov	rax, QWORD PTR _Mid$2[rsp]
	add	rax, 4
	mov	QWORD PTR _Mid$2[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 4
	mov	QWORD PTR _First$[rsp], rax
$LN4@Assign_cou:
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Mid$2[rsp], rax
	je	SHORT $LN3@Assign_cou

; 1446 :                     *_Mid = *_First;

	mov	rax, QWORD PTR _Mid$2[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 1447 :                 }

	jmp	SHORT $LN2@Assign_cou
$LN3@Assign_cou:
$LN8@Assign_cou:

; 1448 :             }
; 1449 : 
; 1450 :             if constexpr (_Nothrow_construct) {
; 1451 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1452 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv148[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv146[rsp], rax
	mov	rax, QWORD PTR _Oldsize$[rsp]
	mov	rcx, QWORD PTR _Newsize$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR tv148[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv146[rsp]
	call	??$_Uninitialized_copy_n@PEAW4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Uninitialized_copy_n<enum ZydisRegister_ *,std::allocator<enum ZydisRegister_> >
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1453 :             } else {
; 1454 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1455 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1456 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1457 :             }
; 1458 :         } else {

	jmp	$LN7@Assign_cou
$LN6@Assign_cou:

; 1459 :             const pointer _Newlast = _Myfirst + _Newsize;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newsize$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR _Newlast$3[rsp], rax

; 1460 :             _STD _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv160[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEAW4ZydisRegister_@@@std@@YA$$QEAPEAW4ZydisRegister_@@AEAPEAW41@@Z ; std::move<enum ZydisRegister_ * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv158[rsp], rax
	mov	r8, QWORD PTR tv160[rsp]
	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR tv158[rsp]
	call	??$_Copy_n_unchecked4@PEAW4ZydisRegister_@@_KPEAW41@@std@@YAPEAW4ZydisRegister_@@PEAW41@_K0@Z ; std::_Copy_n_unchecked4<enum ZydisRegister_ *,unsigned __int64,enum ZydisRegister_ *>

; 1461 :             _STD _Destroy_range(_Newlast, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newlast$3[rsp]
	call	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >

; 1462 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1463 :             _Mylast = _Newlast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Newlast$3[rsp]
	mov	QWORD PTR [rax], rcx
$LN7@Assign_cou:
$LN1@Assign_cou:

; 1464 :         }
; 1465 :     }

	add	rsp, 168				; 000000a8H
	ret	0
??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Assign_counted_range<enum ZydisRegister_ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXAEAV?$allocator@W4ZydisRegister_@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Pocca@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXAEAV?$allocator@W4ZydisRegister_@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<enum ZydisRegister_> >, COMDAT

; 1071 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1072 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1073 :         _Left = _Right;
; 1074 :     }
; 1075 : }

	ret	0
??$_Pocca@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXAEAV?$allocator@W4ZydisRegister_@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@YAPEBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@YAPEBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@YAPEBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {
; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

	ret	0
??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_one_at_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_back_with_unused_capacity<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::forward<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_reallocate<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_one_at_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z PROC ; std::move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ENDP ; std::move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR _First$[rsp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Destroy_ra

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Unfancy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@PEAU10@@Z ; std::_Unfancy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@1@QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::destroy<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	npad	1

; 1100 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1101 :     }
; 1102 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__formal$ = 72
_Val1$ = 80
<_Val2_0>$ = 88
??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1><std::less<enum ZydisRegister_> const &,std::_Zero_then_variadic_args_t>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBU?$less@W4ZydisRegister_@@@std@@@std@@YAAEBU?$less@W4ZydisRegister_@@@0@AEBU10@@Z ; std::forward<std::less<enum ZydisRegister_> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	edx, BYTE PTR [rax]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1><>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1><std::less<enum ZydisRegister_> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_Off$1 = 32
_UFirst$2 = 40
_ULast$3 = 48
_First$ = 80
_Last$ = 88
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >, COMDAT

; 1690 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1691 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1692 :         return _Last - _First; // assume the iterator will do debug checking
; 1693 :     } else {
; 1694 :         _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >

; 1695 :         auto _UFirst             = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _UFirst$2[rsp], rax

; 1696 :         const auto _ULast        = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _ULast$3[rsp], rax

; 1697 :         _Iter_diff_t<_InIt> _Off = 0;

	mov	QWORD PTR _Off$1[rsp], 0

; 1698 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@distance
$LN2@distance:
	lea	rcx, QWORD PTR _UFirst$2[rsp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++
	npad	1
$LN4@distance:
	lea	rdx, QWORD PTR _ULast$3[rsp]
	lea	rcx, QWORD PTR _UFirst$2[rsp]
	call	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@distance

; 1699 :             ++_Off;

	mov	rax, QWORD PTR _Off$1[rsp]
	inc	rax
	mov	QWORD PTR _Off$1[rsp], rax

; 1700 :         }

	jmp	SHORT $LN2@distance
$LN3@distance:

; 1701 : 
; 1702 :         return _Off;

	mov	rax, QWORD PTR _Off$1[rsp]

; 1703 :     }
; 1704 : }

	add	rsp, 72					; 00000048H
	ret	0
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z PROC ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ENDP ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ PROC ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 736  :     _Func_base()                             = default;

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ENDP ; std::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_base<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QEA_NAEA_N@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_N@std@@YA$$QEA_NAEA_N@Z PROC		; std::forward<bool>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@_N@std@@YA$$QEA_NAEA_N@Z ENDP		; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_one_at_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_reallocate<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_one_at_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z PROC		; std::forward<void *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ENDP		; std::forward<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_one_at_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_back_with_unused_capacity<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU2345@AEBU2345@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_reallocate<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_one_at_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z PROC ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {
; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

	ret	0
??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@W4ZydisRegister_@@@std@@QEAA@XZ ; std::allocator<enum ZydisRegister_>::allocator<enum ZydisRegister_>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_one_at_back<enum ZydisRegister_ const &>, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_back_with_unused_capacity<enum ZydisRegister_ const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAPEAW4ZydisRegister_@@QEAW42@AEBW42@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_reallocate<enum ZydisRegister_ const &>
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_one_at_back<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
tv70 = 32
this$ = 64
_Val1$ = 72
_Val2$ = 80
??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo><int,IronMan::Analysis::UObjectAnalysis::DecryptInfo,0>, COMDAT

; 263  :         : first(_Val1), second(_Val2) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Val1$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR _Val2$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo><int,IronMan::Analysis::UObjectAnalysis::DecryptInfo,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv70 = 32
this$ = 64
_Val1$ = 72
_Val2$ = 80
?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA PROC ; `std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo><int,IronMan::Analysis::UObjectAnalysis::DecryptInfo,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@4HA ENDP ; `std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo><int,IronMan::Analysis::UObjectAnalysis::DecryptInfo,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >, COMDAT

; 765  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 766  :         this->_Orphan_all();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 767  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >

; 768  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 769  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_Loc$ = 32
this$ = 80
_Keyval$ = 88
??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find<enum ZydisRegister_>, COMDAT

; 1373 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1374 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find_lower_bound<enum ZydisRegister_>
	npad	1

; 1375 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR _Loc$[rsp+16]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Lower_bound_duplicate<enum ZydisRegister_>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Find

; 1376 :             return _Loc._Bound;

	mov	rax, QWORD PTR _Loc$[rsp+16]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1377 :         }
; 1378 : 
; 1379 :         return _Get_scary()->_Myhead;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	rax, QWORD PTR [rax]
$LN1@Find:

; 1380 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
_Scary$ = 56
tv158 = 64
tv156 = 72
tv154 = 80
tv152 = 88
tv173 = 96
tv172 = 104
_Inserted$ = 112
$T4 = 120
_Loc$ = 128
$T5 = 152
$T6 = 160
$T7 = 176
this$ = 224
__$ReturnUdt$ = 232
_Keyval$ = 240
??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z PROC ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Try_emplace<enum ZydisRegister_ const &>, COMDAT

; 196  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 197  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_lower_bound@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find_lower_bound<enum ZydisRegister_>
	npad	1

; 198  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR _Loc$[rsp+16]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Lower_bound_duplicate@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Lower_bound_duplicate<enum ZydisRegister_>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Try_emplac

; 199  :             return {_Loc._Bound, false};

	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR _Loc$[rsp+16]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * const &,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Try_emplac
$LN2@Try_emplac:

; 200  :         }
; 201  : 
; 202  :         _Mybase::_Check_grow_by_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Check_grow_by_1

; 203  : 
; 204  :         const auto _Scary    = _Mybase::_Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 205  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

	lea	rcx, QWORD PTR $T3[rsp]
	call	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
	mov	QWORD PTR tv158[rsp], rax
	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$forward@AEBW4ZydisRegister_@@@std@@YAAEBW4ZydisRegister_@@AEBW41@@Z ; std::forward<enum ZydisRegister_ const &>
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$forward_as_tuple@AEBW4ZydisRegister_@@@std@@YA?AV?$tuple@AEBW4ZydisRegister_@@@0@AEBW4ZydisRegister_@@@Z ; std::forward_as_tuple<enum ZydisRegister_ const &>
	mov	QWORD PTR tv156[rsp], rax
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv154[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
	mov	QWORD PTR tv152[rsp], rax
	mov	rax, QWORD PTR tv158[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv156[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
	mov	r8, QWORD PTR tv154[rsp]
	mov	rdx, QWORD PTR tv152[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBW4ZydisRegister_@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBW4ZydisRegister_@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > ><std::piecewise_construct_t const &,std::tuple<enum ZydisRegister_ const &>,std::tuple<> >
	mov	QWORD PTR tv173[rsp], rax
	mov	rax, QWORD PTR tv173[rsp]
	mov	QWORD PTR tv172[rsp], rax
	mov	rcx, QWORD PTR tv172[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::_Release
	mov	QWORD PTR _Inserted$[rsp], rax
	lea	rcx, QWORD PTR $T6[rsp]
	call	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 206  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval)),
; 207  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...))
; 208  :                                    ._Release();
; 209  : 
; 210  :         // nothrow hereafter
; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	lea	rax, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR _Loc$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	mov	r8, QWORD PTR _Inserted$[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Insert_node
	mov	QWORD PTR $T4[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Try_emplac:

; 212  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z ENDP ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Try_emplace<enum ZydisRegister_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
_Scary$ = 56
tv158 = 64
tv156 = 72
tv154 = 80
tv152 = 88
tv173 = 96
tv172 = 104
_Inserted$ = 112
$T4 = 120
_Loc$ = 128
$T5 = 152
$T6 = 160
$T7 = 176
this$ = 224
__$ReturnUdt$ = 232
_Keyval$ = 240
?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA PROC ; `std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Try_emplace<enum ZydisRegister_ const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z@4HA ENDP ; `std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Try_emplace<enum ZydisRegister_ const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z
_TEXT	SEGMENT
_UFirst$ = 32
_My_data$ = 40
_Oldfirst$ = 48
_Whereptr$ = 56
_ULast$ = 64
_Length$1 = 72
_Count$2 = 80
_Whereoff$ = 88
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_First$ = 136
_Last$ = 144
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,0>, COMDAT

; 1250 :     _CONSTEXPR20 iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1251 :         const pointer _Whereptr = _Where._Ptr;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	QWORD PTR _Whereptr$[rsp], rax

; 1252 :         auto& _My_data          = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1253 :         const pointer _Oldfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Oldfirst$[rsp], rax

; 1254 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1255 :         _STL_VERIFY(
; 1256 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr,
; 1257 :             "vector insert iterator outside range");
; 1258 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1259 : 
; 1260 :         _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > >

; 1261 :         auto _UFirst         = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1262 :         auto _ULast          = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > > &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1263 :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);

	mov	rax, QWORD PTR _Oldfirst$[rsp]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Whereoff$[rsp], rax

; 1264 :         if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
; 1265 :             const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));

	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$distance@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YA_JPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ; std::distance<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	mov	QWORD PTR _Length$1[rsp], rax

; 1266 :             const auto _Count  = _STD _Convert_size<size_type>(_Length);

	mov	rcx, QWORD PTR _Length$1[rsp]
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	QWORD PTR _Count$2[rsp], rax

; 1267 :             _Insert_counted_range(_Where, _UFirst, _Count);

	mov	r9, QWORD PTR _Count$2[rsp]
	mov	r8, QWORD PTR _UFirst$[rsp]
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Insert_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Insert_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	npad	1

; 1268 : #if _HAS_CXX20
; 1269 :         } else if constexpr (forward_iterator<_Iter>) {
; 1270 :             const auto _Length = _STD _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
; 1271 :             const auto _Count  = _Convert_size<size_type>(_Length);
; 1272 :             _Insert_counted_range(_Where, _UFirst, _Count);
; 1273 : #endif // _HAS_CXX20
; 1274 :         } else {
; 1275 :             _Insert_uncounted_range(_Where, _UFirst, _ULast);
; 1276 :         }
; 1277 :         return _Make_iterator_offset(_Whereoff);

	mov	r8, QWORD PTR _Whereoff$[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Make_iterator_offset
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1278 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Unwrapped, COMDAT

; 344  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU1234@@Z ; std::_Unfancy_maybe_null<IronMan::Analysis::UObjectAnalysis::InstructionInfo>

; 346  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEBAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pvector$ = 64
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 47   :         this->_Adopt(_Pvector);

	mov	rdx, QWORD PTR _Pvector$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 48   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z
_TEXT	SEGMENT
this$ = 48
_Func$ = 56
??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z PROC ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_35d54d29033b35d747bcda686a4dea49>,0>, COMDAT

; 1097 :     function(_Fx&& _Func) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	npad	1

; 1098 :         static_assert(is_copy_constructible_v<decay_t<_Fx>>,
; 1099 :             "The target function object type must be copy constructible (N4988 [func.wrap.func.con]/10.1).");
; 1100 :         this->_Reset(_STD forward<_Fx>(_Func));

	mov	rcx, QWORD PTR _Func$[rsp]
	call	??$forward@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@std@@YA$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@AEAV1@@Z ; std::forward<<lambda_35d54d29033b35d747bcda686a4dea49> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reset@V<lambda_35d54d29033b35d747bcda686a4dea49>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_35d54d29033b35d747bcda686a4dea49> >
	npad	1

; 1101 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ENDP ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_35d54d29033b35d747bcda686a4dea49>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Func$ = 56
?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA PROC ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_35d54d29033b35d747bcda686a4dea49>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z@4HA ENDP ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_35d54d29033b35d747bcda686a4dea49>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
this$ = 8
<bindRegister>$ = 16
<regValue>$ = 24
??0<lambda_35d54d29033b35d747bcda686a4dea49>@@QEAA@AEAV?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAW4ZydisRegister_@@@Z PROC ; <lambda_35d54d29033b35d747bcda686a4dea49>::<lambda_35d54d29033b35d747bcda686a4dea49>

; 246  : 					info = mDecrypts.findValue([&bindRegister, &regValue](const DecryptInfo& value) {return value.BaseRegister == bindRegister[regValue]; });

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <bindRegister>$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <regValue>$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0<lambda_35d54d29033b35d747bcda686a4dea49>@@QEAA@AEAV?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAW4ZydisRegister_@@@Z ENDP ; <lambda_35d54d29033b35d747bcda686a4dea49>::<lambda_35d54d29033b35d747bcda686a4dea49>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
tv73 = 32
tv71 = 40
this$ = 64
value$ = 72
??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; <lambda_35d54d29033b35d747bcda686a4dea49>::operator()

; 246  : 					info = mDecrypts.findValue([&bindRegister, &regValue](const DecryptInfo& value) {return value.BaseRegister == bindRegister[regValue]; });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv71[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv71[rsp]
	call	??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::operator[]
	mov	rcx, QWORD PTR value$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv73[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv73[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_35d54d29033b35d747bcda686a4dea49>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; <lambda_35d54d29033b35d747bcda686a4dea49>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z
_TEXT	SEGMENT
this$ = 48
_Func$ = 56
??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z PROC ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>, COMDAT

; 1097 :     function(_Fx&& _Func) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	npad	1

; 1098 :         static_assert(is_copy_constructible_v<decay_t<_Fx>>,
; 1099 :             "The target function object type must be copy constructible (N4988 [func.wrap.func.con]/10.1).");
; 1100 :         this->_Reset(_STD forward<_Fx>(_Func));

	mov	rcx, QWORD PTR _Func$[rsp]
	call	??$forward@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@std@@YA$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@AEAV1@@Z ; std::forward<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reset@V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_614ae9436da2bf9123d47a10e682c1dd> >
	npad	1

; 1101 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ENDP ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Func$ = 56
?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA PROC ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z@4HA ENDP ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
this$ = 8
<regValue>$ = 16
??0<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEAA@AEAW4ZydisRegister_@@@Z PROC ; <lambda_614ae9436da2bf9123d47a10e682c1dd>::<lambda_614ae9436da2bf9123d47a10e682c1dd>

; 241  : 				auto info = mDecrypts.findValue([&regValue](const DecryptInfo& value) {return value.BaseRegister == regValue; });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <regValue>$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEAA@AEAW4ZydisRegister_@@@Z ENDP ; <lambda_614ae9436da2bf9123d47a10e682c1dd>::<lambda_614ae9436da2bf9123d47a10e682c1dd>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
tv68 = 0
this$ = 32
value$ = 40
??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; <lambda_614ae9436da2bf9123d47a10e682c1dd>::operator()

; 241  : 				auto info = mDecrypts.findValue([&regValue](const DecryptInfo& value) {return value.BaseRegister == regValue; });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR value$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv68[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
??R<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; <lambda_614ae9436da2bf9123d47a10e682c1dd>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z
_TEXT	SEGMENT
this$ = 48
_Func$ = 56
??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z PROC ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>, COMDAT

; 1097 :     function(_Fx&& _Func) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	npad	1

; 1098 :         static_assert(is_copy_constructible_v<decay_t<_Fx>>,
; 1099 :             "The target function object type must be copy constructible (N4988 [func.wrap.func.con]/10.1).");
; 1100 :         this->_Reset(_STD forward<_Fx>(_Func));

	mov	rcx, QWORD PTR _Func$[rsp]
	call	??$forward@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@std@@YA$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@AEAV1@@Z ; std::forward<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reset@V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_c68fd856d6bf2ebe8eef5d5d9756870f> >
	npad	1

; 1101 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ENDP ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Func$ = 56
?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA PROC ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z@4HA ENDP ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
this$ = 8
<bindRegister>$ = 16
<op2>$ = 24
??0<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEAA@AEAV?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEBUZydisDecodedOperand_@@@Z PROC ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f>::<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>

; 219  : 						auto bindInfo = mDecrypts.findValue([&bindRegister, &op2](const DecryptInfo& value) {return value.BaseRegister == bindRegister[op2.reg.value]; });

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <bindRegister>$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <op2>$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEAA@AEAV?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEBUZydisDecodedOperand_@@@Z ENDP ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f>::<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
tv75 = 32
tv73 = 40
this$ = 64
value$ = 72
??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f>::operator()

; 219  : 						auto bindInfo = mDecrypts.findValue([&bindRegister, &op2](const DecryptInfo& value) {return value.BaseRegister == bindRegister[op2.reg.value]; });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 32					; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv73[rsp]
	call	??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::operator[]
	mov	rcx, QWORD PTR value$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z
_TEXT	SEGMENT
this$ = 48
_Func$ = 56
??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z PROC ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>, COMDAT

; 1097 :     function(_Fx&& _Func) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	npad	1

; 1098 :         static_assert(is_copy_constructible_v<decay_t<_Fx>>,
; 1099 :             "The target function object type must be copy constructible (N4988 [func.wrap.func.con]/10.1).");
; 1100 :         this->_Reset(_STD forward<_Fx>(_Func));

	mov	rcx, QWORD PTR _Func$[rsp]
	call	??$forward@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@std@@YA$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@AEAV1@@Z ; std::forward<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reset@V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_bea1f622c03430f47fe65b0f1b1e26e0> >
	npad	1

; 1101 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ENDP ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Func$ = 56
?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA PROC ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z@4HA ENDP ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
this$ = 8
<op2>$ = 16
??0<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEAA@AEBUZydisDecodedOperand_@@@Z PROC ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0>::<lambda_bea1f622c03430f47fe65b0f1b1e26e0>

; 215  : 						});

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <op2>$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEAA@AEBUZydisDecodedOperand_@@@Z ENDP ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0>::<lambda_bea1f622c03430f47fe65b0f1b1e26e0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
tv69 = 0
this$ = 32
value$ = 40
??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0>::operator()

; 215  : 						});

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 214  : 							return value.BaseRegister == op2.reg.value;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR value$[rsp]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 215  : 						});

	add	rsp, 24
	ret	0
??R<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z
_TEXT	SEGMENT
this$ = 48
_Func$ = 56
??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z PROC ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>, COMDAT

; 1097 :     function(_Fx&& _Func) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	npad	1

; 1098 :         static_assert(is_copy_constructible_v<decay_t<_Fx>>,
; 1099 :             "The target function object type must be copy constructible (N4988 [func.wrap.func.con]/10.1).");
; 1100 :         this->_Reset(_STD forward<_Fx>(_Func));

	mov	rcx, QWORD PTR _Func$[rsp]
	call	??$forward@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@std@@YA$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@AEAV1@@Z ; std::forward<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reset@V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAX$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Reset<<lambda_564f9749a9a51d2fffa238f6767f2a0a> >
	npad	1

; 1101 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ENDP ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Func$ = 56
?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA PROC ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z@4HA ENDP ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ PROC ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::~function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ ENDP ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::~function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA PROC ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::~function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ@4HA ENDP ; `std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::~function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set, COMDAT

; 1048 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1049 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 1050 :     }

	ret	0
?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl, COMDAT

; 1044 :     _Ptrt* _Getimpl() const noexcept { // get pointer to object

	mov	QWORD PTR [rsp+8], rcx

; 1045 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax]

; 1046 :     }

	ret	0
?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Local, COMDAT

; 1032 :     bool _Local() const noexcept { // test for locally stored copy of object

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1033 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, rcx
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv68[rsp], 0
$LN4@Local:
	movzx	eax, BYTE PTR tv68[rsp]

; 1034 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ
_TEXT	SEGMENT
tv78 = 32
tv71 = 40
tv81 = 48
this$ = 80
?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Tidy, COMDAT

; 1001 :     void _Tidy() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1002 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Tidy

; 1003 :             _Getimpl()->_Delete_this(!_Local());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl
	mov	QWORD PTR tv71[rsp], rax
	mov	rax, QWORD PTR tv71[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Local@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBA_NXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Local
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv78[rsp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv78[rsp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv78[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	QWORD PTR tv81[rsp]

; 1004 :             _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1
$LN2@Tidy:

; 1005 :         }
; 1006 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Empty, COMDAT

; 938  :     bool _Empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 939  :         return !_Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl
	test	rax, rax
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv67[rsp], 0
$LN4@Empty:
	movzx	eax, BYTE PTR tv67[rsp]

; 940  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 928  :     ~_Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 929  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEAAXXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Tidy
	npad	1

; 930  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::~_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
_Impl$ = 32
tv78 = 40
tv80 = 48
this$ = 80
<_Args_0>$ = 88
??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::operator(), COMDAT

; 920  :     _Ret operator()(_Types... _Args) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 921  :         if (_Empty()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@IEBA_NXZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator

; 922  :             _Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
	npad	1
$LN2@operator:

; 923  :         }
; 924  :         const auto _Impl = _Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEBAPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Getimpl
	mov	QWORD PTR _Impl$[rsp], rax

; 925  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Impl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv80[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@YAAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR _Impl$[rsp]
	call	QWORD PTR tv80[rsp]
$LN3@operator:

; 926  :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ PROC ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>, COMDAT

; 916  :     _Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 917  :         _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@AEAAXPEAV?$_Func_base@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Set
	npad	1

; 918  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ENDP ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
this$ = 8
<op2>$ = 16
??0<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEAA@AEBUZydisDecodedOperand_@@@Z PROC ; <lambda_564f9749a9a51d2fffa238f6767f2a0a>::<lambda_564f9749a9a51d2fffa238f6767f2a0a>

; 198  : 						auto info = mDecrypts.findValue([&op2](const DecryptInfo& value) {return value.BaseRegister == op2.reg.value; });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR <op2>$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEAA@AEBUZydisDecodedOperand_@@@Z ENDP ; <lambda_564f9749a9a51d2fffa238f6767f2a0a>::<lambda_564f9749a9a51d2fffa238f6767f2a0a>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
tv69 = 0
this$ = 32
value$ = 40
??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; <lambda_564f9749a9a51d2fffa238f6767f2a0a>::operator()

; 198  : 						auto info = mDecrypts.findValue([&op2](const DecryptInfo& value) {return value.BaseRegister == op2.reg.value; });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR value$[rsp]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]
	add	rsp, 24
	ret	0
??R<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEBA@AEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; <lambda_564f9749a9a51d2fffa238f6767f2a0a>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
tv77 = 32
tv75 = 40
$T1 = 48
__$ReturnUdt$ = 80
_First$ = 88
_Last$ = 96
_Val$ = 104
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_>, COMDAT

; 6185 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 6186 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > >
	npad	1

; 6187 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 6188 :         return _STD _Find_vbool(_First, _Last, _Val);
; 6189 :     } else {
; 6190 :         _STD _Seek_wrapped(_First, _STD _Find_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Val));

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > const &>
	mov	QWORD PTR tv77[rsp], rax
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > > &>
	mov	QWORD PTR tv75[rsp], rax
	mov	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$_Find_unchecked@PEAW4ZydisRegister_@@W41@@std@@YAPEAW4ZydisRegister_@@PEAW41@QEAW41@AEBW41@@Z ; std::_Find_unchecked<enum ZydisRegister_ *,enum ZydisRegister_>
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@PEAW4ZydisRegister_@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@$$QEAPEAW4ZydisRegister_@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_ *>
	npad	1

; 6191 :         return _First;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 6192 :     }
; 6193 : }

	add	rsp, 72					; 00000048H
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Unwrapped, COMDAT

; 344  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@W4ZydisRegister_@@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Unfancy_maybe_null<enum ZydisRegister_>

; 346  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAPEAW4ZydisRegister_@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
this$ = 48
_It$ = 56
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Seek_to, COMDAT

; 220  :     _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 221  :         _Ptr = _STD _Refancy_maybe_null<_Tptr>(const_cast<value_type*>(_It));

	mov	rcx, QWORD PTR _It$[rsp]
	call	??$_Refancy_maybe_null@PEAW4ZydisRegister_@@$0A@@std@@YAPEAW4ZydisRegister_@@PEAW41@@Z ; std::_Refancy_maybe_null<enum ZydisRegister_ *,0>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 222  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAAXPEBW4ZydisRegister_@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Compat, COMDAT

; 197  :     _CONSTEXPR20 void _Compat(const _Vector_const_iterator& _Right) const noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 198  :         // test for compatible iterator pair
; 199  : #if _ITERATOR_DEBUG_LEVEL == 0
; 200  :         (void) _Right;
; 201  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 202  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 203  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 204  :     }

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::operator==, COMDAT

; 164  :     _NODISCARD _CONSTEXPR20 bool operator==(const _Vector_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 165  :         _Compat(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Compat

; 166  :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 167  :     }

	add	rsp, 56					; 00000038H
	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pvector$ = 64
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 47   :         this->_Adopt(_Pvector);

	mov	rdx, QWORD PTR _Pvector$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 48   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Hinode$ = 40
_Scary$ = 48
_Nodekey$1 = 56
_Comp$ = 64
tv133 = 72
_Lonode$ = 80
tv147 = 88
tv149 = 96
this$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Eqrange<enum ZydisRegister_>, COMDAT

; 1695 :         noexcept(_Nothrow_compare<key_compare, key_type, _Other> && _Nothrow_compare<key_compare, _Other, key_type>) {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1696 :         // find range of nodes equivalent to _Keyval
; 1697 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1698 :         const auto& _Comp = _Getcomp();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp
	mov	QWORD PTR _Comp$[rsp], rax

; 1699 :         _Nodeptr _Pnode   = _Scary->_Myhead->_Parent;

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$[rsp], rax

; 1700 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Lonode$[rsp], rax

; 1701 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Hinode$[rsp], rax
$LN2@Eqrange:

; 1702 : 
; 1703 :         while (!_Pnode->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	$LN3@Eqrange

; 1704 :             const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);

	mov	rax, QWORD PTR _Pnode$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>
	mov	QWORD PTR _Nodekey$1[rsp], rax

; 1705 :             if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {

	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR _Nodekey$1[rsp]
	mov	rcx, QWORD PTR _Comp$[rsp]
	call	??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ; std::less<enum ZydisRegister_>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@Eqrange

; 1706 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax

; 1707 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN7@Eqrange
$LN6@Eqrange:

; 1708 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

	mov	rax, QWORD PTR _Hinode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN8@Eqrange
	mov	r8, QWORD PTR _Nodekey$1[rsp]
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Comp$[rsp]
	call	??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ; std::less<enum ZydisRegister_>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Eqrange

; 1709 :                     _Hinode = _Pnode; // _Pnode greater, remember it

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR _Hinode$[rsp], rax
$LN8@Eqrange:

; 1710 :                 }
; 1711 : 
; 1712 :                 _Lonode = _Pnode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR _Lonode$[rsp], rax

; 1713 :                 _Pnode  = _Pnode->_Left; // descend left subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN7@Eqrange:

; 1714 :             }
; 1715 :         }

	jmp	$LN2@Eqrange
$LN3@Eqrange:

; 1716 : 
; 1717 :         _Pnode = _Hinode->_Isnil ? _Scary->_Myhead->_Parent : _Hinode->_Left; // continue scan for upper bound

	mov	rax, QWORD PTR _Hinode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN12@Eqrange
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv133[rsp], rax
	jmp	SHORT $LN13@Eqrange
$LN12@Eqrange:
	mov	rax, QWORD PTR _Hinode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv133[rsp], rax
$LN13@Eqrange:
	mov	rax, QWORD PTR tv133[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Eqrange:

; 1718 :         while (!_Pnode->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN5@Eqrange

; 1719 :             if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode->_Myval))) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp
	mov	QWORD PTR tv149[rsp], rax
	mov	rax, QWORD PTR _Pnode$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??$_Kfn@$$CBW4ZydisRegister_@@W41@@?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@SAAEBW4ZydisRegister_@@AEBU?$pair@$$CBW4ZydisRegister_@@W41@@1@@Z ; std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0>::_Kfn<enum ZydisRegister_ const ,enum ZydisRegister_>
	mov	QWORD PTR tv147[rsp], rax
	mov	r8, QWORD PTR tv147[rsp]
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv149[rsp]
	call	??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ; std::less<enum ZydisRegister_>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Eqrange

; 1720 :                 // _Pnode greater than _Keyval, remember it
; 1721 :                 _Hinode = _Pnode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR _Hinode$[rsp], rax

; 1722 :                 _Pnode  = _Pnode->_Left; // descend left subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 1723 :             } else {

	jmp	SHORT $LN10@Eqrange
$LN9@Eqrange:

; 1724 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN10@Eqrange:

; 1725 :             }
; 1726 :         }

	jmp	SHORT $LN4@Eqrange
$LN5@Eqrange:

; 1727 : 
; 1728 :         return {_Lonode, _Hinode};

	lea	r8, QWORD PTR _Hinode$[rsp]
	lea	rdx, QWORD PTR _Lonode$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@AEAPEAU01@$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@0@Z ; std::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *>::pair<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> *><std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> * &,0>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1729 :     }

	add	rsp, 120				; 00000078H
	ret	0
??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Eqrange<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator!=, COMDAT

; 236  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 237  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 238  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator==, COMDAT

; 227  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 228  : #if _ITERATOR_DEBUG_LEVEL == 2
; 229  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 230  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 231  : 
; 232  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 233  :     }

	add	rsp, 24
	ret	0
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator!=, COMDAT

; 100  :     _NODISCARD bool operator!=(const _Tree_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 101  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 102  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator==, COMDAT

; 95   :     _NODISCARD bool operator==(const _Tree_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
_Tmp$ = 32
this$ = 64
__$ReturnUdt$ = 72
__formal$ = 80
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++, COMDAT

; 64   :     _Tree_unchecked_const_iterator operator++(int) noexcept {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 65   :         _Tree_unchecked_const_iterator _Tmp = *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 66   :         ++*this;

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++

; 67   :         return _Tmp;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Tmp$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 68   :     }

	add	rsp, 56					; 00000038H
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
_Pnode$1 = 32
this$ = 64
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _Tree_unchecked_const_iterator& operator++() noexcept {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN4@operator
$LN2@operator:

; 51   :             _Nodeptr _Pnode;
; 52   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax
	mov	rax, QWORD PTR _Pnode$1[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$1[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator

; 53   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$1[rsp]
	mov	QWORD PTR [rax], rcx

; 54   :             }

	jmp	SHORT $LN2@operator
$LN3@operator:

; 55   : 
; 56   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$1[rsp]
	mov	QWORD PTR [rax], rcx

; 57   :         } else {

	jmp	SHORT $LN5@operator
$LN4@operator:

; 58   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rax+16]
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Min
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
$LN5@operator:

; 59   :         }
; 60   : 
; 61   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 62   :     }

	add	rsp, 56					; 00000038H
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>, COMDAT

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ PROC ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::~map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::~_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ ENDP ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::~map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::~map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::~_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::~map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z PROC ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::operator[], COMDAT

; 345  :     mapped_type& operator[](const key_type& _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 346  :         return _Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Try_emplace@AEBW4ZydisRegister_@@$$V@?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@_N@1@AEBW4ZydisRegister_@@@Z ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Try_emplace<enum ZydisRegister_ const &>
	mov	rax, QWORD PTR [rax]
	add	rax, 32					; 00000020H

; 347  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z ENDP ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ PROC ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >, COMDAT

; 106  :     map() : _Mybase(key_compare()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ ENDP ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::~_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@W4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@W4ZydisRegister_@@@2@XZ PROC ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ENDP ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Orphan_ptr, COMDAT

; 728  :     void _Orphan_ptr(const _Nodeptr _Ptr) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 729  : #if _ITERATOR_DEBUG_LEVEL == 2
; 730  :         _Lockit _Lock(_LOCK_DEBUG);
; 731  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 732  :         while (*_Pnext) {
; 733  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 734  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 735  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 736  :             } else { // orphan the iterator
; 737  :                 (*_Pnext)->_Myproxy = nullptr;
; 738  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 739  :             }
; 740  :         }
; 741  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 742  :         (void) _Ptr;
; 743  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 744  :     }

	ret	0
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z
_TEXT	SEGMENT
_Pnode$1 = 32
_Head$ = 40
_Parent_sibling$2 = 48
_Parent_sibling$3 = 56
this$ = 80
_Loc$ = 88
_Newnode$ = 96
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Insert_node, COMDAT

; 659  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

$LN19:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 660  :         ++_Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 661  :         const auto _Head  = _Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Head$[rsp], rax

; 662  :         _Newnode->_Parent = _Loc._Parent;

	mov	rax, QWORD PTR _Newnode$[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 663  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN5@Insert_nod

; 664  :             _Head->_Left     = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 665  :             _Head->_Parent   = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 666  :             _Head->_Right    = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 667  :             _Newnode->_Color = _Black; // the root is black

	mov	rax, QWORD PTR _Newnode$[rsp]
	mov	BYTE PTR [rax+24], 1

; 668  :             return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]
	jmp	$LN1@Insert_nod
$LN5@Insert_nod:

; 669  :         }
; 670  : 
; 671  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 672  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

	mov	rax, QWORD PTR _Loc$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN6@Insert_nod

; 673  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 674  :             _Loc._Parent->_Right = _Newnode;

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 675  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN8@Insert_nod

; 676  :                 _Head->_Right = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN8@Insert_nod:

; 677  :             }
; 678  :         } else { // add to left of _Loc._Parent

	jmp	SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 679  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 680  :             _Loc._Parent->_Left = _Newnode;

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 681  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN9@Insert_nod

; 682  :                 _Head->_Left = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN9@Insert_nod:
$LN7@Insert_nod:

; 683  :             }
; 684  :         }
; 685  : 
; 686  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	rax, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR _Pnode$1[rsp], rax
$LN2@Insert_nod:
	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	$LN3@Insert_nod

; 687  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR [rcx+8], rax
	jne	$LN10@Insert_nod

; 688  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Parent_sibling$2[rsp], rax

; 689  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	mov	rax, QWORD PTR _Parent_sibling$2[rsp]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN12@Insert_nod

; 690  :                     _Pnode->_Parent->_Color          = _Black;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 691  :                     _Parent_sibling->_Color          = _Black;

	mov	rax, QWORD PTR _Parent_sibling$2[rsp]
	mov	BYTE PTR [rax+24], 1

; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 693  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 694  :                 } else { // parent's sibling has red and black children

	jmp	SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 695  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR _Pnode$1[rsp], rax
	jne	SHORT $LN14@Insert_nod

; 696  :                         _Pnode = _Pnode->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 697  :                         _Lrotate(_Pnode);

	mov	rdx, QWORD PTR _Pnode$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate
	npad	1
$LN14@Insert_nod:

; 698  :                     }
; 699  : 
; 700  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 701  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 702  :                     _Rrotate(_Pnode->_Parent->_Parent);

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate
	npad	1
$LN13@Insert_nod:

; 703  :                 }
; 704  :             } else { // fixup red-red in right subtree

	jmp	$LN11@Insert_nod
$LN10@Insert_nod:

; 705  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Parent_sibling$3[rsp], rax

; 706  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	mov	rax, QWORD PTR _Parent_sibling$3[rsp]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN15@Insert_nod

; 707  :                     _Pnode->_Parent->_Color          = _Black;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 708  :                     _Parent_sibling->_Color          = _Black;

	mov	rax, QWORD PTR _Parent_sibling$3[rsp]
	mov	BYTE PTR [rax+24], 1

; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 710  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 711  :                 } else { // parent's sibling has red and black children

	jmp	SHORT $LN16@Insert_nod
$LN15@Insert_nod:

; 712  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Pnode$1[rsp], rax
	jne	SHORT $LN17@Insert_nod

; 713  :                         _Pnode = _Pnode->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 714  :                         _Rrotate(_Pnode);

	mov	rdx, QWORD PTR _Pnode$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate
	npad	1
$LN17@Insert_nod:

; 715  :                     }
; 716  : 
; 717  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 718  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 719  :                     _Lrotate(_Pnode->_Parent->_Parent);

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate
	npad	1
$LN16@Insert_nod:
$LN11@Insert_nod:

; 720  :                 }
; 721  :             }
; 722  :         }

	jmp	$LN2@Insert_nod
$LN3@Insert_nod:

; 723  : 
; 724  :         _Head->_Parent->_Color = _Black; // root is always black

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 725  :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]
$LN1@Insert_nod:

; 726  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Fixnodeparent$ = 40
_Fixnode$ = 48
_Erasednode$ = 56
tv133 = 64
tv144 = 72
this$ = 96
_Where$ = 104
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Extract, COMDAT

; 517  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

$LN46:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 518  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

	mov	rax, QWORD PTR _Where$[rsp]
	mov	QWORD PTR _Erasednode$[rsp], rax

; 519  :         ++_Where; // save successor iterator for return

	lea	rcx, QWORD PTR _Where$[rsp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++

; 520  : 
; 521  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 522  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 523  :         _Nodeptr _Pnode = _Erasednode;

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax

; 524  : 
; 525  :         if (_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN5@Extract

; 526  :             _Fixnode = _Pnode->_Right; // stitch up right subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Fixnode$[rsp], rax
	jmp	SHORT $LN6@Extract
$LN5@Extract:

; 527  :         } else if (_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN7@Extract

; 528  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Fixnode$[rsp], rax

; 529  :         } else { // two subtrees, must lift successor node to replace erased

	jmp	SHORT $LN8@Extract
$LN7@Extract:

; 530  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

	mov	rax, QWORD PTR _Where$[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax

; 531  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Fixnode$[rsp], rax
$LN8@Extract:
$LN6@Extract:

; 532  :         }
; 533  : 
; 534  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

	mov	rax, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR _Pnode$[rsp], rax
	jne	$LN9@Extract

; 535  :             _Fixnodeparent = _Erasednode->_Parent;

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Fixnodeparent$[rsp], rax

; 536  :             if (!_Fixnode->_Isnil) {

	mov	rax, QWORD PTR _Fixnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN11@Extract

; 537  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

	mov	rax, QWORD PTR _Fixnode$[rsp]
	mov	rcx, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN11@Extract:

; 538  :             }
; 539  : 
; 540  :             if (_Myhead->_Parent == _Erasednode) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN12@Extract

; 541  :                 _Myhead->_Parent = _Fixnode; // link down from root

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Fixnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN13@Extract
$LN12@Extract:

; 542  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN14@Extract

; 543  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR _Fixnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 544  :             } else {

	jmp	SHORT $LN15@Extract
$LN14@Extract:

; 545  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR _Fixnode$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN15@Extract:
$LN13@Extract:

; 546  :             }
; 547  : 
; 548  :             if (_Myhead->_Left == _Erasednode) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN16@Extract

; 549  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

	mov	rax, QWORD PTR _Fixnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN42@Extract
	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR tv133[rsp], rax
	jmp	SHORT $LN43@Extract
$LN42@Extract:
	mov	rcx, QWORD PTR _Fixnode$[rsp]
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Min
	mov	QWORD PTR tv133[rsp], rax
$LN43@Extract:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tv133[rsp]
	mov	QWORD PTR [rax], rcx
$LN16@Extract:

; 550  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 551  :             }
; 552  : 
; 553  :             if (_Myhead->_Right == _Erasednode) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN17@Extract

; 554  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

	mov	rax, QWORD PTR _Fixnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN44@Extract
	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR tv144[rsp], rax
	jmp	SHORT $LN45@Extract
$LN44@Extract:
	mov	rcx, QWORD PTR _Fixnode$[rsp]
	call	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Max
	mov	QWORD PTR tv144[rsp], rax
$LN45@Extract:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tv144[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN17@Extract:

; 555  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 556  :             }
; 557  :         } else { // erased has two subtrees, _Pnode is successor to erased

	jmp	$LN10@Extract
$LN9@Extract:

; 558  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 559  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 560  : 
; 561  :             if (_Pnode == _Erasednode->_Right) {

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR _Pnode$[rsp], rax
	jne	SHORT $LN18@Extract

; 562  :                 _Fixnodeparent = _Pnode; // successor is next to erased

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR _Fixnodeparent$[rsp], rax

; 563  :             } else { // successor further down, link in place of erased

	jmp	SHORT $LN19@Extract
$LN18@Extract:

; 564  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Fixnodeparent$[rsp], rax

; 565  :                 if (!_Fixnode->_Isnil) {

	mov	rax, QWORD PTR _Fixnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN20@Extract

; 566  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

	mov	rax, QWORD PTR _Fixnode$[rsp]
	mov	rcx, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN20@Extract:

; 567  :                 }
; 568  : 
; 569  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR _Fixnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 570  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 571  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN19@Extract:

; 572  :             }
; 573  : 
; 574  :             if (_Myhead->_Parent == _Erasednode) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN21@Extract

; 575  :                 _Myhead->_Parent = _Pnode; // link down from root

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN22@Extract
$LN21@Extract:

; 576  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN23@Extract

; 577  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 578  :             } else {

	jmp	SHORT $LN24@Extract
$LN23@Extract:

; 579  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

	mov	rax, QWORD PTR _Erasednode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN24@Extract:
$LN22@Extract:

; 580  :             }
; 581  : 
; 582  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Erasednode$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 583  :             _STD swap(_Pnode->_Color, _Erasednode->_Color); // recolor it

	mov	rax, QWORD PTR _Erasednode$[rsp]
	add	rax, 24
	mov	rcx, QWORD PTR _Pnode$[rsp]
	add	rcx, 24
	mov	rdx, rax
	call	??$swap@D$0A@@std@@YAXAEAD0@Z		; std::swap<char,0>
	npad	1
$LN10@Extract:

; 584  :         }
; 585  : 
; 586  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

	mov	rax, QWORD PTR _Erasednode$[rsp]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	$LN25@Extract

; 587  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

	jmp	SHORT $LN4@Extract
$LN2@Extract:
	mov	rax, QWORD PTR _Fixnode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Fixnodeparent$[rsp], rax
$LN4@Extract:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR _Fixnode$[rsp], rax
	je	$LN3@Extract
	mov	rax, QWORD PTR _Fixnode$[rsp]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	$LN3@Extract

; 588  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Fixnode$[rsp], rax
	jne	$LN26@Extract

; 589  :                     _Pnode = _Fixnodeparent->_Right;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax

; 590  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN28@Extract

; 591  :                         _Pnode->_Color         = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 1

; 592  :                         _Fixnodeparent->_Color = _Red;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	BYTE PTR [rax+24], 0

; 593  :                         _Lrotate(_Fixnodeparent);

	mov	rdx, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate

; 594  :                         _Pnode = _Fixnodeparent->_Right;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN28@Extract:

; 595  :                     }
; 596  : 
; 597  :                     if (_Pnode->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN29@Extract

; 598  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR _Fixnode$[rsp], rax

; 599  :                     } else if (_Pnode->_Left->_Color == _Black

	jmp	$LN30@Extract
$LN29@Extract:

; 600  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	SHORT $LN31@Extract
	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	SHORT $LN31@Extract

; 601  :                         _Pnode->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 0

; 602  :                         _Fixnode       = _Fixnodeparent;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR _Fixnode$[rsp], rax

; 603  :                     } else { // must rearrange right subtree

	jmp	$LN32@Extract
$LN31@Extract:

; 604  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	SHORT $LN33@Extract

; 605  :                             _Pnode->_Left->_Color = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	BYTE PTR [rax+24], 1

; 606  :                             _Pnode->_Color        = _Red;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 0

; 607  :                             _Rrotate(_Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate

; 608  :                             _Pnode = _Fixnodeparent->_Right;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN33@Extract:

; 609  :                         }
; 610  : 
; 611  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Fixnodeparent$[rsp]
	movzx	ecx, BYTE PTR [rcx+24]
	mov	BYTE PTR [rax+24], cl

; 612  :                         _Fixnodeparent->_Color = _Black;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	BYTE PTR [rax+24], 1

; 613  :                         _Pnode->_Right->_Color = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rax+24], 1

; 614  :                         _Lrotate(_Fixnodeparent);

	mov	rdx, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate
	npad	1

; 615  :                         break; // tree now recolored/rebalanced

	jmp	$LN3@Extract
$LN32@Extract:
$LN30@Extract:

; 616  :                     }
; 617  :                 } else { // fixup right subtree

	jmp	$LN27@Extract
$LN26@Extract:

; 618  :                     _Pnode = _Fixnodeparent->_Left;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 619  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN34@Extract

; 620  :                         _Pnode->_Color         = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 1

; 621  :                         _Fixnodeparent->_Color = _Red;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	BYTE PTR [rax+24], 0

; 622  :                         _Rrotate(_Fixnodeparent);

	mov	rdx, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate

; 623  :                         _Pnode = _Fixnodeparent->_Left;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN34@Extract:

; 624  :                     }
; 625  : 
; 626  :                     if (_Pnode->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN35@Extract

; 627  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR _Fixnode$[rsp], rax

; 628  :                     } else if (_Pnode->_Right->_Color == _Black

	jmp	$LN36@Extract
$LN35@Extract:

; 629  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	SHORT $LN37@Extract
	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	SHORT $LN37@Extract

; 630  :                         _Pnode->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 0

; 631  :                         _Fixnode       = _Fixnodeparent;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	QWORD PTR _Fixnode$[rsp], rax

; 632  :                     } else { // must rearrange left subtree

	jmp	SHORT $LN38@Extract
$LN37@Extract:

; 633  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+24]
	cmp	eax, 1
	jne	SHORT $LN39@Extract

; 634  :                             _Pnode->_Right->_Color = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rax+24], 1

; 635  :                             _Pnode->_Color         = _Red;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 0

; 636  :                             _Lrotate(_Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate

; 637  :                             _Pnode = _Fixnodeparent->_Left;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN39@Extract:

; 638  :                         }
; 639  : 
; 640  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Fixnodeparent$[rsp]
	movzx	ecx, BYTE PTR [rcx+24]
	mov	BYTE PTR [rax+24], cl

; 641  :                         _Fixnodeparent->_Color = _Black;

	mov	rax, QWORD PTR _Fixnodeparent$[rsp]
	mov	BYTE PTR [rax+24], 1

; 642  :                         _Pnode->_Left->_Color  = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	BYTE PTR [rax+24], 1

; 643  :                         _Rrotate(_Fixnodeparent);

	mov	rdx, QWORD PTR _Fixnodeparent$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate
	npad	1

; 644  :                         break; // tree now recolored/rebalanced

	jmp	SHORT $LN3@Extract
$LN38@Extract:
$LN36@Extract:
$LN27@Extract:

; 645  :                     }
; 646  :                 }
; 647  :             }

	jmp	$LN2@Extract
$LN3@Extract:

; 648  : 
; 649  :             _Fixnode->_Color = _Black; // stopping node is black

	mov	rax, QWORD PTR _Fixnode$[rsp]
	mov	BYTE PTR [rax+24], 1
$LN25@Extract:

; 650  :         }
; 651  : 
; 652  :         if (0 < _Mysize) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jbe	SHORT $LN40@Extract

; 653  :             --_Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
$LN40@Extract:

; 654  :         }
; 655  : 
; 656  :         return _Erasednode;

	mov	rax, QWORD PTR _Erasednode$[rsp]

; 657  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 0
this$ = 32
_Wherenode$ = 40
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate, COMDAT

; 495  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 496  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 497  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 498  : 
; 499  :         if (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN2@Rrotate

; 500  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN2@Rrotate:

; 501  :         }
; 502  : 
; 503  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 504  : 
; 505  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN3@Rrotate

; 506  :             _Myhead->_Parent = _Pnode;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN4@Rrotate
$LN3@Rrotate:

; 507  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN5@Rrotate

; 508  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 509  :         } else {

	jmp	SHORT $LN6@Rrotate
$LN5@Rrotate:

; 510  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Rrotate:
$LN4@Rrotate:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Right      = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 514  :         _Wherenode->_Parent = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 515  :     }

	add	rsp, 24
	ret	0
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 0
this$ = 32
_Wherenode$ = 40
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate, COMDAT

; 473  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 474  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax

; 475  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 476  : 
; 477  :         if (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN2@Lrotate

; 478  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN2@Lrotate:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN3@Lrotate

; 484  :             _Myhead->_Parent = _Pnode;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN4@Lrotate
$LN3@Lrotate:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN5@Lrotate

; 486  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 487  :         } else {

	jmp	SHORT $LN6@Lrotate
$LN5@Lrotate:

; 488  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN6@Lrotate:
$LN4@Lrotate:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Left       = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax], rcx

; 492  :         _Wherenode->_Parent = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 493  :     }

	add	rsp, 24
	ret	0
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Min, COMDAT

; 465  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode

	mov	QWORD PTR [rsp+8], rcx
$LN2@Min:

; 466  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@Min

; 467  :             _Pnode = _Pnode->_Left;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 468  :         }

	jmp	SHORT $LN2@Min
$LN3@Min:

; 469  : 
; 470  :         return _Pnode;

	mov	rax, QWORD PTR _Pnode$[rsp]

; 471  :     }

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Min
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Max, COMDAT

; 457  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode

	mov	QWORD PTR [rsp+8], rcx
$LN2@Max:

; 458  :         while (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@Max

; 459  :             _Pnode = _Pnode->_Right;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax

; 460  :         }

	jmp	SHORT $LN2@Max
$LN3@Max:

; 461  : 
; 462  :         return _Pnode;

	mov	rax, QWORD PTR _Pnode$[rsp]

; 463  :     }

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Max
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >, COMDAT

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z PROC ; std::less<enum ZydisRegister_>::operator(), COMDAT

; 2411 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2412 :         return _Left < _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 2413 :     }

	add	rsp, 24
	ret	0
??R?$less@W4ZydisRegister_@@@std@@QEBA_NAEBW4ZydisRegister_@@0@Z ENDP ; std::less<enum ZydisRegister_>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary, COMDAT

; 1976 :     const _Scary_val* _Get_scary() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1977 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > const >

; 1978 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary, COMDAT

; 1972 :     _Scary_val* _Get_scary() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1973 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >

; 1974 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal, COMDAT

; 1968 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1969 :         return _Mypair._Myval2._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first

; 1970 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal, COMDAT

; 1964 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1965 :         return _Mypair._Myval2._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>::_Get_first

; 1966 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp, COMDAT

; 1960 :     const key_compare& _Getcomp() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1961 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Get_first

; 1962 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBU?$less@W4ZydisRegister_@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Scary$ = 40
_Alproxy$ = 48
this$ = 80
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Alloc_sentinel_and_proxy, COMDAT

; 1943 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1944 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1945 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1946 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);

	mov	r8, QWORD PTR _Scary$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1947 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
	mov	rcx, rax
	call	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	mov	rcx, QWORD PTR _Scary$[rsp]
	mov	QWORD PTR [rcx], rax

; 1948 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1949 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Check_grow_by_1, COMDAT

; 1637 :     void _Check_grow_by_1() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1638 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::max_size
	mov	QWORD PTR tv65[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	rcx, QWORD PTR tv65[rsp]
	cmp	rcx, QWORD PTR [rax+8]
	jne	SHORT $LN2@Check_grow

; 1639 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	npad	1
$LN2@Check_grow:
$LN3@Check_grow:

; 1640 :         }
; 1641 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::find, COMDAT

; 1383 :     _NODISCARD iterator find(const key_type& _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1384 :         return iterator(_Find(_Keyval), _Get_scary());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Find<enum ZydisRegister_>
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1385 :     }

	add	rsp, 56					; 00000038H
	ret	0
?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Head$ = 32
_Scary$ = 40
tv78 = 48
tv76 = 56
this$ = 80
?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::clear, COMDAT

; 1360 :     void clear() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1361 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1362 :         _Scary->_Orphan_ptr(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Orphan_ptr

; 1363 :         auto _Head = _Scary->_Myhead;

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Head$[rsp], rax

; 1364 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >

; 1365 :         _Head->_Parent  = _Head;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1366 :         _Head->_Left    = _Head;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	QWORD PTR [rax], rcx

; 1367 :         _Head->_Right   = _Head;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1368 :         _Scary->_Mysize = 0;

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1369 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
this$ = 96
_Keyval$ = 104
?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::erase, COMDAT

; 1347 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 1348 :         return _Erase(_Eqrange(_Keyval));

	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Eqrange@W4ZydisRegister_@@@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@1@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Eqrange<enum ZydisRegister_>
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase

; 1349 :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z
_TEXT	SEGMENT
_Last$ = 32
_First$ = 40
_Num$ = 48
this$ = 80
_Where$ = 88
?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase, COMDAT

; 1315 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1316 :         const _Unchecked_const_iterator _First(_Where.first, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR _Where$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>

; 1317 :         const _Unchecked_const_iterator _Last(_Where.second, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR _Where$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR _Last$[rsp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>

; 1318 :         const auto _Num = static_cast<size_type>(_STD distance(_First, _Last));

	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0> >
	mov	QWORD PTR _Num$[rsp], rax

; 1319 :         _Erase_unchecked(_First, _Last);

	mov	r8, QWORD PTR _Last$[rsp]
	mov	rdx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked

; 1320 :         return _Num;

	mov	rax, QWORD PTR _Num$[rsp]

; 1321 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAA_KU?$pair@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@PEAU12@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z
_TEXT	SEGMENT
_Begin$ = 32
$T1 = 40
this$ = 64
_First$ = 72
_Last$ = 80
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked, COMDAT

; 1299 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1300 :         const auto _Begin = _Unchecked_begin();

	lea	rdx, QWORD PTR _Begin$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Unchecked_begin
	npad	1

; 1301 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

	lea	rdx, QWORD PTR _Begin$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Erase_unch
	mov	rax, QWORD PTR _Last$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	je	SHORT $LN4@Erase_unch

; 1302 :             // erase all
; 1303 :             clear();

	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::clear

; 1304 :             return _Last._Ptr;

	mov	rax, QWORD PTR _Last$[rsp]
	jmp	SHORT $LN1@Erase_unch
$LN4@Erase_unch:
$LN2@Erase_unch:

; 1305 :         }
; 1306 : 
; 1307 :         // partial erase, one at a time
; 1308 :         while (_First != _Last) {

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Erase_unch

; 1309 :             _Erase_unchecked(_First++);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA?AV01@H@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked
	npad	1

; 1310 :         }

	jmp	SHORT $LN2@Erase_unch
$LN3@Erase_unch:

; 1311 : 
; 1312 :         return _Last._Ptr;

	mov	rax, QWORD PTR _Last$[rsp]
$LN1@Erase_unch:

; 1313 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
_Scary$ = 32
_Erasednode$ = 40
_Successor$ = 48
this$ = 80
_Where$ = 88
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked, COMDAT

; 1289 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1290 :         const auto _Scary                    = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1291 :         _Unchecked_const_iterator _Successor = _Where;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	QWORD PTR _Successor$[rsp], rax

; 1292 :         ++_Successor; // save successor iterator for return

	lea	rcx, QWORD PTR _Successor$[rsp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,std::_Iterator_base0>::operator++

; 1293 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Extract
	mov	QWORD PTR _Erasednode$[rsp], rax

; 1294 :         _Scary->_Orphan_ptr(_Erasednode);

	mov	rdx, QWORD PTR _Erasednode$[rsp]
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Orphan_ptr

; 1295 :         _Node::_Freenode(_Getal(), _Erasednode); // delete erased node

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
	mov	rdx, QWORD PTR _Erasednode$[rsp]
	mov	rcx, rax
	call	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >

; 1296 :         return _Successor._Ptr; // return successor nodeptr

	mov	rax, QWORD PTR _Successor$[rsp]

; 1297 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::max_size, COMDAT

; 1202 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1203 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1204 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1205 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Unchecked_begin, COMDAT

; 1150 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1151 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1152 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_Scary$ = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::end, COMDAT

; 1140 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1141 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1142 :         return iterator(_Scary->_Myhead, _Scary);

	mov	r8, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1143 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Scary$ = 32
this$ = 64
??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::~_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >, COMDAT

; 1085 :     ~_Tree() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1086 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1087 :         _Scary->_Erase_head(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Getal
	mov	rdx, rax
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >
	npad	1

; 1088 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1089 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1090 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1091 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1092 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::~_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv71 = 40
this$ = 64
_Parg$ = 72
??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >, COMDAT

; 894  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	lea	r9, QWORD PTR $T1[rsp]
	mov	r8, QWORD PTR _Parg$[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	??$?0AEBU?$less@W4ZydisRegister_@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@W4ZydisRegister_@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@W4ZydisRegister_@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1>::_Compressed_pair<std::less<enum ZydisRegister_>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >,1>,1><std::less<enum ZydisRegister_> const &,std::_Zero_then_variadic_args_t>
	npad	1

; 895  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Alloc_sentinel_and_proxy
	npad	1

; 896  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@W4ZydisRegister_@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 461168601842738790			; 0666666666666666H

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z	; std::_Get_size_of_n<40>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >::allocator<std::_Tree_node<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z PROC ; std::move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z
_TEXT	SEGMENT
_Other$ = 48
__formal$ = 56
??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z PROC ; std::operator!=<void __cdecl(void *)>, COMDAT

; 1289 : _NODISCARD bool operator!=(const function<_Fty>& _Other, nullptr_t) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1290 :     return static_cast<bool>(_Other);

	mov	rcx, QWORD PTR _Other$[rsp]
	call	??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ ; std::function<void __cdecl(void *)>::operator bool

; 1291 : }

	add	rsp, 40					; 00000028H
	ret	0
??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z ENDP ; std::operator!=<void __cdecl(void *)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z PROC ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 88					; 00000058H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAXI@Z ENDP ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ PROC ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ENDP ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA PROC ; `std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ@4HA ENDP ; `std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
tv72 = 32
this$ = 64
__that$ = 72
??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>, COMDAT

; 278  :     pair(pair&&)      = default;

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR tv72[rsp]
	call	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv72 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA PROC ; `std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@$$QEAU01@@Z@4HA ENDP ; `std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++, COMDAT

; 286  :     _CONSTEXPR20 _Vector_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 287  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++

; 288  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 289  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*, COMDAT

; 270  :     _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 271  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*

; 272  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Compat, COMDAT

; 197  :     _CONSTEXPR20 void _Compat(const _Vector_const_iterator& _Right) const noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 198  :         // test for compatible iterator pair
; 199  : #if _ITERATOR_DEBUG_LEVEL == 0
; 200  :         (void) _Right;
; 201  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 202  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 203  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 204  :     }

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator!=, COMDAT

; 175  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 176  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 177  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator==, COMDAT

; 164  :     _NODISCARD _CONSTEXPR20 bool operator==(const _Vector_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 165  :         _Compat(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Compat

; 166  :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 167  :     }

	add	rsp, 56					; 00000038H
	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++, COMDAT

; 74   :     _CONSTEXPR20 _Vector_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 75   : #if _ITERATOR_DEBUG_LEVEL != 0
; 76   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 77   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 78   :         _STL_VERIFY(_Mycont, "can't increment invalidated vector iterator");
; 79   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 80   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 81   : 
; 82   :         ++_Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 88					; 00000058H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 83   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 84   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*, COMDAT

; 50   :     _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 51   : #if _ITERATOR_DEBUG_LEVEL != 0
; 52   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 53   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 54   :         _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");
; 55   :         _STL_VERIFY(
; 56   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 57   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 58   : 
; 59   :         return *_Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]

; 60   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pvector$ = 64
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 47   :         this->_Adopt(_Pvector);

	mov	rdx, QWORD PTR _Pvector$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 48   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ
_TEXT	SEGMENT
?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ PROC		; IronMan::GetDMA, COMDAT

; 312  : 	inline DMAHandler& GetDMA() { return DMAHandler::Instance(); };

$LN3:
	sub	rsp, 40					; 00000028H
	call	?Instance@DMAHandler@IronMan@@SAAEAV12@XZ ; IronMan::DMAHandler::Instance
	add	rsp, 40					; 00000028H
	ret	0
?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ ENDP		; IronMan::GetDMA
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
text$yd	SEGMENT
??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A ; IronMan::DMAHandler::processInfo
	call	??1BaseProcessInfo@IronMan@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
text$di	SEGMENT
??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::processInfo'', COMDAT

; 116  : 		static inline BaseProcessInfo processInfo{};

	push	rdi
	sub	rsp, 32					; 00000020H

; 92   : 		DWORD pid = 0;

	mov	DWORD PTR ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A, 0

; 116  : 		static inline BaseProcessInfo processInfo{};

	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+40
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 93   : 		std::string name;
; 94   : 		const wchar_t* wname;
; 95   : 		ptr_t base = 0;

	mov	QWORD PTR ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+48, 0

; 116  : 		static inline BaseProcessInfo processInfo{};

	lea	rcx, OFFSET FLAT:??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo''
	call	atexit
	npad	1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::processInfo''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'IronMan::DMAHandler::processInfo'''::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'IronMan::DMAHandler::processInfo'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterReadArray
	call	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::ScatterReadArray'', COMDAT

; 114  : 		static inline std::shared_ptr<std::unordered_map<void*, std::vector<ScatterStruct>>>ScatterReadArray;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::ScatterReadArray''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterWriteArray
	call	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::ScatterWriteArray'', COMDAT

; 113  : 		static inline std::shared_ptr < std::unordered_map<void*, std::vector<ScatterStruct>>>ScatterWriteArray;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::ScatterWriteArray''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >, COMDAT

; 1681 :     ~shared_ptr() noexcept { // release resource

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1682 :         this->_Decref();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
	npad	1

; 1683 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ PROC ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref, COMDAT

; 1375 :     void _Decref() noexcept { // decrement reference count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1376 :         if (_Rep) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Decref

; 1377 :             _Rep->_Decref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?_Decref@_Ref_count_base@std@@QEAAXXZ	; std::_Ref_count_base::_Decref
	npad	1
$LN2@Decref:

; 1378 :         }
; 1379 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ENDP ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
text$di	SEGMENT
??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::UpdateStartTime'', COMDAT

; 107  : 		static inline std::chrono::time_point<std::chrono::system_clock> UpdateStartTime = std::chrono::system_clock::now();

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A ; IronMan::DMAHandler::UpdateStartTime
	call	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::UpdateStartTime''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1BaseProcessInfo@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1BaseProcessInfo@IronMan@@QEAA@XZ PROC		; IronMan::BaseProcessInfo::~BaseProcessInfo, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1BaseProcessInfo@IronMan@@QEAA@XZ ENDP		; IronMan::BaseProcessInfo::~BaseProcessInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::BaseProcessInfo::~BaseProcessInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::BaseProcessInfo::~BaseProcessInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>, COMDAT

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_chrono.hpp
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 212  :         constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 213  :             : _MyDur(_Other) {}

	mov	rax, QWORD PTR _Other$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 88   :         _NODISCARD static time_point now() noexcept { // get current time

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 89   :             return time_point(duration(_Xtime_get_ticks()));

	call	_Xtime_get_ticks
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 90   :         }

	add	rsp, 56					; 00000038H
	ret	0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z PROC	; IronMan::Analysis::UObjectAnalysis::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ ; IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 1832				; 00000728H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GUObjectAnalysis@Analysis@IronMan@@UEAAPEAXI@Z ENDP	; IronMan::Analysis::UObjectAnalysis::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::~SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@0@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@0@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 88					; 00000058H
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAXPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@QEAU10@AEAV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 88					; 00000058H
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rsp], 88	; 00000058H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K1@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[], COMDAT

; 1912 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1913 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1914 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1915 :         _STL_VERIFY(
; 1916 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1917 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1918 : 
; 1919 :         return _My_data._Myfirst[_Pos];

	imul	rax, QWORD PTR _Pos$[rsp], 88		; 00000058H
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rax, QWORD PTR [rcx]

; 1920 :     }

	add	rsp, 24
	ret	0
??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	cdq
	mov	ecx, 88					; 00000058H
	idiv	rcx

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::size, COMDAT

; 1898 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1899 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	cdq
	mov	ecx, 88					; 00000058H
	idiv	rcx

; 1901 :     }

	add	rsp, 24
	ret	0
?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv69 = 0
_My_data$ = 8
this$ = 32
?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::empty, COMDAT

; 1893 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1894 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[rsp]

; 1896 :     }

	add	rsp, 24
	ret	0
?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::end, COMDAT

; 1835 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1836 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1837 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1838 :     }

	add	rsp, 72					; 00000048H
	ret	0
?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::begin, COMDAT

; 1825 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1826 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1827 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1828 :     }

	add	rsp, 72					; 00000048H
	ret	0
?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::push_back, COMDAT

; 921  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 922  :         // insert by moving into element at end, provide strong guarantee
; 923  :         _Emplace_one_at_back(_STD move(_Val));

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$move@AEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAU10@@Z ; std::move<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAU21@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Emplace_one_at_back<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
	npad	1

; 924  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::~vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1>::_Compressed_pair<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >,std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z PROC ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z	; std::_Get_size_of_n<88>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAPEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ENDP ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z PROC ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 88		; 00000058H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXQEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@_K@Z ENDP ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z
_TEXT	SEGMENT
tv83 = 32
tv82 = 40
$T1 = 48
this$ = 144
key$ = 152
??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::operator[], COMDAT

; 82   : 		{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 83   : 			if (this->find(key) != NULL)

	mov	rdx, QWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
	test	rax, rax
	je	SHORT $LN2@operator

; 84   : 			{
; 85   : 				return *this->find(key);

	mov	rdx, QWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
	jmp	SHORT $LN1@operator

; 86   : 			}

	jmp	SHORT $LN3@operator
$LN2@operator:

; 87   : 			else
; 88   : 			{
; 89   : 				this->insert(key, T());

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR tv83[rsp]
	mov	QWORD PTR tv82[rsp], rax
	mov	r8, QWORD PTR tv82[rsp]
	mov	rdx, QWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert
	npad	1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	npad	1
$LN3@operator:

; 90   : 			}
; 91   : 
; 92   : 			return *this->find(key);

	mov	rdx, QWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
$LN1@operator:

; 93   : 		}

	add	rsp, 136				; 00000088H
	ret	0
??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv83 = 32
tv82 = 40
$T1 = 48
this$ = 144
key$ = 152
?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA PROC ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::operator[]'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z@4HA ENDP ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::operator[]'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z
_TEXT	SEGMENT
p$ = 32
tv83 = 40
tv82 = 48
tv78 = 56
$T1 = 64
this$ = 176
f$ = 184
s$ = 192
?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert, COMDAT

; 55   : 		{

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 56   : 			T* p = find(f);

	mov	rdx, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
	mov	QWORD PTR p$[rsp], rax

; 57   : 			if (p == NULL)

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN2@insert

; 58   : 			{
; 59   : 				m_data.push_back(std::pair<K, T>(f, s));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR s$[rsp]
	mov	rdx, QWORD PTR f$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$?0HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@$0A@@?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@AEBHAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo><int,IronMan::Analysis::UObjectAnalysis::DecryptInfo,0>
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR tv83[rsp]
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?push_back@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAX$$QEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::push_back
	npad	1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
	npad	1

; 60   : 			}

	jmp	SHORT $LN3@insert
$LN2@insert:

; 61   : 			else
; 62   : 			{
; 63   : 				*p = s;

	mov	rdx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z
	npad	1
$LN3@insert:

; 64   : 			}
; 65   : 		}

	add	rsp, 168				; 000000a8H
	ret	0
?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
p$ = 32
tv83 = 40
tv82 = 48
tv78 = 56
$T1 = 64
this$ = 176
f$ = 184
s$ = 192
?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA PROC ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z@4HA ENDP ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z
_TEXT	SEGMENT
i$1 = 32
tv84 = 40
tv88 = 48
tv129 = 56
$T2 = 64
$T3 = 72
this$ = 96
f$ = 104
?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue, COMDAT

; 42   : 		{

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 43   : 			for (int i = (m_data.size() - 1); i >= 0; --i)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::size
	dec	rax
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@findValue
$LN2@findValue:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@findValue:
	cmp	DWORD PTR i$1[rsp], 0
	jl	SHORT $LN3@findValue

; 44   : 			{
; 45   : 				if (f(m_data[i].second))

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[]
	add	rax, 8
	mov	QWORD PTR tv88[rsp], rax
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	??R?$_Func_class@_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEBA_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::_Func_class<bool,IronMan::Analysis::UObjectAnalysis::DecryptInfo const &>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@findValue

; 46   : 				{
; 47   : 					return &(m_data[i].second);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv129[rsp], rax
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv129[rsp]
	call	??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[]
	add	rax, 8
	mov	QWORD PTR $T2[rsp], rax
	mov	rcx, QWORD PTR f$[rsp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	mov	rax, QWORD PTR $T2[rsp]
	jmp	SHORT $LN1@findValue
$LN5@findValue:

; 48   : 				}
; 49   : 			}

	jmp	$LN2@findValue
$LN3@findValue:

; 50   : 			return NULL;

	mov	QWORD PTR $T3[rsp], 0
	mov	rcx, QWORD PTR f$[rsp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	mov	rax, QWORD PTR $T3[rsp]
$LN1@findValue:

; 51   : 		}

	add	rsp, 88					; 00000058H
	ret	0
?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv84 = 40
tv88 = 48
tv129 = 56
$T2 = 64
$T3 = 72
this$ = 96
f$ = 104
?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA PROC ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR f$[rbp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z@4HA ENDP ; `IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z
_TEXT	SEGMENT
i$1 = 32
tv65 = 40
tv76 = 48
tv85 = 56
this$ = 80
k$ = 88
?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find, COMDAT

; 30   : 		{

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 31   : 			for (unsigned int i = 0; i < m_data.size(); i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@find
$LN2@find:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@find:
	mov	eax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv65[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::size
	mov	rcx, QWORD PTR tv65[rsp]
	cmp	rcx, rax
	jae	SHORT $LN3@find

; 32   : 			{
; 33   : 				if (m_data[i].first == k)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	eax, DWORD PTR i$1[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv76[rsp]
	call	??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[]
	mov	rcx, QWORD PTR k$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN5@find

; 34   : 				{
; 35   : 					return &(m_data[i].second);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv85[rsp], rax
	mov	eax, DWORD PTR i$1[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv85[rsp]
	call	??A?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@_K@Z ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::operator[]
	add	rax, 8
	jmp	SHORT $LN1@find
$LN5@find:

; 36   : 				}
; 37   : 			}

	jmp	SHORT $LN2@find
$LN3@find:

; 38   : 			return NULL;

	xor	eax, eax
$LN1@find:

; 39   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ
_TEXT	SEGMENT
this$ = 48
?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::empty, COMDAT

; 26   : 		auto empty() const { return m_data.empty(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?empty@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEBA_NXZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::empty
	add	rsp, 40					; 00000028H
	ret	0
?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::end, COMDAT

; 24   : 		auto end() { return m_data.end(); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ PROC ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::begin, COMDAT

; 22   : 		auto begin() { return m_data.begin(); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?begin@?$vector@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$allocator@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>,std::allocator<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > >::begin
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ENDP ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
this$ = 48
??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ PROC	; IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis

; 20   : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObjectAnalysis@Analysis@IronMan@@6B@
	mov	QWORD PTR [rax], rcx

; 21   : 
; 22   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	rcx, rax
	call	??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
	npad	1
	mov	rcx, QWORD PTR this$[rsp]
	call	??1AnalysisBase@Analysis@IronMan@@UEAA@XZ ; IronMan::Analysis::AnalysisBase::~AnalysisBase
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ ENDP	; IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1AnalysisBase@Analysis@IronMan@@UEAA@XZ ; IronMan::Analysis::AnalysisBase::~AnalysisBase
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 1800				; 00000708H
	call	??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1UObjectAnalysis@Analysis@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::~UObjectAnalysis'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
pageSize$ = 32
this$ = 64
entryPoint$ = 72
??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z PROC	; IronMan::Analysis::UObjectAnalysis::UObjectAnalysis

; 13   : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0AnalysisBase@Analysis@IronMan@@IEAA@XZ ; IronMan::Analysis::AnalysisBase::AnalysisBase
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObjectAnalysis@Analysis@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	rcx, rax
	call	??0?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
	npad	1

; 12   : 		: mEntryPoint(entryPoint)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR entryPoint$[rsp]
	mov	QWORD PTR [rax+1824], rcx

; 14   : 		uintptr_t pageSize = 4096;

	mov	QWORD PTR pageSize$[rsp], 4096		; 00001000H

; 15   : 		mBase = (entryPoint - 0x10) & ~(pageSize - 1);

	mov	rax, QWORD PTR entryPoint$[rsp]
	sub	rax, 16
	mov	rcx, QWORD PTR pageSize$[rsp]
	dec	rcx
	not	rcx
	and	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 16   : 		mSize = 0x2000;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 8192		; 00002000H

; 17   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z ENDP	; IronMan::Analysis::UObjectAnalysis::UObjectAnalysis
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pageSize$ = 32
this$ = 64
entryPoint$ = 72
?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::UObjectAnalysis'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1AnalysisBase@Analysis@IronMan@@UEAA@XZ ; IronMan::Analysis::AnalysisBase::~AnalysisBase
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::UObjectAnalysis'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pageSize$ = 32
this$ = 64
entryPoint$ = 72
?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::UObjectAnalysis'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 1800				; 00000708H
	call	??1?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0UObjectAnalysis@Analysis@IronMan@@QEAA@_K@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::UObjectAnalysis'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ PROC ; IronMan::Analysis::UObjectAnalysis::analyseDecrypttions

; 122  : 	{

$LN51:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	mov	eax, 5864				; 000016e8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 123  : 		if (CopyMap2)

	cmp	QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA, 0 ; IronMan::Analysis::CopyMap2
	je	SHORT $LN4@analyseDec

; 124  : 		{
; 125  : 			free(CopyMap2);

	mov	rcx, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	call	free

; 126  : 			CopyMap2 = nullptr;

	mov	QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA, 0 ; IronMan::Analysis::CopyMap2
$LN4@analyseDec:

; 127  : 		}
; 128  : 		CopyMap2 = malloc(mSize);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	malloc
	mov	QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA, rax ; IronMan::Analysis::CopyMap2

; 129  : 		if (!CopyMap2)

	cmp	QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA, 0 ; IronMan::Analysis::CopyMap2
	jne	SHORT $LN5@analyseDec

; 130  : 			return;

	jmp	$LN1@analyseDec
$LN5@analyseDec:

; 131  : 		ZeroMemory(CopyMap2, mSize);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	xor	edx, edx
	mov	rcx, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	call	memset

; 132  : 
; 133  : 		IronMan::GetDMA().Read((ULONG64)mBase, (ULONG64)CopyMap2, mSize);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv140[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	mov	QWORD PTR tv136[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv134[rsp], rax
	mov	r9, QWORD PTR tv138[rsp]
	mov	r8, QWORD PTR tv136[rsp]
	mov	rdx, QWORD PTR tv134[rsp]
	mov	rcx, QWORD PTR tv140[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read
	npad	1

; 134  : 		if (*(ptr_t*)CopyMap2 == 0 && *(ptr_t*)((ptr_t)CopyMap2 + 8) == 0)

	mov	rax, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN6@analyseDec
	mov	rax, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN6@analyseDec

; 135  : 			return;

	jmp	$LN1@analyseDec
$LN6@analyseDec:

; 136  : 
; 137  : 		ptr_t maxaddr = (ptr_t)CopyMap2 + mSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR maxaddr$[rsp], rax

; 138  : 		ptr_t start = (ptr_t)CopyMap2 + (mEntryPoint - mBase);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+1824]
	sub	rax, rcx
	mov	rcx, QWORD PTR ?CopyMap2@Analysis@IronMan@@3PEAXEA ; IronMan::Analysis::CopyMap2
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR start$[rsp], rax

; 139  : 
; 140  : 		std::map<ZydisRegister, ZydisRegister> bindRegister;

	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	??0?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >
	npad	1

; 141  : 		std::vector<InstructionInfo> pendingInstruction;

	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 142  : 
; 143  : 		int index = 0;

	mov	DWORD PTR index$[rsp], 0
$LN2@analyseDec:

; 144  : 		while (true)

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@analyseDec

; 145  : 		{
; 146  : 			if (start >= (maxaddr - 16) || Utils::IsSafeReadPtr((LPVOID)start, 16))

	mov	rax, QWORD PTR maxaddr$[rsp]
	sub	rax, 16
	cmp	QWORD PTR start$[rsp], rax
	jae	SHORT $LN8@analyseDec
	mov	edx, 16
	mov	rcx, QWORD PTR start$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	$LN7@analyseDec
$LN8@analyseDec:

; 147  : 			{
; 148  : 				CONSOLE_INFO("address invalid 2");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BC@HNPCLLDA@address?5invalid?52@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T62[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv161[rsp], rax
	mov	rax, QWORD PTR tv161[rsp]
	mov	QWORD PTR tv901[rsp], rax
	mov	rcx, QWORD PTR tv901[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T62[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 149  : 				break;

	jmp	$LN3@analyseDec
$LN7@analyseDec:

; 150  : 			}
; 151  : 			if (!mCp.Disassemble(start, reinterpret_cast<const unsigned char*>(start)))

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv198[rsp], rax
	mov	r8, QWORD PTR start$[rsp]
	mov	rdx, QWORD PTR start$[rsp]
	mov	rcx, QWORD PTR tv198[rsp]
	call	?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z ; IronMan::Zydis::Disassemble
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@analyseDec

; 152  : 			{
; 153  : 				start++;

	mov	rax, QWORD PTR start$[rsp]
	inc	rax
	mov	QWORD PTR start$[rsp], rax

; 154  : 				continue;

	jmp	$LN2@analyseDec
$LN9@analyseDec:

; 155  : 			}
; 156  : 			if (start + mCp.Size() > maxaddr) // out of range

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?Size@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::Size
	cdqe
	mov	rcx, QWORD PTR start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR maxaddr$[rsp]
	jbe	SHORT $LN10@analyseDec

; 157  : 				break;

	jmp	$LN3@analyseDec
$LN10@analyseDec:

; 158  : 
; 159  : 			auto& tempInfo = InstructionInfo(*mCp.GetInstr(), mCp.Address());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?Address@Zydis@IronMan@@QEBA_KXZ	; IronMan::Zydis::Address
	mov	QWORD PTR tv232[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ ; IronMan::Zydis::GetInstr
	lea	rcx, QWORD PTR $T60[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 1472				; 000005c0H
	rep movsb
	lea	rax, QWORD PTR $T61[rsp]
	lea	rcx, QWORD PTR $T60[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 1472				; 000005c0H
	rep movsb
	mov	r8, QWORD PTR tv232[rsp]
	lea	rdx, QWORD PTR $T61[rsp]
	lea	rcx, QWORD PTR $S25$63[rsp]
	call	??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z ; IronMan::Analysis::UObjectAnalysis::InstructionInfo::InstructionInfo
	lea	rax, QWORD PTR $S25$63[rsp]
	mov	QWORD PTR tempInfo$9[rsp], rax

; 160  : 			if (mCp.GetId() == ZYDIS_MNEMONIC_MOV)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 414				; 0000019eH
	jne	$LN11@analyseDec

; 161  : 			{
; 162  : 				const auto& op1 = mCp[0];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv249[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv249[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR op1$4[rsp], rax

; 163  : 				const auto& op2 = mCp[1];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv259[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv259[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR op2$3[rsp], rax

; 164  : 
; 165  : 				//
; 166  : 				if (op1.type == ZYDIS_OPERAND_TYPE_REGISTER
; 167  : 					&& op2.type == ZYDIS_OPERAND_TYPE_MEMORY
; 168  : 					&& op2.mem.base != ZYDIS_REGISTER_RSP)

	mov	rax, QWORD PTR op1$4[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN13@analyseDec
	mov	rax, QWORD PTR op2$3[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	$LN13@analyseDec
	mov	rax, QWORD PTR op2$3[rsp]
	cmp	DWORD PTR [rax+48], 57			; 00000039H
	je	$LN13@analyseDec

; 169  : 				{
; 170  : 					if (mDecrypts.find(op2.mem.disp.value) == nullptr)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv275[rsp], rax
	mov	rax, QWORD PTR op2$3[rsp]
	mov	eax, DWORD PTR [rax+72]
	mov	DWORD PTR $T10[rsp], eax
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, QWORD PTR tv275[rsp]
	call	?find@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::find
	test	rax, rax
	jne	$LN15@analyseDec

; 171  : 					{
; 172  : 						mDecrypts.insert(op2.mem.disp.value, DecryptInfo(mBase, op1.reg.value, (int32_t)op2.mem.disp.value, index++));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv307[rsp], rax
	mov	eax, DWORD PTR index$[rsp]
	mov	DWORD PTR tv282[rsp], eax
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
	mov	eax, DWORD PTR tv282[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR op2$3[rsp]
	mov	r9d, DWORD PTR [rax+72]
	mov	rax, QWORD PTR op1$4[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR $T54[rsp]
	call	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
	mov	QWORD PTR tv158[rsp], rax
	mov	rax, QWORD PTR tv158[rsp]
	mov	QWORD PTR tv903[rsp], rax
	mov	rax, QWORD PTR tv903[rsp]
	mov	QWORD PTR tv305[rsp], rax
	mov	rax, QWORD PTR op2$3[rsp]
	mov	eax, DWORD PTR [rax+72]
	mov	DWORD PTR $T11[rsp], eax
	mov	r8, QWORD PTR tv305[rsp]
	lea	rdx, QWORD PTR $T11[rsp]
	mov	rcx, QWORD PTR tv307[rsp]
	call	?insert@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAXAEBHAEBUDecryptInfo@UObjectAnalysis@23@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::insert
	npad	1
	lea	rcx, QWORD PTR $T54[rsp]
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	npad	1

; 173  : 						bindRegister.erase(op1.reg.value);

	mov	rax, QWORD PTR op1$4[rsp]
	add	rax, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	?erase@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA_KAEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::erase
	npad	1
$LN15@analyseDec:

; 174  : 					}
; 175  : 
; 176  : 
; 177  : 					auto info = &mDecrypts[op2.mem.disp.value];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv324[rsp], rax
	mov	rax, QWORD PTR op2$3[rsp]
	mov	eax, DWORD PTR [rax+72]
	mov	DWORD PTR $T12[rsp], eax
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR tv324[rsp]
	call	??A?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAAEAUDecryptInfo@UObjectAnalysis@12@AEBH@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::operator[]
	mov	QWORD PTR info$7[rsp], rax

; 178  : 					auto regValue64 = GpRegTo64(op1.reg.value);

	mov	rax, QWORD PTR op1$4[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GpRegTo64@AnalysisBase@Analysis@IronMan@@IEAA?AW4ZydisRegister_@@W44@@Z ; IronMan::Analysis::AnalysisBase::GpRegTo64
	mov	DWORD PTR regValue64$1[rsp], eax

; 179  : 					if (regValue64 != ZYDIS_REGISTER_RCX
; 180  : 						&& regValue64 != ZYDIS_REGISTER_RDX
; 181  : 						&& regValue64 != ZYDIS_REGISTER_R8
; 182  : 						&& regValue64 != ZYDIS_REGISTER_R9
; 183  : 						&& regValue64 != ZYDIS_REGISTER_RAX)

	cmp	DWORD PTR regValue64$1[rsp], 54		; 00000036H
	je	$LN16@analyseDec
	cmp	DWORD PTR regValue64$1[rsp], 55		; 00000037H
	je	$LN16@analyseDec
	cmp	DWORD PTR regValue64$1[rsp], 61		; 0000003dH
	je	$LN16@analyseDec
	cmp	DWORD PTR regValue64$1[rsp], 62		; 0000003eH
	je	$LN16@analyseDec
	cmp	DWORD PTR regValue64$1[rsp], 53		; 00000035H
	je	$LN16@analyseDec

; 184  : 					{
; 185  : 
; 186  : 						auto result = std::find(info->SaveRegisters.begin(), info->SaveRegisters.end(), regValue64);

	mov	rax, QWORD PTR info$7[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv346[rsp], rax
	lea	rdx, QWORD PTR $T50[rsp]
	mov	rcx, QWORD PTR tv346[rsp]
	call	?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T16[rsp], rax
	mov	rax, QWORD PTR info$7[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv353[rsp], rax
	lea	rdx, QWORD PTR $T51[rsp]
	mov	rcx, QWORD PTR tv353[rsp]
	call	?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T17[rsp], rax
	lea	r9, QWORD PTR regValue64$1[rsp]
	mov	r8, QWORD PTR $T16[rsp]
	mov	rdx, QWORD PTR $T17[rsp]
	lea	rcx, QWORD PTR result$18[rsp]
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_>
	npad	1

; 187  : 						if (result == info->SaveRegisters.end())

	mov	rax, QWORD PTR info$7[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv371[rsp], rax
	lea	rdx, QWORD PTR $T35[rsp]
	mov	rcx, QWORD PTR tv371[rsp]
	call	?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR result$18[rsp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@analyseDec

; 188  : 							info->SaveRegisters.push_back(regValue64);

	mov	rax, QWORD PTR info$7[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv380[rsp], rax
	lea	rdx, QWORD PTR regValue64$1[rsp]
	mov	rcx, QWORD PTR tv380[rsp]
	call	?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::push_back
	npad	1
$LN16@analyseDec:

; 189  : 					}
; 190  : 				}

	jmp	$LN14@analyseDec
$LN13@analyseDec:

; 191  : 				else if (op1.type == ZYDIS_OPERAND_TYPE_REGISTER)

	mov	rax, QWORD PTR op1$4[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN18@analyseDec

; 192  : 				{
; 193  : 
; 194  : 					if (op2.type == ZYDIS_OPERAND_TYPE_REGISTER)// mov ax,register

	mov	rax, QWORD PTR op2$3[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN20@analyseDec

; 195  : 					{
; 196  : 						bindRegister[op1.reg.value] = op2.reg.value;

	mov	rax, QWORD PTR op2$3[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv393[rsp], eax
	mov	rax, QWORD PTR op1$4[rsp]
	add	rax, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	??A?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::map<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > >::operator[]
	mov	ecx, DWORD PTR tv393[rsp]
	mov	DWORD PTR [rax], ecx

; 197  : 
; 198  : 						auto info = mDecrypts.findValue([&op2](const DecryptInfo& value) {return value.BaseRegister == op2.reg.value; });

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv412[rsp], rax
	lea	rax, QWORD PTR $T55[rsp]
	mov	QWORD PTR $T19[rsp], rax
	mov	rdx, QWORD PTR op2$3[rsp]
	lea	rcx, QWORD PTR $T36[rsp]
	call	??0<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@QEAA@AEBUZydisDecodedOperand_@@@Z ; <lambda_564f9749a9a51d2fffa238f6767f2a0a>::<lambda_564f9749a9a51d2fffa238f6767f2a0a>
	mov	rdx, rax
	mov	rcx, QWORD PTR $T19[rsp]
	call	??$?0V<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_564f9749a9a51d2fffa238f6767f2a0a>@@@Z ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_564f9749a9a51d2fffa238f6767f2a0a>,0>
	mov	QWORD PTR tv914[rsp], rax
	mov	rax, QWORD PTR tv914[rsp]
	mov	QWORD PTR tv905[rsp], rax
	mov	rdx, QWORD PTR tv905[rsp]
	mov	rcx, QWORD PTR tv412[rsp]
	call	?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
	mov	QWORD PTR info$13[rsp], rax

; 199  : 						if (info != nullptr)

	cmp	QWORD PTR info$13[rsp], 0
	je	SHORT $LN20@analyseDec

; 200  : 						{
; 201  : 							info->Instructions.push_back(tempInfo);

	mov	rax, QWORD PTR info$13[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv417[rsp], rax
	mov	rdx, QWORD PTR tempInfo$9[rsp]
	mov	rcx, QWORD PTR tv417[rsp]
	call	?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::push_back

; 202  : 							info->EndRegister = op1.reg.value;

	mov	rax, QWORD PTR info$13[rsp]
	mov	rcx, QWORD PTR op1$4[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rax+20], ecx
$LN20@analyseDec:

; 203  : 						}
; 204  : 					}
; 205  : 					if (op2.type == ZYDIS_OPERAND_TYPE_IMMEDIATE)// mov ax,xxx

	mov	rax, QWORD PTR op2$3[rsp]
	cmp	DWORD PTR [rax+4], 4
	jne	SHORT $LN22@analyseDec

; 206  : 						pendingInstruction.push_back(tempInfo);

	mov	rdx, QWORD PTR tempInfo$9[rsp]
	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::push_back
	npad	1
$LN22@analyseDec:

; 207  : 				}

	jmp	$LN14@analyseDec
$LN18@analyseDec:

; 208  : 				else if (op1.type == ZYDIS_OPERAND_TYPE_MEMORY
; 209  : 					&& op2.type == ZYDIS_OPERAND_TYPE_REGISTER
; 210  : 					&& op1.mem.base == ZYDIS_REGISTER_RSP)

	mov	rax, QWORD PTR op1$4[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	$LN14@analyseDec
	mov	rax, QWORD PTR op2$3[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN14@analyseDec
	mov	rax, QWORD PTR op1$4[rsp]
	cmp	DWORD PTR [rax+48], 57			; 00000039H
	jne	$LN14@analyseDec

; 211  : 				{
; 212  : 					auto info = mDecrypts.findValue([&op2](const DecryptInfo& value)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv482[rsp], rax
	lea	rax, QWORD PTR $T56[rsp]
	mov	QWORD PTR $T20[rsp], rax
	mov	rdx, QWORD PTR op2$3[rsp]
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@QEAA@AEBUZydisDecodedOperand_@@@Z ; <lambda_bea1f622c03430f47fe65b0f1b1e26e0>::<lambda_bea1f622c03430f47fe65b0f1b1e26e0>
	mov	rdx, rax
	mov	rcx, QWORD PTR $T20[rsp]
	call	??$?0V<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_bea1f622c03430f47fe65b0f1b1e26e0>@@@Z ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_bea1f622c03430f47fe65b0f1b1e26e0>,0>
	mov	QWORD PTR tv915[rsp], rax
	mov	rax, QWORD PTR tv915[rsp]
	mov	QWORD PTR tv907[rsp], rax
	mov	rdx, QWORD PTR tv907[rsp]
	mov	rcx, QWORD PTR tv482[rsp]
	call	?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
	mov	QWORD PTR info$15[rsp], rax

; 213  : 						{
; 214  : 							return value.BaseRegister == op2.reg.value;
; 215  : 						});
; 216  : 
; 217  : 					if (info == nullptr)

	cmp	QWORD PTR info$15[rsp], 0
	jne	$LN24@analyseDec

; 218  : 					{
; 219  : 						auto bindInfo = mDecrypts.findValue([&bindRegister, &op2](const DecryptInfo& value) {return value.BaseRegister == bindRegister[op2.reg.value]; });

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv502[rsp], rax
	lea	rax, QWORD PTR $T57[rsp]
	mov	QWORD PTR $T21[rsp], rax
	mov	r8, QWORD PTR op2$3[rsp]
	lea	rdx, QWORD PTR bindRegister$[rsp]
	lea	rcx, QWORD PTR $T52[rsp]
	call	??0<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@QEAA@AEAV?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEBUZydisDecodedOperand_@@@Z ; <lambda_c68fd856d6bf2ebe8eef5d5d9756870f>::<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>
	mov	rdx, rax
	mov	rcx, QWORD PTR $T21[rsp]
	call	??$?0V<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>@@@Z ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_c68fd856d6bf2ebe8eef5d5d9756870f>,0>
	mov	QWORD PTR tv916[rsp], rax
	mov	rax, QWORD PTR tv916[rsp]
	mov	QWORD PTR tv909[rsp], rax
	mov	rdx, QWORD PTR tv909[rsp]
	mov	rcx, QWORD PTR tv502[rsp]
	call	?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
	mov	QWORD PTR bindInfo$14[rsp], rax

; 220  : 						if (bindRegister.find(op2.reg.value) != bindRegister.end() && bindInfo != nullptr)

	mov	rax, QWORD PTR op2$3[rsp]
	add	rax, 32					; 00000020H
	mov	r8, rax
	lea	rdx, QWORD PTR $T38[rsp]
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::find
	mov	QWORD PTR tv533[rsp], rax
	lea	rdx, QWORD PTR $T39[rsp]
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::end
	mov	QWORD PTR tv531[rsp], rax
	mov	rdx, QWORD PTR tv531[rsp]
	mov	rcx, QWORD PTR tv533[rsp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@analyseDec
	cmp	QWORD PTR bindInfo$14[rsp], 0
	je	SHORT $LN26@analyseDec

; 221  : 						{
; 222  : 							bindInfo->EndRegister = ZYDIS_REGISTER_RSP;

	mov	rax, QWORD PTR bindInfo$14[rsp]
	mov	DWORD PTR [rax+20], 57			; 00000039H

; 223  : 							bindInfo->LastValue = op1.mem.disp.value;

	mov	rax, QWORD PTR bindInfo$14[rsp]
	mov	rcx, QWORD PTR op1$4[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	mov	DWORD PTR [rax+24], ecx
$LN26@analyseDec:

; 224  : 						}
; 225  : 					}

	jmp	SHORT $LN14@analyseDec
$LN24@analyseDec:

; 226  : 					else
; 227  : 					{
; 228  : 						info->EndRegister = ZYDIS_REGISTER_RSP;

	mov	rax, QWORD PTR info$15[rsp]
	mov	DWORD PTR [rax+20], 57			; 00000039H

; 229  : 						info->LastValue = op1.mem.disp.value;

	mov	rax, QWORD PTR info$15[rsp]
	mov	rcx, QWORD PTR op1$4[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	mov	DWORD PTR [rax+24], ecx
$LN14@analyseDec:

; 230  : 					}
; 231  : 				}
; 232  : 			}

	jmp	$LN12@analyseDec
$LN11@analyseDec:

; 233  : 			//
; 234  : 			else if (mCp.GetId() == ZYDIS_MNEMONIC_XOR
; 235  : 				|| mCp.GetId() == ZYDIS_MNEMONIC_ROL
; 236  : 				|| mCp.GetId() == ZYDIS_MNEMONIC_ROR
; 237  : 				|| mCp.GetId() == ZYDIS_MNEMONIC_SHL
; 238  : 				|| mCp.GetId() == ZYDIS_MNEMONIC_SHR)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 1578				; 0000062aH
	je	SHORT $LN29@analyseDec
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 662				; 00000296H
	je	SHORT $LN29@analyseDec
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 663				; 00000297H
	je	SHORT $LN29@analyseDec
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 709				; 000002c5H
	je	SHORT $LN29@analyseDec
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 712				; 000002c8H
	jne	$LN27@analyseDec
$LN29@analyseDec:

; 239  : 			{
; 240  : 				auto regValue = mCp[0].reg.value;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv596[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv596[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR regValue$6[rsp], eax

; 241  : 				auto info = mDecrypts.findValue([&regValue](const DecryptInfo& value) {return value.BaseRegister == regValue; });

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv617[rsp], rax
	lea	rax, QWORD PTR $T58[rsp]
	mov	QWORD PTR $T22[rsp], rax
	lea	rdx, QWORD PTR regValue$6[rsp]
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0<lambda_614ae9436da2bf9123d47a10e682c1dd>@@QEAA@AEAW4ZydisRegister_@@@Z ; <lambda_614ae9436da2bf9123d47a10e682c1dd>::<lambda_614ae9436da2bf9123d47a10e682c1dd>
	mov	rdx, rax
	mov	rcx, QWORD PTR $T22[rsp]
	call	??$?0V<lambda_614ae9436da2bf9123d47a10e682c1dd>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_614ae9436da2bf9123d47a10e682c1dd>@@@Z ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_614ae9436da2bf9123d47a10e682c1dd>,0>
	mov	QWORD PTR tv917[rsp], rax
	mov	rax, QWORD PTR tv917[rsp]
	mov	QWORD PTR tv911[rsp], rax
	mov	rdx, QWORD PTR tv911[rsp]
	mov	rcx, QWORD PTR tv617[rsp]
	call	?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
	mov	QWORD PTR info$5[rsp], rax

; 242  : 				//DecryptInfo* info;
; 243  : 				//if (info == nullptr)
; 244  : 				//{
; 245  : 				if (bindRegister.find(regValue) != bindRegister.end())

	lea	r8, QWORD PTR regValue$6[rsp]
	lea	rdx, QWORD PTR $T41[rsp]
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	?find@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@AEBW4ZydisRegister_@@@Z ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::find
	mov	QWORD PTR tv646[rsp], rax
	lea	rdx, QWORD PTR $T42[rsp]
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	?end@?$_Tree@V?$_Tmap_traits@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum ZydisRegister_,enum ZydisRegister_,std::less<enum ZydisRegister_>,std::allocator<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> >,0> >::end
	mov	QWORD PTR tv644[rsp], rax
	mov	rdx, QWORD PTR tv644[rsp]
	mov	rcx, QWORD PTR tv646[rsp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum ZydisRegister_ const ,enum ZydisRegister_> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN30@analyseDec

; 246  : 					info = mDecrypts.findValue([&bindRegister, &regValue](const DecryptInfo& value) {return value.BaseRegister == bindRegister[regValue]; });

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR tv668[rsp], rax
	lea	rax, QWORD PTR $T59[rsp]
	mov	QWORD PTR $T23[rsp], rax
	lea	r8, QWORD PTR regValue$6[rsp]
	lea	rdx, QWORD PTR bindRegister$[rsp]
	lea	rcx, QWORD PTR $T53[rsp]
	call	??0<lambda_35d54d29033b35d747bcda686a4dea49>@@QEAA@AEAV?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@AEAW4ZydisRegister_@@@Z ; <lambda_35d54d29033b35d747bcda686a4dea49>::<lambda_35d54d29033b35d747bcda686a4dea49>
	mov	rdx, rax
	mov	rcx, QWORD PTR $T23[rsp]
	call	??$?0V<lambda_35d54d29033b35d747bcda686a4dea49>@@$0A@@?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@$$QEAV<lambda_35d54d29033b35d747bcda686a4dea49>@@@Z ; std::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)>::function<bool __cdecl(IronMan::Analysis::UObjectAnalysis::DecryptInfo const &)><<lambda_35d54d29033b35d747bcda686a4dea49>,0>
	mov	QWORD PTR tv918[rsp], rax
	mov	rax, QWORD PTR tv918[rsp]
	mov	QWORD PTR tv913[rsp], rax
	mov	rdx, QWORD PTR tv913[rsp]
	mov	rcx, QWORD PTR tv668[rsp]
	call	?findValue@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAAPEAUDecryptInfo@UObjectAnalysis@23@V?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@@Z ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::findValue
	mov	QWORD PTR info$5[rsp], rax
$LN30@analyseDec:

; 247  : 				//}
; 248  : 
; 249  : 				if (info != nullptr)

	cmp	QWORD PTR info$5[rsp], 0
	je	$LN31@analyseDec

; 250  : 				{
; 251  : 					auto regValue64 = GpRegTo64(regValue);

	mov	edx, DWORD PTR regValue$6[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GpRegTo64@AnalysisBase@Analysis@IronMan@@IEAA?AW4ZydisRegister_@@W44@@Z ; IronMan::Analysis::AnalysisBase::GpRegTo64
	mov	DWORD PTR regValue64$2[rsp], eax

; 252  : 					if (regValue64 != ZYDIS_REGISTER_RCX
; 253  : 						&& regValue64 != ZYDIS_REGISTER_RDX
; 254  : 						&& regValue64 != ZYDIS_REGISTER_R8
; 255  : 						&& regValue64 != ZYDIS_REGISTER_R9
; 256  : 						&& regValue64 != ZYDIS_REGISTER_RAX)

	cmp	DWORD PTR regValue64$2[rsp], 54		; 00000036H
	je	$LN32@analyseDec
	cmp	DWORD PTR regValue64$2[rsp], 55		; 00000037H
	je	$LN32@analyseDec
	cmp	DWORD PTR regValue64$2[rsp], 61		; 0000003dH
	je	$LN32@analyseDec
	cmp	DWORD PTR regValue64$2[rsp], 62		; 0000003eH
	je	$LN32@analyseDec
	cmp	DWORD PTR regValue64$2[rsp], 53		; 00000035H
	je	$LN32@analyseDec

; 257  : 					{
; 258  : 
; 259  : 						auto result = std::find(info->SaveRegisters.begin(), info->SaveRegisters.end(), regValue64);

	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv688[rsp], rax
	lea	rdx, QWORD PTR $T43[rsp]
	mov	rcx, QWORD PTR tv688[rsp]
	call	?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T24[rsp], rax
	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv695[rsp], rax
	lea	rdx, QWORD PTR $T44[rsp]
	mov	rcx, QWORD PTR tv695[rsp]
	call	?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T25[rsp], rax
	lea	r9, QWORD PTR regValue64$2[rsp]
	mov	r8, QWORD PTR $T24[rsp]
	mov	rdx, QWORD PTR $T25[rsp]
	lea	rcx, QWORD PTR result$26[rsp]
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@W4ZydisRegister_@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@0@V10@V10@AEBW4ZydisRegister_@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >,enum ZydisRegister_>
	npad	1

; 260  : 						if (result == info->SaveRegisters.end())

	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv713[rsp], rax
	lea	rdx, QWORD PTR $T45[rsp]
	mov	rcx, QWORD PTR tv713[rsp]
	call	?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR result$26[rsp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN32@analyseDec

; 261  : 							info->SaveRegisters.push_back(regValue64);

	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv722[rsp], rax
	lea	rdx, QWORD PTR regValue64$2[rsp]
	mov	rcx, QWORD PTR tv722[rsp]
	call	?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::push_back
	npad	1
$LN32@analyseDec:

; 262  : 					}
; 263  : 
; 264  : 					if (!pendingInstruction.empty())

	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::empty
	movzx	eax, al
	test	eax, eax
	jne	$LN34@analyseDec

; 265  : 					{
; 266  : 						if (mCp[1].type == ZYDIS_OPERAND_TYPE_REGISTER && mCp[1].reg.value == pendingInstruction.back().Instruct.operands[0].reg.value)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv736[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv736[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN34@analyseDec
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv748[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv748[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR tv745[rsp], rax
	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back
	mov	ecx, 104				; 00000068H
	imul	rcx, rcx, 0
	mov	eax, DWORD PTR [rax+rcx+64]
	mov	rcx, QWORD PTR tv745[rsp]
	cmp	DWORD PTR [rcx+32], eax
	jne	$LN34@analyseDec

; 267  : 						{
; 268  : 							info->Instructions.insert(info->Instructions.end(), pendingInstruction.begin(), pendingInstruction.end());

	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv791[rsp], rax
	lea	rdx, QWORD PTR $T46[rsp]
	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T27[rsp], rax
	mov	rax, QWORD PTR $T27[rsp]
	mov	QWORD PTR $T31[rsp], rax
	lea	rdx, QWORD PTR $T47[rsp]
	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T28[rsp], rax
	mov	rax, QWORD PTR $T28[rsp]
	mov	QWORD PTR $T32[rsp], rax
	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv779[rsp], rax
	lea	rdx, QWORD PTR $T48[rsp]
	mov	rcx, QWORD PTR tv779[rsp]
	call	?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T29[rsp], rax
	mov	rax, QWORD PTR $T29[rsp]
	mov	QWORD PTR $T30[rsp], rax
	mov	rax, QWORD PTR $T30[rsp]
	mov	QWORD PTR $T33[rsp], rax
	mov	rax, QWORD PTR $T31[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR $T32[rsp]
	mov	r8, QWORD PTR $T33[rsp]
	lea	rdx, QWORD PTR $T49[rsp]
	mov	rcx, QWORD PTR tv791[rsp]
	call	??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@$0A@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@1@V21@1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >,0>
	npad	1

; 269  : 							pendingInstruction.clear();

	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::clear
	npad	1
$LN34@analyseDec:

; 270  : 						}
; 271  : 					}
; 272  : 					const auto& op1 = mCp[0];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv833[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv833[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR op1$34[rsp], rax

; 273  : 					const auto& op2 = mCp[1];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv843[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv843[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR op2$8[rsp], rax

; 274  : 					if (op1.type == ZYDIS_OPERAND_TYPE_REGISTER
; 275  : 						&& op2.type == ZYDIS_OPERAND_TYPE_MEMORY
; 276  : 						&& op2.mem.base != ZYDIS_REGISTER_RSP
; 277  : 						&& op2.mem.disp.value == info->Offset)

	mov	rax, QWORD PTR op1$34[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	SHORT $LN36@analyseDec
	mov	rax, QWORD PTR op2$8[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	SHORT $LN36@analyseDec
	mov	rax, QWORD PTR op2$8[rsp]
	cmp	DWORD PTR [rax+48], 57			; 00000039H
	je	SHORT $LN36@analyseDec
	mov	rax, QWORD PTR info$5[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR op2$8[rsp]
	cmp	QWORD PTR [rcx+72], rax
	jne	SHORT $LN36@analyseDec

; 278  : 					{
; 279  : 						tempInfo.Offset = op2.mem.disp.value;

	mov	rax, QWORD PTR tempInfo$9[rsp]
	mov	rcx, QWORD PTR op2$8[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+1480], rcx
$LN36@analyseDec:

; 280  : 					}
; 281  : 					info->Instructions.push_back(tempInfo);

	mov	rax, QWORD PTR info$5[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv865[rsp], rax
	mov	rdx, QWORD PTR tempInfo$9[rsp]
	mov	rcx, QWORD PTR tv865[rsp]
	call	?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::push_back
	npad	1
$LN31@analyseDec:

; 282  : 				}
; 283  : 			}

	jmp	SHORT $LN12@analyseDec
$LN27@analyseDec:

; 284  : 			else if (mCp.IsJump())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?IsJump@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::IsJump
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN37@analyseDec

; 285  : 				break;

	jmp	SHORT $LN3@analyseDec
	jmp	SHORT $LN12@analyseDec
$LN37@analyseDec:

; 286  : 			else if (mCp.IsCondJump() && !mDecrypts.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?IsCondJump@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::IsCondJump
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@analyseDec
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	rcx, rax
	call	?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@analyseDec

; 287  : 				break;

	jmp	SHORT $LN3@analyseDec
$LN12@analyseDec:

; 288  : 
; 289  : 			start += mCp.Size();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?Size@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::Size
	cdqe
	mov	rcx, QWORD PTR start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR start$[rsp], rax

; 290  : 		}

	jmp	$LN2@analyseDec
$LN3@analyseDec:

; 291  : 	}

	lea	rcx, QWORD PTR pendingInstruction$[rsp]
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	lea	rcx, QWORD PTR bindRegister$[rsp]
	call	??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
	npad	1
$LN1@analyseDec:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 5864				; 000016e8H
	pop	rdi
	pop	rsi
	ret	0
?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ ENDP ; IronMan::Analysis::UObjectAnalysis::analyseDecrypttions
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR bindRegister$[rbp]
	call	??1?$map@W4ZydisRegister_@@W41@U?$less@W4ZydisRegister_@@@std@@V?$allocator@U?$pair@$$CBW4ZydisRegister_@@W41@@std@@@3@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR pendingInstruction$[rbp]
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T62[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T54[rbp]
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T19[rbp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T20[rbp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T21[rbp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T22[rbp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
regValue64$1 = 48
regValue64$2 = 52
op2$3 = 56
op1$4 = 64
info$5 = 72
regValue$6 = 80
start$ = 88
index$ = 96
info$7 = 104
op2$8 = 112
tempInfo$9 = 120
bindRegister$ = 128
$T10 = 144
tv282 = 148
$T11 = 152
$T12 = 156
tv393 = 160
info$13 = 168
bindInfo$14 = 176
info$15 = 184
maxaddr$ = 192
pendingInstruction$ = 200
tv134 = 224
tv140 = 232
tv161 = 240
tv901 = 248
tv198 = 256
tv232 = 264
tv249 = 272
tv259 = 280
tv275 = 288
tv158 = 296
tv903 = 304
tv305 = 312
tv307 = 320
tv324 = 328
tv346 = 336
tv353 = 344
$T16 = 352
$T17 = 360
tv371 = 368
result$18 = 376
tv380 = 384
$T19 = 392
tv914 = 400
tv905 = 408
tv412 = 416
tv417 = 424
$T20 = 432
tv915 = 440
tv907 = 448
tv482 = 456
$T21 = 464
tv916 = 472
tv909 = 480
tv502 = 488
tv531 = 496
tv533 = 504
tv596 = 512
$T22 = 520
tv917 = 528
tv911 = 536
tv617 = 544
tv644 = 552
tv646 = 560
$T23 = 568
tv918 = 576
tv913 = 584
tv668 = 592
tv688 = 600
tv695 = 608
$T24 = 616
$T25 = 624
tv713 = 632
result$26 = 640
tv722 = 648
tv736 = 656
tv748 = 664
tv745 = 672
$T27 = 680
$T28 = 688
tv779 = 696
$T29 = 704
$T30 = 712
$T31 = 720
$T32 = 728
$T33 = 736
tv791 = 744
tv833 = 752
tv843 = 760
op1$34 = 768
tv865 = 776
tv138 = 784
tv136 = 792
$T35 = 800
$T36 = 808
$T37 = 816
$T38 = 824
$T39 = 832
$T40 = 840
$T41 = 848
$T42 = 856
$T43 = 864
$T44 = 872
$T45 = 880
$T46 = 888
$T47 = 896
$T48 = 904
$T49 = 912
$T50 = 920
$T51 = 928
$T52 = 936
$T53 = 952
$T54 = 968
$T55 = 1048
$T56 = 1112
$T57 = 1176
$T58 = 1240
$T59 = 1304
$T60 = 1368
$T61 = 2848
$T62 = 4320
$S25$63 = 4352
__$ArrayPad$ = 5840
this$ = 5888
?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T23[rbp]
	call	??1?$function@$$A6A_NAEBUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0??analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::analyseDecrypttions'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.h
;	COMDAT ?GetEntryPoint@UObjectAnalysis@Analysis@IronMan@@UEBA?B_KXZ
_TEXT	SEGMENT
this$ = 8
?GetEntryPoint@UObjectAnalysis@Analysis@IronMan@@UEBA?B_KXZ PROC ; IronMan::Analysis::UObjectAnalysis::GetEntryPoint, COMDAT

; 51   : 		const ptr_t GetEntryPoint() const override { return mEntryPoint; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+1824]
	ret	0
?GetEntryPoint@UObjectAnalysis@Analysis@IronMan@@UEBA?B_KXZ ENDP ; IronMan::Analysis::UObjectAnalysis::GetEntryPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
a$1 = 32
$T2 = 40
i$3 = 44
tv322 = 48
i$4 = 52
decrypt$5 = 56
i$6 = 64
op1$7 = 72
tv649 = 80
inst$8 = 88
tv160 = 96
tv465 = 100
<begin>$L0$9 = 104
op2$10 = 112
op$11 = 120
<range>$L0$12 = 128
tv136 = 136
tv452 = 144
stack_size$13 = 152
tv622 = 160
<end>$L0$14 = 168
tv141 = 176
tv158 = 184
tv174 = 192
tv176 = 200
tv177 = 208
tv202 = 216
tv216 = 224
tv214 = 232
tv218 = 240
tv229 = 248
tv227 = 256
tv231 = 264
tv259 = 272
tv257 = 280
tv261 = 288
tv262 = 296
tv275 = 304
tv344 = 312
tv342 = 320
tv346 = 328
tv367 = 336
tv365 = 344
tv369 = 352
tv390 = 360
tv388 = 368
tv392 = 376
tv413 = 384
tv411 = 392
tv415 = 400
tv436 = 408
tv434 = 416
tv438 = 424
tv463 = 432
tv467 = 440
tv532 = 448
tv530 = 456
tv534 = 464
tv535 = 472
tv567 = 480
tv574 = 488
tv572 = 496
tv608 = 504
tv617 = 512
tv619 = 520
tv628 = 528
tv639 = 536
sa$15 = 544
$T16 = 560
$T17 = 576
$T18 = 592
$T19 = 608
$T20 = 624
$T21 = 640
$T22 = 656
$T23 = 672
$T24 = 688
$T25 = 704
$T26 = 720
BuildCp$27 = 736
lastInstruct$28 = 2480
__$ArrayPad$ = 3968
this$ = 4016
callback$ = 4024
?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z PROC ; IronMan::Analysis::UObjectAnalysis::Build

; 31   : 	{

$LN35:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 3992				; 00000f98H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 32   : 		for (const auto& decrypt : mDecrypts)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	QWORD PTR <range>$L0$12[rsp], rax
	lea	rdx, QWORD PTR <begin>$L0$9[rsp]
	mov	rcx, QWORD PTR <range>$L0$12[rsp]
	call	?begin@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::begin
	lea	rdx, QWORD PTR <end>$L0$14[rsp]
	mov	rcx, QWORD PTR <range>$L0$12[rsp]
	call	?end@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEAA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::end
	npad	1
	jmp	SHORT $LN4@Build
$LN2@Build:
	lea	rcx, QWORD PTR <begin>$L0$9[rsp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator++
	npad	1
$LN4@Build:
	lea	rdx, QWORD PTR <end>$L0$14[rsp]
	lea	rcx, QWORD PTR <begin>$L0$9[rsp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@Build
	lea	rcx, QWORD PTR <begin>$L0$9[rsp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo> > > >::operator*
	mov	QWORD PTR decrypt$5[rsp], rax

; 33   : 		{
; 34   : 			if (callback != nullptr)

	xor	edx, edx
	mov	rcx, QWORD PTR callback$[rsp]
	call	??$?9$$A6AXPEAX@Z@std@@YA_NAEBV?$function@$$A6AXPEAX@Z@0@$$T@Z ; std::operator!=<void __cdecl(void *)>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@Build

; 35   : 				callback((void*)(&decrypt.second));

	mov	rax, QWORD PTR decrypt$5[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR callback$[rsp]
	call	??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z	; std::_Func_class<void,void *>::operator()
	npad	1
$LN16@Build:

; 36   : 
; 37   : 
; 38   : 			auto a = AsmFactory::GetAssembler();

	lea	rcx, QWORD PTR a$1[rsp]
	call	?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ ; IronMan::AsmFactory::GetAssembler
	npad	1

; 39   : 
; 40   : 			a->GenPrologue();

	lea	rcx, QWORD PTR a$1[rsp]
	call	??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator->
	mov	QWORD PTR tv136[rsp], rax
	mov	rax, QWORD PTR tv136[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv141[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv136[rsp]
	call	QWORD PTR tv141[rsp]

; 41   : 
; 42   : 			AsmStackAllocator sa(a->assembler(), 0x30 + (int32_t)decrypt.second.SaveRegisters.size() * 8);

	mov	rax, QWORD PTR decrypt$5[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::size
	lea	eax, DWORD PTR [rax*8+48]
	mov	DWORD PTR tv160[rsp], eax
	lea	rcx, QWORD PTR a$1[rsp]
	call	??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator->
	mov	rcx, rax
	call	?assembler@IAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::assembler
	mov	QWORD PTR tv158[rsp], rax
	mov	r8d, DWORD PTR tv160[rsp]
	mov	rdx, QWORD PTR tv158[rsp]
	lea	rcx, QWORD PTR sa$15[rsp]
	call	??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z ; IronMan::AsmStackAllocator::AsmStackAllocator

; 43   : 
; 44   : 			size_t stack_size = Align(sa.getTotalSize(), 0x10);

	lea	rcx, QWORD PTR sa$15[rsp]
	call	?getTotalSize@AsmStackAllocator@IronMan@@QEBA_JXZ ; IronMan::AsmStackAllocator::getTotalSize
	mov	edx, 16
	mov	rcx, rax
	call	?Align@@YA_K_K0@Z			; Align
	mov	QWORD PTR stack_size$13[rsp], rax

; 45   : 			(*a)->sub(asmjit::host::rsp, stack_size);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv176[rsp], rax
	mov	rax, QWORD PTR ?rsp@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv174[rsp], rax
	mov	r8, QWORD PTR stack_size$13[rsp]
	mov	rdx, QWORD PTR tv174[rsp]
	mov	rcx, QWORD PTR tv176[rsp]
	call	?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z ; asmjit::X86Assembler::sub
	npad	1

; 46   : 
; 47   : 			// Save registers
; 48   : 			for (int i = 0; i < decrypt.second.SaveRegisters.size(); i++)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN7@Build
$LN5@Build:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN7@Build:
	movsxd	rax, DWORD PTR i$3[rsp]
	mov	QWORD PTR tv177[rsp], rax
	mov	rcx, QWORD PTR decrypt$5[rsp]
	add	rcx, 64					; 00000040H
	call	?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::size
	mov	rcx, QWORD PTR tv177[rsp]
	cmp	rcx, rax
	jae	$LN6@Build

; 49   : 				(*a)->mov(asmjit::host::qword_ptr(asmjit::host::rsp, 0x28 + i * 8), ToGpReg(decrypt.second.SaveRegisters[i]));

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv218[rsp], rax
	mov	rax, QWORD PTR decrypt$5[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR tv202[rsp], rax
	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv202[rsp]
	call	??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator[]
	mov	r8d, DWORD PTR [rax]
	lea	rdx, QWORD PTR $T16[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv216[rsp], rax
	mov	eax, DWORD PTR i$3[rsp]
	lea	eax, DWORD PTR [rax*8+40]
	mov	r8d, eax
	mov	rdx, QWORD PTR ?rsp@x86@asmjit@@3AEBUX86GpReg@2@EB
	lea	rcx, QWORD PTR $T17[rsp]
	call	?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z ; asmjit::x86::qword_ptr
	mov	QWORD PTR tv214[rsp], rax
	mov	r8, QWORD PTR tv216[rsp]
	mov	rdx, QWORD PTR tv214[rsp]
	mov	rcx, QWORD PTR tv218[rsp]
	call	?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z ; asmjit::X86Assembler::mov
	npad	1
	jmp	$LN5@Build
$LN6@Build:

; 50   : 			(*a)->mov(asmjit::host::r15, asmjit::host::rcx);//mov r15,rcx

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv231[rsp], rax
	mov	rax, QWORD PTR ?rcx@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv229[rsp], rax
	mov	rax, QWORD PTR ?r15@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv227[rsp], rax
	mov	r8, QWORD PTR tv229[rsp]
	mov	rdx, QWORD PTR tv227[rsp]
	mov	rcx, QWORD PTR tv231[rsp]
	call	?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::mov
	npad	1

; 51   : 			(*a)->mov(ToGpReg(GpRegTo64(decrypt.second.BaseRegister)), asmjit::host::rcx);//mov rdx,rcx

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv261[rsp], rax
	mov	rax, QWORD PTR ?rcx@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv259[rsp], rax
	mov	rax, QWORD PTR decrypt$5[rsp]
	mov	edx, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GpRegTo64@AnalysisBase@Analysis@IronMan@@IEAA?AW4ZydisRegister_@@W44@@Z ; IronMan::Analysis::AnalysisBase::GpRegTo64
	mov	r8d, eax
	lea	rdx, QWORD PTR $T18[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv257[rsp], rax
	mov	r8, QWORD PTR tv259[rsp]
	mov	rdx, QWORD PTR tv257[rsp]
	mov	rcx, QWORD PTR tv261[rsp]
	call	?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::mov
	npad	1

; 52   : 
; 53   : 
; 54   : 			for (int i = 0; i < decrypt.second.Instructions.size(); i++)

	mov	DWORD PTR i$6[rsp], 0
	jmp	SHORT $LN10@Build
$LN8@Build:
	mov	eax, DWORD PTR i$6[rsp]
	inc	eax
	mov	DWORD PTR i$6[rsp], eax
$LN10@Build:
	movsxd	rax, DWORD PTR i$6[rsp]
	mov	QWORD PTR tv262[rsp], rax
	mov	rcx, QWORD PTR decrypt$5[rsp]
	add	rcx, 40					; 00000028H
	call	?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::size
	mov	rcx, QWORD PTR tv262[rsp]
	cmp	rcx, rax
	jae	$LN9@Build

; 55   : 			{
; 56   : 				const auto& inst = decrypt.second.Instructions[i];

	mov	rax, QWORD PTR decrypt$5[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv275[rsp], rax
	movsxd	rax, DWORD PTR i$6[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv275[rsp]
	call	??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator[]
	mov	QWORD PTR inst$8[rsp], rax

; 57   : 				Zydis BuildCp;

	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	??0Zydis@IronMan@@QEAA@XZ		; IronMan::Zydis::Zydis
	npad	1

; 58   : 				if (!BuildCp.Disassemble(inst.Address, reinterpret_cast<const unsigned char*>(inst.Address)))

	mov	rax, QWORD PTR inst$8[rsp]
	mov	r8, QWORD PTR [rax+1472]
	mov	rax, QWORD PTR inst$8[rsp]
	mov	rdx, QWORD PTR [rax+1472]
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z ; IronMan::Zydis::Disassemble
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@Build

; 59   : 					continue;

	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	??1Zydis@IronMan@@QEAA@XZ		; IronMan::Zydis::~Zydis
	npad	1
	jmp	$LN8@Build
$LN17@Build:

; 60   : 				const auto& op1 = BuildCp[0];

	xor	edx, edx
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR op1$7[rsp], rax

; 61   : 				const auto& op2 = BuildCp[1];

	mov	edx, 1
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
	mov	QWORD PTR op2$10[rsp], rax

; 62   : 				if (op1.type == ZYDIS_OPERAND_TYPE_REGISTER
; 63   : 					&& op2.type == ZYDIS_OPERAND_TYPE_MEMORY
; 64   : 					&& op2.mem.base != ZYDIS_REGISTER_RSP
; 65   : 					&& op2.mem.disp.value == inst.Offset
; 66   : 					&& (BuildCp.GetId() == ZYDIS_MNEMONIC_XOR

	mov	rax, QWORD PTR op1$7[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN18@Build
	mov	rax, QWORD PTR op2$10[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	$LN18@Build
	mov	rax, QWORD PTR op2$10[rsp]
	cmp	DWORD PTR [rax+48], 57			; 00000039H
	je	$LN18@Build
	mov	rax, QWORD PTR op2$10[rsp]
	mov	rcx, QWORD PTR inst$8[rsp]
	mov	rcx, QWORD PTR [rcx+1480]
	cmp	QWORD PTR [rax+72], rcx
	jne	$LN18@Build
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 1578				; 0000062aH
	je	SHORT $LN20@Build
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 662				; 00000296H
	je	SHORT $LN20@Build
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 663				; 00000297H
	je	SHORT $LN20@Build
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 709				; 000002c5H
	je	SHORT $LN20@Build
	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	cmp	eax, 712				; 000002c8H
	jne	$LN18@Build
$LN20@Build:

; 67   : 						|| BuildCp.GetId() == ZYDIS_MNEMONIC_ROL
; 68   : 						|| BuildCp.GetId() == ZYDIS_MNEMONIC_ROR
; 69   : 						|| BuildCp.GetId() == ZYDIS_MNEMONIC_SHL
; 70   : 						|| BuildCp.GetId() == ZYDIS_MNEMONIC_SHR))
; 71   : 				{
; 72   : 					switch (BuildCp.GetId())

	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
	mov	DWORD PTR tv322[rsp], eax
	cmp	DWORD PTR tv322[rsp], 662		; 00000296H
	je	$LN22@Build
	cmp	DWORD PTR tv322[rsp], 663		; 00000297H
	je	$LN23@Build
	cmp	DWORD PTR tv322[rsp], 709		; 000002c5H
	je	$LN24@Build
	cmp	DWORD PTR tv322[rsp], 712		; 000002c8H
	je	$LN25@Build
	cmp	DWORD PTR tv322[rsp], 1578		; 0000062aH
	je	SHORT $LN21@Build
	jmp	$LN11@Build
$LN21@Build:

; 73   : 					{
; 74   : 					case ZYDIS_MNEMONIC_XOR:
; 75   : 						(*a)->xor_(ToGpReg(op1.reg.value), asmjit::host::r15);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv346[rsp], rax
	mov	rax, QWORD PTR ?r15@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv344[rsp], rax
	mov	rax, QWORD PTR op1$7[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, QWORD PTR $T19[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv342[rsp], rax
	mov	r8, QWORD PTR tv344[rsp]
	mov	rdx, QWORD PTR tv342[rsp]
	mov	rcx, QWORD PTR tv346[rsp]
	call	?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::xor_
	npad	1

; 76   : 						break;

	jmp	$LN11@Build
$LN22@Build:

; 77   : 					case ZYDIS_MNEMONIC_ROL:
; 78   : 						(*a)->rol(ToGpReg(op1.reg.value), asmjit::host::r15);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv369[rsp], rax
	mov	rax, QWORD PTR ?r15@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv367[rsp], rax
	mov	rax, QWORD PTR op1$7[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, QWORD PTR $T20[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv365[rsp], rax
	mov	r8, QWORD PTR tv367[rsp]
	mov	rdx, QWORD PTR tv365[rsp]
	mov	rcx, QWORD PTR tv369[rsp]
	call	?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::rol
	npad	1

; 79   : 						break;

	jmp	$LN11@Build
$LN23@Build:

; 80   : 					case ZYDIS_MNEMONIC_ROR:
; 81   : 						(*a)->ror(ToGpReg(op1.reg.value), asmjit::host::r15);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv392[rsp], rax
	mov	rax, QWORD PTR ?r15@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv390[rsp], rax
	mov	rax, QWORD PTR op1$7[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, QWORD PTR $T21[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv388[rsp], rax
	mov	r8, QWORD PTR tv390[rsp]
	mov	rdx, QWORD PTR tv388[rsp]
	mov	rcx, QWORD PTR tv392[rsp]
	call	?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::ror
	npad	1

; 82   : 						break;

	jmp	$LN11@Build
$LN24@Build:

; 83   : 					case ZYDIS_MNEMONIC_SHL:
; 84   : 						(*a)->shl(ToGpReg(op1.reg.value), asmjit::host::r15);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv415[rsp], rax
	mov	rax, QWORD PTR ?r15@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv413[rsp], rax
	mov	rax, QWORD PTR op1$7[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, QWORD PTR $T22[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv411[rsp], rax
	mov	r8, QWORD PTR tv413[rsp]
	mov	rdx, QWORD PTR tv411[rsp]
	mov	rcx, QWORD PTR tv415[rsp]
	call	?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::shl
	npad	1

; 85   : 						break;

	jmp	SHORT $LN11@Build
$LN25@Build:

; 86   : 					case ZYDIS_MNEMONIC_SHR:
; 87   : 						(*a)->shr(ToGpReg(op1.reg.value), asmjit::host::r15);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv438[rsp], rax
	mov	rax, QWORD PTR ?r15@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv436[rsp], rax
	mov	rax, QWORD PTR op1$7[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, QWORD PTR $T23[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv434[rsp], rax
	mov	r8, QWORD PTR tv436[rsp]
	mov	rdx, QWORD PTR tv434[rsp]
	mov	rcx, QWORD PTR tv438[rsp]
	call	?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::shr
	npad	1
$LN11@Build:

; 88   : 						break;
; 89   : 					default:
; 90   : 						break;
; 91   : 					}
; 92   : 				}

	jmp	SHORT $LN19@Build
$LN18@Build:

; 93   : 				else {
; 94   : 					(*a)->embed(reinterpret_cast<const unsigned char*>(inst.Address), inst.Instruct.length);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv452[rsp], rax
	mov	rax, QWORD PTR tv452[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv467[rsp], rax
	mov	rax, QWORD PTR inst$8[rsp]
	movzx	eax, BYTE PTR [rax+8]
	mov	DWORD PTR tv465[rsp], eax
	mov	rax, QWORD PTR inst$8[rsp]
	mov	rax, QWORD PTR [rax+1472]
	mov	QWORD PTR tv463[rsp], rax
	mov	r8d, DWORD PTR tv465[rsp]
	mov	rdx, QWORD PTR tv463[rsp]
	mov	rcx, QWORD PTR tv452[rsp]
	call	QWORD PTR tv467[rsp]
	npad	1
$LN19@Build:

; 95   : 				}
; 96   : 			}

	lea	rcx, QWORD PTR BuildCp$27[rsp]
	call	??1Zydis@IronMan@@QEAA@XZ		; IronMan::Zydis::~Zydis
	npad	1
	jmp	$LN8@Build
$LN9@Build:

; 97   : 
; 98   : 			// Last instruction result
; 99   : 			auto lastInstruct = decrypt.second.Instructions.back();

	mov	rax, QWORD PTR decrypt$5[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back
	lea	rcx, QWORD PTR lastInstruct$28[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 1488				; 000005d0H
	rep movsb

; 100  : 			if (lastInstruct.Instruct.operand_count > 0  /*lastInstruct.Instruct.mnemonic == ZYDIS_MNEMONIC_MOV*/)

	movzx	eax, BYTE PTR lastInstruct$28[rsp+24]
	test	eax, eax
	jle	$LN27@Build

; 101  : 			{
; 102  : 				const auto& op = lastInstruct.Instruct.operands[0];

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	lea	rax, QWORD PTR lastInstruct$28[rsp+rax+32]
	mov	QWORD PTR op$11[rsp], rax

; 103  : 				if (op.type == ZYDIS_OPERAND_TYPE_REGISTER
; 104  : 					&& inRange(op.reg.value, ZYDIS_REGISTER_AL, ZYDIS_REGISTER_R15)
; 105  : 					&& GpRegTo64(op.reg.value) != ZYDIS_REGISTER_RAX)

	mov	rax, QWORD PTR op$11[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	$LN27@Build
	mov	rax, QWORD PTR op$11[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	r9d, 68					; 00000044H
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z ; IronMan::Analysis::AnalysisBase::inRange
	movzx	eax, al
	test	eax, eax
	je	$LN27@Build
	mov	rax, QWORD PTR op$11[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GpRegTo64@AnalysisBase@Analysis@IronMan@@IEAA?AW4ZydisRegister_@@W44@@Z ; IronMan::Analysis::AnalysisBase::GpRegTo64
	cmp	eax, 53					; 00000035H
	je	$LN27@Build

; 106  : 					(*a)->mov(asmjit::host::rax, ToGpReg(GpRegTo64(lastInstruct.Instruct.operands[0].reg.value)));

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv534[rsp], rax
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	edx, DWORD PTR lastInstruct$28[rsp+rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GpRegTo64@AnalysisBase@Analysis@IronMan@@IEAA?AW4ZydisRegister_@@W44@@Z ; IronMan::Analysis::AnalysisBase::GpRegTo64
	mov	r8d, eax
	lea	rdx, QWORD PTR $T24[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv532[rsp], rax
	mov	rax, QWORD PTR ?rax@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv530[rsp], rax
	mov	r8, QWORD PTR tv532[rsp]
	mov	rdx, QWORD PTR tv530[rsp]
	mov	rcx, QWORD PTR tv534[rsp]
	call	?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ; asmjit::X86Assembler::mov
	npad	1
$LN27@Build:

; 107  : 			}
; 108  : 
; 109  : 
; 110  : 			// Restore registers 
; 111  : 			for (int i = 0; i < decrypt.second.SaveRegisters.size(); i++)

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN15@Build
$LN13@Build:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN15@Build:
	movsxd	rax, DWORD PTR i$4[rsp]
	mov	QWORD PTR tv535[rsp], rax
	mov	rcx, QWORD PTR decrypt$5[rsp]
	add	rcx, 64					; 00000040H
	call	?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::size
	mov	rcx, QWORD PTR tv535[rsp]
	cmp	rcx, rax
	jae	$LN14@Build

; 112  : 				(*a)->mov(ToGpReg(decrypt.second.SaveRegisters[i]), asmjit::host::qword_ptr(asmjit::host::rsp, 0x28 + i * 8));

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv608[rsp], rax
	mov	eax, DWORD PTR i$4[rsp]
	lea	eax, DWORD PTR [rax*8+40]
	mov	r8d, eax
	mov	rdx, QWORD PTR ?rsp@x86@asmjit@@3AEBUX86GpReg@2@EB
	lea	rcx, QWORD PTR $T25[rsp]
	call	?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z ; asmjit::x86::qword_ptr
	mov	QWORD PTR tv574[rsp], rax
	mov	rax, QWORD PTR decrypt$5[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR tv567[rsp], rax
	movsxd	rax, DWORD PTR i$4[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv567[rsp]
	call	??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator[]
	mov	r8d, DWORD PTR [rax]
	lea	rdx, QWORD PTR $T26[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ToGpReg@AnalysisBase@Analysis@IronMan@@IEAA?AUX86GpReg@asmjit@@W4ZydisRegister_@@@Z ; IronMan::Analysis::AnalysisBase::ToGpReg
	mov	QWORD PTR tv572[rsp], rax
	mov	r8, QWORD PTR tv574[rsp]
	mov	rdx, QWORD PTR tv572[rsp]
	mov	rcx, QWORD PTR tv608[rsp]
	call	?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z ; asmjit::X86Assembler::mov
	npad	1
	jmp	$LN13@Build
$LN14@Build:

; 113  : 
; 114  : 
; 115  : 			(*a)->add(asmjit::host::rsp, stack_size);

	lea	rcx, QWORD PTR a$1[rsp]
	call	??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
	mov	rcx, rax
	call	??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ; IronMan::IAsmHelper::operator->
	mov	QWORD PTR tv619[rsp], rax
	mov	rax, QWORD PTR ?rsp@x86@asmjit@@3AEBUX86GpReg@2@EB
	mov	QWORD PTR tv617[rsp], rax
	mov	r8, QWORD PTR stack_size$13[rsp]
	mov	rdx, QWORD PTR tv617[rsp]
	mov	rcx, QWORD PTR tv619[rsp]
	call	?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z ; asmjit::X86Assembler::add

; 116  : 			a->GenEpilogue();

	lea	rcx, QWORD PTR a$1[rsp]
	call	??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator->
	mov	QWORD PTR tv622[rsp], rax
	mov	rax, QWORD PTR tv622[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv628[rsp], rax
	mov	r8d, -1
	xor	edx, edx
	mov	rcx, QWORD PTR tv622[rsp]
	call	QWORD PTR tv628[rsp]

; 117  : 			mBuildResult.push_back(std::move(a));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1776				; 000006f0H
	mov	QWORD PTR tv639[rsp], rax
	lea	rcx, QWORD PTR a$1[rsp]
	call	??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv639[rsp]
	call	?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::push_back
	npad	1

; 118  : 		}

	lea	rcx, QWORD PTR a$1[rsp]
	call	??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >
	npad	1
	jmp	$LN2@Build
$LN3@Build:

; 119  : 		return !mBuildResult.empty();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1776				; 000006f0H
	mov	rcx, rax
	call	?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN30@Build
	mov	DWORD PTR tv649[rsp], 1
	jmp	SHORT $LN31@Build
$LN30@Build:
	mov	DWORD PTR tv649[rsp], 0
$LN31@Build:
	movzx	eax, BYTE PTR tv649[rsp]
	mov	BYTE PTR $T2[rsp], al
	mov	rcx, QWORD PTR callback$[rsp]
	call	??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]

; 120  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 3992				; 00000f98H
	pop	rdi
	pop	rsi
	ret	0
?Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z ENDP ; IronMan::Analysis::UObjectAnalysis::Build
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
a$1 = 32
$T2 = 40
i$3 = 44
tv322 = 48
i$4 = 52
decrypt$5 = 56
i$6 = 64
op1$7 = 72
tv649 = 80
inst$8 = 88
tv160 = 96
tv465 = 100
<begin>$L0$9 = 104
op2$10 = 112
op$11 = 120
<range>$L0$12 = 128
tv136 = 136
tv452 = 144
stack_size$13 = 152
tv622 = 160
<end>$L0$14 = 168
tv141 = 176
tv158 = 184
tv174 = 192
tv176 = 200
tv177 = 208
tv202 = 216
tv216 = 224
tv214 = 232
tv218 = 240
tv229 = 248
tv227 = 256
tv231 = 264
tv259 = 272
tv257 = 280
tv261 = 288
tv262 = 296
tv275 = 304
tv344 = 312
tv342 = 320
tv346 = 328
tv367 = 336
tv365 = 344
tv369 = 352
tv390 = 360
tv388 = 368
tv392 = 376
tv413 = 384
tv411 = 392
tv415 = 400
tv436 = 408
tv434 = 416
tv438 = 424
tv463 = 432
tv467 = 440
tv532 = 448
tv530 = 456
tv534 = 464
tv535 = 472
tv567 = 480
tv574 = 488
tv572 = 496
tv608 = 504
tv617 = 512
tv619 = 520
tv628 = 528
tv639 = 536
sa$15 = 544
$T16 = 560
$T17 = 576
$T18 = 592
$T19 = 608
$T20 = 624
$T21 = 640
$T22 = 656
$T23 = 672
$T24 = 688
$T25 = 704
$T26 = 720
BuildCp$27 = 736
lastInstruct$28 = 2480
__$ArrayPad$ = 3968
this$ = 4016
callback$ = 4024
?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::Build'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR callback$[rbp]
	call	??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::Build'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
a$1 = 32
$T2 = 40
i$3 = 44
tv322 = 48
i$4 = 52
decrypt$5 = 56
i$6 = 64
op1$7 = 72
tv649 = 80
inst$8 = 88
tv160 = 96
tv465 = 100
<begin>$L0$9 = 104
op2$10 = 112
op$11 = 120
<range>$L0$12 = 128
tv136 = 136
tv452 = 144
stack_size$13 = 152
tv622 = 160
<end>$L0$14 = 168
tv141 = 176
tv158 = 184
tv174 = 192
tv176 = 200
tv177 = 208
tv202 = 216
tv216 = 224
tv214 = 232
tv218 = 240
tv229 = 248
tv227 = 256
tv231 = 264
tv259 = 272
tv257 = 280
tv261 = 288
tv262 = 296
tv275 = 304
tv344 = 312
tv342 = 320
tv346 = 328
tv367 = 336
tv365 = 344
tv369 = 352
tv390 = 360
tv388 = 368
tv392 = 376
tv413 = 384
tv411 = 392
tv415 = 400
tv436 = 408
tv434 = 416
tv438 = 424
tv463 = 432
tv467 = 440
tv532 = 448
tv530 = 456
tv534 = 464
tv535 = 472
tv567 = 480
tv574 = 488
tv572 = 496
tv608 = 504
tv617 = 512
tv619 = 520
tv628 = 528
tv639 = 536
sa$15 = 544
$T16 = 560
$T17 = 576
$T18 = 592
$T19 = 608
$T20 = 624
$T21 = 640
$T22 = 656
$T23 = 672
$T24 = 688
$T25 = 704
$T26 = 720
BuildCp$27 = 736
lastInstruct$28 = 2480
__$ArrayPad$ = 3968
this$ = 4016
callback$ = 4024
?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::Build'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR a$1[rbp]
	call	??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::Build'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
a$1 = 32
$T2 = 40
i$3 = 44
tv322 = 48
i$4 = 52
decrypt$5 = 56
i$6 = 64
op1$7 = 72
tv649 = 80
inst$8 = 88
tv160 = 96
tv465 = 100
<begin>$L0$9 = 104
op2$10 = 112
op$11 = 120
<range>$L0$12 = 128
tv136 = 136
tv452 = 144
stack_size$13 = 152
tv622 = 160
<end>$L0$14 = 168
tv141 = 176
tv158 = 184
tv174 = 192
tv176 = 200
tv177 = 208
tv202 = 216
tv216 = 224
tv214 = 232
tv218 = 240
tv229 = 248
tv227 = 256
tv231 = 264
tv259 = 272
tv257 = 280
tv261 = 288
tv262 = 296
tv275 = 304
tv344 = 312
tv342 = 320
tv346 = 328
tv367 = 336
tv365 = 344
tv369 = 352
tv390 = 360
tv388 = 368
tv392 = 376
tv413 = 384
tv411 = 392
tv415 = 400
tv436 = 408
tv434 = 416
tv438 = 424
tv463 = 432
tv467 = 440
tv532 = 448
tv530 = 456
tv534 = 464
tv535 = 472
tv567 = 480
tv574 = 488
tv572 = 496
tv608 = 504
tv617 = 512
tv619 = 520
tv628 = 528
tv639 = 536
sa$15 = 544
$T16 = 560
$T17 = 576
$T18 = 592
$T19 = 608
$T20 = 624
$T21 = 640
$T22 = 656
$T23 = 672
$T24 = 688
$T25 = 704
$T26 = 720
BuildCp$27 = 736
lastInstruct$28 = 2480
__$ArrayPad$ = 3968
this$ = 4016
callback$ = 4024
?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::Build'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR BuildCp$27[rbp]
	call	??1Zydis@IronMan@@QEAA@XZ		; IronMan::Zydis::~Zydis
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??Build@UObjectAnalysis@Analysis@IronMan@@UEAA_NV?$function@$$A6AXPEAX@Z@std@@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::Build'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.cpp
_TEXT	SEGMENT
tv70 = 32
this$ = 64
?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ PROC ; IronMan::Analysis::UObjectAnalysis::Analyse

; 25   : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 26   : 		analyseDecrypttions();

	mov	rcx, QWORD PTR this$[rsp]
	call	?analyseDecrypttions@UObjectAnalysis@Analysis@IronMan@@AEAAXXZ ; IronMan::Analysis::UObjectAnalysis::analyseDecrypttions

; 27   : 		return !mDecrypts.empty();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1800				; 00000708H
	mov	rcx, rax
	call	?empty@?$SelfMap@HUDecryptInfo@UObjectAnalysis@Analysis@IronMan@@@Analysis@IronMan@@QEBA@XZ ; IronMan::Analysis::SelfMap<int,IronMan::Analysis::UObjectAnalysis::DecryptInfo>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Analyse
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@Analyse
$LN3@Analyse:
	mov	DWORD PTR tv70[rsp], 0
$LN4@Analyse:
	movzx	eax, BYTE PTR tv70[rsp]

; 28   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?Analyse@UObjectAnalysis@Analysis@IronMan@@UEAA_NXZ ENDP ; IronMan::Analysis::UObjectAnalysis::Analyse
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z PROC ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::operator=, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+12], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rax+20], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rax+24], ecx
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 32					; 00000020H
	mov	rdx, rax
	call	??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator=
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 56					; 00000038H
	mov	rdx, rax
	call	??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator=
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAAAEAU0123@AEBU0123@@Z ENDP ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z
_TEXT	SEGMENT
tv82 = 32
tv91 = 40
this$ = 64
__that$ = 72
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z PROC ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo, COMDAT
$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+12], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rax+20], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rax+24], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 32					; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv82[rsp]
	call	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv91[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 56					; 00000038H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv91[rsp]
	call	??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z ENDP ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv82 = 32
tv91 = 40
this$ = 64
__that$ = 72
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 32					; 00000020H
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv82 = 32
tv91 = 40
this$ = 64
__that$ = 72
?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@$$QEAU0123@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z
_TEXT	SEGMENT
tv82 = 32
tv91 = 40
this$ = 64
__that$ = 72
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z PROC ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo, COMDAT
$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+12], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rax+20], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rax+24], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 32					; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv82[rsp]
	call	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv91[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 56					; 00000038H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv91[rsp]
	call	??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z ENDP ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv82 = 32
tv91 = 40
this$ = 64
__that$ = 72
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 32					; 00000020H
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv82 = 32
tv91 = 40
this$ = 64
__that$ = 72
?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@AEBU0123@@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ PROC ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ ENDP ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 32					; 00000020H
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::~DecryptInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.h
;	COMDAT ??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ PROC ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo, COMDAT

; 44   : 			{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 43   : 				: DecryptInfo(0, ZYDIS_REGISTER_RAX, 0, -1)

	mov	DWORD PTR [rsp+32], -1			; ffffffffH
	xor	r9d, r9d
	mov	r8d, 53					; 00000035H
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
	npad	1

; 45   : 			}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ ENDP ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.h
;	COMDAT ??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z
_TEXT	SEGMENT
this$ = 48
parent$ = 56
BaseRegisterIn$ = 64
offset$ = 72
index$ = 80
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z PROC ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo, COMDAT

; 39   : 			{

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 32   : 				:Parent(parent),

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR parent$[rsp]
	mov	QWORD PTR [rax], rcx

; 33   : 				BaseRegister(BaseRegisterIn),

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR BaseRegisterIn$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 34   : 				Index(index),

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 35   : 				Offset(offset),

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 36   : 
; 37   : 				EndRegister(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], 0

; 38   : 				LastValue(0)

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 0

; 39   : 			{

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	npad	1

; 40   : 
; 41   : 			}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z ENDP ; IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
parent$ = 56
BaseRegisterIn$ = 64
offset$ = 72
index$ = 80
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 32					; 00000020H
	call	??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
parent$ = 56
BaseRegisterIn$ = 64
offset$ = 72
index$ = 80
?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA PROC ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0DecryptInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@_KW4ZydisRegister_@@II@Z@4HA ENDP ; `IronMan::Analysis::UObjectAnalysis::DecryptInfo::DecryptInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@00@Z PROC ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >::_Vector_val<std::_Simple_types<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAXPEAW4ZydisRegister_@@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAXPEAW4ZydisRegister_@@0@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAXPEAW4ZydisRegister_@@0@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newsize$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newcapacity$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXQEAW4ZydisRegister_@@_K1@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_nonzero, COMDAT

; 2025 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2026 :         // allocate array with _Newcapacity elements
; 2027 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2028 :         auto& _My_data    = _Mypair._Myval2;
; 2029 :         pointer& _Myfirst = _My_data._Myfirst;
; 2030 :         pointer& _Mylast  = _My_data._Mylast;
; 2031 :         pointer& _Myend   = _My_data._Myend;
; 2032 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2033 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2034 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2035 : 
; 2036 :         if (_Newcapacity > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size
	cmp	QWORD PTR _Newcapacity$[rsp], rax
	jbe	SHORT $LN2@Buy_nonzer

; 2037 :             _Xlength();

	call	?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Xlength
	npad	1
$LN2@Buy_nonzer:

; 2038 :         }
; 2039 : 
; 2040 :         _Buy_raw(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_raw
	npad	1
$LN3@Buy_nonzer:

; 2041 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Buy_nonzero@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
_My_data$ = 32
_Newvec$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newcapacity$ = 104
?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_raw, COMDAT

; 2009 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2010 :         // allocate array with _Newcapacity elements
; 2011 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2012 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2013 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2014 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2015 : 
; 2016 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2017 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 2018 : 
; 2019 :         const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, rax
	call	??$_Allocate_at_least_helper@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAPEAW4ZydisRegister_@@AEAV?$allocator@W4ZydisRegister_@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<enum ZydisRegister_> >
	mov	QWORD PTR _Newvec$[rsp], rax

; 2020 :         _Myfirst              = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2021 :         _Mylast               = _Newvec;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2022 :         _Myend                = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newcapacity$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2023 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator[], COMDAT

; 1922 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1923 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1924 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1925 :         _STL_VERIFY(
; 1926 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1927 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1928 : 
; 1929 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pos$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]

; 1930 :     }

	add	rsp, 24
	ret	0
??A?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBAAEBW4ZydisRegister_@@_K@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 2

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA_KAEBV?$allocator@W4ZydisRegister_@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::size, COMDAT

; 1898 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1899 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 2

; 1901 :     }

	add	rsp, 24
	ret	0
?size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end, COMDAT

; 1835 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1836 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1837 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1838 :     }

	add	rsp, 72					; 00000048H
	ret	0
?end@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::begin, COMDAT

; 1825 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1826 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1827 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<enum ZydisRegister_> > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@std@@QEAA@PEAW4ZydisRegister_@@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1828 :     }

	add	rsp, 72					; 00000048H
	ret	0
?begin@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@std@@@2@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
_Newcapacity$ = 72
this$ = 96
_Newsize$ = 104
?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Clear_and_reserve_geometric, COMDAT

; 1676 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1677 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1678 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1679 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1680 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1681 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1682 : 
; 1683 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1684 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1685 :         _Check_all_orphaned();
; 1686 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1687 : 
; 1688 :         if (_Newsize > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEBA_KXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::max_size
	cmp	QWORD PTR _Newsize$[rsp], rax
	jbe	SHORT $LN2@Clear_and_

; 1689 :             _Xlength();

	call	?_Xlength@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@CAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Xlength
	npad	1
$LN2@Clear_and_:

; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBA_K_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Clear_and_

; 1695 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXPEAW4ZydisRegister_@@QEAW41@AEAV?$allocator@W4ZydisRegister_@@@0@@Z ; std::_Destroy_range<std::allocator<enum ZydisRegister_> >

; 1696 :             _ASAN_VECTOR_REMOVE;
; 1697 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z ; std::allocator<enum ZydisRegister_>::deallocate

; 1698 : 
; 1699 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 1700 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 1701 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN3@Clear_and_:

; 1702 :         }
; 1703 : 
; 1704 :         _Buy_raw(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_raw@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Buy_raw
	npad	1
$LN4@Clear_and_:

; 1705 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Clear_and_reserve_geometric@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
_Right_data$ = 32
_Right_al$ = 40
_Al$ = 48
this$ = 80
_Right$ = 88
??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator=, COMDAT

; 1508 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1509 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@$$CBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@@std@@YAPEBV?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> > const >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 1510 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1514 :         auto& _Right_al = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocca@V?$allocator@W4ZydisRegister_@@@std@@@std@@YAXAEAV?$allocator@W4ZydisRegister_@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<enum ZydisRegister_> >

; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Assign_counted_range@PEAW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXPEAW4ZydisRegister_@@_K@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Assign_counted_range<enum ZydisRegister_ *>

; 1525 : 
; 1526 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 1527 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::push_back, COMDAT

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 918  :         _Emplace_one_at_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBW4ZydisRegister_@@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAW4ZydisRegister_@@AEBW42@@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Emplace_one_at_back<enum ZydisRegister_ const &>
	npad	1

; 919  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAAXAEBW4ZydisRegister_@@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAXXZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::~vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
$T4 = 58
$T5 = 66
$T6 = 80
$T7 = 88
$T8 = 96
tv128 = 104
tv130 = 112
tv139 = 120
tv155 = 128
this$ = 160
_Right$ = 168
??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >, COMDAT

; 748  :               _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 745  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	mov	QWORD PTR $T3[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 16
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rax
	call	??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z ; std::exchange<enum ZydisRegister_ *,std::nullptr_t>
	mov	QWORD PTR $T6[rsp], rax
	mov	QWORD PTR $T4[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rax
	call	??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z ; std::exchange<enum ZydisRegister_ *,std::nullptr_t>
	mov	QWORD PTR $T7[rsp], rax
	mov	QWORD PTR $T5[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rax
	call	??$exchange@PEAW4ZydisRegister_@@$$T@std@@YAPEAW4ZydisRegister_@@AEAPEAW41@$$QEA$$T@Z ; std::exchange<enum ZydisRegister_ *,std::nullptr_t>
	mov	QWORD PTR $T8[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAAEAV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@W4ZydisRegister_@@@std@@@std@@YA$$QEAV?$allocator@W4ZydisRegister_@@@0@AEAV10@@Z ; std::move<std::allocator<enum ZydisRegister_> &>
	mov	QWORD PTR tv128[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T8[rsp]
	mov	r8, QWORD PTR tv128[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$?0V?$allocator@W4ZydisRegister_@@@std@@PEAW4ZydisRegister_@@PEAW42@PEAW42@@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@$$QEAPEAW4ZydisRegister_@@22@Z ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_>,enum ZydisRegister_ *,enum ZydisRegister_ *,enum ZydisRegister_ *>
	npad	1

; 749  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv139[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv139[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 750  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv155[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv155[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 751  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 152				; 00000098H
	ret	0
??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
_Right_data$ = 40
tv76 = 48
tv78 = 56
_Count$ = 64
this$ = 96
_Right$ = 104
??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >, COMDAT

; 731  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEBAAEBV?$allocator@W4ZydisRegister_@@@2@XZ ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA?AV?$allocator@W4ZydisRegister_@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::select_on_container_copy_construction
	mov	QWORD PTR tv76[rsp], rax
	movzx	eax, BYTE PTR $T3[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv76[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?0V?$allocator@W4ZydisRegister_@@@std@@$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4ZydisRegister_@@@1@@Z ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><std::allocator<enum ZydisRegister_> >
	npad	1

; 732  :         const auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 733  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 2
	mov	QWORD PTR _Count$[rsp], rax

; 734  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);

	mov	rax, QWORD PTR _Right_data$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	r9, rax
	mov	r8, rcx
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct_n@AEBQEAW4ZydisRegister_@@AEBQEAW41@@?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@AEAAX_KAEBQEAW4ZydisRegister_@@1@Z ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::_Construct_n<enum ZydisRegister_ * const &,enum ZydisRegister_ * const &>
	npad	1

; 735  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ PROC ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@W4ZydisRegister_@@@std@@V?$_Vector_val@U?$_Simple_types@W4ZydisRegister_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1>::_Compressed_pair<std::allocator<enum ZydisRegister_>,std::_Vector_val<std::_Simple_types<enum ZydisRegister_> >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@W4ZydisRegister_@@V?$allocator@W4ZydisRegister_@@@std@@@std@@QEAA@XZ ENDP ; std::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >::vector<enum ZydisRegister_,std::allocator<enum ZydisRegister_> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA?AV?$allocator@W4ZydisRegister_@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA?AV?$allocator@W4ZydisRegister_@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 750  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA?AV?$allocator@W4ZydisRegister_@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA_KAEBV?$allocator@W4ZydisRegister_@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA_KAEBV?$allocator@W4ZydisRegister_@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@W4ZydisRegister_@@@std@@@std@@SA_KAEBV?$allocator@W4ZydisRegister_@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum ZydisRegister_> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z PROC ; std::allocator<enum ZydisRegister_>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$03@std@@YA_K_K@Z	; std::_Get_size_of_n<4>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@W4ZydisRegister_@@@std@@QEAAPEAW4ZydisRegister_@@_K@Z ENDP ; std::allocator<enum ZydisRegister_>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z PROC ; std::allocator<enum ZydisRegister_>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 2
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@W4ZydisRegister_@@@std@@QEAAXQEAW4ZydisRegister_@@_K@Z ENDP ; std::allocator<enum ZydisRegister_>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@W4ZydisRegister_@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@W4ZydisRegister_@@@std@@QEAA@XZ PROC	; std::allocator<enum ZydisRegister_>::allocator<enum ZydisRegister_>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@W4ZydisRegister_@@@std@@QEAA@XZ ENDP	; std::allocator<enum ZydisRegister_>::allocator<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@00@Z PROC ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
_My_data$ = 32
tv82 = 40
tv80 = 48
this$ = 80
__$ReturnUdt$ = 88
_Offset$ = 96
?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Make_iterator_offset, COMDAT

; 2223 :     _NODISCARD _CONSTEXPR20 iterator _Make_iterator_offset(const size_type _Offset) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2224 :         // return the iterator begin() + _Offset without a debugging check
; 2225 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2226 :         return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
	mov	QWORD PTR tv82[rsp], rax
	imul	rax, QWORD PTR _Offset$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR tv80[rsp], rax
	mov	r8, QWORD PTR tv82[rsp]
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2227 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Make_iterator_offset@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Make_iterator_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@0@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K1@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_nonzero, COMDAT

; 2025 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2026 :         // allocate array with _Newcapacity elements
; 2027 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2028 :         auto& _My_data    = _Mypair._Myval2;
; 2029 :         pointer& _Myfirst = _My_data._Myfirst;
; 2030 :         pointer& _Mylast  = _My_data._Mylast;
; 2031 :         pointer& _Myend   = _My_data._Myend;
; 2032 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2033 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2034 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2035 : 
; 2036 :         if (_Newcapacity > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
	cmp	QWORD PTR _Newcapacity$[rsp], rax
	jbe	SHORT $LN2@Buy_nonzer

; 2037 :             _Xlength();

	call	?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength
	npad	1
$LN2@Buy_nonzer:

; 2038 :         }
; 2039 : 
; 2040 :         _Buy_raw(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_raw
	npad	1
$LN3@Buy_nonzer:

; 2041 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Buy_nonzero@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
_My_data$ = 32
_Newvec$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newcapacity$ = 104
?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_raw, COMDAT

; 2009 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2010 :         // allocate array with _Newcapacity elements
; 2011 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2012 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2013 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2014 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2015 : 
; 2016 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2017 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 2018 : 
; 2019 :         const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, rax
	call	??$_Allocate_at_least_helper@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	mov	QWORD PTR _Newvec$[rsp], rax

; 2020 :         _Myfirst              = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2021 :         _Mylast               = _Newvec;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2022 :         _Myend                = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rsp], 1488	; 000005d0H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2023 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back, COMDAT

; 1977 :     _NODISCARD _CONSTEXPR20 const _Ty& back() const noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1978 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1979 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1980 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1981 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1982 : 
; 1983 :         return _My_data._Mylast[-1];

	mov	eax, 1488				; 000005d0H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rax, QWORD PTR [rcx+8]

; 1984 :     }

	add	rsp, 24
	ret	0
?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back, COMDAT

; 1968 :     _NODISCARD _CONSTEXPR20 _Ty& back() noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1969 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1970 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1971 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1972 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1973 : 
; 1974 :         return _My_data._Mylast[-1];

	mov	eax, 1488				; 000005d0H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rax, QWORD PTR [rcx+8]

; 1975 :     }

	add	rsp, 24
	ret	0
?back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator[], COMDAT

; 1922 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1923 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1924 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1925 :         _STL_VERIFY(
; 1926 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1927 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1928 : 
; 1929 :         return _My_data._Myfirst[_Pos];

	imul	rax, QWORD PTR _Pos$[rsp], 1488		; 000005d0H
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rax, QWORD PTR [rcx]

; 1930 :     }

	add	rsp, 24
	ret	0
??A?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBAAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::size, COMDAT

; 1898 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1899 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx

; 1901 :     }

	add	rsp, 24
	ret	0
?size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv69 = 0
_My_data$ = 8
this$ = 32
?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::empty, COMDAT

; 1893 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1894 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[rsp]

; 1896 :     }

	add	rsp, 24
	ret	0
?empty@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::end, COMDAT

; 1835 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1836 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1837 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1838 :     }

	add	rsp, 72					; 00000048H
	ret	0
?end@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::begin, COMDAT

; 1825 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1826 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1827 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@QEAA@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1828 :     }

	add	rsp, 72					; 00000048H
	ret	0
?begin@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@2@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
_Myfirst$ = 48
tv82 = 56
tv84 = 64
tv80 = 72
this$ = 96
?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::clear, COMDAT

; 1792 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1793 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1794 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1795 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1796 : 
; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;

	jmp	SHORT $LN1@clear
$LN2@clear:

; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv80[rsp], rax
	mov	r8, QWORD PTR tv82[rsp]
	mov	rdx, QWORD PTR tv84[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN1@clear:

; 1808 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXXZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
_Newcapacity$ = 72
this$ = 96
_Newsize$ = 104
?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Clear_and_reserve_geometric, COMDAT

; 1676 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1677 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1678 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1679 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1680 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1681 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1682 : 
; 1683 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1684 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1685 :         _Check_all_orphaned();
; 1686 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1687 : 
; 1688 :         if (_Newsize > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
	cmp	QWORD PTR _Newsize$[rsp], rax
	jbe	SHORT $LN2@Clear_and_

; 1689 :             _Xlength();

	call	?_Xlength@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Xlength
	npad	1
$LN2@Clear_and_:

; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBA_K_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Clear_and_

; 1695 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAU1234@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1696 :             _ASAN_VECTOR_REMOVE;
; 1697 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate

; 1698 : 
; 1699 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 1700 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 1701 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN3@Clear_and_:

; 1702 :         }
; 1703 : 
; 1704 :         _Buy_raw(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_raw@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Buy_raw
	npad	1
$LN4@Clear_and_:

; 1705 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Clear_and_reserve_geometric@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
_Right_data$ = 32
_Right_al$ = 40
_Al$ = 48
this$ = 80
_Right$ = 88
??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator=, COMDAT

; 1508 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1509 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@$$CBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@@std@@YAPEBV?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> > const >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 1510 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1514 :         auto& _Right_al = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocca@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YAXAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >

; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Assign_counted_range@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Assign_counted_range<IronMan::Analysis::UObjectAnalysis::InstructionInfo *>

; 1525 : 
; 1526 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 1527 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::push_back, COMDAT

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 918  :         _Emplace_one_at_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Emplace_one_at_back<IronMan::Analysis::UObjectAnalysis::InstructionInfo const &>
	npad	1

; 919  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAAXAEBUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAXXZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::~vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
$T4 = 58
$T5 = 66
$T6 = 80
$T7 = 88
$T8 = 96
tv128 = 104
tv130 = 112
tv139 = 120
tv155 = 128
this$ = 160
_Right$ = 168
??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 748  :               _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 745  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	mov	QWORD PTR $T3[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 16
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rax
	call	??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z ; std::exchange<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::nullptr_t>
	mov	QWORD PTR $T6[rsp], rax
	mov	QWORD PTR $T4[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rax
	call	??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z ; std::exchange<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::nullptr_t>
	mov	QWORD PTR $T7[rsp], rax
	mov	QWORD PTR $T5[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rax
	call	??$exchange@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@$$T@std@@YAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEAPEAU1234@$$QEA$$T@Z ; std::exchange<IronMan::Analysis::UObjectAnalysis::InstructionInfo *,std::nullptr_t>
	mov	QWORD PTR $T8[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@YA$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@0@AEAV10@@Z ; std::move<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> &>
	mov	QWORD PTR tv128[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T8[rsp]
	mov	r8, QWORD PTR tv128[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@PEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@PEAU2345@PEAU2345@@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@$$QEAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@22@Z ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *,IronMan::Analysis::UObjectAnalysis::InstructionInfo *>
	npad	1

; 749  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv139[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv139[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 750  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv155[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv155[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 751  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 152				; 00000098H
	ret	0
??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
_Right_data$ = 40
tv76 = 48
tv78 = 56
_Count$ = 64
this$ = 96
_Right$ = 104
??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 731  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@XZ ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA?AV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::select_on_container_copy_construction
	mov	QWORD PTR tv76[rsp], rax
	movzx	eax, BYTE PTR $T3[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv76[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?0V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@1@@Z ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
	npad	1

; 732  :         const auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 733  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	cdq
	mov	ecx, 1488				; 000005d0H
	idiv	rcx
	mov	QWORD PTR _Count$[rsp], rax

; 734  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);

	mov	rax, QWORD PTR _Right_data$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	r9, rax
	mov	r8, rcx
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct_n@AEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@AEBQEAU1234@@?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@AEAAX_KAEBQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@1@Z ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::_Construct_n<IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &,IronMan::Analysis::UObjectAnalysis::InstructionInfo * const &>
	npad	1

; 735  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1>::_Compressed_pair<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>,std::_Vector_val<std::_Simple_types<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::vector<IronMan::Analysis::UObjectAnalysis::InstructionInfo,std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA?AV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA?AV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 750  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA?AV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 12397005425880075			; 002c0b02c0b02c0bH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z PROC ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0FNA@@std@@YA_K_K@Z	; std::_Get_size_of_n<1488>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAPEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ENDP ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z PROC ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 1488	; 000005d0H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAAXQEAUInstructionInfo@UObjectAnalysis@Analysis@IronMan@@_K@Z ENDP ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ PROC ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@UInstructionInfo@UObjectAnalysis@Analysis@IronMan@@@std@@QEAA@XZ ENDP ; std::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>::allocator<IronMan::Analysis::UObjectAnalysis::InstructionInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\UObjectAnalysis.h
;	COMDAT ??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z
_TEXT	SEGMENT
this$ = 24
instruct$ = 32
address$ = 40
??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z PROC ; IronMan::Analysis::UObjectAnalysis::InstructionInfo::InstructionInfo, COMDAT

; 17   : 			{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi

; 16   : 				:Instruct(instruct), Address(address), Offset(0)

	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, QWORD PTR instruct$[rsp]
	mov	ecx, 1472				; 000005c0H
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR address$[rsp]
	mov	QWORD PTR [rax+1472], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+1480], 0

; 18   : 			}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	pop	rsi
	ret	0
??0InstructionInfo@UObjectAnalysis@Analysis@IronMan@@QEAA@UZydisDecodedInstruction_@@_K@Z ENDP ; IronMan::Analysis::UObjectAnalysis::InstructionInfo::InstructionInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ PROC		; std::function<void __cdecl(void *)>::~function<void __cdecl(void *)>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Func_class@XPEAX@std@@QEAA@XZ	; std::_Func_class<void,void *>::~_Func_class<void,void *>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ ENDP		; std::function<void __cdecl(void *)>::~function<void __cdecl(void *)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA PROC ; `std::function<void __cdecl(void *)>::~function<void __cdecl(void *)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@XPEAX@std@@QEAA@XZ	; std::_Func_class<void,void *>::~_Func_class<void,void *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$function@$$A6AXPEAX@Z@std@@QEAA@XZ@4HA ENDP ; `std::function<void __cdecl(void *)>::~function<void __cdecl(void *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ PROC		; std::function<void __cdecl(void *)>::operator bool, COMDAT

; 1191 :     explicit operator bool() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1192 :         return !this->_Empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ ; std::_Func_class<void,void *>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv72[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv72[rsp]

; 1193 :     }

	add	rsp, 56					; 00000038H
	ret	0
??B?$function@$$A6AXPEAX@Z@std@@QEBA_NXZ ENDP		; std::function<void __cdecl(void *)>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Set@?$_Func_class@XPEAX@std@@AEAAXPEAV?$_Func_base@XPEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Set@?$_Func_class@XPEAX@std@@AEAAXPEAV?$_Func_base@XPEAX@2@@Z PROC ; std::_Func_class<void,void *>::_Set, COMDAT

; 1048 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1049 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 1050 :     }

	ret	0
?_Set@?$_Func_class@XPEAX@std@@AEAAXPEAV?$_Func_base@XPEAX@2@@Z ENDP ; std::_Func_class<void,void *>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ PROC ; std::_Func_class<void,void *>::_Getimpl, COMDAT

; 1044 :     _Ptrt* _Getimpl() const noexcept { // get pointer to object

	mov	QWORD PTR [rsp+8], rcx

; 1045 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax]

; 1046 :     }

	ret	0
?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ ENDP ; std::_Func_class<void,void *>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ PROC		; std::_Func_class<void,void *>::_Local, COMDAT

; 1032 :     bool _Local() const noexcept { // test for locally stored copy of object

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1033 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ ; std::_Func_class<void,void *>::_Getimpl
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, rcx
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv68[rsp], 0
$LN4@Local:
	movzx	eax, BYTE PTR tv68[rsp]

; 1034 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ ENDP		; std::_Func_class<void,void *>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ
_TEXT	SEGMENT
tv78 = 32
tv71 = 40
tv81 = 48
this$ = 80
?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ PROC		; std::_Func_class<void,void *>::_Tidy, COMDAT

; 1001 :     void _Tidy() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1002 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ ; std::_Func_class<void,void *>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Tidy

; 1003 :             _Getimpl()->_Delete_this(!_Local());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ ; std::_Func_class<void,void *>::_Getimpl
	mov	QWORD PTR tv71[rsp], rax
	mov	rax, QWORD PTR tv71[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Local@?$_Func_class@XPEAX@std@@AEBA_NXZ ; std::_Func_class<void,void *>::_Local
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv78[rsp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv78[rsp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv78[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	QWORD PTR tv81[rsp]

; 1004 :             _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@XPEAX@std@@AEAAXPEAV?$_Func_base@XPEAX@2@@Z ; std::_Func_class<void,void *>::_Set
	npad	1
$LN2@Tidy:

; 1005 :         }
; 1006 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ ENDP		; std::_Func_class<void,void *>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ PROC		; std::_Func_class<void,void *>::_Empty, COMDAT

; 938  :     bool _Empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 939  :         return !_Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ ; std::_Func_class<void,void *>::_Getimpl
	test	rax, rax
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv67[rsp], 0
$LN4@Empty:
	movzx	eax, BYTE PTR tv67[rsp]

; 940  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ ENDP		; std::_Func_class<void,void *>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??1?$_Func_class@XPEAX@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Func_class@XPEAX@std@@QEAA@XZ PROC		; std::_Func_class<void,void *>::~_Func_class<void,void *>, COMDAT

; 928  :     ~_Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 929  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Func_class@XPEAX@std@@IEAAXXZ	; std::_Func_class<void,void *>::_Tidy
	npad	1

; 930  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Func_class@XPEAX@std@@QEAA@XZ ENDP		; std::_Func_class<void,void *>::~_Func_class<void,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z
_TEXT	SEGMENT
_Impl$ = 32
tv77 = 40
tv79 = 48
this$ = 80
<_Args_0>$ = 88
??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z PROC		; std::_Func_class<void,void *>::operator(), COMDAT

; 920  :     _Ret operator()(_Types... _Args) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 921  :         if (_Empty()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@XPEAX@std@@IEBA_NXZ ; std::_Func_class<void,void *>::_Empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator

; 922  :             _Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
	npad	1
$LN2@operator:

; 923  :         }
; 924  :         const auto _Impl = _Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XPEAX@std@@AEBAPEAV?$_Func_base@XPEAX@2@XZ ; std::_Func_class<void,void *>::_Getimpl
	mov	QWORD PTR _Impl$[rsp], rax

; 925  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Impl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ; std::forward<void *>
	mov	QWORD PTR tv77[rsp], rax
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR _Impl$[rsp]
	call	QWORD PTR tv79[rsp]
	npad	1
$LN3@operator:

; 926  :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$_Func_class@XPEAX@std@@QEBAXPEAX@Z ENDP		; std::_Func_class<void,void *>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z PROC	; IronMan::Analysis::AnalysisBase::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1AnalysisBase@Analysis@IronMan@@UEAA@XZ ; IronMan::Analysis::AnalysisBase::~AnalysisBase
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 1800				; 00000708H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GAnalysisBase@Analysis@IronMan@@UEAAPEAXI@Z ENDP	; IronMan::Analysis::AnalysisBase::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@0@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@0@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newsize$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newcapacity$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K1@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv69 = 0
_My_data$ = 8
this$ = 32
?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::empty, COMDAT

; 1893 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1894 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[rsp]

; 1896 :     }

	add	rsp, 24
	ret	0
?empty@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEBA_NXZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::push_back, COMDAT

; 921  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 922  :         // insert by moving into element at end, provide strong guarantee
; 923  :         _Emplace_one_at_back(_STD move(_Val));

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$move@AEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Emplace_one_at_back<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
	npad	1

; 924  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@@Z ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z PROC ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ENDP ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z PROC ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@2@_K@Z ENDP ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z
_TEXT	SEGMENT
tv66 = 0
this$ = 32
addr$ = 40
min$ = 48
max$ = 56
?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z PROC ; IronMan::Analysis::AnalysisBase::inRange, COMDAT

; 119  : 		{

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 120  : 			return addr >= min && addr <= max;

	mov	rax, QWORD PTR min$[rsp]
	cmp	QWORD PTR addr$[rsp], rax
	jb	SHORT $LN3@inRange
	mov	rax, QWORD PTR max$[rsp]
	cmp	QWORD PTR addr$[rsp], rax
	ja	SHORT $LN3@inRange
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@inRange
$LN3@inRange:
	mov	DWORD PTR tv66[rsp], 0
$LN4@inRange:
	movzx	eax, BYTE PTR tv66[rsp]

; 121  : 		}

	add	rsp, 24
	ret	0
?inRange@AnalysisBase@Analysis@IronMan@@IEBA_N_K00@Z ENDP ; IronMan::Analysis::AnalysisBase::inRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ??0AnalysisBase@Analysis@IronMan@@IEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0AnalysisBase@Analysis@IronMan@@IEAA@XZ PROC		; IronMan::Analysis::AnalysisBase::AnalysisBase, COMDAT

; 111  : 		AnalysisBase() {}

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7AnalysisBase@Analysis@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0Zydis@IronMan@@QEAA@XZ		; IronMan::Zydis::Zydis
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1776				; 000006f0H
	mov	rcx, rax
	call	??0?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0AnalysisBase@Analysis@IronMan@@IEAA@XZ ENDP		; IronMan::Analysis::AnalysisBase::AnalysisBase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA PROC ; `IronMan::Analysis::AnalysisBase::AnalysisBase'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 32					; 00000020H
	call	??1Zydis@IronMan@@QEAA@XZ		; IronMan::Zydis::~Zydis
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA ENDP ; `IronMan::Analysis::AnalysisBase::AnalysisBase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA PROC ; `IronMan::Analysis::AnalysisBase::AnalysisBase'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 1776				; 000006f0H
	call	??1?$vector@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@V?$allocator@V?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >::~vector<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >,std::allocator<std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0AnalysisBase@Analysis@IronMan@@IEAA@XZ@4HA ENDP ; `IronMan::Analysis::AnalysisBase::AnalysisBase'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Analysis\AnalysisBase.h
;	COMDAT ?GetEntryPoint@AnalysisBase@Analysis@IronMan@@UEBA?B_KXZ
_TEXT	SEGMENT
this$ = 8
?GetEntryPoint@AnalysisBase@Analysis@IronMan@@UEBA?B_KXZ PROC ; IronMan::Analysis::AnalysisBase::GetEntryPoint, COMDAT

; 106  : 		virtual const ptr_t GetEntryPoint() const { return 0; }

	mov	QWORD PTR [rsp+8], rcx
	xor	eax, eax
	ret	0
?GetEntryPoint@AnalysisBase@Analysis@IronMan@@UEBA?B_KXZ ENDP ; IronMan::Analysis::AnalysisBase::GetEntryPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv78 = 48
tv80 = 56
this$ = 80
_Right$ = 88
??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64>,0>, COMDAT

; 3376 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv80[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::release
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::get_deleter
	mov	rcx, rax
	call	??$forward@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VAsmHelper64@IronMan@@@0@AEAU10@@Z ; std::forward<std::default_delete<IronMan::AsmHelper64> >
	mov	QWORD PTR tv78[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	lea	r9, QWORD PTR $T3[rsp]
	mov	r8, QWORD PTR tv78[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VAsmHelper64@IronMan@@@1@$$QEAPEAVAsmHelper64@IronMan@@@Z ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$?0VAsmHelper64@IronMan@@$0A@@?$default_delete@VIAsmHelper@IronMan@@@std@@QEAA@AEBU?$default_delete@VAsmHelper64@IronMan@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0VAsmHelper64@IronMan@@$0A@@?$default_delete@VIAsmHelper@IronMan@@@std@@QEAA@AEBU?$default_delete@VAsmHelper64@IronMan@@@1@@Z PROC ; std::default_delete<IronMan::IAsmHelper>::default_delete<IronMan::IAsmHelper><IronMan::AsmHelper64,0>, COMDAT

; 3295 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0VAsmHelper64@IronMan@@$0A@@?$default_delete@VIAsmHelper@IronMan@@@std@@QEAA@AEBU?$default_delete@VAsmHelper64@IronMan@@@1@@Z ENDP ; std::default_delete<IronMan::IAsmHelper>::default_delete<IronMan::IAsmHelper><IronMan::AsmHelper64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ PROC ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::release, COMDAT

; 3437 :     _CONSTEXPR23 pointer release() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3438 :         return _STD exchange(_Mypair._Myval2, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAVAsmHelper64@IronMan@@$$T@std@@YAPEAVAsmHelper64@IronMan@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<IronMan::AsmHelper64 *,std::nullptr_t>

; 3439 :     }

	add	rsp, 56					; 00000038H
	ret	0
?release@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAPEAVAsmHelper64@IronMan@@XZ ENDP ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ PROC ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::get_deleter, COMDAT

; 3413 :     _NODISCARD _CONSTEXPR23 _Dx& get_deleter() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3414 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Get_first

; 3415 :     }

	add	rsp, 40					; 00000028H
	ret	0
?get_deleter@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ENDP ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv75 = 32
tv77 = 40
this$ = 64
??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::~unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >, COMDAT

; 3407 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3408 :         if (_Mypair._Myval2) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@unique_ptr

; 3409 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@VAsmHelper64@IronMan@@@std@@PEAVAsmHelper64@IronMan@@$00@std@@QEAAAEAU?$default_delete@VAsmHelper64@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::AsmHelper64>,IronMan::AsmHelper64 *,1>::_Get_first
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z ; std::default_delete<IronMan::AsmHelper64>::operator()
	npad	1
$LN2@unique_ptr:

; 3410 :         }
; 3411 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::~unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
tv75 = 40
tv76 = 48
this$ = 80
_Ptr$ = 88
??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z PROC ; std::default_delete<IronMan::AsmHelper64>::operator(), COMDAT

; 3297 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3298 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3299 :         delete _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR tv75[rsp]
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	QWORD PTR tv76[rsp], 0
$LN4@operator:

; 3300 :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$default_delete@VAsmHelper64@IronMan@@@std@@QEBAXPEAVAsmHelper64@IronMan@@@Z ENDP ; std::default_delete<IronMan::AsmHelper64>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv77 = 48
$T3 = 56
__$ReturnUdt$ = 80
??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ PROC ; std::make_unique<IronMan::AsmHelper64,0>, COMDAT

; 3593 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T1[rsp], 0

; 3594 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 448				; 000001c0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN3@make_uniqu
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0AsmHelper64@IronMan@@QEAA@XZ		; IronMan::AsmHelper64::AsmHelper64
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN4@make_uniqu
$LN3@make_uniqu:
	mov	QWORD PTR tv77[rsp], 0
$LN4@make_uniqu:
	mov	rax, QWORD PTR tv77[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@PEAVAsmHelper64@IronMan@@@Z ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> ><std::default_delete<IronMan::AsmHelper64>,0>
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3595 : }

	add	rsp, 72					; 00000048H
	ret	0
	int	3
??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ ENDP ; std::make_unique<IronMan::AsmHelper64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv77 = 48
$T3 = 56
__$ReturnUdt$ = 80
?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA PROC ; `std::make_unique<IronMan::AsmHelper64,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 448				; 000001c0H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA ENDP ; `std::make_unique<IronMan::AsmHelper64,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv77 = 48
$T3 = 56
__$ReturnUdt$ = 80
?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA PROC ; `std::make_unique<IronMan::AsmHelper64,0>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::~unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >
$LN7@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ@4HA ENDP ; `std::make_unique<IronMan::AsmHelper64,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv78 = 48
tv80 = 56
this$ = 80
_Right$ = 88
??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><std::default_delete<IronMan::IAsmHelper>,0>, COMDAT

; 3368 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv80[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::release
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::get_deleter
	mov	rcx, rax
	call	??$forward@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@YA$$QEAU?$default_delete@VIAsmHelper@IronMan@@@0@AEAU10@@Z ; std::forward<std::default_delete<IronMan::IAsmHelper> >
	mov	QWORD PTR tv78[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	lea	r9, QWORD PTR $T3[rsp]
	mov	r8, QWORD PTR tv78[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VIAsmHelper@IronMan@@@1@$$QEAPEAVIAsmHelper@IronMan@@@Z ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1><std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0U?$default_delete@VIAsmHelper@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><std::default_delete<IronMan::IAsmHelper>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::release, COMDAT

; 3437 :     _CONSTEXPR23 pointer release() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3438 :         return _STD exchange(_Mypair._Myval2, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAVIAsmHelper@IronMan@@$$T@std@@YAPEAVIAsmHelper@IronMan@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<IronMan::IAsmHelper *,std::nullptr_t>

; 3439 :     }

	add	rsp, 56					; 00000038H
	ret	0
?release@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAPEAVIAsmHelper@IronMan@@XZ ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator->, COMDAT

; 3425 :     _NODISCARD _CONSTEXPR23 pointer operator->() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 3426 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]

; 3427 :     }

	ret	0
??C?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAPEAVIAsmHelper@IronMan@@XZ ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*, COMDAT

; 3421 :     _NODISCARD _CONSTEXPR23 add_lvalue_reference_t<_Ty> operator*() const noexcept(noexcept(*_STD declval<pointer>())) {

	mov	QWORD PTR [rsp+8], rcx

; 3422 :         return *_Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]

; 3423 :     }

	ret	0
??D?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEBAAEAVIAsmHelper@IronMan@@XZ ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::get_deleter, COMDAT

; 3413 :     _NODISCARD _CONSTEXPR23 _Dx& get_deleter() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3414 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Get_first

; 3415 :     }

	add	rsp, 40					; 00000028H
	ret	0
?get_deleter@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv75 = 32
tv77 = 40
this$ = 64
??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >, COMDAT

; 3407 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3408 :         if (_Mypair._Myval2) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@unique_ptr

; 3409 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@VIAsmHelper@IronMan@@@std@@PEAVIAsmHelper@IronMan@@$00@std@@QEAAAEAU?$default_delete@VIAsmHelper@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::IAsmHelper>,IronMan::IAsmHelper *,1>::_Get_first
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z ; std::default_delete<IronMan::IAsmHelper>::operator()
	npad	1
$LN2@unique_ptr:

; 3410 :         }
; 3411 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
tv71 = 40
tv72 = 48
this$ = 80
_Ptr$ = 88
??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z PROC ; std::default_delete<IronMan::IAsmHelper>::operator(), COMDAT

; 3297 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3298 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3299 :         delete _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv71[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR tv71[rsp]
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	QWORD PTR tv72[rsp], 0
$LN4@operator:

; 3300 :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$default_delete@VIAsmHelper@IronMan@@@std@@QEBAXPEAVIAsmHelper@IronMan@@@Z ENDP ; std::default_delete<IronMan::IAsmHelper>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Asm\AsmFactory.hpp
;	COMDAT ?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ
_TEXT	SEGMENT
$T1 = 32
tv78 = 40
tv73 = 48
$T2 = 56
__$ReturnUdt$ = 80
?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ PROC ; IronMan::AsmFactory::GetAssembler, COMDAT

; 79   : 		{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T1[rsp], 0

; 80   : 			#ifdef USE64
; 81   : 			return std::make_unique<AsmHelper64>();

	lea	rcx, QWORD PTR $T2[rsp]
	call	??$make_unique@VAsmHelper64@IronMan@@$$V$0A@@std@@YA?AV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@0@XZ ; std::make_unique<IronMan::AsmHelper64,0>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv73[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@$0A@@?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@1@@Z ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> ><IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64>,0>
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::~unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 82   : 			#else
; 83   : 			return std::make_unique<AsmHelper32>();
; 84   : 			#endif
; 85   : 		}

	add	rsp, 72					; 00000048H
	ret	0
	int	3
?GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ ENDP ; IronMan::AsmFactory::GetAssembler
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv78 = 40
tv73 = 48
$T2 = 56
__$ReturnUdt$ = 80
?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA PROC ; `IronMan::AsmFactory::GetAssembler'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$unique_ptr@VAsmHelper64@IronMan@@U?$default_delete@VAsmHelper64@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >::~unique_ptr<IronMan::AsmHelper64,std::default_delete<IronMan::AsmHelper64> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA ENDP ; `IronMan::AsmFactory::GetAssembler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv78 = 40
tv73 = 48
$T2 = 56
__$ReturnUdt$ = 80
?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA PROC ; `IronMan::AsmFactory::GetAssembler'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >::~unique_ptr<IronMan::IAsmHelper,std::default_delete<IronMan::IAsmHelper> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetAssembler@AsmFactory@IronMan@@SA?AV?$unique_ptr@VIAsmHelper@IronMan@@U?$default_delete@VIAsmHelper@IronMan@@@std@@@std@@XZ@4HA ENDP ; `IronMan::AsmFactory::GetAssembler'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Asm\IAsmHelper.hpp
;	COMDAT ??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ
_TEXT	SEGMENT
this$ = 8
??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ PROC ; IronMan::IAsmHelper::operator->, COMDAT

; 90   : 		inline asmjit::X86Assembler* operator ->() { return &_assembler; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 168				; 000000a8H
	ret	0
??CIAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ENDP ; IronMan::IAsmHelper::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Asm\IAsmHelper.hpp
;	COMDAT ?assembler@IAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ
_TEXT	SEGMENT
this$ = 8
?assembler@IAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ PROC ; IronMan::IAsmHelper::assembler, COMDAT

; 89   : 		inline asmjit::X86Assembler* assembler() { return &_assembler; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 168				; 000000a8H
	ret	0
?assembler@IAsmHelper@IronMan@@QEAAPEAUX86Assembler@asmjit@@XZ ENDP ; IronMan::IAsmHelper::assembler
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Asm\AsmStack.hpp
;	COMDAT ?getTotalSize@AsmStackAllocator@IronMan@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?getTotalSize@AsmStackAllocator@IronMan@@QEBA_JXZ PROC	; IronMan::AsmStackAllocator::getTotalSize, COMDAT

; 72   : 		inline intptr_t getTotalSize() const { return disp_ofst; };

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+8]
	ret	0
?getTotalSize@AsmStackAllocator@IronMan@@QEBA_JXZ ENDP	; IronMan::AsmStackAllocator::getTotalSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Asm\AsmStack.hpp
;	COMDAT ??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z
_TEXT	SEGMENT
tv74 = 32
this$ = 64
pAsm$ = 72
baseval$ = 80
??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z PROC ; IronMan::AsmStackAllocator::AsmStackAllocator, COMDAT

; 20   : 		{

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 18   : 			: _pAsm(pAsm)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR pAsm$[rsp]
	mov	QWORD PTR [rax], rcx

; 19   : 			, disp_ofst(pAsm->getArch() == asmjit::kArch::kArchX64 ? baseval : sizeof(uint64_t))

	mov	rcx, QWORD PTR pAsm$[rsp]
	call	?getArch@CodeGen@asmjit@@QEBAIXZ	; asmjit::CodeGen::getArch
	cmp	eax, 2
	jne	SHORT $LN3@AsmStackAl
	movsxd	rax, DWORD PTR baseval$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN4@AsmStackAl
$LN3@AsmStackAl:
	mov	QWORD PTR tv74[rsp], 8
$LN4@AsmStackAl:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR tv74[rsp]
	mov	DWORD PTR [rax+8], ecx

; 21   : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0AsmStackAllocator@IronMan@@QEAA@PEAUX86Assembler@asmjit@@H@Z ENDP ; IronMan::AsmStackAllocator::AsmStackAllocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z PROC	; asmjit::X86Assembler::xor_, COMDAT

; 1419 :   INST_2x(xor_, kX86InstIdXor, X86GpReg, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 1052				; 0000041cH
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?xor_@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ENDP	; asmjit::X86Assembler::xor_
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z PROC	; asmjit::X86Assembler::sub, COMDAT

; 1388 :   INST_2i(sub, kX86InstIdSub, X86GpReg, Imm)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 609				; 00000261H
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?sub@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z ENDP	; asmjit::X86Assembler::sub
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z PROC	; asmjit::X86Assembler::shr, COMDAT

; 1339 :   INST_2x(shr, kX86InstIdShr, X86GpReg, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 593				; 00000251H
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?shr@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ENDP	; asmjit::X86Assembler::shr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z PROC	; asmjit::X86Assembler::shl, COMDAT

; 1328 :   INST_2x(shl, kX86InstIdShl, X86GpReg, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 590				; 0000024eH
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?shl@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ENDP	; asmjit::X86Assembler::shl
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z PROC	; asmjit::X86Assembler::ror, COMDAT

; 1267 :   INST_2x(ror, kX86InstIdRor, X86GpReg, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 542				; 0000021eH
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?ror@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ENDP	; asmjit::X86Assembler::ror
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z PROC	; asmjit::X86Assembler::rol, COMDAT

; 1256 :   INST_2x(rol, kX86InstIdRol, X86GpReg, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 541				; 0000021dH
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?rol@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ENDP	; asmjit::X86Assembler::rol
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z PROC ; asmjit::X86Assembler::mov, COMDAT

; 1040 :   INST_2x(mov, kX86InstIdMov, X86Mem, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 291				; 00000123H
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?mov@X86Assembler@asmjit@@QEAAIAEBUX86Mem@2@AEBUX86GpReg@2@@Z ENDP ; asmjit::X86Assembler::mov
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z PROC ; asmjit::X86Assembler::mov, COMDAT

; 1036 :   INST_2x(mov, kX86InstIdMov, X86GpReg, X86Mem)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 291				; 00000123H
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@AEBUX86Mem@2@@Z ENDP ; asmjit::X86Assembler::mov
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z PROC	; asmjit::X86Assembler::mov, COMDAT

; 1034 :   INST_2x(mov, kX86InstIdMov, X86GpReg, X86GpReg)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 291				; 00000123H
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?mov@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@0@Z ENDP	; asmjit::X86Assembler::mov
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.h
;	COMDAT ?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z
_TEXT	SEGMENT
this$ = 48
o0$ = 56
o1$ = 64
?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z PROC	; asmjit::X86Assembler::add, COMDAT

; 813  :   INST_2i(add, kX86InstIdAdd, X86GpReg, Imm)

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, 2
	mov	rcx, QWORD PTR this$[rsp]
	call	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z ; asmjit::Assembler::emit
	add	rsp, 40					; 00000028H
	ret	0
?add@X86Assembler@asmjit@@QEAAIAEBUX86GpReg@2@_K@Z ENDP	; asmjit::X86Assembler::add
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
base$ = 56
disp$ = 64
?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z PROC ; asmjit::x86::qword_ptr

; 1877 : ASMJIT_EXPAND_PTR_REG(qword, 8)

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9d, 8
	mov	r8d, DWORD PTR disp$[rsp]
	mov	rdx, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z ; asmjit::X86Mem::X86Mem
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?qword_ptr@x86@asmjit@@YA?AUX86Mem@2@AEBUX86GpReg@2@H@Z ENDP ; asmjit::x86::qword_ptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z
_TEXT	SEGMENT
base$ = 8
?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z PROC	; asmjit::X86Mem::_getGpdFlags, COMDAT

; 1514 :   static ASMJIT_INLINE uint32_t _getGpdFlags(const Operand& base) {

	mov	QWORD PTR [rsp+8], rcx

; 1515 :     return (base._vreg.size & 0x4) << (kX86MemGpdIndex - 2);

	mov	rax, QWORD PTR base$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	eax, 4
	shl	eax, 1

; 1516 :   }

	ret	0
?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z ENDP	; asmjit::X86Mem::_getGpdFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z
_TEXT	SEGMENT
tv95 = 48
tv93 = 52
this$ = 80
base$ = 88
disp$ = 96
size$ = 104
??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z PROC		; asmjit::X86Mem::X86Mem, COMDAT

; 1092 :   ASMJIT_INLINE X86Mem(const X86GpReg& base, int32_t disp, uint32_t size = 0) : BaseMem(NoInit) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::BaseMem::BaseMem

; 1093 :     _init_packed_op_sz_b0_b1_id(kOperandTypeMem, size, kMemTypeBaseIndex,

	mov	rcx, QWORD PTR base$[rsp]
	call	?getRegIndex@Reg@asmjit@@QEBAIXZ	; asmjit::Reg::getRegIndex
	mov	DWORD PTR tv95[rsp], eax
	mov	rcx, QWORD PTR base$[rsp]
	call	?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z ; asmjit::X86Mem::_getGpdFlags
	mov	DWORD PTR tv93[rsp], eax
	mov	eax, DWORD PTR tv95[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR tv93[rsp]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8d, DWORD PTR size$[rsp]
	mov	edx, 3
	mov	rcx, QWORD PTR this$[rsp]
	call	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id

; 1094 :       _getGpdFlags(base)
; 1095 :         + (kX86MemVSibGpz << kX86MemVSibIndex),
; 1096 :       base.getRegIndex());
; 1097 :     _init_packed_d2_d3(kInvalidValue, disp);

	mov	r8d, DWORD PTR disp$[rsp]
	mov	edx, -1					; ffffffffH
	mov	rcx, QWORD PTR this$[rsp]
	call	?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z ; asmjit::Operand::_init_packed_d2_d3
	npad	1

; 1098 :   }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0X86Mem@asmjit@@QEAA@AEBUX86GpReg@1@HI@Z ENDP		; asmjit::X86Mem::X86Mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::BaseMem::BaseMem, COMDAT

; 645  :   explicit ASMJIT_INLINE BaseMem(const _NoInit&) : Operand(NoInit) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::Operand::Operand
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::BaseMem::BaseMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getRegIndex@Reg@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getRegIndex@Reg@asmjit@@QEBAIXZ PROC			; asmjit::Reg::getRegIndex, COMDAT

; 584  :   ASMJIT_INLINE uint32_t getRegIndex() const {

	mov	QWORD PTR [rsp+8], rcx

; 585  :     return _vreg.index;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+2]

; 586  :   }

	ret	0
?getRegIndex@Reg@asmjit@@QEBAIXZ ENDP			; asmjit::Reg::getRegIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z
_TEXT	SEGMENT
tv72 = 32
this$ = 64
u2$ = 72
u3$ = 80
?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z PROC	; asmjit::Operand::_init_packed_d2_d3, COMDAT

; 352  :   ASMJIT_INLINE void _init_packed_d2_d3(uint32_t u2, uint32_t u3) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 353  :     _packed[1].setPacked_2x32(u2, u3);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, DWORD PTR u3$[rsp]
	mov	edx, DWORD PTR u2$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ; asmjit::UInt64::setPacked_2x32
	npad	1

; 354  :   }

	add	rsp, 56					; 00000038H
	ret	0
?_init_packed_d2_d3@Operand@asmjit@@QEAAXII@Z ENDP	; asmjit::Operand::_init_packed_d2_d3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z
_TEXT	SEGMENT
tv77 = 32
this$ = 64
op$ = 72
sz$ = 80
r0$ = 88
r1$ = 96
id$ = 104
?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z PROC ; asmjit::Operand::_init_packed_op_sz_b0_b1_id, COMDAT

; 334  :   ASMJIT_INLINE void _init_packed_op_sz_b0_b1_id(uint32_t op, uint32_t sz, uint32_t r0, uint32_t r1, uint32_t id) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 335  :     // This hack is not for performance, but to decrease the size of the binary
; 336  :     // generated when constructing AsmJit operands (mostly for third parties).
; 337  :     // Some compilers are not able to join four BYTE writes to a single DWORD
; 338  :     // write. Because the 'a', 'b', 'c' and 'd' variables are usually compile
; 339  :     // time constants the compiler can do a really nice job if they are joined
; 340  :     // by using bitwise operations.
; 341  :     _packed[0].setPacked_2x32(IntUtil::pack32_4x8(op, sz, r0, r1), id);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv77[rsp], rax
	mov	r9d, DWORD PTR r1$[rsp]
	mov	r8d, DWORD PTR r0$[rsp]
	mov	edx, DWORD PTR sz$[rsp]
	mov	ecx, DWORD PTR op$[rsp]
	call	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z	; asmjit::IntUtil::pack32_4x8
	mov	r8d, DWORD PTR id$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv77[rsp]
	call	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ; asmjit::UInt64::setPacked_2x32
	npad	1

; 342  :   }

	add	rsp, 56					; 00000038H
	ret	0
?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ENDP ; asmjit::Operand::_init_packed_op_sz_b0_b1_id
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::Operand::Operand, COMDAT

; 312  :   explicit ASMJIT_INLINE Operand(const _NoInit&) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::Operand::Operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z
_TEXT	SEGMENT
this$ = 48
u0$ = 56
u1$ = 64
?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z PROC	; asmjit::UInt64::setPacked_2x32, COMDAT

; 498  :   ASMJIT_INLINE UInt64& setPacked_2x32(uint32_t u0, uint32_t u1) {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 499  :     if (kArchHost64Bit) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@setPacked_

; 500  :       u64 = IntUtil::pack64_2x32(u0, u1);

	mov	edx, DWORD PTR u1$[rsp]
	mov	ecx, DWORD PTR u0$[rsp]
	call	?pack64_2x32@IntUtil@asmjit@@SA_KII@Z	; asmjit::IntUtil::pack64_2x32
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 501  :     }

	jmp	SHORT $LN3@setPacked_
$LN2@setPacked_:

; 502  :     else {
; 503  :       u32[0] = u0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR u0$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 504  :       u32[1] = u1;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR u1$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN3@setPacked_:

; 505  :     }
; 506  :     return *this;

	mov	rax, QWORD PTR this$[rsp]

; 507  :   }

	add	rsp, 40					; 00000028H
	ret	0
?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ENDP	; asmjit::UInt64::setPacked_2x32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack64_2x32@IntUtil@asmjit@@SA_KII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
?pack64_2x32@IntUtil@asmjit@@SA_KII@Z PROC		; asmjit::IntUtil::pack64_2x32, COMDAT

; 102  :   static ASMJIT_INLINE uint64_t pack64_2x32(uint32_t u0, uint32_t u1) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 103  : #if defined(ASMJIT_HOST_LE)
; 104  :     return (static_cast<uint64_t>(u1) << 32) + u0;

	mov	eax, DWORD PTR u1$[rsp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR u0$[rsp]
	add	rax, rcx

; 105  : #else
; 106  :     return (static_cast<uint64_t>(u0) << 32) + u1;
; 107  : #endif // ASMJIT_HOST
; 108  :   }

	ret	0
?pack64_2x32@IntUtil@asmjit@@SA_KII@Z ENDP		; asmjit::IntUtil::pack64_2x32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
u2$ = 24
u3$ = 32
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z PROC		; asmjit::IntUtil::pack32_4x8, COMDAT

; 93   :   static ASMJIT_INLINE uint32_t pack32_4x8(uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3) {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 94   : #if defined(ASMJIT_HOST_LE)
; 95   :     return u0 + (u1 << 8) + (u2 << 16) + (u3 << 24);

	mov	eax, DWORD PTR u1$[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR u0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR u2$[rsp]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, DWORD PTR u3$[rsp]
	shl	ecx, 24
	add	eax, ecx

; 96   : #else
; 97   :     return (u0 << 24) + (u1 << 16) + (u2 << 8) + u3;
; 98   : #endif // ASMJIT_HOST
; 99   :   }

	ret	0
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z ENDP		; asmjit::IntUtil::pack32_4x8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?getArch@CodeGen@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getArch@CodeGen@asmjit@@QEBAIXZ PROC			; asmjit::CodeGen::getArch, COMDAT

; 160  :   ASMJIT_INLINE uint32_t getArch() const {

	mov	QWORD PTR [rsp+8], rcx

; 161  :     return _arch;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]

; 162  :   }

	ret	0
?getArch@CodeGen@asmjit@@QEBAIXZ ENDP			; asmjit::CodeGen::getArch
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.h
;	COMDAT ?IsJump@Zydis@IronMan@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 48
?IsJump@Zydis@IronMan@@QEBA_NXZ PROC			; IronMan::Zydis::IsJump, COMDAT

; 102  : 		bool IsJump() const { return IsBranchType(BTJmp); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	edx, 6144				; 00001800H
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsBranchType@Zydis@IronMan@@QEBA_NI@Z	; IronMan::Zydis::IsBranchType
	add	rsp, 40					; 00000028H
	ret	0
?IsJump@Zydis@IronMan@@QEBA_NXZ ENDP			; IronMan::Zydis::IsJump
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.h
;	COMDAT ?IsCondJump@Zydis@IronMan@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 48
?IsCondJump@Zydis@IronMan@@QEBA_NXZ PROC		; IronMan::Zydis::IsCondJump, COMDAT

; 101  : 		bool IsCondJump() const { return IsBranchType(BTCondJmp); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	edx, 1024				; 00000400H
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsBranchType@Zydis@IronMan@@QEBA_NI@Z	; IronMan::Zydis::IsBranchType
	add	rsp, 40					; 00000028H
	ret	0
?IsCondJump@Zydis@IronMan@@QEBA_NXZ ENDP		; IronMan::Zydis::IsCondJump
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 416  : [[noreturn]] inline void _Throw_tree_length_error() {

$LN3:
	sub	rsp, 40					; 00000028H

; 417  :     _Xlength_error("map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BB@GCADKGJO@map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Throw_tree:

; 418  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?Align@@YA_K_K0@Z
_TEXT	SEGMENT
tv69 = 0
val$ = 32
alignment$ = 40
?Align@@YA_K_K0@Z PROC					; Align, COMDAT

; 151  : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 152  : 	return (val % alignment == 0) ? val : (val / alignment + 1) * alignment;

	xor	edx, edx
	mov	rax, QWORD PTR val$[rsp]
	div	QWORD PTR alignment$[rsp]
	mov	rax, rdx
	test	rax, rax
	jne	SHORT $LN3@Align
	mov	rax, QWORD PTR val$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@Align
$LN3@Align:
	xor	edx, edx
	mov	rax, QWORD PTR val$[rsp]
	div	QWORD PTR alignment$[rsp]
	inc	rax
	imul	rax, QWORD PTR alignment$[rsp]
	mov	QWORD PTR tv69[rsp], rax
$LN4@Align:
	mov	rax, QWORD PTR tv69[rsp]

; 153  : }

	add	rsp, 24
	ret	0
?Align@@YA_K_K0@Z ENDP					; Align
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decwref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT

; 1165 :     void _Decwref() noexcept { // decrement weak reference count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1166 :         if (_MT_DECR(_Weaks) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decwref

; 1167 :             _Delete_this();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+8]
	npad	1
$LN2@Decwref:

; 1168 :         }
; 1169 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decwref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT

; 1158 :     void _Decref() noexcept { // decrement use count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1159 :         if (_MT_DECR(_Uses) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decref

; 1160 :             _Destroy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax]

; 1161 :             _Decwref();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decwref@_Ref_count_base@std@@QEAAXXZ	; std::_Ref_count_base::_Decwref
	npad	1
$LN2@Decref:

; 1162 :         }
; 1163 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 831  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 833  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 834  : 
; 835  :         // initialize basic_string data members
; 836  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 838  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 842  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 684  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 685  :         _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 686  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT

; 214  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1187 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
