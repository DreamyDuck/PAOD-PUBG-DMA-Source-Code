; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	?startCrc@Utils@IronMan@@3_NA			; IronMan::Utils::startCrc
PUBLIC	_Avx2WmemEnabledWeakValue
_BSS	SEGMENT
?startCrc@Utils@IronMan@@3_NA DB 01H DUP (?)		; IronMan::Utils::startCrc
_BSS	ENDS
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__local_stdio_printf_options
PUBLIC	_vswprintf_s_l
PUBLIC	vswprintf_s
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	sprintf
PUBLIC	?_Is_constant_evaluated@std@@YA_NXZ		; std::_Is_constant_evaluated
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
PUBLIC	?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z	; std::_WChar_traits<wchar_t>::length
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z		; std::_WChar_traits<wchar_t>::eq
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??0?$allocator@_W@std@@QEAA@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
PUBLIC	?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty
PUBLIC	?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::rfind
PUBLIC	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z ; std::to_string
PUBLIC	??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z ; std::_UIntegral_to_string<char,unsigned long>
PUBLIC	NtCurrentTeb
PUBLIC	?LastNtStatus@@YAJXZ				; LastNtStatus
PUBLIC	?SetLastNtStatus@@YAJJ@Z			; SetLastNtStatus
PUBLIC	?hash_@@YA?B_KPEBD@Z				; hash_
PUBLIC	?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; hash_
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z ; IronMan::Utils::QueryMemory
PUBLIC	?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z ; IronMan::Utils::GetTextBetween
PUBLIC	?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z ; IronMan::Utils::split
PUBLIC	?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ ; IronMan::Utils::FormatString
PUBLIC	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
PUBLIC	?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; IronMan::Utils::UnicodeToUTF8
PUBLIC	?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; IronMan::Utils::UTF8ToUnicode
PUBLIC	?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; IronMan::Utils::UnicodeToANSI
PUBLIC	?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; IronMan::Utils::ANSIToUnicode
PUBLIC	?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z ; IronMan::Utils::UTF8ToANSI
PUBLIC	?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z ; IronMan::Utils::ANSIToUTF8
PUBLIC	?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z ; IronMan::Utils::SplitString
PUBLIC	?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z ; IronMan::Utils::SplitText
PUBLIC	?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z ; IronMan::Utils::StripPath
PUBLIC	?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z ; IronMan::Utils::StripPath
PUBLIC	?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z ; IronMan::Utils::ToLower
PUBLIC	?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z ; IronMan::Utils::ToUpper
PUBLIC	?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ; IronMan::Utils::ToLower
PUBLIC	?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ; IronMan::Utils::ToUpper
PUBLIC	?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z	; IronMan::Utils::hasNullTerminator
PUBLIC	?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IronMan::Utils::FileExists
PUBLIC	?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::FileExists
PUBLIC	?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; IronMan::Utils::GetExePath
PUBLIC	?GetModuleLen@Utils@IronMan@@YAKPEAUHINSTANCE__@@@Z ; IronMan::Utils::GetModuleLen
PUBLIC	?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z ; IronMan::Utils::MessageBoxTermination
PUBLIC	?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::writeToClipboard
PUBLIC	?IsAdministratorRun@Utils@IronMan@@YAHXZ	; IronMan::Utils::IsAdministratorRun
PUBLIC	?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z	; IronMan::Utils::ReadLibrary
PUBLIC	?RandomFloat@Utils@IronMan@@YAMXZ		; IronMan::Utils::RandomFloat
PUBLIC	?RandomRange@Utils@IronMan@@YAMMM@Z		; IronMan::Utils::RandomRange
PUBLIC	?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::isAlphanumericWithSpecialChars
PUBLIC	?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::StringIsValid
PUBLIC	?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::StringIsValid2
PUBLIC	?checkAndCreateDirectory@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::checkAndCreateDirectory
PUBLIC	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z	; IronMan::Utils::IsSafeReadPtr
PUBLIC	?IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z	; IronMan::Utils::IsSafeWritePtr
PUBLIC	?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z ; IronMan::Utils::SimpleHttpGet
PUBLIC	?GetMachineCode@Utils@IronMan@@YA_KXZ		; IronMan::Utils::GetMachineCode
PUBLIC	??0CriticalSection@IronMan@@QEAA@XZ		; IronMan::CriticalSection::CriticalSection
PUBLIC	??1CriticalSection@IronMan@@QEAA@XZ		; IronMan::CriticalSection::~CriticalSection
PUBLIC	?lock@CriticalSection@IronMan@@QEAAXXZ		; IronMan::CriticalSection::lock
PUBLIC	?unlock@CriticalSection@IronMan@@QEAAXXZ	; IronMan::CriticalSection::unlock
PUBLIC	??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ; IronMan::CSLock::CSLock
PUBLIC	??1CSLock@IronMan@@QEAA@XZ			; IronMan::CSLock::~CSLock
PUBLIC	??Rrandom_device@std@@QEAAIXZ			; std::random_device::operator()
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset
PUBLIC	?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
PUBLIC	?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAX_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Verify_offset
PUBLIC	?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Seek_to
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator()
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?Instance@DynImport@IronMan@@SAAEAV12@XZ	; IronMan::DynImport::Instance
PUBLIC	??0DynImport@IronMan@@QEAA@XZ			; IronMan::DynImport::DynImport
PUBLIC	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z		; std::equal_to<unsigned __int64>::operator()
PUBLIC	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
PUBLIC	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z		; std::hash<unsigned __int64>::_Do_hash
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
PUBLIC	??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate
PUBLIC	??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter
PUBLIC	?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
PUBLIC	??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	??1DynImport@IronMan@@QEAA@XZ			; IronMan::DynImport::~DynImport
PUBLIC	??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance''
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	??0?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,LogMemory> >::allocator<std::pair<unsigned __int64 const ,LogMemory> >
PUBLIC	??0?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::deallocate
PUBLIC	??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
PUBLIC	??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Unchecked_end
PUBLIC	?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >
PUBLIC	??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
PUBLIC	??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
PUBLIC	?right_rotate@Utils@IronMan@@YAIII@Z		; IronMan::Utils::right_rotate
PUBLIC	?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z ; IronMan::Utils::pad
PUBLIC	??0?$allocator@E@std@@QEAA@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z	; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::allocator<unsigned char>,0>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
PUBLIC	?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z ; std::copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
PUBLIC	??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z ; IronMan::DynImport::safeCall<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64),void const *,_MEMORY_BASIC_INFORMATION * &,unsigned __int64>
PUBLIC	??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64)>
PUBLIC	??$forward@PEBX@std@@YA$$QEAPEBXAEAPEBX@Z	; std::forward<void const *>
PUBLIC	??$forward@AEAPEAU_MEMORY_BASIC_INFORMATION@@@std@@YAAEAPEAU_MEMORY_BASIC_INFORMATION@@AEAPEAU1@@Z ; std::forward<_MEMORY_BASIC_INFORMATION * &>
PUBLIC	??$forward@_K@std@@YA$$QEA_KAEA_K@Z		; std::forward<unsigned __int64>
PUBLIC	??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z ; vswprintf_s<4096>
PUBLIC	??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z ; _vsnprintf_s<4096>
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,unsigned short (__cdecl*)(unsigned short)>
PUBLIC	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
PUBLIC	??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<int (__cdecl*)(void *,unsigned long,wchar_t *,unsigned long *)>
PUBLIC	??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>
PUBLIC	??0?$uniform_real@M@std@@QEAA@MM@Z		; std::uniform_real<float>::uniform_real<float>
PUBLIC	??0param_type@?$uniform_real@M@std@@QEAA@MM@Z	; std::uniform_real<float>::param_type::param_type
PUBLIC	?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z ; std::uniform_real<float>::param_type::_Init
PUBLIC	??0?$uniform_real_distribution@M@std@@QEAA@MM@Z	; std::uniform_real_distribution<float>::uniform_real_distribution<float>
PUBLIC	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_real_distribution<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Utils::GetCPUID
PUBLIC	?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Utils::GetVolumeSerialNumber
PUBLIC	?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Utils::GetMACAddress
PUBLIC	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEBV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEBV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > const >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::move<std::allocator<unsigned char> &>
PUBLIC	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
PUBLIC	??$_Adl_verify_range@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z ; std::_Traits_rfind_ch<std::char_traits<wchar_t> >
PUBLIC	??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z	; std::_Refancy<wchar_t *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
PUBLIC	??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
PUBLIC	??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ; std::_Traits_rfind_ch<std::char_traits<char> >
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z		; std::_Refancy<char const *,0>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > ><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
PUBLIC	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
PUBLIC	??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> ><std::pair<unsigned __int64 const ,LogMemory> >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
PUBLIC	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
PUBLIC	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z		; std::_Get_size_of_n<40>
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z	; std::_UIntegral_to_buff<char,unsigned long>
PUBLIC	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > &>
PUBLIC	??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
PUBLIC	??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const &>
PUBLIC	??$_Adl_verify_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
PUBLIC	??$move@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AEAV10@@Z ; std::move<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
PUBLIC	??$_Idl_distance@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEBE@std@@YA?A_PAEBQEBE0@Z ; std::_Idl_distance<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char const *>
PUBLIC	??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,__int64>
PUBLIC	??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::move<unsigned char * &>
PUBLIC	??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ; std::_Copy_unchecked<unsigned char const *,unsigned char const *,unsigned char *>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
PUBLIC	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > const &>
PUBLIC	??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PEA_W@std@@YA?A_PAEBQEA_W0@Z ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t *>
PUBLIC	??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &,__int64>
PUBLIC	??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t * &>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
PUBLIC	??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA?A_PAEBQEAD0@Z ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>
PUBLIC	??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>
PUBLIC	??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>
PUBLIC	??$distance@PEBD@std@@YA_JPEBD0@Z		; std::distance<char const *>
PUBLIC	??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z	; std::move<char const * &>
PUBLIC	??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char const *,char const *,unsigned __int64>
PUBLIC	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_real<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::forward<std::allocator<unsigned char> >
PUBLIC	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::forward<unsigned char *>
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z ; std::_Find_last_vectorized<wchar_t const ,wchar_t>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ; std::_Find_last_vectorized<char const ,char>
PUBLIC	??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ; std::_Search_vectorized<char const ,char const >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
PUBLIC	??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > ><std::pair<unsigned __int64 const ,LogMemory> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
PUBLIC	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@M@std@@YA$$QEAMAEAM@Z		; std::forward<float>
PUBLIC	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z	; std::addressof<wchar_t *>
PUBLIC	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z	; std::forward<wchar_t * &>
PUBLIC	??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ; std::forward<std::allocator<wchar_t> const &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
PUBLIC	??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z ; std::_Unfancy_maybe_null<wchar_t const >
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to
PUBLIC	??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z	; std::_Unfancy_maybe_null<char const >
PUBLIC	??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
PUBLIC	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
PUBLIC	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>
PUBLIC	??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>
PUBLIC	??$forward@AEBV?$allocator@E@std@@@std@@YAAEBV?$allocator@E@0@AEBV10@@Z ; std::forward<std::allocator<unsigned char> const &>
PUBLIC	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >
PUBLIC	??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ; std::_Copy_memmove<unsigned char const *,unsigned char *>
PUBLIC	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>
PUBLIC	??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$_Copy_n_unchecked4@PEBD_KPEA_W@std@@YAPEA_WPEBD_KPEA_W@Z ; std::_Copy_n_unchecked4<char const *,unsigned __int64,wchar_t *>
PUBLIC	??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z ; std::uniform_real<float>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
PUBLIC	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z	; std::forward<wchar_t * const &>
PUBLIC	??$addressof@U?$pair@$$CB_KULogMemory@@@std@@@std@@YAPEAU?$pair@$$CB_KULogMemory@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,LogMemory> >
PUBLIC	??$destroy@U?$pair@$$CB_KULogMemory@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KULogMemory@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::destroy<std::pair<unsigned __int64 const ,LogMemory> >
PUBLIC	??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
PUBLIC	??$forward@AEAV?$allocator@D@std@@@std@@YAAEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> &>
PUBLIC	??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ; std::_Refancy_maybe_null<unsigned char *,0>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >
PUBLIC	??$_Refancy_maybe_null@PEB_W$0A@@std@@YAPEB_WPEB_W@Z ; std::_Refancy_maybe_null<wchar_t const *,0>
PUBLIC	??$_Refancy_maybe_null@PEBD$0A@@std@@YAPEBDPEBD@Z ; std::_Refancy_maybe_null<char const *,0>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
PUBLIC	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
PUBLIC	??$_Unfancy@E@std@@YAPEAEPEAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z		; std::_Fill_memset<unsigned char *,unsigned char>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
PUBLIC	??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>
PUBLIC	??$_To_address@PEBE@std@@YA?A_PAEBQEBE@Z	; std::_To_address<unsigned char const *>
PUBLIC	??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z ; std::_Copy_memmove_tail<unsigned char *>
PUBLIC	??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ; std::_Nrand_impl<float,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?A_TAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
PUBLIC	??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
PUBLIC	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z		; std::_Get_size_of_n<32>
PUBLIC	??$_Get_size_of_n@$01@std@@YA_K_K@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Hash_representation@_K@std@@YA_KAEB_K@Z	; std::_Hash_representation<unsigned __int64>
PUBLIC	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z	; std::_To_address<unsigned char *>
PUBLIC	??$forward@AEBE@std@@YAAEBEAEBE@Z		; std::forward<unsigned char const &>
PUBLIC	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ; std::generate_canonical<float,24,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z	; std::_Fnv1a_append_value<unsigned __int64>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_04JFFKLGJF@?$CF02X@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance
PUBLIC	?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
PUBLIC	?VirutalMap@Utils@IronMan@@3V?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@A ; IronMan::Utils::VirutalMap
PUBLIC	??_C@_0N@MAAAEOL@VirtualQuery@			; `string'
PUBLIC	??_C@_0BL@DJAAHBPE@QueryFullProcessImageNameW@	; `string'
PUBLIC	??_C@_0BJ@ONFBAHNE@Failed?5to?5open?5clipboard@	; `string'
PUBLIC	??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ ; `string'
PUBLIC	??_C@_0BK@DPKMAAKB@Failed?5to?5empty?5clipboard@ ; `string'
PUBLIC	??_C@_0CN@CKEHACNA@Failed?5to?5allocate?5memory?5for?5c@ ; `string'
PUBLIC	??_C@_0CJ@IEFDILKB@Failed?5to?5lock?5memory?5for?5clipb@ ; `string'
PUBLIC	??_C@_0DC@LOMALFKN@Copy?5the?5URL?5successfully?0Press@ ; `string'
PUBLIC	??_C@_04OHJIHAFH@None@				; `string'
PUBLIC	??_C@_1CI@POKKGHLI@?$AAW?$AAi?$AAn?$AAH?$AAT?$AAT?$AAP?$AA?5?$AAE?$AAx?$AAa?$AAm?$AAp?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_0BH@FHIJFMJL@WinHttpOpen?5failed?3?5?$CFx@ ; `string'
PUBLIC	??_C@_0BL@NNCNJHDB@WinHttpCrackUrl?5failed?3?5?$CFx@ ; `string'
PUBLIC	??_C@_0BK@IHJKAELJ@WinHttpConnect?5failed?3?5?$CFx@ ; `string'
PUBLIC	??_C@_17KCHPOIEI@?$AAG?$AAE?$AAT@		; `string'
PUBLIC	??_C@_0BO@DLFGADJM@WinHttpOpenRequest?5failed?3?5?$CFx@ ; `string'
PUBLIC	??_C@_0CE@DNKGMBPP@WinHttpAddRequestHeaders?5failed@ ; `string'
PUBLIC	??_C@_0BO@NBEGPBEP@WinHttpSendRequest?5failed?3?5?$CFx@ ; `string'
PUBLIC	??_C@_0CC@CGBDJCIK@WinHttpReceiveResponse?5failed?3?5@ ; `string'
PUBLIC	??_C@_0CF@HJMNAIEA@WinHttpQueryDataAvailable?5faile@ ; `string'
PUBLIC	??_C@_0O@NALGGDJF@Out?5of?5memory@		; `string'
PUBLIC	??_C@_0BL@EBICDIGF@WinHttpReadData?5failed?3?5?$CFx@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BK@ENBLOMCO@Can?8t?5open?5DLL?5file?5?$CC?$CFs?$CC?4@ ; `string'
PUBLIC	??_C@_03GIOIKFCO@C?3?2@				; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	__real@33800000
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	atexit:PROC
EXTRN	_Init_thread_header:PROC
EXTRN	_Init_thread_abort:PROC
EXTRN	_Init_thread_footer:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	__stdio_common_vswprintf_s:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	__stdio_common_vsnprintf_s:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	wcslen:PROC
EXTRN	strcpy_s:PROC
EXTRN	strlen:PROC
EXTRN	towupper:PROC
EXTRN	towlower:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	__std_find_last_trivial_1:PROC
EXTRN	__std_find_last_trivial_2:PROC
EXTRN	__std_search_1:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	isalnum:PROC
EXTRN	toupper:PROC
EXTRN	tolower:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_GetFileAttributesA:PROC
EXTRN	__imp_GetFileAttributesW:PROC
EXTRN	__imp_GetVolumeInformationA:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_GetCurrentThread:PROC
EXTRN	__imp_OpenProcessToken:PROC
EXTRN	__imp_OpenThreadToken:PROC
EXTRN	__imp_GetModuleFileNameW:PROC
EXTRN	__imp_AccessCheck:PROC
EXTRN	__imp_AddAccessAllowedAce:PROC
EXTRN	__imp_AllocateAndInitializeSid:PROC
EXTRN	__imp_FreeSid:PROC
EXTRN	__imp_GetLengthSid:PROC
EXTRN	__imp_ImpersonateSelf:PROC
EXTRN	__imp_InitializeAcl:PROC
EXTRN	__imp_InitializeSecurityDescriptor:PROC
EXTRN	__imp_IsValidSecurityDescriptor:PROC
EXTRN	__imp_RevertToSelf:PROC
EXTRN	__imp_SetSecurityDescriptorDacl:PROC
EXTRN	__imp_SetSecurityDescriptorGroup:PROC
EXTRN	__imp_SetSecurityDescriptorOwner:PROC
EXTRN	__imp_GlobalAlloc:PROC
EXTRN	__imp_GlobalUnlock:PROC
EXTRN	__imp_GlobalLock:PROC
EXTRN	__imp_GlobalFree:PROC
EXTRN	__imp_LocalAlloc:PROC
EXTRN	__imp_LocalFree:PROC
EXTRN	__imp_IsBadReadPtr:PROC
EXTRN	__imp_IsBadWritePtr:PROC
EXTRN	__imp_OpenClipboard:PROC
EXTRN	__imp_CloseClipboard:PROC
EXTRN	__imp_SetClipboardData:PROC
EXTRN	__imp_EmptyClipboard:PROC
EXTRN	__imp_MultiByteToWideChar:PROC
EXTRN	__imp_WideCharToMultiByte:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	?Print@Console@IronMan@@YA_NPEBDZZ:PROC		; IronMan::Console::Print
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	_access:PROC
EXTRN	?_Random_device@std@@YAIXZ:PROC			; std::_Random_device
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	__imp_WinHttpCrackUrl:PROC
EXTRN	__imp_WinHttpOpen:PROC
EXTRN	__imp_WinHttpCloseHandle:PROC
EXTRN	__imp_WinHttpConnect:PROC
EXTRN	__imp_WinHttpReadData:PROC
EXTRN	__imp_WinHttpQueryDataAvailable:PROC
EXTRN	__imp_WinHttpOpenRequest:PROC
EXTRN	__imp_WinHttpAddRequestHeaders:PROC
EXTRN	__imp_WinHttpSendRequest:PROC
EXTRN	__imp_WinHttpReceiveResponse:PROC
EXTRN	?InitializeOnce@IronMan@@YA_NXZ:PROC		; IronMan::InitializeOnce
EXTRN	_mkdir:PROC
EXTRN	__imp_GetAdaptersInfo:PROC
EXTRN	_CxxThrowException:PROC
EXTRN	__C_specific_handler:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	_Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
_BSS	ENDS
;	COMDAT ?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A
_BSS	SEGMENT
?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A DB 068H DUP (?) ; `IronMan::DynImport::Instance'::`2'::instance
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA DD 01H DUP (?) ; `IronMan::DynImport::Instance'::`2'::$TSS0
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?VirutalMap@Utils@IronMan@@3V?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@A DB 040H DUP (?) ; IronMan::Utils::VirutalMap
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vswprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+110
	DD	imagerel $unwind$_vswprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vswprintf_s DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$vswprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+126
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z DD imagerel $LN5
	DD	imagerel $LN5+85
	DD	imagerel $unwind$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z DD imagerel $LN5
	DD	imagerel $LN5+53
	DD	imagerel $unwind$?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+172
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DD imagerel $LN12
	DD	imagerel $LN12+1063
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+411
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+252
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+252
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+203
	DD	imagerel $unwind$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN5
	DD	imagerel $LN5+105
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+123
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA DD imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+176
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+415
	DD	imagerel $unwind$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA DD imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+175
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD imagerel ?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DD	imagerel ?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN7
	DD	imagerel $LN7+210
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA DD imagerel ?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA DD imagerel ?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA
	DD	imagerel ?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA DD imagerel ?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LastNtStatus@@YAJXZ DD imagerel $LN3
	DD	imagerel $LN3+20
	DD	imagerel $unwind$?LastNtStatus@@YAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetLastNtStatus@@YAJJ@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?SetLastNtStatus@@YAJJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hash_@@YA?B_KPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$?hash_@@YA?B_KPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z DD imagerel $LN4
	DD	imagerel $LN4+160
	DD	imagerel $unwind$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA DD imagerel ?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA
	DD	imagerel ?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z DD imagerel $LN12
	DD	imagerel $LN12+558
	DD	imagerel $unwind$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA DD imagerel ?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
	DD	imagerel ?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
$pdata$?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA DD imagerel ?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
	DD	imagerel ?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
$pdata$?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA DD imagerel ?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
	DD	imagerel ?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DD imagerel $LN13
	DD	imagerel $LN13+340
	DD	imagerel $unwind$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+41
	DD	imagerel $unwind$?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ DD imagerel $LN5
	DD	imagerel $LN5+186
	DD	imagerel $unwind$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA DD imagerel ?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA
	DD	imagerel ?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ DD imagerel $LN5
	DD	imagerel $LN5+191
	DD	imagerel $unwind$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA DD imagerel ?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA
	DD	imagerel ?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD imagerel $LN6
	DD	imagerel $LN6+351
	DD	imagerel $unwind$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD imagerel ?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
	DD	imagerel ?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
$pdata$?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD imagerel ?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
	DD	imagerel ?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DD imagerel $LN6
	DD	imagerel $LN6+341
	DD	imagerel $unwind$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD imagerel ?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
	DD	imagerel ?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
$pdata$?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD imagerel ?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
	DD	imagerel ?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD imagerel $LN7
	DD	imagerel $LN7+317
	DD	imagerel $unwind$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD imagerel ?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
	DD	imagerel ?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
$pdata$?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD imagerel ?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
	DD	imagerel ?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DD imagerel $LN6
	DD	imagerel $LN6+312
	DD	imagerel $unwind$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD imagerel ?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
	DD	imagerel ?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
$pdata$?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD imagerel ?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
	DD	imagerel ?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DD imagerel $LN6
	DD	imagerel $LN6+128
	DD	imagerel $unwind$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD imagerel ?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
	DD	imagerel ?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
$pdata$?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD imagerel ?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
	DD	imagerel ?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DD imagerel $LN6
	DD	imagerel $LN6+128
	DD	imagerel $unwind$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD imagerel ?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
	DD	imagerel ?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
$pdata$?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD imagerel ?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
	DD	imagerel ?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DD imagerel $LN13
	DD	imagerel $LN13+456
	DD	imagerel $unwind$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$pdata$?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD imagerel ?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DD	imagerel ?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA+41
	DD	imagerel $unwind$?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z DD imagerel $LN13
	DD	imagerel $LN13+491
	DD	imagerel $unwind$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD imagerel ?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DD	imagerel ?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
$pdata$?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD imagerel ?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DD	imagerel ?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
$pdata$?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD imagerel ?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DD	imagerel ?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
$pdata$?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD imagerel ?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DD	imagerel ?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA+24
	DD	imagerel $unwind$?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
$pdata$?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD imagerel ?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DD	imagerel ?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
$pdata$?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD imagerel ?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DD	imagerel ?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA+41
	DD	imagerel $unwind$?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z DD imagerel $LN14
	DD	imagerel $LN14+454
	DD	imagerel $unwind$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA DD imagerel ?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA
	DD	imagerel ?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA
$pdata$?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA DD imagerel ?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA
	DD	imagerel ?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z DD imagerel $LN14
	DD	imagerel $LN14+460
	DD	imagerel $unwind$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA DD imagerel ?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA
	DD	imagerel ?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA
$pdata$?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA DD imagerel ?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA
	DD	imagerel ?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DD imagerel $LN6
	DD	imagerel $LN6+236
	DD	imagerel $unwind$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD imagerel ?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
$pdata$?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD imagerel ?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DD imagerel $LN6
	DD	imagerel $LN6+236
	DD	imagerel $unwind$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD imagerel ?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
$pdata$?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD imagerel ?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DD imagerel $LN6
	DD	imagerel $LN6+236
	DD	imagerel $unwind$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD imagerel ?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
$pdata$?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD imagerel ?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DD imagerel $LN6
	DD	imagerel $LN6+236
	DD	imagerel $unwind$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD imagerel ?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
$pdata$?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD imagerel ?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
	DD	imagerel ?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z DD imagerel $LN14
	DD	imagerel $LN14+115
	DD	imagerel $unwind$?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA DD imagerel ?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA
	DD	imagerel ?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA+13
	DD	imagerel $unwind$?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
$pdata$?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$pdata$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DD imagerel $LN8
	DD	imagerel $LN8+251
	DD	imagerel $unwind$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA
$pdata$?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA DD imagerel ?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA
	DD	imagerel ?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetModuleLen@Utils@IronMan@@YAKPEAUHINSTANCE__@@@Z DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?GetModuleLen@Utils@IronMan@@YAKPEAUHINSTANCE__@@@Z
$pdata$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z DD imagerel $LN5
	DD	imagerel $LN5+41
	DD	imagerel $unwind$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA DD imagerel ?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA
	DD	imagerel ?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN12
	DD	imagerel $LN12+935
	DD	imagerel $unwind$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$pdata$?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$pdata$?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$pdata$?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$pdata$?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?IsAdministratorRun@Utils@IronMan@@YAHXZ DD imagerel $LN38
	DD	imagerel $LN38+996
	DD	imagerel $unwind$?IsAdministratorRun@Utils@IronMan@@YAHXZ
$pdata$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z DD imagerel $LN8
	DD	imagerel $LN8+421
	DD	imagerel $unwind$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA DD imagerel ?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA
	DD	imagerel ?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?RandomFloat@Utils@IronMan@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$?RandomFloat@Utils@IronMan@@YAMXZ
$pdata$?RandomRange@Utils@IronMan@@YAMMM@Z DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$?RandomRange@Utils@IronMan@@YAMMM@Z
$pdata$?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN8
	DD	imagerel $LN8+160
	DD	imagerel $unwind$?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$pdata$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN6
	DD	imagerel $LN6+260
	DD	imagerel $unwind$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN6
	DD	imagerel $LN6+260
	DD	imagerel $unwind$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?checkAndCreateDirectory@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN7
	DD	imagerel $LN7+74
	DD	imagerel $unwind$?checkAndCreateDirectory@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$pdata$?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+74
	DD	imagerel $unwind$?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA DD imagerel ?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA
	DD	imagerel ?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA+21
	DD	imagerel $unwind$?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+74
	DD	imagerel $unwind$?IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA DD imagerel ?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA
	DD	imagerel ?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA+21
	DD	imagerel $unwind$?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z DD imagerel $LN37
	DD	imagerel $LN37+3824
	DD	imagerel $unwind$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+41
	DD	imagerel $unwind$?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$pdata$?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD imagerel ?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DD	imagerel ?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA+27
	DD	imagerel $unwind$?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetMachineCode@Utils@IronMan@@YA_KXZ DD imagerel $LN6
	DD	imagerel $LN6+222
	DD	imagerel $unwind$?GetMachineCode@Utils@IronMan@@YA_KXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA DD imagerel ?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
	DD	imagerel ?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
$pdata$?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA DD imagerel ?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
	DD	imagerel ?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
$pdata$?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA DD imagerel ?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
	DD	imagerel ?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA+24
	DD	imagerel $unwind$?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CriticalSection@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??0CriticalSection@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CriticalSection@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??1CriticalSection@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@CriticalSection@IronMan@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?lock@CriticalSection@IronMan@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unlock@CriticalSection@IronMan@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?unlock@CriticalSection@IronMan@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CSLock@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$??1CSLock@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Rrandom_device@std@@QEAAIXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$??Rrandom_device@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+311
	DD	imagerel $unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+248
	DD	imagerel $unwind$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+205
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z DD imagerel $LN6
	DD	imagerel $LN6+173
	DD	imagerel $unwind$?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN6
	DD	imagerel $LN6+209
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+541
	DD	imagerel $unwind$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+186
	DD	imagerel $unwind$?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Instance@DynImport@IronMan@@SAAEAV12@XZ DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$?Instance@DynImport@IronMan@@SAAEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA DD imagerel ?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA
	DD	imagerel ?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0DynImport@IronMan@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$??0DynImport@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1DynImport@IronMan@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$??1DynImport@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EVirutalMap@Utils@IronMan@@YAXXZ DD imagerel ??__EVirutalMap@Utils@IronMan@@YAXXZ
	DD	imagerel ??__EVirutalMap@Utils@IronMan@@YAXXZ+34
	DD	imagerel $unwind$??__EVirutalMap@Utils@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FVirutalMap@Utils@IronMan@@YAXXZ DD imagerel ??__FVirutalMap@Utils@IronMan@@YAXXZ
	DD	imagerel ??__FVirutalMap@Utils@IronMan@@YAXXZ+22
	DD	imagerel $unwind$??__FVirutalMap@Utils@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z DD imagerel $LN11
	DD	imagerel $LN11+493
	DD	imagerel $unwind$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA DD imagerel ?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA
	DD	imagerel ?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA
$pdata$?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA DD imagerel ?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA
	DD	imagerel ?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+311
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+145
	DD	imagerel $unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+201
	DD	imagerel $unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD imagerel $LN3
	DD	imagerel $LN3+253
	DD	imagerel $unwind$??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z DD imagerel $LN5
	DD	imagerel $LN5+164
	DD	imagerel $unwind$??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+261
	DD	imagerel $unwind$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z DD imagerel $LN6
	DD	imagerel $LN6+214
	DD	imagerel $unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z DD imagerel $LN6
	DD	imagerel $LN6+213
	DD	imagerel $unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+261
	DD	imagerel $unwind$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+241
	DD	imagerel $unwind$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$uniform_real@M@std@@QEAA@MM@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??0?$uniform_real@M@std@@QEAA@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0param_type@?$uniform_real@M@std@@QEAA@MM@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0param_type@?$uniform_real@M@std@@QEAA@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$uniform_real_distribution@M@std@@QEAA@MM@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0?$uniform_real_distribution@M@std@@QEAA@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN12
	DD	imagerel $LN12+638
	DD	imagerel $unwind$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN12
	DD	imagerel $LN12+401
	DD	imagerel $unwind$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z DD imagerel $LN12
	DD	imagerel $LN12+292
	DD	imagerel $unwind$??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN5
	DD	imagerel $LN5+394
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN5
	DD	imagerel $LN5+354
	DD	imagerel $unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z DD imagerel $LN12
	DD	imagerel $LN12+286
	DD	imagerel $unwind$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN14
	DD	imagerel $LN14+385
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+450
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+354
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel $LN6
	DD	imagerel $LN6+448
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+178
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z DD imagerel $LN5
	DD	imagerel $LN5+183
	DD	imagerel $unwind$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA DD imagerel ?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+352
	DD	imagerel $unwind$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN8
	DD	imagerel $LN8+653
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+176
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DD imagerel $LN8
	DD	imagerel $LN8+653
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+185
	DD	imagerel $unwind$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+164
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$01@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??$_Get_size_of_n@$01@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+150
	DD	imagerel $unwind$??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@33800000
CONST	SEGMENT
__real@33800000 DD 033800000r			; 5.96046e-08
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03GIOIKFCO@C?3?2@
CONST	SEGMENT
??_C@_03GIOIKFCO@C?3?2@ DB 'C:\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ENBLOMCO@Can?8t?5open?5DLL?5file?5?$CC?$CFs?$CC?4@
CONST	SEGMENT
??_C@_0BK@ENBLOMCO@Can?8t?5open?5DLL?5file?5?$CC?$CFs?$CC?4@ DB 'Can''t o'
	DB	'pen DLL file "%s".', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EBICDIGF@WinHttpReadData?5failed?3?5?$CFx@
CONST	SEGMENT
??_C@_0BL@EBICDIGF@WinHttpReadData?5failed?3?5?$CFx@ DB 'WinHttpReadData '
	DB	'failed: %x', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NALGGDJF@Out?5of?5memory@
CONST	SEGMENT
??_C@_0O@NALGGDJF@Out?5of?5memory@ DB 'Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HJMNAIEA@WinHttpQueryDataAvailable?5faile@
CONST	SEGMENT
??_C@_0CF@HJMNAIEA@WinHttpQueryDataAvailable?5faile@ DB 'WinHttpQueryData'
	DB	'Available failed: %x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CGBDJCIK@WinHttpReceiveResponse?5failed?3?5@
CONST	SEGMENT
??_C@_0CC@CGBDJCIK@WinHttpReceiveResponse?5failed?3?5@ DB 'WinHttpReceive'
	DB	'Response failed: %x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NBEGPBEP@WinHttpSendRequest?5failed?3?5?$CFx@
CONST	SEGMENT
??_C@_0BO@NBEGPBEP@WinHttpSendRequest?5failed?3?5?$CFx@ DB 'WinHttpSendRe'
	DB	'quest failed: %x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DNKGMBPP@WinHttpAddRequestHeaders?5failed@
CONST	SEGMENT
??_C@_0CE@DNKGMBPP@WinHttpAddRequestHeaders?5failed@ DB 'WinHttpAddReques'
	DB	'tHeaders failed: %x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DLFGADJM@WinHttpOpenRequest?5failed?3?5?$CFx@
CONST	SEGMENT
??_C@_0BO@DLFGADJM@WinHttpOpenRequest?5failed?3?5?$CFx@ DB 'WinHttpOpenRe'
	DB	'quest failed: %x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17KCHPOIEI@?$AAG?$AAE?$AAT@
CONST	SEGMENT
??_C@_17KCHPOIEI@?$AAG?$AAE?$AAT@ DB 'G', 00H, 'E', 00H, 'T', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IHJKAELJ@WinHttpConnect?5failed?3?5?$CFx@
CONST	SEGMENT
??_C@_0BK@IHJKAELJ@WinHttpConnect?5failed?3?5?$CFx@ DB 'WinHttpConnect fa'
	DB	'iled: %x', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NNCNJHDB@WinHttpCrackUrl?5failed?3?5?$CFx@
CONST	SEGMENT
??_C@_0BL@NNCNJHDB@WinHttpCrackUrl?5failed?3?5?$CFx@ DB 'WinHttpCrackUrl '
	DB	'failed: %x', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FHIJFMJL@WinHttpOpen?5failed?3?5?$CFx@
CONST	SEGMENT
??_C@_0BH@FHIJFMJL@WinHttpOpen?5failed?3?5?$CFx@ DB 'WinHttpOpen failed: '
	DB	'%x', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@POKKGHLI@?$AAW?$AAi?$AAn?$AAH?$AAT?$AAT?$AAP?$AA?5?$AAE?$AAx?$AAa?$AAm?$AAp?$AAl?$AAe@
CONST	SEGMENT
??_C@_1CI@POKKGHLI@?$AAW?$AAi?$AAn?$AAH?$AAT?$AAT?$AAP?$AA?5?$AAE?$AAx?$AAa?$AAm?$AAp?$AAl?$AAe@ DB 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'H', 00H, 'T', 00H, 'T', 00H, 'P', 00H
	DB	' ', 00H, 'E', 00H, 'x', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l'
	DB	00H, 'e', 00H, '/', 00H, '1', 00H, '.', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None@
CONST	SEGMENT
??_C@_04OHJIHAFH@None@ DB 'None', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LOMALFKN@Copy?5the?5URL?5successfully?0Press@
CONST	SEGMENT
??_C@_0DC@LOMALFKN@Copy?5the?5URL?5successfully?0Press@ DB 'Copy the URL '
	DB	'successfully,Press CTRL+V To Browser', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IEFDILKB@Failed?5to?5lock?5memory?5for?5clipb@
CONST	SEGMENT
??_C@_0CJ@IEFDILKB@Failed?5to?5lock?5memory?5for?5clipb@ DB 'Failed to lo'
	DB	'ck memory for clipboard data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CKEHACNA@Failed?5to?5allocate?5memory?5for?5c@
CONST	SEGMENT
??_C@_0CN@CKEHACNA@Failed?5to?5allocate?5memory?5for?5c@ DB 'Failed to al'
	DB	'locate memory for clipboard data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DPKMAAKB@Failed?5to?5empty?5clipboard@
CONST	SEGMENT
??_C@_0BK@DPKMAAKB@Failed?5to?5empty?5clipboard@ DB 'Failed to empty clip'
	DB	'board', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ DB '['
	DB	0e8H, 0beH, 093H, 0e5H, 087H, 0baH, 0e4H, 0bfH, 0a1H, 0e6H, 081H
	DB	0afH, '] %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ONFBAHNE@Failed?5to?5open?5clipboard@
CONST	SEGMENT
??_C@_0BJ@ONFBAHNE@Failed?5to?5open?5clipboard@ DB 'Failed to open clipbo'
	DB	'ard', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DJAAHBPE@QueryFullProcessImageNameW@
CONST	SEGMENT
??_C@_0BL@DJAAHBPE@QueryFullProcessImageNameW@ DB 'QueryFullProcessImageN'
	DB	'ameW', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MAAAEOL@VirtualQuery@
CONST	SEGMENT
??_C@_0N@MAAAEOL@VirtualQuery@ DB 'VirtualQuery', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X@ DB '%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z DD 020a01H
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$01@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z DD 011401H
	DD	04214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0c1H, 04H
	DB	02H
	DB	01H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0c1H, 04H
	DB	02H
	DB	01H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z DB 06H
	DB	00H
	DB	00H
	DB	095H, 03H
	DB	02H
	DB	0d6H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z
	DD	imagerel $ip2state$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z DB 06H
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z
	DD	imagerel $ip2state$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	0e2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
	DD	imagerel $ip2state$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 040H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
	DD	imagerel $ip2state$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z DD 011901H
	DD	0a219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$uniform_real_distribution@M@std@@QEAA@MM@Z DD 011501H
	DD	04215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0param_type@?$uniform_real@M@std@@QEAA@MM@Z DD 011501H
	DD	04215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$uniform_real@M@std@@QEAA@MM@Z DD 011501H
	DD	06215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	't'
	DB	02H
	DB	0b5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
	DD	imagerel $ip2state$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	0a9H, 02H
	DB	00H
	DB	'"'
	DB	02H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010e11H
	DD	0e20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z DB 040H
	DD	imagerel $ip2state$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z DD 011819H
	DD	06218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z DB 040H
	DD	imagerel $ip2state$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	0a9H, 02H
	DB	00H
	DB	'"'
	DB	02H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010e11H
	DD	0e20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FVirutalMap@Utils@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EVirutalMap@Utils@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1DynImport@IronMan@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1DynImport@IronMan@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1DynImport@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1DynImport@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1DynImport@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0DynImport@IronMan@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0DynImport@IronMan@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0DynImport@IronMan@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0DynImport@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??0DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0DynImport@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Instance@DynImport@IronMan@@SAAEAV12@XZ DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Instance@DynImport@IronMan@@SAAEAV12@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Instance@DynImport@IronMan@@SAAEAV12@XZ DB 08H
	DD	imagerel $stateUnwindMap$?Instance@DynImport@IronMan@@SAAEAV12@XZ
	DD	imagerel $ip2state$?Instance@DynImport@IronMan@@SAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Instance@DynImport@IronMan@@SAAEAV12@XZ DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Instance@DynImport@IronMan@@SAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DB 04H
	DB	00H
	DB	00H
	DB	'j'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Rrandom_device@std@@QEAAIXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CSLock@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1CSLock@IronMan@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1CSLock@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CSLock@IronMan@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1CSLock@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unlock@CriticalSection@IronMan@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@CriticalSection@IronMan@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CriticalSection@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1CriticalSection@IronMan@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1CriticalSection@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CriticalSection@IronMan@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1CriticalSection@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CriticalSection@IronMan@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	013H
	DD	017eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	018H
	DD	0263H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z
	DD	020H
	DD	0ed7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RandomFloat@Utils@IronMan@@YAMXZ
	DD	017H
	DD	059H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z
	DD	018H
	DD	0193H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?IsAdministratorRun@Utils@IronMan@@YAHXZ
	DD	011H
	DD	03ccH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	016H
	DD	038fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
	DD	017H
	DD	0e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z
	DD	01dH
	DD	01b9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z
	DD	01dH
	DD	01b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z
	DD	025H
	DD	01d2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
	DD	020H
	DD	01afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
	DD	018H
	DD	06dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
	DD	018H
	DD	06dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	01bH
	DD	0122H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	01bH
	DD	0124H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	01bH
	DD	013fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	01bH
	DD	0146H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ
	DD	02cH
	DD	0a5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ
	DD	02cH
	DD	0a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
	DD	020H
	DD	013eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z
	DD	025H
	DD	0215H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z
	DD	018H
	DD	08eH
voltbl	ENDS
xdata	SEGMENT
$unwind$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z
	DD	06aH
$cppxdata$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z
	DD	imagerel $ip2state$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z
$stateUnwindMap$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA
$ip2state$?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z DB 06H
	DB	00H
	DB	00H
	DB	0aeH
	DB	02H
	DB	'N'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z DD 022d19H
	DD	013011bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z
	DD	08aH
$cppxdata$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z
	DD	imagerel $ip2state$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z
$stateUnwindMap$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA
$ip2state$?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z DB 016H
	DB	00H
	DB	00H
	DB	'9', 02H
	DB	02H
	DB	'0'
	DB	00H
	DB	094H
	DB	04H
	DB	082H
	DB	02H
	DB	'.'
	DB	04H
	DB	082H
	DB	06H
	DB	' '
	DB	04H
	DB	'n'
	DB	02H
	DB	'('
	DB	04H
	DB	'>'
	DB	02H
$ip2state$?GetMachineCode@Utils@IronMan@@YA_KXZ DB 02H
	DB	00H
	DB	00H
$unwind$?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
	DD	072H
$cppxdata$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DB 08H
	DD	imagerel $stateUnwindMap$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
	DD	imagerel $ip2state$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
$stateUnwindMap$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$ip2state$?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DB 010H
	DB	00H
	DB	00H
	DB	'Z'
	DB	06H
	DB	016H
	DB	08H
	DB	086H
	DB	0aH
	DB	0b6H
	DB	08H
	DB	't'
	DB	06H
	DB	016H
	DB	04H
	DB	01cH
	DB	02H
$unwind$?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ DD 033419H
	DD	04080122H
	DD	07015H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ
	DD	02032H
$cppxdata$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ DB 08H
	DD	imagerel $stateUnwindMap$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ
	DD	imagerel $ip2state$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ
$stateUnwindMap$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA
$ip2state$?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ DB 04H
	DB	00H
	DB	00H
	DB	'5', 02H
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA DD 020601H
	DD	050023206H
$unwind$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ DD 033419H
	DD	02080122H
	DD	07015H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ
	DD	01032H
$cppxdata$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ DB 08H
	DD	imagerel $stateUnwindMap$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ
	DD	imagerel $ip2state$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ
$stateUnwindMap$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA
$ip2state$?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ DB 04H
	DB	00H
	DB	00H
	DB	'I', 02H
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA DD 020601H
	DD	050023206H
$unwind$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	082H
$cppxdata$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DB 08H
	DD	imagerel $stateUnwindMap$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	imagerel $ip2state$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
$stateUnwindMap$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
$ip2state$?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DB 06H
	DB	00H
	DB	00H
	DB	09H, 04H
	DB	04H
	DB	'd'
	DB	02H
$unwind$?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	07aH
$cppxdata$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DB 08H
	DD	imagerel $stateUnwindMap$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	imagerel $ip2state$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
$stateUnwindMap$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
$ip2state$?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DB 06H
	DB	00H
	DB	00H
	DB	0edH, 03H
	DB	04H
	DB	'd'
	DB	02H
$unwind$?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	082H
$cppxdata$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DB 08H
	DD	imagerel $stateUnwindMap$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	imagerel $ip2state$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
$stateUnwindMap$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA
$ip2state$?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'l'
	DB	04H
	DB	0adH, 02H
	DB	02H
	DB	'('
	DB	04H
	DB	':'
	DB	02H
$unwind$?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	07aH
$cppxdata$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	imagerel $ip2state$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
$stateUnwindMap$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA
$ip2state$?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DB 06H
	DB	00H
	DB	00H
	DB	'y', 03H
	DB	04H
	DB	'd'
	DB	02H
$unwind$?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
	DD	05aH
$cppxdata$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
	DD	imagerel $ip2state$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
$stateUnwindMap$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
$ip2state$?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DB 06H
	DB	00H
	DB	00H
	DB	086H
	DB	04H
	DB	'4'
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
	DD	05aH
$cppxdata$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
	DD	imagerel $ip2state$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z
$stateUnwindMap$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA
$ip2state$?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z DB 06H
	DB	00H
	DB	00H
	DB	086H
	DB	04H
	DB	'4'
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
	DD	0b2H
$cppxdata$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DB 08H
	DD	imagerel $stateUnwindMap$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
	DD	imagerel $ip2state$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z
$stateUnwindMap$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DB 0cH
	DB	0eH
	DD	imagerel ?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
	DB	056H
	DD	imagerel ?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA
$ip2state$?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z DB 014H
	DB	00H
	DB	00H
	DB	'`'
	DB	06H
	DB	016H
	DB	08H
	DB	0d6H
	DB	0aH
	DB	' '
	DB	08H
	DB	'A', 02H
	DB	0cH
	DB	' '
	DB	08H
	DB	'V'
	DB	06H
	DB	016H
	DB	04H
	DB	01cH
	DB	02H
	ORG $+2
$unwind$?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z
	DD	0a2H
$cppxdata$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z DB 08H
	DD	imagerel $stateUnwindMap$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z
	DD	imagerel $ip2state$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z
$stateUnwindMap$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z DB 0cH
	DB	0eH
	DD	imagerel ?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA
$ip2state$?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z DB 012H
	DB	00H
	DB	00H
	DB	'j'
	DB	08H
	DB	016H
	DB	0aH
	DB	'i', 03H
	DB	0cH
	DB	' '
	DB	0aH
	DB	0d8H
	DB	08H
	DB	016H
	DB	06H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
$unwind$?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA DD 020601H
	DD	050023206H
$unwind$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z
	DD	052H
$cppxdata$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z DB 08H
	DD	imagerel $stateUnwindMap$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z
	DD	imagerel $ip2state$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z
$stateUnwindMap$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA
$ip2state$?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z DB 016H
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	'*'
	DB	00H
	DB	0ccH
	DB	04H
	DB	0a4H
	DB	02H
	DB	','
	DB	04H
	DB	'4'
	DB	02H
	DB	'&'
	DB	04H
	DB	'4'
	DB	02H
	DB	'<'
	DB	00H
	DB	' '
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z
	DD	052H
$cppxdata$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z DB 08H
	DD	imagerel $stateUnwindMap$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z
	DD	imagerel $ip2state$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z
$stateUnwindMap$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA
$ip2state$?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z DB 016H
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	'*'
	DB	00H
	DB	0d4H
	DB	04H
	DB	0a8H
	DB	02H
	DB	','
	DB	04H
	DB	'4'
	DB	02H
	DB	'&'
	DB	04H
	DB	'4'
	DB	02H
	DB	'<'
	DB	00H
	DB	' '
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DD 021111H
	DD	0130111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
$cppxdata$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
	DD	imagerel $ip2state$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
$stateUnwindMap$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
$ip2state$?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	04H
	DB	0d5H, 02H
	DB	02H
$unwind$?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DD 021111H
	DD	0130111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
$cppxdata$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
	DD	imagerel $ip2state$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z
$stateUnwindMap$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA
$ip2state$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	04H
	DB	0d5H, 02H
	DB	02H
$unwind$?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DD 021111H
	DD	0130111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
$cppxdata$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
	DD	imagerel $ip2state$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
$stateUnwindMap$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
$ip2state$?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	04H
	DB	0d5H, 02H
	DB	02H
$unwind$?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DD 021111H
	DD	0130111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
$cppxdata$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
	DD	imagerel $ip2state$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
$stateUnwindMap$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA
$ip2state$?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	04H
	DB	0d5H, 02H
	DB	02H
$unwind$?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z DD 010e09H
	DD	0220eH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN14+14
	DD	imagerel $LN14+108
	DD	imagerel ?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA
	DD	imagerel $LN14+108
$unwind$?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA DD 010201H
	DD	05002H
$unwind$?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 010901H
	DD	06209H
$unwind$?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010901H
	DD	06209H
$unwind$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DD 031f19H
	DD	050010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
	DD	0272H
$cppxdata$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
	DD	imagerel $ip2state$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
$stateUnwindMap$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA
$ip2state$?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DB 06H
	DB	00H
	DB	00H
	DB	0b8H
	DB	04H
	DB	'('
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetModuleLen@Utils@IronMan@@YAKPEAUHINSTANCE__@@@Z DD 010901H
	DD	04209H
$unwind$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z
$cppxdata$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z DB 08H
	DD	imagerel $stateUnwindMap$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z
	DD	imagerel $ip2state$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z
$stateUnwindMap$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA
$ip2state$?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z DB 06H
	DB	00H
	DB	00H
	DB	01cH
	DB	02H
	DB	016H
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021e19H
	DD	029010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0132H
$cppxdata$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$stateUnwindMap$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	086H
	DD	imagerel ?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	0aeH
	DD	imagerel ?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$ip2state$?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 016H
	DB	00H
	DB	00H
	DB	'%', 02H
	DB	02H
	DB	'&'
	DB	00H
	DB	0f8H
	DB	04H
	DB	'&'
	DB	00H
	DB	091H, 02H
	DB	06H
	DB	'&'
	DB	00H
	DB	'E', 02H
	DB	08H
	DB	'&'
	DB	00H
	DB	095H, 03H
	DB	0aH
	DB	','
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?IsAdministratorRun@Utils@IronMan@@YAHXZ DD 021919H
	DD	01d0107H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z
	DD	06aH
$cppxdata$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z
	DD	imagerel $ip2state$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z
$stateUnwindMap$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA
$ip2state$?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'i', 02H
	DB	02H
	DB	'6'
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?RandomFloat@Utils@IronMan@@YAMXZ DD 021f19H
	DD	027b010dH
	DD	imagerel __GSHandlerCheck
	DD	013c0H
$unwind$?RandomRange@Utils@IronMan@@YAMMM@Z DD 011001H
	DD	06210H
$unwind$?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010901H
	DD	08209H
$unwind$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010911H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$cppxdata$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$stateUnwindMap$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$ip2state$?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'E', 03H
	DB	00H
	DB	'"'
	DB	02H
	DB	0aH
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010911H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$cppxdata$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$stateUnwindMap$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$ip2state$?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'E', 03H
	DB	00H
	DB	'"'
	DB	02H
	DB	0aH
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?checkAndCreateDirectory@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010901H
	DD	04209H
$unwind$?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z DD 010e09H
	DD	0620eH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+26
	DD	imagerel $LN12+65
	DD	imagerel ?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA
	DD	imagerel $LN12+65
$unwind$?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z DD 010e09H
	DD	0620eH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+26
	DD	imagerel $LN12+65
	DD	imagerel ?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA
	DD	imagerel $LN12+65
$unwind$?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z DD 022819H
	DD	0910116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z
	DD	0472H
$cppxdata$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z DB 08H
	DD	imagerel $stateUnwindMap$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z
	DD	imagerel $ip2state$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z
$stateUnwindMap$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z DB 020H
	DB	0eH
	DD	imagerel ?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	056H
	DD	imagerel ?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	056H
	DD	imagerel ?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	056H
	DD	imagerel ?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	07eH
	DD	imagerel ?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	0ceH
	DD	imagerel ?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	0f6H
	DD	imagerel ?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	03dH
	DB	02H
	DD	imagerel ?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	09dH
	DB	02H
	DD	imagerel ?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
	DB	0fdH
	DB	02H
	DD	imagerel ?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA
$ip2state$?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z DB 'z'
	DB	00H
	DB	00H
	DB	'|'
	DB	04H
	DB	'q', 02H
	DB	06H
	DB	'N'
	DB	04H
	DB	'Z'
	DB	02H
	DB	'4'
	DB	04H
	DB	091H, 03H
	DB	08H
	DB	0f1H, 02H
	DB	0aH
	DB	'T'
	DB	08H
	DB	'p'
	DB	04H
	DB	01cH
	DB	02H
	DB	'4'
	DB	08H
	DB	'@'
	DB	0cH
	DB	'Z'
	DB	0eH
	DB	0a5H, 02H
	DB	010H
	DB	'T'
	DB	0eH
	DB	'p'
	DB	0cH
	DB	01cH
	DB	08H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	'4'
	DB	0eH
	DB	'u', 03H
	DB	012H
	DB	'T'
	DB	0eH
	DB	086H
	DB	0cH
	DB	01cH
	DB	08H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	'4'
	DB	0eH
	DB	0c1H, 02H
	DB	014H
	DB	081H, 02H
	DB	016H
	DB	'T'
	DB	014H
	DB	09cH
	DB	0eH
	DB	01cH
	DB	0cH
	DB	01cH
	DB	08H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	'4'
	DB	0eH
	DB	0cdH, 02H
	DB	018H
	DB	'T'
	DB	0eH
	DB	09cH
	DB	0cH
	DB	01cH
	DB	08H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	'4'
	DB	0eH
	DB	019H, 02H
	DB	01aH
	DB	'T'
	DB	0eH
	DB	09cH
	DB	0cH
	DB	01cH
	DB	08H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	'4'
	DB	0eH
	DB	0a9H, 02H
	DB	01cH
	DB	'T'
	DB	0eH
	DB	0cdH, 02H
	DB	01eH
	DB	','
	DB	0eH
	DB	0f9H, 02H
	DB	' '
	DB	'T'
	DB	0eH
	DB	0b1H, 02H
	DB	0cH
	DB	01cH
	DB	08H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?GetMachineCode@Utils@IronMan@@YA_KXZ DD 020711H
	DD	01f0107H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetMachineCode@Utils@IronMan@@YA_KXZ
$cppxdata$?GetMachineCode@Utils@IronMan@@YA_KXZ DB 08H
	DD	imagerel $stateUnwindMap$?GetMachineCode@Utils@IronMan@@YA_KXZ
	DD	imagerel $ip2state$?GetMachineCode@Utils@IronMan@@YA_KXZ
$stateUnwindMap$?GetMachineCode@Utils@IronMan@@YA_KXZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA
	ORG $+3
$unwind$?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA DD 020601H
	DD	050023206H
$unwind$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z
$cppxdata$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z DB 08H
	DD	imagerel $stateUnwindMap$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z
	DD	imagerel $ip2state$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z
$stateUnwindMap$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA
$ip2state$?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z DB 06H
	DB	00H
	DB	00H
	DB	'A', 02H
	DB	04H
	DB	0fdH, 04H
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 042019H
	DD	037010eH
	DD	030067007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	01aaH
$cppxdata$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$stateUnwindMap$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 01cH
	DB	0eH
	DD	imagerel ?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	07eH
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	0ceH
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	03dH
	DB	02H
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	0edH
	DB	02H
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	09dH
	DB	03H
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	04dH
	DB	04H
	DD	imagerel ?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$ip2state$?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 01cH
	DB	00H
	DB	00H
	DB	'1', 02H
	DB	04H
	DB	'r'
	DB	06H
	DB	'r'
	DB	08H
	DB	'l'
	DB	0aH
	DB	'f'
	DB	0cH
	DB	08aH
	DB	0eH
	DB	'\'
	DB	012H
	DB	01cH
	DB	014H
	DB	01cH
	DB	016H
	DB	01cH
	DB	018H
	DB	01cH
	DB	01aH
	DB	01cH
	DB	01cH
	DB	'\'
	DB	02H
	ORG $+2
$unwind$?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 010911H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$cppxdata$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$stateUnwindMap$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$ip2state$?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 04H
	DB	00H
	DB	00H
	DB	0c4H
	DB	02H
$unwind$?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	06aH
$cppxdata$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$stateUnwindMap$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$ip2state$?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 0aH
	DB	00H
	DB	00H
	DB	'A', 02H
	DB	04H
	DB	0a1H, 02H
	DB	02H
	DB	'('
	DB	00H
	DB	'>'
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'.'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hash_@@YA?B_KPEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetLastNtStatus@@YAJJ@Z DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LastNtStatus@@YAJXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
	DB	078H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DB 04H
	DB	00H
	DB	00H
	DB	0d0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
	DD	imagerel $ip2state$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DB 04H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DB 08H
	DD	imagerel $stateUnwindMap$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
	DD	imagerel $ip2state$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DD 010d11H
	DD	0620dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
	DB	0bfH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DB 04H
	DB	00H
	DB	00H
	DB	0bdH, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
	DD	imagerel $ip2state$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 04H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 08H
	DD	imagerel $stateUnwindMap$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
	DD	imagerel $ip2state$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 010d11H
	DD	0620dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DB 04H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DB 08H
	DD	imagerel $stateUnwindMap$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	imagerel $ip2state$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DB 040H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	09aH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	'*'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	't'
	DB	02H
	DB	0d8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a4H
	DB	02H
	DB	'j'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 04H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 08H
	DD	imagerel $stateUnwindMap$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
	DD	imagerel $ip2state$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 040H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 06H
	DB	00H
	DB	00H
	DB	0c6H
	DB	02H
	DB	0d1H, 0eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DD 021a11H
	DD	01d011aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	09aH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	't'
	DB	02H
	DB	0d0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a4H
	DB	02H
	DB	'j'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD 010c01H
	DD	0220cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DB 040H
	DD	imagerel $ip2state$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z DB 040H
	DD	imagerel $ip2state$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vswprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vswprintf_s_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?VirutalMap$initializer$@Utils@IronMan@@3P6AXXZEA DQ FLAT:??__EVirutalMap@Utils@IronMan@@YAXXZ ; IronMan::Utils::VirutalMap$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
_TEXT	SEGMENT
_Val$ = 48
_Keyval$ = 56
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z PROC	; std::_Fnv1a_append_value<unsigned __int64>, COMDAT

; 2310 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2311 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2312 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	mov	r8d, 8
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	call	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2313 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ENDP	; std::_Fnv1a_append_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z
_TEXT	SEGMENT
_Sx$1 = 32
_Minbits$ = 36
_Gxmin$2 = 40
_Gxmax$3 = 44
_Discarded_bits$4 = 48
_Digits$ = 56
_Params$5 = 64
_Gx$ = 112
??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z PROC ; std::generate_canonical<float,24,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 298  : _NODISCARD _Real generate_canonical(_Gen& _Gx) { // build a floating-point value from random sequence

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H

; 299  :     _RNG_REQUIRE_REALTYPE(generate_canonical, _Real);
; 300  : 
; 301  :     constexpr auto _Digits  = static_cast<size_t>(numeric_limits<_Real>::digits);

	mov	QWORD PTR _Digits$[rsp], 24

; 302  :     constexpr auto _Minbits = static_cast<int>(_Digits < _Bits ? _Digits : _Bits);

	mov	DWORD PTR _Minbits$[rsp], 24

; 303  : 
; 304  :     if constexpr (_Minbits == 0) {
; 305  :         return _Real{0};
; 306  :     } else {
; 307  :         using _Result_uint_type = conditional_t<_Minbits <= 32, uint32_t, uint64_t>;
; 308  : 
; 309  :         constexpr auto _Gxmin  = (_Gen::min)();

	mov	DWORD PTR _Gxmin$2[rsp], 0

; 310  :         constexpr auto _Gxmax  = (_Gen::max)();

	mov	DWORD PTR _Gxmax$3[rsp], -1		; ffffffffH

; 311  :         constexpr auto _Params = _Generate_canonical_params(_Minbits, _Gxmax - _Gxmin);

	mov	BYTE PTR _Params$5[rsp], 1
	lea	rax, QWORD PTR _Params$5[rsp+1]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 3
	rep stosb
	mov	DWORD PTR _Params$5[rsp+4], 1
	mov	QWORD PTR _Params$5[rsp+8], 256		; 00000100H
	movss	xmm0, DWORD PTR __real@33800000
	movss	DWORD PTR _Params$5[rsp+16], xmm0
	mov	DWORD PTR _Params$5[rsp+20], 32		; 00000020H

; 312  : 
; 313  :         _STL_INTERNAL_STATIC_ASSERT(_Params._Kx >= 1);
; 314  : 
; 315  :         if constexpr (_Params._Rx_is_pow2) {
; 316  :             // Always needs only one attempt. Multiplications can be replaced with shift/add.
; 317  :             constexpr int _Discarded_bits = _Params._Smax_bits - _Minbits;

	mov	DWORD PTR _Discarded_bits$4[rsp], 8

; 318  :             _Result_uint_type _Sx         = static_cast<_Result_uint_type>((_Gx() - _Gxmin) >> _Discarded_bits);

	mov	rcx, QWORD PTR _Gx$[rsp]
	call	??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator()
	shr	eax, 8
	mov	DWORD PTR _Sx$1[rsp], eax

; 319  : 
; 320  :             if constexpr (_Params._Kx > 1) {
; 321  :                 constexpr int _Rx_bits = _Params._Smax_bits / _Params._Kx;
; 322  :                 int _Shift             = -_Discarded_bits;
; 323  :                 for (int _Idx = 1; _Idx < _Params._Kx; ++_Idx) {
; 324  :                     _Shift += _Rx_bits;
; 325  :                     _Sx += static_cast<_Result_uint_type>(_Gx() - _Gxmin) << _Shift;
; 326  :                 }
; 327  :             }
; 328  : 
; 329  :             return static_cast<_Real>(_Sx) * static_cast<_Real>(_Params._Scale);

	mov	eax, DWORD PTR _Sx$1[rsp]
	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR _Params$5[rsp+16]

; 330  :         } else {
; 331  :             using _Sx_type = conditional_t<_Params._Smax_bits <= 32, uint32_t,
; 332  :                 conditional_t<_Params._Smax_bits <= 64, uint64_t, _Unsigned128>>;
; 333  : 
; 334  :             constexpr auto _Rx        = _Sx_type{_Gxmax - _Gxmin} + 1u;
; 335  :             constexpr _Sx_type _Limit = static_cast<_Sx_type>(_Params._Xx) * (_Sx_type{1} << _Minbits);
; 336  : 
; 337  :             _Sx_type _Sx;
; 338  : 
; 339  :             do {
; 340  :                 // unroll first two iterations to avoid unnecessary multiplications
; 341  :                 _Sx = static_cast<_Sx_type>(_Gx() - _Gxmin);
; 342  :                 if constexpr (_Params._Kx == 2) {
; 343  :                     _Sx += static_cast<_Sx_type>(_Gx() - _Gxmin) * _Rx;
; 344  :                 } else if constexpr (_Params._Kx > 2) {
; 345  :                     _Sx += static_cast<_Sx_type>(_Gx() - _Gxmin) * _Rx;
; 346  :                     _Sx_type _Factor = _Rx;
; 347  :                     for (int _Idx = 2; _Idx < _Params._Kx; ++_Idx) {
; 348  :                         _Factor *= _Rx;
; 349  :                         _Sx += static_cast<_Sx_type>(_Gx() - _Gxmin) * _Factor;
; 350  :                     }
; 351  :                 }
; 352  :             } while (_Sx >= _Limit);
; 353  : 
; 354  :             return static_cast<_Real>(static_cast<_Result_uint_type>(_Sx / _Params._Xx))
; 355  :                  * static_cast<_Real>(_Params._Scale);
; 356  :         }
; 357  :     }
; 358  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ENDP ; std::generate_canonical<float,24,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBE@std@@YAAEBEAEBE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBE@std@@YAAEBEAEBE@Z PROC			; std::forward<unsigned char const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBE@std@@YAAEBEAEBE@Z ENDP			; std::forward<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z PROC		; std::_To_address<unsigned char *>, COMDAT

; 4641 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4642 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4643 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4644 : }

	ret	0
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ENDP		; std::_To_address<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Hash_representation@_K@std@@YA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 48
??$_Hash_representation@_K@std@@YA_KAEB_K@Z PROC	; std::_Hash_representation<unsigned __int64>, COMDAT

; 2316 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2317 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, -3750763034362895579		; cbf29ce484222325H
	call	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ; std::_Fnv1a_append_value<unsigned __int64>

; 2318 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Hash_representation@_K@std@@YA_KAEB_K@Z ENDP	; std::_Hash_representation<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$01@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$01@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<2>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$01@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<32>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?A_TAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?A_TAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?A_TAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z
_TEXT	SEGMENT
_Digits$ = 32
_Gx$ = 64
??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z PROC ; std::_Nrand_impl<float,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 413  : _NODISCARD _Real _Nrand_impl(_Gen& _Gx) { // build a floating-point value from random sequence

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 414  :     _RNG_REQUIRE_REALTYPE(_Nrand_impl, _Real);
; 415  : 
; 416  :     constexpr auto _Digits = static_cast<size_t>(numeric_limits<_Real>::digits);

	mov	QWORD PTR _Digits$[rsp], 24

; 417  : 
; 418  :     if constexpr (_Has_static_min_max<_Gen>::value) {
; 419  :         return _STD generate_canonical<_Real, _Digits>(_Gx);

	mov	rcx, QWORD PTR _Gx$[rsp]
	call	??$generate_canonical@M$0BI@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ; std::generate_canonical<float,24,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >

; 420  :     } else if constexpr (is_integral_v<typename _Gen::result_type>) {
; 421  :         // TRANSITION, for integral tr1 machinery only; Standard machinery can call generate_canonical directly
; 422  :         const auto _Gxmax = (_Gx.max)();
; 423  :         const auto _Gxmin = (_Gx.min)();
; 424  :         _Real _Val{0};
; 425  : 
; 426  :         if (_Gxmax == UINT64_MAX && _Gxmin == 0) {
; 427  :             // special case when uint64_t can't hold the full URBG range
; 428  :             _Val = static_cast<_Real>(static_cast<uint64_t>(_Gx()) >> (64 - _Digits));
; 429  :         } else {
; 430  :             constexpr auto _Rd = 1ULL << _Digits;
; 431  :             const auto _Rx     = static_cast<uint64_t>(_Gxmax - _Gxmin) + 1;
; 432  :             uint64_t _Sx       = 0;
; 433  :             uint64_t _Factor   = 1;
; 434  : 
; 435  :             // Try with 64 bits first, upgrade to 128 if necessary.
; 436  :             const bool _Would_overflow = _Nrand_for_tr1<uint64_t>(_Rd, _Rx, _Gx, _Val, _Sx, _Factor);
; 437  :             if (_Would_overflow) {
; 438  :                 _Nrand_for_tr1<_Unsigned128>(_Rd, _Rx, _Gx, _Val, _Sx, _Factor);
; 439  :             }
; 440  :         }
; 441  : 
; 442  :         return _STD ldexp(_Val, -static_cast<int>(_Digits));
; 443  :     } else {
; 444  :         // TRANSITION, the pre-P0952R2 algorithm, for non-integral tr1 machinery only (e.g. subtract_with_carry_01)
; 445  :         const _Real _Gxmin = static_cast<_Real>((_Gx.min)());
; 446  :         const _Real _Gxmax = static_cast<_Real>((_Gx.max)());
; 447  :         const _Real _Rx    = (_Gxmax - _Gxmin) + _Real{1};
; 448  : 
; 449  :         const int _Ceil = static_cast<int>(_STD ceil(static_cast<_Real>(_Digits) / _STD log2(_Rx)));
; 450  :         const int _Kx   = _Ceil < 1 ? 1 : _Ceil;
; 451  : 
; 452  :         _Real _Ans{0};
; 453  :         _Real _Factor{1};
; 454  : 
; 455  :         for (int _Idx = 0; _Idx < _Kx; ++_Idx) { // add in another set of bits
; 456  :             _Ans += (static_cast<_Real>(_Gx()) - _Gxmin) * _Factor;
; 457  :             _Factor *= _Rx;
; 458  :         }
; 459  : 
; 460  :         return _Ans / _Factor;
; 461  :     }
; 462  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ENDP ; std::_Nrand_impl<float,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z
_TEXT	SEGMENT
_Dest_ch$ = 32
_Dest_ptr$ = 40
_First_ch$ = 64
_Dest$ = 72
_Byte_count$ = 80
_Object_count$ = 88
??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z PROC ; std::_Copy_memmove_tail<unsigned char *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ; std::_To_address<unsigned char *>
	mov	QWORD PTR _Dest_ptr$[rsp], rax

; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));

	mov	rax, QWORD PTR _Dest_ptr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove
	npad	1

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

	mov	rax, QWORD PTR _Byte_count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z ENDP ; std::_Copy_memmove_tail<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_To_address@PEBE@std@@YA?A_PAEBQEBE@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEBE@std@@YA?A_PAEBQEBE@Z PROC		; std::_To_address<unsigned char const *>, COMDAT

; 4641 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4642 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4643 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4644 : }

	ret	0
??$_To_address@PEBE@std@@YA?A_PAEBQEBE@Z ENDP		; std::_To_address<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@E@std@@YAPEAEPEAE@Z		; std::_Unfancy<unsigned char>
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z
_TEXT	SEGMENT
_Dest_val$ = 32
tv66 = 36
_Dest$ = 64
_Val$ = 72
_Count$ = 80
??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z PROC		; std::_Fill_memset<unsigned char *,unsigned char>, COMDAT

; 5278 : void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5279 :     // implicitly convert (a cast would suppress warnings); also handles _Iter_value_t<_CtgIt> being bool
; 5280 :     _Iter_value_t<_CtgIt> _Dest_val = _Val;

	movzx	eax, BYTE PTR _Val$[rsp]
	mov	BYTE PTR _Dest_val$[rsp], al

; 5281 :     _CSTD memset(_STD _To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);

	movzx	eax, BYTE PTR _Dest_val$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ; std::_To_address<unsigned char *>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	ecx, DWORD PTR tv66[rsp]
	mov	edx, ecx
	mov	rcx, rax
	call	memset
	npad	1

; 5282 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z ENDP		; std::_Fill_memset<unsigned char *,unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@E@std@@YAPEAEPEAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@E@std@@YAPEAEPEAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv76 = 32
tv73 = 40
this$ = 64
_Keyval1$ = 72
_Keyval2$ = 80
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>, COMDAT

; 155  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :         // test if _Keyval1 NOT equal to _Keyval2
; 157  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR _Keyval2$[rsp]
	mov	rdx, QWORD PTR _Keyval1$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z	; std::equal_to<unsigned __int64>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv76[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv76[rsp]

; 158  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ; std::allocator<unsigned char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PEBD$0A@@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy_maybe_null@PEBD$0A@@std@@YAPEBDPEBD@Z PROC	; std::_Refancy_maybe_null<char const *,0>, COMDAT

; 312  : _CONSTEXPR20 _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 313  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 314  : }

	ret	0
??$_Refancy_maybe_null@PEBD$0A@@std@@YAPEBDPEBD@Z ENDP	; std::_Refancy_maybe_null<char const *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PEB_W$0A@@std@@YAPEB_WPEB_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy_maybe_null@PEB_W$0A@@std@@YAPEB_WPEB_W@Z PROC ; std::_Refancy_maybe_null<wchar_t const *,0>, COMDAT

; 312  : _CONSTEXPR20 _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 313  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 314  : }

	ret	0
??$_Refancy_maybe_null@PEB_W$0A@@std@@YAPEB_WPEB_W@Z ENDP ; std::_Refancy_maybe_null<wchar_t const *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z PROC	; std::_Refancy_maybe_null<unsigned char *,0>, COMDAT

; 312  : _CONSTEXPR20 _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 313  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 314  : }

	ret	0
??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ENDP	; std::_Refancy_maybe_null<unsigned char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAV?$allocator@D@std@@@std@@YAAEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$allocator@D@std@@@std@@YAAEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAV?$allocator@D@std@@@std@@YAAEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	ret	0
??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CB_KULogMemory@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KULogMemory@@@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CB_KULogMemory@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KULogMemory@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::destroy<std::pair<unsigned __int64 const ,LogMemory> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	ret	0
??$destroy@U?$pair@$$CB_KULogMemory@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KULogMemory@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::destroy<std::pair<unsigned __int64 const ,LogMemory> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_KULogMemory@@@std@@@std@@YAPEAU?$pair@$$CB_KULogMemory@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CB_KULogMemory@@@std@@@std@@YAPEAU?$pair@$$CB_KULogMemory@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,LogMemory> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CB_KULogMemory@@@std@@@std@@YAPEAU?$pair@$$CB_KULogMemory@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,LogMemory> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z PROC	; std::forward<wchar_t * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ENDP	; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?A_TAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?A_TAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rax, QWORD PTR $T1[rsp]

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$ = 56
_Par0$ = 64
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z PROC ; std::uniform_real<float>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 3221 :     result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3222 :         return _NRAND(_Eng, _Ty) * (_Par0._Max - _Par0._Min) + _Par0._Min;

	mov	rcx, QWORD PTR _Eng$[rsp]
	call	??$_Nrand_impl@MV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@YAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ; std::_Nrand_impl<float,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
	mov	rax, QWORD PTR _Par0$[rsp]
	mov	rcx, QWORD PTR _Par0$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx]
	mulss	xmm0, xmm1
	mov	rax, QWORD PTR _Par0$[rsp]
	addss	xmm0, DWORD PTR [rax]

; 3223 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z ENDP ; std::uniform_real<float>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEBD_KPEA_W@std@@YAPEA_WPEBD_KPEA_W@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Dest$ = 24
??$_Copy_n_unchecked4@PEBD_KPEA_W@std@@YAPEA_WPEBD_KPEA_W@Z PROC ; std::_Copy_n_unchecked4<char const *,unsigned __int64,wchar_t *>, COMDAT

; 4813 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 4814 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4815 :     // note: has callers outside the copy family
; 4816 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4817 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 4818 : 
; 4819 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4820 : #if _HAS_CXX20
; 4821 :         if (!_STD is_constant_evaluated())
; 4822 : #endif // _HAS_CXX20
; 4823 :         {
; 4824 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4825 :         }
; 4826 :     }
; 4827 : 
; 4828 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	jmp	SHORT $LN4@Copy_n_unc
$LN2@Copy_n_unc:
	mov	rax, QWORD PTR _Dest$[rsp]
	add	rax, 2
	mov	QWORD PTR _Dest$[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN4@Copy_n_unc:
	cmp	QWORD PTR _Count$[rsp], 0
	je	SHORT $LN3@Copy_n_unc

; 4829 :         *_Dest = *_First;

	mov	rax, QWORD PTR _First$[rsp]
	movsx	ax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	WORD PTR [rcx], ax

; 4830 :     }

	jmp	SHORT $LN2@Copy_n_unc
$LN3@Copy_n_unc:

; 4831 : 
; 4832 :     return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]

; 4833 : }

	ret	0
??$_Copy_n_unchecked4@PEBD_KPEA_W@std@@YAPEA_WPEBD_KPEA_W@Z ENDP ; std::_Copy_n_unchecked4<char const *,unsigned __int64,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 96   :     _CONSTEXPR20 ~_Tidy_deallocate_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 97   :         if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy_deall

; 98   :             _Target->_Tidy_deallocate();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1
$LN2@Tidy_deall:

; 99   :         }
; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z
_TEXT	SEGMENT
_First_ptr$ = 32
_Last_ptr$ = 40
_First_ch$ = 48
_Last_ch$ = 56
_Object_count$ = 64
_Byte_count$ = 72
_First$ = 96
_Last$ = 104
_Dest$ = 112
??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z PROC	; std::_Copy_memmove<unsigned char const *,unsigned char *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEBE@std@@YA?A_PAEBQEBE@Z ; std::_To_address<unsigned char const *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEBE@std@@YA?A_PAEBQEBE@Z ; std::_To_address<unsigned char const *>
	mov	QWORD PTR _Last_ptr$[rsp], rax

; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	rcx, QWORD PTR _Last_ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Object_count$[rsp], rax

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));

	mov	rax, QWORD PTR _Last_ptr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Byte_count$[rsp], rax

; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z ; std::move<unsigned char * &>
	mov	r9, QWORD PTR _Object_count$[rsp]
	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _First_ch$[rsp]
	call	??$_Copy_memmove_tail@PEAE@std@@YAPEAEQEBDQEAE_K2@Z ; std::_Copy_memmove_tail<unsigned char *>

; 4787 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ENDP	; std::_Copy_memmove<unsigned char const *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Count$ = 104
_Val$ = 112
_Al$ = 120
??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >, COMDAT

; 1970 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1971 :     // copy _Count copies of _Val to raw _First, using _Al
; 1972 :     using _Ty = typename _Alloc::value_type;
; 1973 :     if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1974 : #if _HAS_CXX20
; 1975 :         if (!_STD is_constant_evaluated())
; 1976 : #endif // _HAS_CXX20
; 1977 :         {
; 1978 :             _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));

	mov	rax, QWORD PTR _Val$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv72[rsp], al
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Unfancy@E@std@@YAPEAEPEAE@Z		; std::_Unfancy<unsigned char>
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	movzx	edx, BYTE PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Fill_memset@PEAEE@std@@YAXPEAEE_K@Z	; std::_Fill_memset<unsigned char *,unsigned char>

; 1979 :             return _First + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Uninitiali

; 1980 :         }
; 1981 :     } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1982 : #if _HAS_CXX20
; 1983 :         if (!_STD is_constant_evaluated())
; 1984 : #endif // _HAS_CXX20
; 1985 :         {
; 1986 :             if (_Is_all_bits_zero(_Val)) {
; 1987 :                 _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
; 1988 :                 return _First + _Count;
; 1989 :             }
; 1990 :         }
; 1991 :     }
; 1992 : 
; 1993 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _First$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >

; 1994 :     for (; 0 < _Count; --_Count) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN4@Uninitiali:
	cmp	QWORD PTR _Count$[rsp], 0
	jbe	SHORT $LN3@Uninitiali

; 1995 :         _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>
	npad	1

; 1996 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1997 : 
; 1998 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1999 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv72 = 32
tv70 = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Count$ = 104
_Val$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA PROC ; `std::_Uninitialized_fill_n<std::allocator<unsigned char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z@4HA ENDP ; `std::_Uninitialized_fill_n<std::allocator<unsigned char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 86   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 87   :         if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy_guard

; 88   :             _Target->_Tidy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
	npad	1
$LN2@Tidy_guard:

; 89   :         }
; 90   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@E@std@@@std@@YAAEBV?$allocator@E@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@E@std@@@std@@YAAEBV?$allocator@E@0@AEBV10@@Z PROC ; std::forward<std::allocator<unsigned char> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@E@std@@@std@@YAAEBV?$allocator@E@0@AEBV10@@Z ENDP ; std::forward<std::allocator<unsigned char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv75 = 32
this$ = 64
_Keyval$ = 72
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>, COMDAT

; 148  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 149  :         // hash _Keyval to size_t value
; 150  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()

; 151  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 123  : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Lhs$ = 8
_Rhs$ = 16
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z PROC ; std::_Allocators_equal<std::allocator<char> >, COMDAT

; 2234 : _NODISCARD constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2235 :     if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
; 2236 :         return true;

	mov	al, 1

; 2237 :     } else {
; 2238 :         return _Lhs == _Rhs;
; 2239 :     }
; 2240 : }

	ret	0
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ENDP ; std::_Allocators_equal<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEAV?$allocator@D@std@@@std@@YAAEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z PROC	; std::_Unfancy_maybe_null<char const >, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z ENDP	; std::_Unfancy_maybe_null<char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z PROC	; std::_Unfancy_maybe_null<wchar_t const >, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z ENDP	; std::_Unfancy_maybe_null<wchar_t const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z PROC	; std::forward<wchar_t * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ENDP	; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z PROC ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_KULogMemory@@@std@@@std@@YAPEAU?$pair@$$CB_KULogMemory@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,LogMemory> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CB_KULogMemory@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KULogMemory@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::destroy<std::pair<unsigned __int64 const ,LogMemory> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > ><std::pair<unsigned __int64 const ,LogMemory> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > ><std::pair<unsigned __int64 const ,LogMemory> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > ><std::pair<unsigned __int64 const ,LogMemory> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z
_TEXT	SEGMENT
_First1$ = 48
_Last1$ = 56
_First2$ = 64
_Count2$ = 72
??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z PROC ; std::_Search_vectorized<char const ,char const >, COMDAT

; 277  : _Ty1* _Search_vectorized(_Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 278  :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Ty1) == sizeof(_Ty2));
; 279  :     if constexpr (sizeof(_Ty1) == 1) {
; 280  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_1(_First1, _Last1, _First2, _Count2)));

	mov	r9, QWORD PTR _Count2$[rsp]
	mov	r8, QWORD PTR _First2$[rsp]
	mov	rdx, QWORD PTR _Last1$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	__std_search_1

; 281  :     } else if constexpr (sizeof(_Ty1) == 2) {
; 282  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));
; 283  :     } else {
; 284  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 285  :     }
; 286  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ENDP ; std::_Search_vectorized<char const ,char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z PROC ; std::_Find_last_vectorized<char const ,char>, COMDAT

; 226  : _Ty* _Find_last_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 228  : #ifdef _WIN64
; 229  :         return const_cast<_Ty*>(
; 230  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 231  : #else
; 232  :         return const_cast<_Ty*>(
; 233  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 234  : #endif
; 235  :     } else if constexpr (sizeof(_Ty) == 1) {
; 236  :         return const_cast<_Ty*>(

	movzx	r8d, BYTE PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	__std_find_last_trivial_1

; 237  :             static_cast<const _Ty*>(::__std_find_last_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 238  :     } else if constexpr (sizeof(_Ty) == 2) {
; 239  :         return const_cast<_Ty*>(
; 240  :             static_cast<const _Ty*>(::__std_find_last_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 241  :     } else if constexpr (sizeof(_Ty) == 4) {
; 242  :         return const_cast<_Ty*>(
; 243  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 244  :     } else if constexpr (sizeof(_Ty) == 8) {
; 245  :         return const_cast<_Ty*>(
; 246  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 247  :     } else {
; 248  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 249  :     }
; 250  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ENDP ; std::_Find_last_vectorized<char const ,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ; std::addressof<wchar_t *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ; std::forward<wchar_t * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z PROC ; std::_Find_last_vectorized<wchar_t const ,wchar_t>, COMDAT

; 226  : _Ty* _Find_last_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

$LN3:
	mov	WORD PTR [rsp+24], r8w
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 228  : #ifdef _WIN64
; 229  :         return const_cast<_Ty*>(
; 230  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 231  : #else
; 232  :         return const_cast<_Ty*>(
; 233  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 234  : #endif
; 235  :     } else if constexpr (sizeof(_Ty) == 1) {
; 236  :         return const_cast<_Ty*>(
; 237  :             static_cast<const _Ty*>(::__std_find_last_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 238  :     } else if constexpr (sizeof(_Ty) == 2) {
; 239  :         return const_cast<_Ty*>(

	movzx	r8d, WORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	__std_find_last_trivial_2

; 240  :             static_cast<const _Ty*>(::__std_find_last_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 241  :     } else if constexpr (sizeof(_Ty) == 4) {
; 242  :         return const_cast<_Ty*>(
; 243  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 244  :     } else if constexpr (sizeof(_Ty) == 8) {
; 245  :         return const_cast<_Ty*>(
; 246  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 247  :     } else {
; 248  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 249  :     }
; 250  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z ENDP ; std::_Find_last_vectorized<wchar_t const ,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 5
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 5
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	QWORD PTR tv132[rsp], rax
	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA PROC ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA ENDP ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv81 = 48
tv79 = 56
tv77 = 64
_Result$ = 72
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 5
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 5
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv132[rsp], rax
	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv74 = 48
tv72 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::forward<unsigned char *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::forward<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::forward<std::allocator<unsigned char> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::forward<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$ = 56
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::uniform_real<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 3181 :     _NODISCARD result_type operator()(_Engine& _Eng) _DISTRIBUTION_CONST {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3182 :         return _Eval(_Eng, _Par);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Eng$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@AEBAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@AEBUparam_type@01@@Z ; std::uniform_real<float>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >

; 3183 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::uniform_real<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
_Can_construct_by_copy$ = 33
_My_data$ = 40
_New_capacity$1 = 48
_Data$2 = 56
_Guard$ = 64
_Alproxy$ = 72
_Al$ = 80
_New_ptr$3 = 88
this$ = 112
_First$ = 120
_Last$ = 128
_Count$ = 136
??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char const *,char const *,unsigned __int64>, COMDAT

; 908  :     _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 909  :         // Pre: _Iter models input_iterator or meets the Cpp17InputIterator requirements.
; 910  :         // Pre: [_First, _Last) is a valid range.
; 911  :         // Pre: if _Iter models forward_iterator or meets the Cpp17ForwardIterator requirements,
; 912  :         //      then is_same_v<_Size, size_type> holds.
; 913  :         // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
; 914  :         // Pre: *this is in small mode; the lifetime of the SSO elements has already begun.
; 915  : 
; 916  :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 917  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 918  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 919  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 920  : 
; 921  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 922  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 923  : 
; 924  :         if constexpr (is_same_v<_Size, size_type>) {
; 925  :             if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct_

; 926  :                 _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct_:

; 927  :             }
; 928  : 
; 929  :             if (_Count > _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 7
	jbe	SHORT $LN3@Construct_

; 930  :                 size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$1[rsp], rax

; 931  :                 const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$3[rsp], rax

; 932  :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$3[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>

; 933  :                 _My_data._Myres = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$1[rsp]
	mov	QWORD PTR [rax+24], rcx
$LN3@Construct_:

; 934  :             }
; 935  :         }
; 936  : 
; 937  :         _Tidy_deallocate_guard<basic_string> _Guard{this};

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax

; 938  : 
; 939  :         constexpr bool _Can_construct_by_copy =

	mov	BYTE PTR _Can_construct_by_copy$[rsp], 1

; 940  :             _Is_specialization_v<_Traits, char_traits> && _Is_EcharT<_Elem> && is_same_v<_Size, size_type>;
; 941  : 
; 942  :         if constexpr (_Can_construct_by_copy) {
; 943  :             const auto _Data = _My_data._Myptr();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	QWORD PTR _Data$2[rsp], rax

; 944  :             _STD _Copy_n_unchecked4(_STD move(_First), _Count, _Data);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z ; std::move<char const * &>
	mov	r8, QWORD PTR _Data$2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Copy_n_unchecked4@PEBD_KPEA_W@std@@YAPEA_WPEBD_KPEA_W@Z ; std::_Copy_n_unchecked4<char const *,unsigned __int64,wchar_t *>

; 945  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 946  :             _Data[_Count]    = _Elem();

	xor	eax, eax
	mov	rcx, QWORD PTR _Data$2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	WORD PTR [rcx+rdx*2], ax

; 947  :         } else {
; 948  :             for (; _First != _Last; ++_First) {
; 949  :                 if constexpr (!is_same_v<_Size, size_type>) {
; 950  :                     if (_My_data._Mysize == _My_data._Myres) { // Need to grow
; 951  :                         if (_My_data._Mysize == max_size()) {
; 952  :                             _Xlen_string(); // result too long
; 953  :                         }
; 954  : 
; 955  :                         _Elem* const _Old_ptr   = _My_data._Myptr();
; 956  :                         size_type _New_capacity = _Calculate_growth(_My_data._Mysize + 1);
; 957  :                         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 958  : 
; 959  :                         _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
; 960  :                         if (_My_data._Large_mode_engaged()) { // Need to deallocate old storage
; 961  :                             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
; 962  :                             _My_data._Bx._Ptr = _New_ptr;
; 963  :                         } else {
; 964  :                             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 965  :                         }
; 966  :                         _My_data._Myres = _New_capacity;
; 967  :                     }
; 968  :                 }
; 969  : 
; 970  :                 _Elem* const _Ptr = _My_data._Myptr();
; 971  :                 _Traits::assign(_Ptr[_My_data._Mysize], *_First);
; 972  :                 ++_My_data._Mysize;
; 973  :             }
; 974  : 
; 975  :             _Elem* const _Ptr = _My_data._Myptr();
; 976  :             _Traits::assign(_Ptr[_My_data._Mysize], _Elem());
; 977  :         }
; 978  : 
; 979  :         _ASAN_STRING_CREATE(*this);
; 980  :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 981  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 982  :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
	npad	1
	add	rsp, 104				; 00000068H
	ret	0
$LN6@Construct_:
??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char const *,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Proxy$ = 32
_Can_construct_by_copy$ = 33
_My_data$ = 40
_New_capacity$1 = 48
_Data$2 = 56
_Guard$ = 64
_Alproxy$ = 72
_Al$ = 80
_New_ptr$3 = 88
this$ = 112
_First$ = 120
_Last$ = 128
_Count$ = 136
?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char const *,char const *,unsigned __int64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char const *,char const *,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z PROC		; std::move<char const * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z ENDP		; std::move<char const * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$distance@PEBD@std@@YA_JPEBD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEBD@std@@YA_JPEBD0@Z PROC			; std::distance<char const *>, COMDAT

; 1690 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1691 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1692 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx

; 1693 :     } else {
; 1694 :         _STD _Adl_verify_range(_First, _Last);
; 1695 :         auto _UFirst             = _STD _Get_unwrapped(_First);
; 1696 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1697 :         _Iter_diff_t<_InIt> _Off = 0;
; 1698 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1699 :             ++_Off;
; 1700 :         }
; 1701 : 
; 1702 :         return _Off;
; 1703 :     }
; 1704 : }

	ret	0
??$distance@PEBD@std@@YA_JPEBD0@Z ENDP			; std::distance<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z
_TEXT	SEGMENT
_It$ = 48
_UIt$ = 56
??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z PROC ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>, COMDAT

; 1507 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1508 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1509 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rcx, QWORD PTR _UIt$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to
	npad	1

; 1510 :     } else {
; 1511 :         _It = _STD forward<_UIter>(_UIt);
; 1512 :     }
; 1513 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z ENDP ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_COff$1 = 32
_It$ = 64
_Off$ = 72
??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>, COMDAT

; 1473 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1474 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1475 :         return _It + 0;
; 1476 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && _Integer_like<_Diff>) {
; 1477 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1478 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1479 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1480 :         const auto _COff = static_cast<_CDiff>(_Off);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	QWORD PTR _COff$1[rsp], rax

; 1481 : 
; 1482 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1483 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1484 :             "integer overflow");
; 1485 :         (void) _COff;
; 1486 : 
; 1487 :         _It._Verify_offset(static_cast<_IDiff>(_Off));

	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset

; 1488 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped

; 1489 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1490 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1491 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1492 :     } else {
; 1493 :         // pass through iterator that doesn't participate in checking
; 1494 :         return static_cast<_Iter&&>(_It);
; 1495 :     }
; 1496 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA?A_PAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA?A_PAEBQEAD0@Z PROC ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>, COMDAT

; 1580 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1581 :     // Returns the distance between _First and _Last or
; 1582 :     // an indicator that the distance cannot be determined in O(1).
; 1583 :     _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Unwrapped_t<_Checked>, _Iter>);
; 1584 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1585 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx

; 1586 :     } else {
; 1587 :         return _Distance_unknown{};
; 1588 :     }
; 1589 : }

	ret	0
??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA?A_PAEBQEAD0@Z ENDP ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z
_TEXT	SEGMENT
_It$ = 48
_UIt$ = 56
??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z PROC ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t * &>, COMDAT

; 1507 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1508 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1509 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rcx, QWORD PTR _UIt$[rsp]
	call	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ; std::forward<wchar_t * &>
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Seek_to
	npad	1

; 1510 :     } else {
; 1511 :         _It = _STD forward<_UIter>(_UIt);
; 1512 :     }
; 1513 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z ENDP ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_COff$1 = 32
_It$ = 64
_Off$ = 72
??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &,__int64>, COMDAT

; 1473 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1474 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1475 :         return _It + 0;
; 1476 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && _Integer_like<_Diff>) {
; 1477 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1478 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1479 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1480 :         const auto _COff = static_cast<_CDiff>(_Off);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	QWORD PTR _COff$1[rsp], rax

; 1481 : 
; 1482 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1483 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1484 :             "integer overflow");
; 1485 :         (void) _COff;
; 1486 : 
; 1487 :         _It._Verify_offset(static_cast<_IDiff>(_Off));

	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAX_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Verify_offset

; 1488 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped

; 1489 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1490 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1491 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1492 :     } else {
; 1493 :         // pass through iterator that doesn't participate in checking
; 1494 :         return static_cast<_Iter&&>(_It);
; 1495 :     }
; 1496 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PEA_W@std@@YA?A_PAEBQEA_W0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PEA_W@std@@YA?A_PAEBQEA_W0@Z PROC ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t *>, COMDAT

; 1580 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1581 :     // Returns the distance between _First and _Last or
; 1582 :     // an indicator that the distance cannot be determined in O(1).
; 1583 :     _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Unwrapped_t<_Checked>, _Iter>);
; 1584 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1585 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 1

; 1586 :     } else {
; 1587 :         return _Distance_unknown{};
; 1588 :     }
; 1589 : }

	ret	0
??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PEA_W@std@@YA?A_PAEBQEA_W0@Z ENDP ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 48
_UIt$ = 56
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>, COMDAT

; 1507 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1508 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1509 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rcx, QWORD PTR _UIt$[rsp]
	call	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ; std::forward<unsigned char *>
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
	npad	1

; 1510 :     } else {
; 1511 :         _It = _STD forward<_UIter>(_UIt);
; 1512 :     }
; 1513 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z PROC ; std::_Copy_unchecked<unsigned char const *,unsigned char const *,unsigned char *>, COMDAT

; 4845 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4846 :     // copy [_First, _Last) to [_Dest, ...)
; 4847 :     // note: _Copy_unchecked has callers other than the copy family
; 4848 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 4849 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 4850 :     } else {
; 4851 :         if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
; 4852 : #if _HAS_CXX20
; 4853 :             if (!_STD is_constant_evaluated())
; 4854 : #endif // _HAS_CXX20
; 4855 :             {
; 4856 : #if _HAS_CXX20
; 4857 :                 if constexpr (!is_same_v<_InIt, _Sent>) {
; 4858 :                     return _STD _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
; 4859 :                 } else
; 4860 : #endif // _HAS_CXX20
; 4861 :                 {
; 4862 :                     return _STD _Copy_memmove(_First, _Last, _Dest);

	mov	r8, QWORD PTR _Dest$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ; std::_Copy_memmove<unsigned char const *,unsigned char *>
	jmp	SHORT $LN1@Copy_unche

; 4863 :                 }
; 4864 :             }
; 4865 :         }
; 4866 : 
; 4867 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

	jmp	SHORT $LN4@Copy_unche
$LN2@Copy_unche:
	mov	rax, QWORD PTR _Dest$[rsp]
	inc	rax
	mov	QWORD PTR _Dest$[rsp], rax
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
$LN4@Copy_unche:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Copy_unche

; 4868 :             *_Dest = *_First;

	mov	rax, QWORD PTR _Dest$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 4869 :         }

	jmp	SHORT $LN2@Copy_unche
$LN3@Copy_unche:

; 4870 : 
; 4871 :         return _Dest;

	mov	rax, QWORD PTR _Dest$[rsp]
$LN1@Copy_unche:

; 4872 :     }
; 4873 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ENDP ; std::_Copy_unchecked<unsigned char const *,unsigned char const *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::move<unsigned char * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::move<unsigned char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_COff$1 = 32
_It$ = 64
_Off$ = 72
??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,__int64>, COMDAT

; 1473 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1474 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1475 :         return _It + 0;
; 1476 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && _Integer_like<_Diff>) {
; 1477 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1478 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1479 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1480 :         const auto _COff = static_cast<_CDiff>(_Off);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	QWORD PTR _COff$1[rsp], rax

; 1481 : 
; 1482 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1483 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1484 :             "integer overflow");
; 1485 :         (void) _COff;
; 1486 : 
; 1487 :         _It._Verify_offset(static_cast<_IDiff>(_Off));

	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset

; 1488 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped

; 1489 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1490 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1491 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1492 :     } else {
; 1493 :         // pass through iterator that doesn't participate in checking
; 1494 :         return static_cast<_Iter&&>(_It);
; 1495 :     }
; 1496 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Idl_distance@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEBE@std@@YA?A_PAEBQEBE0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEBE@std@@YA?A_PAEBQEBE0@Z PROC ; std::_Idl_distance<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char const *>, COMDAT

; 1580 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1581 :     // Returns the distance between _First and _Last or
; 1582 :     // an indicator that the distance cannot be determined in O(1).
; 1583 :     _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Unwrapped_t<_Checked>, _Iter>);
; 1584 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1585 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx

; 1586 :     } else {
; 1587 :         return _Distance_unknown{};
; 1588 :     }
; 1589 : }

	ret	0
??$_Idl_distance@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEBE@std@@YA?A_PAEBQEBE0@Z ENDP ; std::_Idl_distance<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_Guard$1 = 48
_Alproxy$ = 56
_Al$ = 64
this$ = 96
_Count$ = 104
<_Val_0>$ = 112
??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const &>, COMDAT

; 2087 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2088 :         // Dispatches between the three sized constructions.
; 2089 :         // 1-arg -> value-construction, e.g. vector(5)
; 2090 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2091 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2092 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2093 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2094 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2095 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 2096 :         if (_Count != 0) {

	cmp	QWORD PTR _Count$[rsp], 0
	je	SHORT $LN2@Construct_

; 2097 :             _Buy_nonzero(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero

; 2098 :             _Tidy_guard<vector> _Guard{this};

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Guard$1[rsp], rax

; 2099 :             if constexpr (sizeof...(_Val) == 0) {
; 2100 :                 _My_data._Mylast = _STD _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
; 2101 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2102 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2103 :                 _My_data._Mylast = _STD _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR <_Val_0>$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEBEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 2104 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2105 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2106 :             } else {
; 2107 :                 _STL_INTERNAL_STATIC_ASSERT(false); // unexpected number of arguments
; 2108 :             }
; 2109 :             _ASAN_VECTOR_CREATE;
; 2110 :             _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$1[rsp], 0

; 2111 :         }

	lea	rcx, QWORD PTR _Guard$1[rsp]
	call	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
	npad	1
$LN2@Construct_:

; 2112 : 
; 2113 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 2114 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_Guard$1 = 48
_Alproxy$ = 56
_Al$ = 64
this$ = 96
_Count$ = 104
<_Val_0>$ = 112
?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA PROC ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$1[rbp]
	call	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z@4HA ENDP ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@E@std@@@std@@YAAEBV?$allocator@E@0@AEBV10@@Z ; std::forward<std::allocator<unsigned char> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;
; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped

; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z
_TEXT	SEGMENT
_UVal_trunc$ = 0
_RNext$ = 32
_UVal$ = 40
??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z PROC	; std::_UIntegral_to_buff<char,unsigned long>, COMDAT

; 2717 : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // used by both to_string and thread::id output

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2718 :     // format _UVal into buffer *ending at* _RNext
; 2719 :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 2720 : 
; 2721 : #ifdef _WIN64
; 2722 :     auto _UVal_trunc = _UVal;

	mov	eax, DWORD PTR _UVal$[rsp]
	mov	DWORD PTR _UVal_trunc$[rsp], eax
$LN4@UIntegral_:

; 2723 : #else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
; 2724 : 
; 2725 :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 2726 :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 2727 :         while (_UVal > 0xFFFFFFFFU) {
; 2728 :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 2729 :             _UVal /= 1000000000;
; 2730 : 
; 2731 :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 2732 :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 2733 :                 _UVal_chunk /= 10;
; 2734 :             }
; 2735 :         }
; 2736 :     }
; 2737 : 
; 2738 :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 2739 : #endif // ^^^ !defined(_WIN64) ^^^
; 2740 : 
; 2741 :     do {
; 2742 :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	mov	rax, QWORD PTR _RNext$[rsp]
	dec	rax
	mov	QWORD PTR _RNext$[rsp], rax
	xor	edx, edx
	mov	eax, DWORD PTR _UVal_trunc$[rsp]
	mov	ecx, 10
	div	ecx
	mov	eax, edx
	add	eax, 48					; 00000030H
	mov	rcx, QWORD PTR _RNext$[rsp]
	mov	BYTE PTR [rcx], al

; 2743 :         _UVal_trunc /= 10;

	xor	edx, edx
	mov	eax, DWORD PTR _UVal_trunc$[rsp]
	mov	ecx, 10
	div	ecx
	mov	DWORD PTR _UVal_trunc$[rsp], eax

; 2744 :     } while (_UVal_trunc != 0);

	cmp	DWORD PTR _UVal_trunc$[rsp], 0
	jne	SHORT $LN4@UIntegral_

; 2745 :     return _RNext;

	mov	rax, QWORD PTR _RNext$[rsp]

; 2746 : }

	add	rsp, 24
	ret	0
??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z ENDP	; std::_UIntegral_to_buff<char,unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
_UFirst$ = 40
_ULast$ = 48
tv70 = 56
this$ = 80
_First$ = 88
_Last$ = 96
_Al$ = 104
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 775  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
	npad	1

; 776  :         _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>

; 777  :         auto _UFirst = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ; std::_Get_unwrapped<char * &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 778  :         auto _ULast  = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ; std::_Get_unwrapped<char * &>
	mov	QWORD PTR _ULast$[rsp], rax

; 779  :         if (_UFirst == _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	jne	SHORT $LN2@allocator

; 780  :             _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 781  :         } else {

	jmp	SHORT $LN3@allocator
$LN2@allocator:

; 782  :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 783  :                 _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	npad	1
$LN3@allocator:

; 784  :                     _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 785  :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 786  :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 787  :                 const auto _Count  = _STD _Convert_size<size_type>(_Length);
; 788  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 789  :             } else {
; 790  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 791  :             }
; 792  :         }
; 793  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_UFirst$ = 40
_ULast$ = 48
tv70 = 56
this$ = 80
_First$ = 88
_Last$ = 96
_Al$ = 104
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_UVal_trunc$ = 0
_RNext$ = 32
_UVal$ = 40
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 2717 : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // used by both to_string and thread::id output

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2718 :     // format _UVal into buffer *ending at* _RNext
; 2719 :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 2720 : 
; 2721 : #ifdef _WIN64
; 2722 :     auto _UVal_trunc = _UVal;

	mov	eax, DWORD PTR _UVal$[rsp]
	mov	DWORD PTR _UVal_trunc$[rsp], eax
$LN4@UIntegral_:

; 2723 : #else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
; 2724 : 
; 2725 :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 2726 :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 2727 :         while (_UVal > 0xFFFFFFFFU) {
; 2728 :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 2729 :             _UVal /= 1000000000;
; 2730 : 
; 2731 :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 2732 :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 2733 :                 _UVal_chunk /= 10;
; 2734 :             }
; 2735 :         }
; 2736 :     }
; 2737 : 
; 2738 :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 2739 : #endif // ^^^ !defined(_WIN64) ^^^
; 2740 : 
; 2741 :     do {
; 2742 :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	mov	rax, QWORD PTR _RNext$[rsp]
	dec	rax
	mov	QWORD PTR _RNext$[rsp], rax
	xor	edx, edx
	mov	eax, DWORD PTR _UVal_trunc$[rsp]
	mov	ecx, 10
	div	ecx
	mov	eax, edx
	add	eax, 48					; 00000030H
	mov	rcx, QWORD PTR _RNext$[rsp]
	mov	BYTE PTR [rcx], al

; 2743 :         _UVal_trunc /= 10;

	xor	edx, edx
	mov	eax, DWORD PTR _UVal_trunc$[rsp]
	mov	ecx, 10
	div	ecx
	mov	DWORD PTR _UVal_trunc$[rsp], eax

; 2744 :     } while (_UVal_trunc != 0);

	cmp	DWORD PTR _UVal_trunc$[rsp], 0
	jne	SHORT $LN4@UIntegral_

; 2745 :     return _RNext;

	mov	rax, QWORD PTR _RNext$[rsp]

; 2746 : }

	add	rsp, 24
	ret	0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 2061 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2062 :     return _Array + _Size;

	mov	rax, QWORD PTR _Array$[rsp]
	add	rax, 21

; 2063 : }

	ret	0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<40>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<40>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z PROC	; std::_Destroy_in_place<wchar_t *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ENDP	; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> ><std::pair<unsigned __int64 const ,LogMemory> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> ><std::pair<unsigned __int64 const ,LogMemory> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KULogMemory@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> ><std::pair<unsigned __int64 const ,LogMemory> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	ecx, BYTE PTR <_Args_1>$[rsp]
	mov	BYTE PTR [rsp+40], cl
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	movzx	ecx, BYTE PTR <_Args_1>$[rsp]
	mov	BYTE PTR [rsp+40], cl
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Count$ = 96
_Ch$ = 104
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z PROC ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator(), COMDAT

; 1532 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1529 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1530 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1531 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1532 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ENDP ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ; std::forward<std::allocator<wchar_t> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ; std::addressof<wchar_t *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ; std::forward<wchar_t * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Destroy_ra

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1

; 1100 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1101 :     }
; 1102 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv81 = 48
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
<_Val2_1>$ = 104
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv79[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > ><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > ><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {
; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_New_capacity$ = 48
_New_ptr$ = 56
_Alproxy$ = 64
_Al$ = 72
tv135 = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8d, 16
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	rax, QWORD PTR _Count$[rsp]
	inc	rax
	mov	QWORD PTR tv135[rsp], rax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR tv135[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1078 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1079 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1080 :         _Left = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	npad	1

; 1081 :     }
; 1082 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 1505 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1505 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 302  : _CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 303  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 304  : }

	ret	0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z PROC		; std::_Refancy<char const *,0>, COMDAT

; 302  : _CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 303  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 304  : }

	ret	0
??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z ENDP		; std::_Refancy<char const *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Possible_matches_end$ = 56
_Haystack$ = 80
_Hay_size$ = 88
_Start_at$ = 96
_Needle$ = 104
_Needle_size$ = 112
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 613  :     const size_t _Needle_size) noexcept {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 614  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 615  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rax, QWORD PTR _Hay_size$[rsp]
	cmp	QWORD PTR _Needle_size$[rsp], rax
	ja	SHORT $LN6@Traits_fin
	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Start_at$[rsp], rax
	jbe	SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 616  :         // xpos cannot exist, report failure
; 617  :         // N4950 [string.view.find]/3 says:
; 618  :         // 1. _Start_at <= xpos
; 619  :         // 2. xpos + _Needle_size <= _Hay_size;
; 620  :         // therefore:
; 621  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 622  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 623  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 624  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN5@Traits_fin:

; 625  :     }
; 626  : 
; 627  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	cmp	QWORD PTR _Needle_size$[rsp], 0
	jne	SHORT $LN7@Traits_fin

; 628  :         return _Start_at;

	mov	rax, QWORD PTR _Start_at$[rsp]
	jmp	$LN1@Traits_fin
$LN7@Traits_fin:

; 629  :     }
; 630  : 
; 631  : #if _USE_STD_VECTOR_ALGORITHMS
; 632  :     if constexpr (_Is_implementation_handled_char_traits<_Traits> && sizeof(typename _Traits::char_type) <= 2) {
; 633  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@Traits_fin

; 634  :             const auto _End = _Haystack + _Hay_size;

	mov	rax, QWORD PTR _Hay_size$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _End$2[rsp], rax

; 635  :             const auto _Ptr = _STD _Search_vectorized(_Haystack + _Start_at, _End, _Needle, _Needle_size);

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR _Needle_size$[rsp]
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, rax
	call	??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ; std::_Search_vectorized<char const ,char const >
	mov	QWORD PTR _Ptr$3[rsp], rax

; 636  : 
; 637  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN9@Traits_fin

; 638  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	$LN1@Traits_fin

; 639  :             } else {

	jmp	SHORT $LN10@Traits_fin
$LN9@Traits_fin:

; 640  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN10@Traits_fin:
$LN8@Traits_fin:

; 641  :             }
; 642  :         }
; 643  :     }
; 644  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 645  : 
; 646  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Haystack$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR _Possible_matches_end$[rsp], rax

; 647  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_fin
$LN2@Traits_fin:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	inc	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_fin:

; 648  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	mov	rax, QWORD PTR _Match_try$1[rsp]
	mov	rcx, QWORD PTR _Possible_matches_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
	mov	QWORD PTR _Match_try$1[rsp], rax

; 649  :         if (!_Match_try) { // didn't find first character; report failure

	cmp	QWORD PTR _Match_try$1[rsp], 0
	jne	SHORT $LN11@Traits_fin

; 650  :             return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_fin
$LN11@Traits_fin:

; 651  :         }
; 652  : 
; 653  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	mov	r8, QWORD PTR _Needle_size$[rsp]
	mov	rdx, QWORD PTR _Needle$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
	test	eax, eax
	jne	SHORT $LN12@Traits_fin

; 654  :             return static_cast<size_t>(_Match_try - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_fin
$LN12@Traits_fin:

; 655  :         }
; 656  :     }

	jmp	SHORT $LN2@Traits_fin
$LN1@Traits_fin:

; 657  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Actual_start_at$ = 56
$T4 = 64
_Haystack$ = 96
_Hay_size$ = 104
_Start_at$ = 112
_Ch$ = 120
??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z PROC ; std::_Traits_rfind_ch<std::char_traits<char> >, COMDAT

; 720  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {

$LN12:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 721  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 722  : 
; 723  :     if (_Hay_size == 0) { // no room for match

	cmp	QWORD PTR _Hay_size$[rsp], 0
	jne	SHORT $LN5@Traits_rfi

; 724  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_rfi
$LN5@Traits_rfi:

; 725  :     }
; 726  : 
; 727  :     const size_t _Actual_start_at = (_STD min)(_Start_at, _Hay_size - 1);

	mov	rax, QWORD PTR _Hay_size$[rsp]
	dec	rax
	mov	QWORD PTR $T4[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR _Start_at$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Actual_start_at$[rsp], rax

; 728  : 
; 729  : #if _USE_STD_VECTOR_ALGORITHMS
; 730  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 731  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Traits_rfi

; 732  :             const auto _End = _Haystack + _Actual_start_at + 1;

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Actual_start_at$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR _End$2[rsp], rax

; 733  :             const auto _Ptr = _STD _Find_last_vectorized(_Haystack, _End, _Ch);

	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	call	??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ; std::_Find_last_vectorized<char const ,char>
	mov	QWORD PTR _Ptr$3[rsp], rax

; 734  : 
; 735  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN7@Traits_rfi

; 736  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_rfi

; 737  :             } else {

	jmp	SHORT $LN8@Traits_rfi
$LN7@Traits_rfi:

; 738  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN8@Traits_rfi:
$LN6@Traits_rfi:

; 739  :             }
; 740  :         }
; 741  :     }
; 742  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 743  : 
; 744  :     for (auto _Match_try = _Haystack + _Actual_start_at;; --_Match_try) {

	mov	rax, QWORD PTR _Actual_start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_rfi
$LN2@Traits_rfi:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	dec	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_rfi:

; 745  :         if (_Traits::eq(*_Match_try, _Ch)) {

	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rax, QWORD PTR _Match_try$1[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ; std::_Narrow_char_traits<char,int>::eq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Traits_rfi

; 746  :             return static_cast<size_t>(_Match_try - _Haystack); // found a match

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_rfi
$LN9@Traits_rfi:

; 747  :         }
; 748  : 
; 749  :         if (_Match_try == _Haystack) {

	mov	rax, QWORD PTR _Haystack$[rsp]
	cmp	QWORD PTR _Match_try$1[rsp], rax
	jne	SHORT $LN10@Traits_rfi

; 750  :             return static_cast<size_t>(-1); // at beginning, no more chance for match

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN10@Traits_rfi:

; 751  :         }
; 752  :     }

	jmp	SHORT $LN2@Traits_rfi
$LN1@Traits_rfi:

; 753  : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ENDP ; std::_Traits_rfind_ch<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_New_capacity$ = 48
_New_ptr$ = 56
_Alproxy$ = 64
_Al$ = 72
tv135 = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 7
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
	npad	1

; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	mov	r8, rax
	mov	edx, 7
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	rax, QWORD PTR _Count$[rsp]
	inc	rax
	mov	QWORD PTR tv135[rsp], rax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR tv135[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
	npad	1

; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 34
$T2 = 36
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 7
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	mov	r8, rax
	mov	edx, 7
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR $T2[rsp], ax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z PROC		; std::_Refancy<wchar_t *,0>, COMDAT

; 302  : _CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 303  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 304  : }

	ret	0
??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ENDP		; std::_Refancy<wchar_t *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Actual_start_at$ = 56
$T4 = 64
_Haystack$ = 96
_Hay_size$ = 104
_Start_at$ = 112
_Ch$ = 120
??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z PROC ; std::_Traits_rfind_ch<std::char_traits<wchar_t> >, COMDAT

; 720  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {

$LN12:
	mov	WORD PTR [rsp+32], r9w
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 721  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 722  : 
; 723  :     if (_Hay_size == 0) { // no room for match

	cmp	QWORD PTR _Hay_size$[rsp], 0
	jne	SHORT $LN5@Traits_rfi

; 724  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_rfi
$LN5@Traits_rfi:

; 725  :     }
; 726  : 
; 727  :     const size_t _Actual_start_at = (_STD min)(_Start_at, _Hay_size - 1);

	mov	rax, QWORD PTR _Hay_size$[rsp]
	dec	rax
	mov	QWORD PTR $T4[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR _Start_at$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Actual_start_at$[rsp], rax

; 728  : 
; 729  : #if _USE_STD_VECTOR_ALGORITHMS
; 730  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 731  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Traits_rfi

; 732  :             const auto _End = _Haystack + _Actual_start_at + 1;

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Actual_start_at$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2+2]
	mov	QWORD PTR _End$2[rsp], rax

; 733  :             const auto _Ptr = _STD _Find_last_vectorized(_Haystack, _End, _Ch);

	movzx	r8d, WORD PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	call	??$_Find_last_vectorized@$$CB_W_W@std@@YAPEB_WQEB_W0_W@Z ; std::_Find_last_vectorized<wchar_t const ,wchar_t>
	mov	QWORD PTR _Ptr$3[rsp], rax

; 734  : 
; 735  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN7@Traits_rfi

; 736  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	jmp	SHORT $LN1@Traits_rfi

; 737  :             } else {

	jmp	SHORT $LN8@Traits_rfi
$LN7@Traits_rfi:

; 738  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN8@Traits_rfi:
$LN6@Traits_rfi:

; 739  :             }
; 740  :         }
; 741  :     }
; 742  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 743  : 
; 744  :     for (auto _Match_try = _Haystack + _Actual_start_at;; --_Match_try) {

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Actual_start_at$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_rfi
$LN2@Traits_rfi:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	sub	rax, 2
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_rfi:

; 745  :         if (_Traits::eq(*_Match_try, _Ch)) {

	movzx	edx, WORD PTR _Ch$[rsp]
	mov	rax, QWORD PTR _Match_try$1[rsp]
	movzx	ecx, WORD PTR [rax]
	call	?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z	; std::_WChar_traits<wchar_t>::eq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Traits_rfi

; 746  :             return static_cast<size_t>(_Match_try - _Haystack); // found a match

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	jmp	SHORT $LN1@Traits_rfi
$LN9@Traits_rfi:

; 747  :         }
; 748  : 
; 749  :         if (_Match_try == _Haystack) {

	mov	rax, QWORD PTR _Haystack$[rsp]
	cmp	QWORD PTR _Match_try$1[rsp], rax
	jne	SHORT $LN10@Traits_rfi

; 750  :             return static_cast<size_t>(-1); // at beginning, no more chance for match

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN10@Traits_rfi:

; 751  :         }
; 752  :     }

	jmp	SHORT $LN2@Traits_rfi
$LN1@Traits_rfi:

; 753  : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z ENDP ; std::_Traits_rfind_ch<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z
_TEXT	SEGMENT
tv86 = 32
tv84 = 40
tv82 = 48
tv88 = 56
this$ = 80
__formal$ = 88
_Val1$ = 96
<_Val2_0>$ = 104
<_Val2_1>$ = 112
<_Val2_2>$ = 120
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	mov	rcx, QWORD PTR <_Val2_2>$[rsp]
	call	??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv86[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv82[rsp], rax
	mov	r9, QWORD PTR tv86[rsp]
	mov	r8, QWORD PTR tv84[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv88[rsp]
	call	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z
_TEXT	SEGMENT
tv86 = 32
tv84 = 40
tv82 = 48
tv88 = 56
this$ = 80
__formal$ = 88
_Val1$ = 96
<_Val2_0>$ = 104
<_Val2_1>$ = 112
<_Val2_2>$ = 120
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::forward<std::allocator<unsigned char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	mov	rcx, QWORD PTR <_Val2_2>$[rsp]
	call	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ; std::forward<unsigned char *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv86[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ; std::forward<unsigned char *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ; std::forward<unsigned char *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv82[rsp], rax
	mov	r9, QWORD PTR tv86[rsp]
	mov	r8, QWORD PTR tv84[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv88[rsp]
	call	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z PROC	; std::exchange<unsigned char *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ENDP	; std::exchange<unsigned char *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::move<std::allocator<unsigned char> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::move<std::allocator<unsigned char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEBV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEBV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEBV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
i$1 = 32
$T2 = 36
dwBufLen$ = 40
AdapterInfo$ = 48
hex$3 = 56
pAdapterInfo$4 = 64
macAddr$5 = 72
__$ArrayPad$ = 104
__$ReturnUdt$ = 128
?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Utils::GetMACAddress

; 1093 : 	std::string GetMACAddress() {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 1094 : 		PIP_ADAPTER_INFO AdapterInfo;
; 1095 : 		DWORD dwBufLen = sizeof(AdapterInfo);

	mov	DWORD PTR dwBufLen$[rsp], 8

; 1096 : 		AdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));

	mov	ecx, 704				; 000002c0H
	call	malloc
	mov	QWORD PTR AdapterInfo$[rsp], rax

; 1097 : 		if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {

	lea	rdx, QWORD PTR dwBufLen$[rsp]
	mov	rcx, QWORD PTR AdapterInfo$[rsp]
	call	QWORD PTR __imp_GetAdaptersInfo
	cmp	eax, 111				; 0000006fH
	jne	SHORT $LN5@GetMACAddr

; 1098 : 			AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen);

	mov	eax, DWORD PTR dwBufLen$[rsp]
	mov	ecx, eax
	call	malloc
	mov	QWORD PTR AdapterInfo$[rsp], rax
$LN5@GetMACAddr:

; 1099 : 		}
; 1100 : 		if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {

	lea	rdx, QWORD PTR dwBufLen$[rsp]
	mov	rcx, QWORD PTR AdapterInfo$[rsp]
	call	QWORD PTR __imp_GetAdaptersInfo
	test	eax, eax
	jne	$LN6@GetMACAddr

; 1101 : 			PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;

	mov	rax, QWORD PTR AdapterInfo$[rsp]
	mov	QWORD PTR pAdapterInfo$4[rsp], rax

; 1102 : 			std::string macAddr = "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR macAddr$5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1103 : 			for (UINT i = 0; i < pAdapterInfo->AddressLength; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@GetMACAddr
$LN2@GetMACAddr:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@GetMACAddr:
	mov	rax, QWORD PTR pAdapterInfo$4[rsp]
	mov	eax, DWORD PTR [rax+404]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN3@GetMACAddr

; 1104 : 				char hex[3];
; 1105 : 				sprintf(hex, "%02X", pAdapterInfo->Address[i]);

	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR pAdapterInfo$4[rsp]
	movzx	eax, BYTE PTR [rcx+rax+408]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_04JFFKLGJF@?$CF02X@
	lea	rcx, QWORD PTR hex$3[rsp]
	call	sprintf

; 1106 : 				macAddr += hex;

	lea	rdx, QWORD PTR hex$3[rsp]
	lea	rcx, QWORD PTR macAddr$5[rsp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1

; 1107 : 				if (i < pAdapterInfo->AddressLength - 1) {

	mov	rax, QWORD PTR pAdapterInfo$4[rsp]
	mov	eax, DWORD PTR [rax+404]
	dec	eax
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN7@GetMACAddr

; 1108 : 					macAddr += ":";

	lea	rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3@
	lea	rcx, QWORD PTR macAddr$5[rsp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
$LN7@GetMACAddr:

; 1109 : 				}
; 1110 : 			}

	jmp	SHORT $LN2@GetMACAddr
$LN3@GetMACAddr:

; 1111 : 			free(AdapterInfo);

	mov	rcx, QWORD PTR AdapterInfo$[rsp]
	call	free

; 1112 : 			return macAddr;

	lea	rdx, QWORD PTR macAddr$5[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	lea	rcx, QWORD PTR macAddr$5[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetMACAddr
$LN6@GetMACAddr:

; 1113 : 		}
; 1114 : 		free(AdapterInfo);

	mov	rcx, QWORD PTR AdapterInfo$[rsp]
	call	free

; 1115 : 		return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetMACAddr:

; 1116 : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
	int	3
?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Utils::GetMACAddress
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
$T2 = 36
dwBufLen$ = 40
AdapterInfo$ = 48
hex$3 = 56
pAdapterInfo$4 = 64
macAddr$5 = 72
__$ArrayPad$ = 104
__$ReturnUdt$ = 128
?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetMACAddress'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR macAddr$5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetMACAddress'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
$T2 = 36
dwBufLen$ = 40
AdapterInfo$ = 48
hex$3 = 56
pAdapterInfo$4 = 64
macAddr$5 = 72
__$ArrayPad$ = 104
__$ReturnUdt$ = 128
?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetMACAddress'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@dtor$1
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetMACAddress'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
serialNumber$ = 64
$T1 = 68
__$ReturnUdt$ = 96
?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Utils::GetVolumeSerialNumber

; 1078 : 	std::string GetVolumeSerialNumber() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	DWORD PTR $T1[rsp], 0

; 1079 : 		DWORD serialNumber = 0;

	mov	DWORD PTR serialNumber$[rsp], 0

; 1080 : 		GetVolumeInformationA(

	mov	DWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR serialNumber$[rsp]
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_03GIOIKFCO@C?3?2@
	call	QWORD PTR __imp_GetVolumeInformationA

; 1081 : 			"C:\\",
; 1082 : 			NULL,
; 1083 : 			0,
; 1084 : 			&serialNumber,
; 1085 : 			NULL,
; 1086 : 			NULL,
; 1087 : 			NULL,
; 1088 : 			0
; 1089 : 		);
; 1090 : 		return std::to_string(serialNumber);

	mov	edx, DWORD PTR serialNumber$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z ; std::to_string
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1091 : 	}

	add	rsp, 88					; 00000058H
	ret	0
	int	3
?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Utils::GetVolumeSerialNumber
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
serialNumber$ = 64
$T1 = 68
__$ReturnUdt$ = 96
?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetVolumeSerialNumber'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetVolumeSerialNumber'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Utils::GetCPUID

; 1071 : 	std::string GetCPUID() {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rdi
	sub	rsp, 440				; 000001b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 1072 : 		int CPUInfo[4] = { -1 };

	mov	DWORD PTR CPUInfo$[rsp], -1
	lea	rax, QWORD PTR CPUInfo$[rsp+4]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 12
	rep stosb

; 1073 : 		__cpuid(CPUInfo, 0);

	xor	eax, eax
	xor	ecx, ecx
	cpuid
	lea	rdi, QWORD PTR CPUInfo$[rsp]
	mov	DWORD PTR [rdi], eax
	mov	DWORD PTR [rdi+4], ebx
	mov	DWORD PTR [rdi+8], ecx
	mov	DWORD PTR [rdi+12], edx

; 1074 : 		std::string id = std::to_string(CPUInfo[0]) + std::to_string(CPUInfo[1]) + std::to_string(CPUInfo[2]) + std::to_string(CPUInfo[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	edx, DWORD PTR CPUInfo$[rsp+rax]
	lea	rcx, QWORD PTR $T7[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	QWORD PTR tv181[rsp], rax
	mov	rax, QWORD PTR tv181[rsp]
	mov	QWORD PTR tv164[rsp], rax
	mov	rax, QWORD PTR tv164[rsp]
	mov	QWORD PTR tv157[rsp], rax
	mov	eax, 4
	imul	rax, rax, 2
	mov	edx, DWORD PTR CPUInfo$[rsp+rax]
	lea	rcx, QWORD PTR $T6[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	QWORD PTR tv182[rsp], rax
	mov	rax, QWORD PTR tv182[rsp]
	mov	QWORD PTR tv166[rsp], rax
	mov	rax, QWORD PTR tv166[rsp]
	mov	QWORD PTR tv149[rsp], rax
	mov	eax, 4
	imul	rax, rax, 1
	mov	edx, DWORD PTR CPUInfo$[rsp+rax]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	QWORD PTR tv183[rsp], rax
	mov	rax, QWORD PTR tv183[rsp]
	mov	QWORD PTR tv168[rsp], rax
	mov	rax, QWORD PTR tv168[rsp]
	mov	QWORD PTR tv141[rsp], rax
	mov	eax, 4
	imul	rax, rax, 0
	mov	edx, DWORD PTR CPUInfo$[rsp+rax]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	QWORD PTR tv184[rsp], rax
	mov	rax, QWORD PTR tv184[rsp]
	mov	QWORD PTR tv170[rsp], rax
	mov	rax, QWORD PTR tv170[rsp]
	mov	QWORD PTR tv139[rsp], rax
	mov	r8, QWORD PTR tv141[rsp]
	mov	rdx, QWORD PTR tv139[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv185[rsp], rax
	mov	rax, QWORD PTR tv185[rsp]
	mov	QWORD PTR tv172[rsp], rax
	mov	rax, QWORD PTR tv172[rsp]
	mov	QWORD PTR tv147[rsp], rax
	mov	r8, QWORD PTR tv149[rsp]
	mov	rdx, QWORD PTR tv147[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv186[rsp], rax
	mov	rax, QWORD PTR tv186[rsp]
	mov	QWORD PTR tv174[rsp], rax
	mov	rax, QWORD PTR tv174[rsp]
	mov	QWORD PTR tv155[rsp], rax
	mov	r8, QWORD PTR tv157[rsp]
	mov	rdx, QWORD PTR tv155[rsp]
	lea	rcx, QWORD PTR id$[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1075 : 		return id;

	lea	rdx, QWORD PTR id$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR id$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1076 : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 440				; 000001b8H
	pop	rdi
	pop	rbx
	ret	0
	int	3
?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Utils::GetCPUID
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR id$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv181 = 40
tv164 = 48
tv182 = 56
tv166 = 64
tv183 = 72
tv168 = 80
tv184 = 88
tv170 = 96
tv141 = 104
tv139 = 112
tv185 = 120
tv172 = 128
tv149 = 136
tv147 = 144
tv186 = 152
tv174 = 160
tv157 = 168
tv155 = 176
id$ = 184
$T2 = 216
$T3 = 248
$T4 = 280
$T5 = 312
$T6 = 344
$T7 = 376
CPUInfo$ = 408
__$ArrayPad$ = 424
__$ReturnUdt$ = 464
?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetCPUID'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@dtor$7
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@dtor$7:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetCPUID'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$ = 56
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::uniform_real_distribution<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 3286 :     _NODISCARD result_type operator()(_Engine& _Eng) _DISTRIBUTION_CONST {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3287 :         return _Mybase::operator()(_Eng);

	mov	rdx, QWORD PTR _Eng$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_real<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >

; 3288 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::uniform_real_distribution<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??0?$uniform_real_distribution@M@std@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 48
_Min0$ = 56
_Max0$ = 64
??0?$uniform_real_distribution@M@std@@QEAA@MM@Z PROC	; std::uniform_real_distribution<float>::uniform_real_distribution<float>, COMDAT

; 3253 :     explicit uniform_real_distribution(_Ty _Min0, _Ty _Max0 = _Ty{1}) noexcept // strengthened

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3254 :         : _Mybase(_Min0, _Max0) {}

	movss	xmm2, DWORD PTR _Max0$[rsp]
	movss	xmm1, DWORD PTR _Min0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$uniform_real@M@std@@QEAA@MM@Z	; std::uniform_real<float>::uniform_real<float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$uniform_real_distribution@M@std@@QEAA@MM@Z ENDP	; std::uniform_real_distribution<float>::uniform_real_distribution<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z PROC	; std::uniform_real<float>::param_type::_Init, COMDAT

; 3137 :         void _Init(_Ty _Min0, _Ty _Max0) noexcept { // set internal state

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 3138 :             _STL_ASSERT(_Min0 <= _Max0 && (0 <= _Min0 || _Max0 <= _Min0 + (numeric_limits<_Ty>::max)()),
; 3139 :                 "invalid min and max arguments for uniform_real");
; 3140 :             _Min = _Min0;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _Min0$[rsp]
	movss	DWORD PTR [rax], xmm0

; 3141 :             _Max = _Max0;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _Max0$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 3142 :         }

	ret	0
?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z ENDP	; std::uniform_real<float>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??0param_type@?$uniform_real@M@std@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 48
_Min0$ = 56
_Max0$ = 64
??0param_type@?$uniform_real@M@std@@QEAA@MM@Z PROC	; std::uniform_real<float>::param_type::param_type, COMDAT

; 3113 :         explicit param_type(_Ty _Min0, _Ty _Max0 = _Ty{1}) noexcept {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3114 :             _Init(_Min0, _Max0);

	movss	xmm2, DWORD PTR _Max0$[rsp]
	movss	xmm1, DWORD PTR _Min0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z ; std::uniform_real<float>::param_type::_Init
	npad	1

; 3115 :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0param_type@?$uniform_real@M@std@@QEAA@MM@Z ENDP	; std::uniform_real<float>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??0?$uniform_real@M@std@@QEAA@MM@Z
_TEXT	SEGMENT
tv70 = 32
this$ = 64
_Min0$ = 72
_Max0$ = 80
??0?$uniform_real@M@std@@QEAA@MM@Z PROC			; std::uniform_real<float>::uniform_real<float>, COMDAT

; 3150 :     explicit uniform_real(_Ty _Min0, _Ty _Max0 = _Ty{1}) noexcept : _Par(_Min0, _Max0) {}

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	movss	xmm2, DWORD PTR _Max0$[rsp]
	movss	xmm1, DWORD PTR _Min0$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0param_type@?$uniform_real@M@std@@QEAA@MM@Z ; std::uniform_real<float>::param_type::param_type
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$uniform_real@M@std@@QEAA@MM@Z ENDP			; std::uniform_real<float>::uniform_real<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
$T1 = 32
_ULast$ = 40
_UFirst$ = 48
tv70 = 56
_Length$2 = 64
_Count$3 = 72
tv129 = 80
tv95 = 88
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>, COMDAT

; 775  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
	npad	1

; 776  :         _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > >

; 777  :         auto _UFirst = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 778  :         auto _ULast  = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > &>
	mov	QWORD PTR _ULast$[rsp], rax

; 779  :         if (_UFirst == _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	jne	SHORT $LN2@allocator

; 780  :             _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
	npad	1

; 781  :         } else {

	jmp	SHORT $LN3@allocator
$LN2@allocator:

; 782  :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 783  :                 _Construct<_Construct_strategy::_From_ptr>(
; 784  :                     _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 785  :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 786  :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));

	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$distance@PEBD@std@@YA_JPEBD0@Z	; std::distance<char const *>
	mov	QWORD PTR _Length$2[rsp], rax

; 787  :                 const auto _Count  = _STD _Convert_size<size_type>(_Length);

	mov	rcx, QWORD PTR _Length$2[rsp]
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	QWORD PTR _Count$3[rsp], rax

; 788  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);

	lea	rcx, QWORD PTR _ULast$[rsp]
	call	??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z ; std::move<char const * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv129[rsp], rax
	lea	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAPEBD@std@@YA$$QEAPEBDAEAPEBD@Z ; std::move<char const * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv95[rsp], rax
	mov	r9, QWORD PTR _Count$3[rsp]
	mov	r8, QWORD PTR tv129[rsp]
	mov	rdx, QWORD PTR tv95[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct_from_iter@PEBDPEBD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEBDQEBD_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char const *,char const *,unsigned __int64>
	npad	1
$LN3@allocator:

; 789  :             } else {
; 790  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 791  :             }
; 792  :         }
; 793  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	ret	0
??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_ULast$ = 40
_UFirst$ = 48
tv70 = 56
_Length$2 = 64
_Count$3 = 72
tv129 = 80
tv95 = 88
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::DynImport::get<int (__cdecl*)(void *,unsigned long,wchar_t *,unsigned long *)>, COMDAT

; 229  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 230  : 			InitializeOnce();

	call	?InitializeOnce@IronMan@@YA_NXZ		; IronMan::InitializeOnce

; 231  : 
; 232  : 			CSLock lck(_mapGuard);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ; IronMan::CSLock::CSLock
	npad	1

; 233  : 
; 234  : 			auto iter = _funcs.find(hash_(name.c_str()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	rcx, QWORD PTR name$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR $T1[rsp], rax
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR iter$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
	npad	1

; 235  : 			if (iter != _funcs.end() && *reinterpret_cast<int64_t*>(iter->second.func) == iter->second.codehash)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv133[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@get
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv142[rsp], rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv142[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN2@get

; 236  : 				return reinterpret_cast<T>(iter->second.func);

	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T2[rsp]
	jmp	SHORT $LN1@get
$LN2@get:

; 237  : 
; 238  : 			return nullptr;

	mov	QWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T3[rsp]
$LN1@get:

; 239  : 		}

	add	rsp, 120				; 00000078H
	ret	0
??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::DynImport::get<int (__cdecl*)(void *,unsigned long,wchar_t *,unsigned long *)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::DynImport::get<int (__cdecl*)(void *,unsigned long,wchar_t *,unsigned long *)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR lck$[rbp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::DynImport::get<int (__cdecl*)(void *,unsigned long,wchar_t *,unsigned long *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\algorithm
;	COMDAT ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z
_TEXT	SEGMENT
_UFirst$ = 32
_UDest$ = 40
_ULast$ = 48
tv83 = 56
__$ReturnUdt$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
_Func$ = 112
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z PROC ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>, COMDAT

; 3762 : _CONSTEXPR20 _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3763 :     // transform [_First, _Last) with _Func
; 3764 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >

; 3765 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 3766 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 3767 :     auto _UDest       = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	rdx, QWORD PTR _ULast$[rsp]
	lea	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA?A_PAEBQEAD0@Z ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>
	mov	QWORD PTR _UDest$[rsp], rax

; 3768 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

	jmp	SHORT $LN4@transform
$LN2@transform:
	mov	rax, QWORD PTR _UFirst$[rsp]
	inc	rax
	mov	QWORD PTR _UFirst$[rsp], rax
	mov	rax, QWORD PTR _UDest$[rsp]
	inc	rax
	mov	QWORD PTR _UDest$[rsp], rax
$LN4@transform:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@transform

; 3769 :         *_UDest = _Func(*_UFirst);

	mov	rax, QWORD PTR _Func$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _UFirst$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR _UDest$[rsp]
	mov	BYTE PTR [rcx], al

; 3770 :     }

	jmp	SHORT $LN2@transform
$LN3@transform:

; 3771 : 
; 3772 :     _STD _Seek_wrapped(_Dest, _UDest);

	lea	rdx, QWORD PTR _UDest$[rsp]
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>

; 3773 :     return _Dest;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3774 : }

	add	rsp, 72					; 00000048H
	ret	0
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ENDP ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\algorithm
;	COMDAT ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z
_TEXT	SEGMENT
_UFirst$ = 32
_UDest$ = 40
_ULast$ = 48
tv82 = 56
__$ReturnUdt$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
_Func$ = 112
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z PROC ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,unsigned short (__cdecl*)(unsigned short)>, COMDAT

; 3762 : _CONSTEXPR20 _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3763 :     // transform [_First, _Last) with _Func
; 3764 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >

; 3765 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 3766 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 3767 :     auto _UDest       = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	rdx, QWORD PTR _ULast$[rsp]
	lea	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PEA_W@std@@YA?A_PAEBQEA_W0@Z ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t *>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &,__int64>
	mov	QWORD PTR _UDest$[rsp], rax

; 3768 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

	jmp	SHORT $LN4@transform
$LN2@transform:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 2
	mov	QWORD PTR _UFirst$[rsp], rax
	mov	rax, QWORD PTR _UDest$[rsp]
	add	rax, 2
	mov	QWORD PTR _UDest$[rsp], rax
$LN4@transform:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@transform

; 3769 :         *_UDest = _Func(*_UFirst);

	mov	rax, QWORD PTR _Func$[rsp]
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR _UFirst$[rsp]
	movzx	ecx, WORD PTR [rax]
	call	QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR _UDest$[rsp]
	mov	WORD PTR [rcx], ax

; 3770 :     }

	jmp	SHORT $LN2@transform
$LN3@transform:

; 3771 : 
; 3772 :     _STD _Seek_wrapped(_Dest, _UDest);

	lea	rdx, QWORD PTR _UDest$[rsp]
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@AEAPEA_W@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@AEAPEA_W@Z ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,wchar_t * &>

; 3773 :     return _Dest;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3774 : }

	add	rsp, 72					; 00000048H
	ret	0
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z ENDP ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,unsigned short (__cdecl*)(unsigned short)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped, COMDAT

; 346  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 347  :         return const_cast<value_type*>(_STD _Unfancy_maybe_null(this->_Ptr));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z ; std::_Unfancy_maybe_null<wchar_t const >

; 348  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT ??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z PROC ; _vsnprintf_s<4096>, COMDAT

; 1610 :         )

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1603 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	edx, 4096				; 00001000H
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_s
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z ENDP ; _vsnprintf_s<4096>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
;	COMDAT ??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z
_TEXT	SEGMENT
_Buffer$ = 48
_Format$ = 56
_ArgList$ = 64
??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z PROC	; vswprintf_s<4096>, COMDAT

; 1290 :         )

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1284 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

	mov	r9, QWORD PTR _ArgList$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	edx, 4096				; 00001000H
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	vswprintf_s
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z ENDP	; vswprintf_s<4096>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@_K@std@@YA$$QEA_KAEA_K@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_K@std@@YA$$QEA_KAEA_K@Z PROC		; std::forward<unsigned __int64>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@_K@std@@YA$$QEA_KAEA_K@Z ENDP		; std::forward<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU_MEMORY_BASIC_INFORMATION@@@std@@YAAEAPEAU_MEMORY_BASIC_INFORMATION@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU_MEMORY_BASIC_INFORMATION@@@std@@YAAEAPEAU_MEMORY_BASIC_INFORMATION@@AEAPEAU1@@Z PROC ; std::forward<_MEMORY_BASIC_INFORMATION * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU_MEMORY_BASIC_INFORMATION@@@std@@YAAEAPEAU_MEMORY_BASIC_INFORMATION@@AEAPEAU1@@Z ENDP ; std::forward<_MEMORY_BASIC_INFORMATION * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEBX@std@@YA$$QEAPEBXAEAPEBX@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEBX@std@@YA$$QEAPEBXAEAPEBX@Z PROC		; std::forward<void const *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEBX@std@@YA$$QEAPEBXAEAPEBX@Z ENDP		; std::forward<void const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::DynImport::get<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64)>, COMDAT

; 229  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 230  : 			InitializeOnce();

	call	?InitializeOnce@IronMan@@YA_NXZ		; IronMan::InitializeOnce

; 231  : 
; 232  : 			CSLock lck(_mapGuard);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ; IronMan::CSLock::CSLock
	npad	1

; 233  : 
; 234  : 			auto iter = _funcs.find(hash_(name.c_str()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	rcx, QWORD PTR name$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR $T1[rsp], rax
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR iter$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
	npad	1

; 235  : 			if (iter != _funcs.end() && *reinterpret_cast<int64_t*>(iter->second.func) == iter->second.codehash)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv133[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@get
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv142[rsp], rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv142[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN2@get

; 236  : 				return reinterpret_cast<T>(iter->second.func);

	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T2[rsp]
	jmp	SHORT $LN1@get
$LN2@get:

; 237  : 
; 238  : 			return nullptr;

	mov	QWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T3[rsp]
$LN1@get:

; 239  : 		}

	add	rsp, 120				; 00000078H
	ret	0
??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::DynImport::get<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::DynImport::get<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR lck$[rbp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::DynImport::get<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z
_TEXT	SEGMENT
pfn$ = 32
tv86 = 40
tv82 = 48
tv80 = 56
tv78 = 64
tv84 = 72
this$ = 96
name$ = 104
<args_0>$ = 112
<args_1>$ = 120
<args_2>$ = 128
??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z PROC ; IronMan::DynImport::safeCall<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64),void const *,_MEMORY_BASIC_INFORMATION * &,unsigned __int64>, COMDAT

; 264  : 		{

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 265  : 			auto pfn = DynImport::get<T>(name);

	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$get@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@Z@DynImport@IronMan@@QEAAP6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64)>
	mov	QWORD PTR pfn$[rsp], rax

; 266  : 			return pfn ? pfn(std::forward<Args>(args)...) : std::invoke_result_t<T, Args...>();

	cmp	QWORD PTR pfn$[rsp], 0
	je	SHORT $LN3@safeCall
	mov	rax, QWORD PTR pfn$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR <args_2>$[rsp]
	call	??$forward@_K@std@@YA$$QEA_KAEA_K@Z	; std::forward<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv82[rsp], rax
	mov	rcx, QWORD PTR <args_1>$[rsp]
	call	??$forward@AEAPEAU_MEMORY_BASIC_INFORMATION@@@std@@YAAEAPEAU_MEMORY_BASIC_INFORMATION@@AEAPEAU1@@Z ; std::forward<_MEMORY_BASIC_INFORMATION * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv80[rsp], rax
	mov	rcx, QWORD PTR <args_0>$[rsp]
	call	??$forward@PEBX@std@@YA$$QEAPEBXAEAPEBX@Z ; std::forward<void const *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv82[rsp]
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	QWORD PTR tv84[rsp]
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN4@safeCall
$LN3@safeCall:
	mov	QWORD PTR tv86[rsp], 0
$LN4@safeCall:
	mov	rax, QWORD PTR tv86[rsp]

; 267  : 		}

	add	rsp, 88					; 00000058H
	ret	0
??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z ENDP ; IronMan::DynImport::safeCall<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64),void const *,_MEMORY_BASIC_INFORMATION * &,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
_ULast$ = 32
_UFirst$ = 40
tv81 = 48
tv79 = 56
_UDest$ = 64
tv91 = 72
tv93 = 80
tv89 = 88
$T1 = 96
__$ReturnUdt$ = 128
_First$ = 136
_Last$ = 144
_Dest$ = 152
??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >, COMDAT

; 4876 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 4877 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >

; 4878 :     const auto _UFirst = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 4879 :     const auto _ULast  = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
	mov	QWORD PTR _ULast$[rsp], rax

; 4880 :     auto _UDest        = _STD _Get_unwrapped_n(_STD move(_Dest), _STD _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	rdx, QWORD PTR _ULast$[rsp]
	lea	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Idl_distance@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEBE@std@@YA?A_PAEBQEBE0@Z ; std::_Idl_distance<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char const *>
	mov	QWORD PTR tv81[rsp], rax
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AEAV10@@Z ; std::move<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &>
	mov	QWORD PTR tv79[rsp], rax
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_T$$QEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,__int64>
	mov	QWORD PTR _UDest$[rsp], rax

; 4881 :     _STD _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _STD move(_UDest)));

	lea	rcx, QWORD PTR _UDest$[rsp]
	call	??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z ; std::move<unsigned char * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rax, QWORD PTR _ULast$[rsp]
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	mov	r8, QWORD PTR tv91[rsp]
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv89[rsp]
	call	??$_Copy_unchecked@PEBEPEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ; std::_Copy_unchecked<unsigned char const *,unsigned char const *,unsigned char *>
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
	npad	1

; 4882 :     return _Dest;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 4883 : }

	add	rsp, 120				; 00000078H
	ret	0
??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped, COMDAT

; 344  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z ; std::_Unfancy_maybe_null<unsigned char>

; 346  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z
_TEXT	SEGMENT
this$ = 48
_It$ = 56
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to, COMDAT

; 220  :     _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 221  :         _Ptr = _STD _Refancy_maybe_null<_Tptr>(const_cast<value_type*>(_It));

	mov	rcx, QWORD PTR _It$[rsp]
	call	??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ; std::_Refancy_maybe_null<unsigned char *,0>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 222  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped, COMDAT

; 216  :     _NODISCARD _CONSTEXPR20 const value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 217  :         return _STD _Unfancy_maybe_null(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z ; std::_Unfancy_maybe_null<unsigned char>

; 218  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEBEXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset, COMDAT

; 110  :     _CONSTEXPR20 void _Verify_offset(const difference_type _Off) const noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 111  : #if _ITERATOR_DEBUG_LEVEL == 0
; 112  :         (void) _Off;
; 113  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 114  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 115  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 116  :         _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
; 117  :         if (_Off < 0) {
; 118  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 119  :         }
; 120  : 
; 121  :         if (_Off > 0) {
; 122  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 123  :         }
; 124  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 125  :     }

	ret	0
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pvector$ = 64
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 47   :         this->_Adopt(_Pvector);

	mov	rdx, QWORD PTR _Pvector$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 48   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Count$ = 72
_Val$ = 80
_Al$ = 88
??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::allocator<unsigned char>,0>, COMDAT

; 672  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
	npad	1

; 673  :         _Construct_n(_Count, _Val);

	mov	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct_n@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const &>
	npad	1

; 674  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::allocator<unsigned char>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero, COMDAT

; 2025 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2026 :         // allocate array with _Newcapacity elements
; 2027 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2028 :         auto& _My_data    = _Mypair._Myval2;
; 2029 :         pointer& _Myfirst = _My_data._Myfirst;
; 2030 :         pointer& _Mylast  = _My_data._Mylast;
; 2031 :         pointer& _Myend   = _My_data._Myend;
; 2032 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2033 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2034 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2035 : 
; 2036 :         if (_Newcapacity > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	cmp	QWORD PTR _Newcapacity$[rsp], rax
	jbe	SHORT $LN2@Buy_nonzer

; 2037 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN2@Buy_nonzer:

; 2038 :         }
; 2039 : 
; 2040 :         _Buy_raw(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
	npad	1
$LN3@Buy_nonzer:

; 2041 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
_My_data$ = 32
_Newvec$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newcapacity$ = 104
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw, COMDAT

; 2009 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2010 :         // allocate array with _Newcapacity elements
; 2011 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2012 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2013 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2014 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2015 : 
; 2016 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2017 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 2018 : 
; 2019 :         const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, rax
	call	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
	mov	QWORD PTR _Newvec$[rsp], rax

; 2020 :         _Myfirst              = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2021 :         _Mylast               = _Newvec;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2022 :         _Myend                = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2023 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT

; 1912 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1913 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1914 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1915 :         _STL_VERIFY(
; 1916 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1917 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1918 : 
; 1919 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR _Pos$[rsp]

; 1920 :     }

	add	rsp, 24
	ret	0
??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT

; 1898 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1899 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx

; 1901 :     }

	add	rsp, 24
	ret	0
?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT

; 1840 :     _NODISCARD _CONSTEXPR20 const_iterator end() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1841 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1842 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEBV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEBV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > const >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1843 :     }

	add	rsp, 72					; 00000048H
	ret	0
?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT

; 1830 :     _NODISCARD _CONSTEXPR20 const_iterator begin() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1831 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1832 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEBV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEBV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > const >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1833 :     }

	add	rsp, 72					; 00000048H
	ret	0
?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
tv80 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT

; 1825 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1826 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1827 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1828 :     }

	add	rsp, 72					; 00000048H
	ret	0
?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
$T4 = 58
$T5 = 66
$T6 = 80
$T7 = 88
$T8 = 96
tv128 = 104
tv130 = 112
tv139 = 120
tv155 = 128
this$ = 160
_Right$ = 168
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 748  :               _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 745  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	mov	QWORD PTR $T3[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 16
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rax
	call	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
	mov	QWORD PTR $T6[rsp], rax
	mov	QWORD PTR $T4[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rax
	call	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
	mov	QWORD PTR $T7[rsp], rax
	mov	QWORD PTR $T5[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rax
	call	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
	mov	QWORD PTR $T8[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::move<std::allocator<unsigned char> &>
	mov	QWORD PTR tv128[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T8[rsp]
	mov	r8, QWORD PTR tv128[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
	npad	1

; 749  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv139[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv139[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 750  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv155[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv155[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 751  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 152				; 00000098H
	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z PROC	; std::allocator<unsigned char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ENDP	; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@E@std@@QEAA@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@E@std@@QEAA@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
padded_length$ = 40
i$4 = 48
original_length$ = 56
bit_length$ = 64
tv79 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
tv143 = 128
padded$ = 136
$T11 = 160
$T12 = 168
$T13 = 176
$T14 = 184
__$ReturnUdt$ = 208
input$ = 216
?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z PROC ; IronMan::Utils::pad

; 72   : 	std::vector<uint8_t> pad(const std::vector<uint8_t>& input) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	DWORD PTR $T3[rsp], 0

; 73   : 		size_t original_length = input.size();

	mov	rcx, QWORD PTR input$[rsp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	mov	QWORD PTR original_length$[rsp], rax

; 74   : 		size_t padded_length = original_length + 1 + 8;

	mov	rax, QWORD PTR original_length$[rsp]
	add	rax, 9
	mov	QWORD PTR padded_length$[rsp], rax
$LN2@pad:

; 75   : 
; 76   : 		while (padded_length % 64 != 0) {

	xor	edx, edx
	mov	rax, QWORD PTR padded_length$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN3@pad

; 77   : 			padded_length++;

	mov	rax, QWORD PTR padded_length$[rsp]
	inc	rax
	mov	QWORD PTR padded_length$[rsp], rax

; 78   : 		}

	jmp	SHORT $LN2@pad
$LN3@pad:

; 79   : 
; 80   : 		std::vector<uint8_t> padded(padded_length, 0);

	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$allocator@E@std@@QEAA@XZ		; std::allocator<unsigned char>::allocator<unsigned char>
	mov	QWORD PTR tv79[rsp], rax
	mov	BYTE PTR $T1[rsp], 0
	mov	r9, QWORD PTR tv79[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR padded_length$[rsp]
	lea	rcx, QWORD PTR padded$[rsp]
	call	??$?0V?$allocator@E@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBEAEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::allocator<unsigned char>,0>
	npad	1

; 81   : 		std::copy(input.begin(), input.end(), padded.begin());

	lea	rdx, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR padded$[rsp]
	call	?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T8[rsp], rax
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR input$[rsp]
	call	?end@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T6[rsp], rax
	mov	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T9[rsp], rax
	lea	rdx, QWORD PTR $T13[rsp]
	mov	rcx, QWORD PTR input$[rsp]
	call	?begin@?$vector@EV?$allocator@E@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T7[rsp], rax
	mov	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T10[rsp], rax
	mov	r9, QWORD PTR $T8[rsp]
	mov	r8, QWORD PTR $T9[rsp]
	mov	rdx, QWORD PTR $T10[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??$copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z ; std::copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
	npad	1

; 82   : 		padded[original_length] = 0x80;

	mov	rdx, QWORD PTR original_length$[rsp]
	lea	rcx, QWORD PTR padded$[rsp]
	call	??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
	mov	BYTE PTR [rax], 128			; 00000080H

; 83   : 
; 84   : 		uint64_t bit_length = original_length * 8;

	mov	rax, QWORD PTR original_length$[rsp]
	shl	rax, 3
	mov	QWORD PTR bit_length$[rsp], rax

; 85   : 		for (size_t i = 0; i < 8; ++i) {

	mov	QWORD PTR i$4[rsp], 0
	jmp	SHORT $LN6@pad
$LN4@pad:
	mov	rax, QWORD PTR i$4[rsp]
	inc	rax
	mov	QWORD PTR i$4[rsp], rax
$LN6@pad:
	cmp	QWORD PTR i$4[rsp], 8
	jae	SHORT $LN5@pad

; 86   : 			padded[padded_length - 1 - i] = bit_length & 0xFF;

	mov	rax, QWORD PTR bit_length$[rsp]
	and	rax, 255				; 000000ffH
	mov	QWORD PTR tv143[rsp], rax
	mov	rcx, QWORD PTR padded_length$[rsp]
	dec	rcx
	sub	rcx, QWORD PTR i$4[rsp]
	mov	rdx, rcx
	lea	rcx, QWORD PTR padded$[rsp]
	call	??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
	mov	rcx, QWORD PTR tv143[rsp]
	mov	BYTE PTR [rax], cl

; 87   : 			bit_length >>= 8;

	mov	rax, QWORD PTR bit_length$[rsp]
	shr	rax, 8
	mov	QWORD PTR bit_length$[rsp], rax

; 88   : 		}

	jmp	SHORT $LN4@pad
$LN5@pad:

; 89   : 
; 90   : 		return padded;

	lea	rdx, QWORD PTR padded$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR $T3[rsp]
	or	eax, 1
	mov	DWORD PTR $T3[rsp], eax
	lea	rcx, QWORD PTR padded$[rsp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 91   : 	}

	add	rsp, 200				; 000000c8H
	ret	0
	int	3
?pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z ENDP ; IronMan::Utils::pad
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
padded_length$ = 40
i$4 = 48
original_length$ = 56
bit_length$ = 64
tv79 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
tv143 = 128
padded$ = 136
$T11 = 160
$T12 = 168
$T13 = 176
$T14 = 184
__$ReturnUdt$ = 208
input$ = 216
?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA PROC ; `IronMan::Utils::pad'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR padded$[rbp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA ENDP ; `IronMan::Utils::pad'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
padded_length$ = 40
i$4 = 48
original_length$ = 56
bit_length$ = 64
tv79 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
tv143 = 128
padded$ = 136
$T11 = 160
$T12 = 168
$T13 = 176
$T14 = 184
__$ReturnUdt$ = 208
input$ = 216
?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA PROC ; `IronMan::Utils::pad'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T3[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T3[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??pad@Utils@IronMan@@YA?AV?$vector@EV?$allocator@E@std@@@std@@AEBV34@@Z@4HA ENDP ; `IronMan::Utils::pad'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
value$ = 8
count$ = 16
?right_rotate@Utils@IronMan@@YAIII@Z PROC		; IronMan::Utils::right_rotate

; 68   : 	uint32_t right_rotate(uint32_t value, uint32_t count) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 69   : 		return (value >> count) | (value << (32 - count));

	mov	eax, DWORD PTR count$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR value$[rsp]
	shr	eax, cl
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR count$[rsp]
	mov	edx, DWORD PTR value$[rsp]
	shl	edx, cl
	mov	ecx, edx
	or	eax, ecx

; 70   : 	}

	ret	0
?right_rotate@Utils@IronMan@@YAIII@Z ENDP		; IronMan::Utils::right_rotate
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FVirutalMap@Utils@IronMan@@YAXXZ
text$yd	SEGMENT
??__FVirutalMap@Utils@IronMan@@YAXXZ PROC		; IronMan::Utils::`dynamic atexit destructor for 'VirutalMap'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?VirutalMap@Utils@IronMan@@3V?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@A ; IronMan::Utils::VirutalMap
	call	??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__FVirutalMap@Utils@IronMan@@YAXXZ ENDP		; IronMan::Utils::`dynamic atexit destructor for 'VirutalMap''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
;	COMDAT ??__EVirutalMap@Utils@IronMan@@YAXXZ
text$di	SEGMENT
??__EVirutalMap@Utils@IronMan@@YAXXZ PROC		; IronMan::Utils::`dynamic initializer for 'VirutalMap'', COMDAT

; 38   : 	std::unordered_map<ptr_t, LogMemory>VirutalMap;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?VirutalMap@Utils@IronMan@@3V?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@A ; IronMan::Utils::VirutalMap
	call	??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
	lea	rcx, OFFSET FLAT:??__FVirutalMap@Utils@IronMan@@YAXXZ ; IronMan::Utils::`dynamic atexit destructor for 'VirutalMap''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__EVirutalMap@Utils@IronMan@@YAXXZ ENDP		; IronMan::Utils::`dynamic initializer for 'VirutalMap''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,LogMemory> >::allocator<std::pair<unsigned __int64 const ,LogMemory> >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@_KULogMemory@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::unordered_map<unsigned __int64,LogMemory,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > ><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::~list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KULogMemory@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,LogMemory> > >,1><std::allocator<std::pair<unsigned __int64 const ,LogMemory> > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CB_KULogMemory@@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >::list<std::pair<unsigned __int64 const ,LogMemory>,std::allocator<std::pair<unsigned __int64 const ,LogMemory> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z	; std::_Get_size_of_n<40>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KULogMemory@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,LogMemory>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@_KULogMemory@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>::_Umap_traits<unsigned __int64,LogMemory,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,LogMemory> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,LogMemory> >::allocator<std::pair<unsigned __int64 const ,LogMemory> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CB_KULogMemory@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,LogMemory> >::allocator<std::pair<unsigned __int64 const ,LogMemory> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=, COMDAT

; 201  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 203  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ
text$yd	SEGMENT
??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ PROC ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance'', COMDAT
$LN3:
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance
	call	??1DynImport@IronMan@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ ENDP ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1DynImport@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1DynImport@IronMan@@QEAA@XZ PROC			; IronMan::DynImport::~DynImport, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??1CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::~CriticalSection
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1DynImport@IronMan@@QEAA@XZ ENDP			; IronMan::DynImport::~DynImport
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::~DynImport'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::~DynImport'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::~DynImport'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::~CriticalSection
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::~DynImport'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z	; std::_Get_size_of_n<40>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 48
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z PROC		; std::hash<unsigned __int64>::_Do_hash, COMDAT

; 2355 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2356 :         return _Hash_representation(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$_Hash_representation@_K@std@@YA_KAEB_K@Z ; std::_Hash_representation<unsigned __int64>

; 2357 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z ENDP		; std::hash<unsigned __int64>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z PROC ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator(), COMDAT

; 2337 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2338 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z	; std::hash<unsigned __int64>::_Do_hash

; 2339 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ENDP ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z PROC		; std::equal_to<unsigned __int64>::operator(), COMDAT

; 634  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 635  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 636  :     }

	add	rsp, 24
	ret	0
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z ENDP		; std::equal_to<unsigned __int64>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size, COMDAT

; 160  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 161  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 162  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
tv75 = 40
this$ = 64
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >, COMDAT

; 137  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR $T3[rsp], xmm0
	lea	r9, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??0DynImport@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0DynImport@IronMan@@QEAA@XZ PROC			; IronMan::DynImport::DynImport, COMDAT

; 219  : 		DynImport() = default;

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::CriticalSection
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0DynImport@IronMan@@QEAA@XZ ENDP			; IronMan::DynImport::DynImport
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::DynImport'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::DynImport'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::DynImport'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::~CriticalSection
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::DynImport'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ?Instance@DynImport@IronMan@@SAAEAV12@XZ
_TEXT	SEGMENT
?Instance@DynImport@IronMan@@SAAEAV12@XZ PROC		; IronMan::DynImport::Instance, COMDAT

; 214  : 		{

$LN5:
	sub	rsp, 40					; 00000028H

; 215  : 			static DynImport instance;

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA, eax ; `IronMan::DynImport::Instance'::`2'::$TSS0
	jle	SHORT $LN2@Instance
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA, -1 ; `IronMan::DynImport::Instance'::`2'::$TSS0
	jne	SHORT $LN2@Instance
	lea	rcx, OFFSET FLAT:?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance
	call	??0DynImport@IronMan@@QEAA@XZ		; IronMan::DynImport::DynImport
	lea	rcx, OFFSET FLAT:??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
	call	_Init_thread_footer
	npad	1
$LN2@Instance:

; 216  : 			return instance;

	lea	rax, OFFSET FLAT:?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance

; 217  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?Instance@DynImport@IronMan@@SAAEAV12@XZ ENDP		; IronMan::DynImport::Instance
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA PROC ; `IronMan::DynImport::Instance'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA ENDP ; `IronMan::DynImport::Instance'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped, COMDAT

; 346  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 347  :         return const_cast<value_type*>(_STD _Unfancy_maybe_null(this->_Ptr));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z ; std::_Unfancy_maybe_null<char const >

; 348  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 48
??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator(), COMDAT

; 1528 :     _NODISCARD result_type operator()() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1529 :         return _Mybase::operator()();

	mov	rcx, QWORD PTR this$[rsp]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 1530 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z
_TEXT	SEGMENT
this$ = 48
_Xx0$ = 56
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>, COMDAT

; 1455 :     explicit mersenne_twister_engine(result_type _Xx0) : _Mybase(_Xx0, _Dx, _Fx) {}

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9d, 1812433253				; 6c078965H
	mov	r8d, -1					; ffffffffH
	mov	edx, DWORD PTR _Xx0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
_TEXT	SEGMENT
_Tmp$1 = 0
tv128 = 4
tv130 = 8
_Ix$2 = 16
this$ = 48
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper, COMDAT

; 1403 :     void _Refill_upper() { // compute values for the upper half of the history array

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1404 :         for (size_t _Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	mov	QWORD PTR _Ix$2[rsp], 624		; 00000270H
	jmp	SHORT $LN4@Refill_upp
$LN2@Refill_upp:
	mov	rax, QWORD PTR _Ix$2[rsp]
	inc	rax
	mov	QWORD PTR _Ix$2[rsp], rax
$LN4@Refill_upp:
	cmp	QWORD PTR _Ix$2[rsp], 1248		; 000004e0H
	jae	$LN3@Refill_upp

; 1405 :             const _Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ix$2[rsp]
	mov	eax, DWORD PTR [rax+rcx*4-2492]
	and	eax, -2147483648			; 80000000H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$2[rsp]
	mov	ecx, DWORD PTR [rcx+rdx*4-2488]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR _Tmp$1[rsp], eax

; 1406 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, DWORD PTR _Tmp$1[rsp]
	shr	eax, 1
	mov	DWORD PTR tv130[rsp], eax
	mov	eax, DWORD PTR _Tmp$1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@Refill_upp
	mov	DWORD PTR tv128[rsp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN7@Refill_upp
$LN6@Refill_upp:
	mov	DWORD PTR tv128[rsp], 0
$LN7@Refill_upp:
	mov	eax, DWORD PTR tv128[rsp]
	mov	ecx, DWORD PTR tv130[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$2[rsp]
	xor	eax, DWORD PTR [rcx+rdx*4-904]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$2[rsp]
	mov	DWORD PTR [rcx+rdx*4+4], eax

; 1407 :         }

	jmp	$LN2@Refill_upp
$LN3@Refill_upp:

; 1408 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
_TEXT	SEGMENT
_Ix$1 = 0
_Ix$2 = 8
_Tmp$3 = 16
tv128 = 20
_Tmp$4 = 24
tv174 = 28
_Tmp$5 = 32
tv215 = 36
tv130 = 40
tv176 = 44
tv217 = 48
_Wrap_bound_one$ = 56
_Wrap_bound_m$ = 64
_Ix$6 = 72
this$ = 96
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower, COMDAT

; 1363 :     _Post_satisfies_(this->_Idx == 0) void _Refill_lower() {

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1364 :         // compute values for the lower half of the history array
; 1365 :         constexpr size_t _Wrap_bound_one = _Nx - _One_mod_n;

	mov	QWORD PTR _Wrap_bound_one$[rsp], 623	; 0000026fH

; 1366 :         constexpr size_t _Wrap_bound_m   = _Nx - _M_mod_n;

	mov	QWORD PTR _Wrap_bound_m$[rsp], 227	; 000000e3H

; 1367 : 
; 1368 :         if constexpr (_M_mod_n == 0) {
; 1369 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_one; ++_Ix) { // fill in values
; 1370 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);
; 1371 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];
; 1372 :             }
; 1373 : 
; 1374 :             if constexpr (_One_mod_n == 1) { // fill in _Ax[_Nx - 1]
; 1375 :                 constexpr size_t _Ix = _Wrap_bound_one;
; 1376 : 
; 1377 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);
; 1378 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];
; 1379 :             }
; 1380 :         } else {
; 1381 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_m; ++_Ix) { // fill in lower region

	mov	QWORD PTR _Ix$1[rsp], 0
	jmp	SHORT $LN4@Refill_low
$LN2@Refill_low:
	mov	rax, QWORD PTR _Ix$1[rsp]
	inc	rax
	mov	QWORD PTR _Ix$1[rsp], rax
$LN4@Refill_low:
	cmp	QWORD PTR _Ix$1[rsp], 227		; 000000e3H
	jae	$LN3@Refill_low

; 1382 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ix$1[rsp]
	mov	eax, DWORD PTR [rax+rcx*4+2500]
	and	eax, -2147483648			; 80000000H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$1[rsp]
	mov	ecx, DWORD PTR [rcx+rdx*4+2504]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR _Tmp$3[rsp], eax

; 1383 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];

	mov	eax, DWORD PTR _Tmp$3[rsp]
	shr	eax, 1
	mov	DWORD PTR tv130[rsp], eax
	mov	eax, DWORD PTR _Tmp$3[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@Refill_low
	mov	DWORD PTR tv128[rsp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN10@Refill_low
$LN9@Refill_low:
	mov	DWORD PTR tv128[rsp], 0
$LN10@Refill_low:
	mov	eax, DWORD PTR tv128[rsp]
	mov	ecx, DWORD PTR tv130[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$1[rsp]
	xor	eax, DWORD PTR [rcx+rdx*4+4088]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$1[rsp]
	mov	DWORD PTR [rcx+rdx*4+4], eax

; 1384 :             }

	jmp	$LN2@Refill_low
$LN3@Refill_low:

; 1385 : 
; 1386 :             for (size_t _Ix = _Wrap_bound_m; _Ix < _Wrap_bound_one; ++_Ix) {

	mov	QWORD PTR _Ix$2[rsp], 227		; 000000e3H
	jmp	SHORT $LN7@Refill_low
$LN5@Refill_low:
	mov	rax, QWORD PTR _Ix$2[rsp]
	inc	rax
	mov	QWORD PTR _Ix$2[rsp], rax
$LN7@Refill_low:
	cmp	QWORD PTR _Ix$2[rsp], 623		; 0000026fH
	jae	$LN6@Refill_low

; 1387 :                 // fill in upper region (avoids modulus operation)
; 1388 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ix$2[rsp]
	mov	eax, DWORD PTR [rax+rcx*4+2500]
	and	eax, -2147483648			; 80000000H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$2[rsp]
	mov	ecx, DWORD PTR [rcx+rdx*4+2504]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR _Tmp$4[rsp], eax

; 1389 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, DWORD PTR _Tmp$4[rsp]
	shr	eax, 1
	mov	DWORD PTR tv176[rsp], eax
	mov	eax, DWORD PTR _Tmp$4[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@Refill_low
	mov	DWORD PTR tv174[rsp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN12@Refill_low
$LN11@Refill_low:
	mov	DWORD PTR tv174[rsp], 0
$LN12@Refill_low:
	mov	eax, DWORD PTR tv174[rsp]
	mov	ecx, DWORD PTR tv176[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$2[rsp]
	xor	eax, DWORD PTR [rcx+rdx*4-904]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ix$2[rsp]
	mov	DWORD PTR [rcx+rdx*4+4], eax

; 1390 :             }

	jmp	$LN5@Refill_low
$LN6@Refill_low:

; 1391 : 
; 1392 :             if constexpr (_One_mod_n == 1) { // fill in _Ax[_Nx - 1]
; 1393 :                 constexpr size_t _Ix = _Wrap_bound_one;

	mov	QWORD PTR _Ix$6[rsp], 623		; 0000026fH

; 1394 : 
; 1395 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

	mov	eax, 4
	imul	rax, rax, 1247				; 000004dfH
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, -2147483648			; 80000000H
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+4]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR _Tmp$5[rsp], eax

; 1396 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, DWORD PTR _Tmp$5[rsp]
	shr	eax, 1
	mov	DWORD PTR tv217[rsp], eax
	mov	eax, DWORD PTR _Tmp$5[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN13@Refill_low
	mov	DWORD PTR tv215[rsp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN14@Refill_low
$LN13@Refill_low:
	mov	DWORD PTR tv215[rsp], 0
$LN14@Refill_low:
	mov	eax, DWORD PTR tv215[rsp]
	mov	ecx, DWORD PTR tv217[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 396				; 0000018cH
	mov	rdx, QWORD PTR this$[rsp]
	xor	eax, DWORD PTR [rdx+rcx+4]
	mov	ecx, 4
	imul	rcx, rcx, 623				; 0000026fH
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx+4], eax

; 1397 :             }
; 1398 :         }
; 1399 : 
; 1400 :         this->_Idx = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 1401 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
_TEXT	SEGMENT
_Res$ = 32
tv128 = 36
this$ = 64
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT

; 1341 :     _NODISCARD result_type operator()() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1342 :         if (this->_Idx == _Nx) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 624			; 00000270H
	jne	SHORT $LN2@operator

; 1343 :             _Refill_upper();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
	npad	1
	jmp	SHORT $LN3@operator
$LN2@operator:

; 1344 :         } else if (2 * _Nx <= this->_Idx) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 1248			; 000004e0H
	jb	SHORT $LN4@operator

; 1345 :             _Refill_lower();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
	npad	1
$LN4@operator:
$LN3@operator:

; 1346 :         }
; 1347 : 
; 1348 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+4]
	mov	DWORD PTR tv128[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR tv128[rsp]
	mov	DWORD PTR _Res$[rsp], eax

; 1349 :         _Res ^= (_Res >> _Ux) & _Dxval;

	mov	eax, DWORD PTR _Res$[rsp]
	shr	eax, 11
	mov	rcx, QWORD PTR this$[rsp]
	and	eax, DWORD PTR [rcx+4996]
	mov	ecx, DWORD PTR _Res$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR _Res$[rsp], eax

; 1350 :         _Res ^= (_Res << _Sx) & _Bx;

	mov	eax, DWORD PTR _Res$[rsp]
	shl	eax, 7
	and	eax, -1658038656			; 9d2c5680H
	mov	ecx, DWORD PTR _Res$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR _Res$[rsp], eax

; 1351 :         _Res ^= (_Res << _Tx) & _Cx;

	mov	eax, DWORD PTR _Res$[rsp]
	shl	eax, 15
	and	eax, -272236544				; efc60000H
	mov	ecx, DWORD PTR _Res$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR _Res$[rsp], eax

; 1352 :         _Res ^= (_Res & _WMSK) >> _Lx;

	mov	eax, DWORD PTR _Res$[rsp]
	shr	eax, 18
	mov	ecx, DWORD PTR _Res$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR _Res$[rsp], eax

; 1353 :         return _Res;

	mov	eax, DWORD PTR _Res$[rsp]

; 1354 :     }

	add	rsp, 56					; 00000038H
	ret	0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z
_TEXT	SEGMENT
_Prev$ = 0
_Ix$1 = 8
tv85 = 16
this$ = 48
_Xx0$ = 56
_Fx$ = 64
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed, COMDAT

; 1282 :     void seed(_Ty _Xx0 = default_seed, _Ty _Fx = static_cast<_Ty>(1812433253)) {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1283 :         // set initial values from specified value
; 1284 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR _Xx0$[rsp]
	mov	DWORD PTR [rcx+rax+4], edx
	mov	eax, DWORD PTR _Xx0$[rsp]
	mov	DWORD PTR _Prev$[rsp], eax

; 1285 :         for (size_t _Ix = 1; _Ix < _Nx; ++_Ix) {

	mov	QWORD PTR _Ix$1[rsp], 1
	jmp	SHORT $LN4@seed
$LN2@seed:
	mov	rax, QWORD PTR _Ix$1[rsp]
	inc	rax
	mov	QWORD PTR _Ix$1[rsp], rax
$LN4@seed:
	cmp	QWORD PTR _Ix$1[rsp], 624		; 00000270H
	jae	SHORT $LN3@seed

; 1286 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	eax, DWORD PTR _Prev$[rsp]
	shr	eax, 30
	mov	ecx, DWORD PTR _Prev$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR _Fx$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR _Ix$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, -1					; ffffffffH
	and	rax, rcx
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ix$1[rsp]
	mov	edx, DWORD PTR tv85[rsp]
	mov	DWORD PTR [rax+rcx*4+4], edx
	mov	eax, DWORD PTR tv85[rsp]
	mov	DWORD PTR _Prev$[rsp], eax

; 1287 :         }

	jmp	SHORT $LN2@seed
$LN3@seed:

; 1288 : 
; 1289 :         this->_Idx = _Nx;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 624			; 00000270H

; 1290 :     }

	add	rsp, 40					; 00000028H
	ret	0
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z
_TEXT	SEGMENT
this$ = 48
_Xx0$ = 56
_Dxarg$ = 64
_Fxarg$ = 72
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>, COMDAT

; 1272 :     explicit mersenne_twister(_Ty _Xx0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast<_Ty>(1812433253))

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1273 :         : _Dxval(_Dxarg) {

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Dxarg$[rsp]
	mov	DWORD PTR [rax+4996], ecx

; 1274 :         seed(_Xx0, _Fxarg);

	mov	r8d, DWORD PTR _Fxarg$[rsp]
	mov	edx, DWORD PTR _Xx0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
	npad	1

; 1275 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3184 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T2[rsp], 0

; 3185 : #if _ITERATOR_DEBUG_LEVEL == 2
; 3186 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),
; 3187 :         "You cannot concatenate the same moved string to itself. See N4950 [res.on.arguments]/1.3: "
; 3188 :         "If a function argument is bound to an rvalue reference parameter, the implementation may assume that "
; 3189 :         "this parameter is a unique reference to this argument, except that the argument passed to "
; 3190 :         "a move-assignment operator may be a reference to *this ([lib.types.movedfrom]).");
; 3191 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 3192 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, QWORD PTR _Right$[rsp]
	mov	r8, QWORD PTR _Left$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3193 : }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 5
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 5
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rsp], 32	; 00000020H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 5

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT

; 921  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 922  :         // insert by moving into element at end, provide strong guarantee
; 923  :         _Emplace_one_at_back(_STD move(_Val));

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1

; 924  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 918  :         _Emplace_one_at_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1

; 919  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
$T4 = 58
$T5 = 66
$T6 = 80
$T7 = 88
$T8 = 96
tv128 = 104
tv130 = 112
tv139 = 120
tv155 = 128
this$ = 160
_Right$ = 168
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 748  :               _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 745  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	mov	QWORD PTR $T3[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 16
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rax
	call	??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::nullptr_t>
	mov	QWORD PTR $T6[rsp], rax
	mov	QWORD PTR $T4[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rax
	call	??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::nullptr_t>
	mov	QWORD PTR $T7[rsp], rax
	mov	QWORD PTR $T5[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rax
	call	??$exchange@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$T@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::nullptr_t>
	mov	QWORD PTR $T8[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
	mov	QWORD PTR tv128[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T8[rsp]
	mov	r8, QWORD PTR tv128[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@22@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	npad	1

; 749  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv139[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv139[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 750  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv155[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv155[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 751  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 152				; 00000098H
	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z	; std::_Get_size_of_n<32>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z
_TEXT	SEGMENT
this$ = 48
_It$ = 56
?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Seek_to, COMDAT

; 226  :     _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  :         _Ptr = _STD _Refancy_maybe_null<pointer>(const_cast<value_type*>(_It));

	mov	rcx, QWORD PTR _It$[rsp]
	call	??$_Refancy_maybe_null@PEB_W$0A@@std@@YAPEB_WPEB_W@Z ; std::_Refancy_maybe_null<wchar_t const *,0>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 228  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAAXPEB_W@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Verify_offset, COMDAT

; 103  :     _CONSTEXPR20 void _Verify_offset(const difference_type _Off) const noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 104  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 105  :         if (_Off == 0) {
; 106  :             return;
; 107  :         }
; 108  : 
; 109  :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 110  :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 111  :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was "
; 112  :                              "invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 113  :         const auto _Contptr = _Mycont->_Myptr();
; 114  :         const auto _Rawptr  = _Unfancy(_Ptr);
; 115  : 
; 116  :         if (_Off < 0) {
; 117  :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 118  :         }
; 119  : 
; 120  :         if (_Off > 0) {
; 121  :             using _Size_type = typename _Mystr::size_type;
; 122  :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 123  :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 124  :         }
; 125  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
; 126  :         (void) _Off;
; 127  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
; 128  :     }

	ret	0
?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pstring$ = 64
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 41   :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 42   :         this->_Adopt(_Pstring);

	mov	rdx, QWORD PTR _Pstring$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 43   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z
_TEXT	SEGMENT
this$ = 48
_It$ = 56
?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to, COMDAT

; 226  :     _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  :         _Ptr = _STD _Refancy_maybe_null<pointer>(const_cast<value_type*>(_It));

	mov	rcx, QWORD PTR _It$[rsp]
	call	??$_Refancy_maybe_null@PEBD$0A@@std@@YAPEBDPEBD@Z ; std::_Refancy_maybe_null<char const *,0>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 228  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped, COMDAT

; 222  :     _NODISCARD _CONSTEXPR20 const value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 223  :         return _STD _Unfancy_maybe_null(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z ; std::_Unfancy_maybe_null<char const >

; 224  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset, COMDAT

; 103  :     _CONSTEXPR20 void _Verify_offset(const difference_type _Off) const noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 104  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 105  :         if (_Off == 0) {
; 106  :             return;
; 107  :         }
; 108  : 
; 109  :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 110  :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 111  :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was "
; 112  :                              "invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 113  :         const auto _Contptr = _Mycont->_Myptr();
; 114  :         const auto _Rawptr  = _Unfancy(_Ptr);
; 115  : 
; 116  :         if (_Off < 0) {
; 117  :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 118  :         }
; 119  : 
; 120  :         if (_Off > 0) {
; 121  :             using _Size_type = typename _Mystr::size_type;
; 122  :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 123  :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 124  :         }
; 125  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
; 126  :         (void) _Off;
; 127  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
; 128  :     }

	ret	0
?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pstring$ = 64
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 41   :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 42   :         this->_Adopt(_Pstring);

	mov	rdx, QWORD PTR _Pstring$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 43   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\random
;	COMDAT ??Rrandom_device@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 48
??Rrandom_device@std@@QEAAIXZ PROC			; std::random_device::operator(), COMDAT

; 5634 :     _NODISCARD result_type operator()() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5635 :         return _Random_device();

	call	?_Random_device@std@@YAIXZ		; std::_Random_device

; 5636 :     }

	add	rsp, 40					; 00000028H
	ret	0
??Rrandom_device@std@@QEAAIXZ ENDP			; std::random_device::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??1CSLock@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CSLock@IronMan@@QEAA@XZ PROC				; IronMan::CSLock::~CSLock, COMDAT

; 297  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 298  : 			_cs.unlock();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?unlock@CriticalSection@IronMan@@QEAAXXZ ; IronMan::CriticalSection::unlock
	npad	1

; 299  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??1CSLock@IronMan@@QEAA@XZ ENDP				; IronMan::CSLock::~CSLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z
_TEXT	SEGMENT
this$ = 48
cs$ = 56
??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z PROC	; IronMan::CSLock::CSLock, COMDAT

; 292  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 291  : 			: _cs(cs)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cs$[rsp]
	mov	QWORD PTR [rax], rcx

; 293  : 			cs.lock();

	mov	rcx, QWORD PTR cs$[rsp]
	call	?lock@CriticalSection@IronMan@@QEAAXXZ	; IronMan::CriticalSection::lock
	npad	1

; 294  : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ENDP	; IronMan::CSLock::CSLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ?unlock@CriticalSection@IronMan@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?unlock@CriticalSection@IronMan@@QEAAXXZ PROC		; IronMan::CriticalSection::unlock, COMDAT

; 276  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 277  : 			LeaveCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1

; 278  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?unlock@CriticalSection@IronMan@@QEAAXXZ ENDP		; IronMan::CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ?lock@CriticalSection@IronMan@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?lock@CriticalSection@IronMan@@QEAAXXZ PROC		; IronMan::CriticalSection::lock, COMDAT

; 271  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 272  : 			EnterCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_EnterCriticalSection
	npad	1

; 273  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?lock@CriticalSection@IronMan@@QEAAXXZ ENDP		; IronMan::CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??1CriticalSection@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CriticalSection@IronMan@@QEAA@XZ PROC		; IronMan::CriticalSection::~CriticalSection, COMDAT

; 266  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 267  : 			DeleteCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_DeleteCriticalSection
	npad	1

; 268  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??1CriticalSection@IronMan@@QEAA@XZ ENDP		; IronMan::CriticalSection::~CriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??0CriticalSection@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0CriticalSection@IronMan@@QEAA@XZ PROC		; IronMan::CriticalSection::CriticalSection, COMDAT

; 260  : 		CriticalSection()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 261  : 		{
; 262  : 			InitializeCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_InitializeCriticalSection
	npad	1

; 263  : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0CriticalSection@IronMan@@QEAA@XZ ENDP		; IronMan::CriticalSection::CriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
macAddress$ = 32
$T1 = 40
tv137 = 48
tv132 = 56
$T2 = 64
tv138 = 72
tv134 = 80
$T3 = 88
tv139 = 96
tv136 = 104
cpuID$ = 112
volumeSerial$ = 120
machineCode$ = 128
$T4 = 136
$T5 = 168
$T6 = 200
?GetMachineCode@Utils@IronMan@@YA_KXZ PROC		; IronMan::Utils::GetMachineCode

; 1118 : 	hash_t Utils::GetMachineCode() {

$LN6:
	sub	rsp, 248				; 000000f8H

; 1119 : 		hash_t cpuID = hash_(GetCPUID());

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	?GetCPUID@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Utils::GetCPUID
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR tv137[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rcx, QWORD PTR tv132[rsp]
	call	?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; hash_
	mov	QWORD PTR cpuID$[rsp], rax

; 1120 : 		hash_t volumeSerial = hash_(GetVolumeSerialNumber());

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rcx, QWORD PTR $T2[rsp]
	call	?GetVolumeSerialNumber@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Utils::GetVolumeSerialNumber
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR tv138[rsp]
	mov	QWORD PTR tv134[rsp], rax
	mov	rcx, QWORD PTR tv134[rsp]
	call	?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; hash_
	mov	QWORD PTR volumeSerial$[rsp], rax

; 1121 : 		hash_t macAddress = hash_(GetMACAddress());

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, QWORD PTR $T3[rsp]
	call	?GetMACAddress@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Utils::GetMACAddress
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR tv139[rsp]
	mov	QWORD PTR tv136[rsp], rax
	mov	rcx, QWORD PTR tv136[rsp]
	call	?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; hash_
	mov	QWORD PTR macAddress$[rsp], rax

; 1122 : 		hash_t machineCode = ((((cpuID + 52) ^ volumeSerial) - 0x10065) + macAddress) ^ macAddress;

	mov	rax, QWORD PTR cpuID$[rsp]
	add	rax, 52					; 00000034H
	xor	rax, QWORD PTR volumeSerial$[rsp]
	mov	rcx, QWORD PTR macAddress$[rsp]
	lea	rax, QWORD PTR [rax+rcx-65637]
	xor	rax, QWORD PTR macAddress$[rsp]
	mov	QWORD PTR machineCode$[rsp], rax

; 1123 : 		return machineCode;

	mov	rax, QWORD PTR machineCode$[rsp]

; 1124 : 	}

	add	rsp, 248				; 000000f8H
	ret	0
?GetMachineCode@Utils@IronMan@@YA_KXZ ENDP		; IronMan::Utils::GetMachineCode
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
macAddress$ = 32
$T1 = 40
tv137 = 48
tv132 = 56
$T2 = 64
tv138 = 72
tv134 = 80
$T3 = 88
tv139 = 96
tv136 = 104
cpuID$ = 112
volumeSerial$ = 120
machineCode$ = 128
$T4 = 136
$T5 = 168
$T6 = 200
?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA PROC ; `IronMan::Utils::GetMachineCode'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA ENDP ; `IronMan::Utils::GetMachineCode'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
macAddress$ = 32
$T1 = 40
tv137 = 48
tv132 = 56
$T2 = 64
tv138 = 72
tv134 = 80
$T3 = 88
tv139 = 96
tv136 = 104
cpuID$ = 112
volumeSerial$ = 120
machineCode$ = 128
$T4 = 136
$T5 = 168
$T6 = 200
?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA PROC ; `IronMan::Utils::GetMachineCode'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA ENDP ; `IronMan::Utils::GetMachineCode'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
macAddress$ = 32
$T1 = 40
tv137 = 48
tv132 = 56
$T2 = 64
tv138 = 72
tv134 = 80
$T3 = 88
tv139 = 96
tv136 = 104
cpuID$ = 112
volumeSerial$ = 120
machineCode$ = 128
$T4 = 136
$T5 = 168
$T6 = 200
?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA PROC ; `IronMan::Utils::GetMachineCode'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GetMachineCode@Utils@IronMan@@YA_KXZ@4HA ENDP ; `IronMan::Utils::GetMachineCode'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z PROC ; IronMan::Utils::SimpleHttpGet

; 894  : 	std::string Utils::SimpleHttpGet(const std::string& url, const std::string& additionalHeaders) {

$LN37:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1160				; 00000488H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 895  : 		std::string result;

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 896  : 
; 897  : 		// Initialize WinHTTP session
; 898  : 		HINTERNET hSession = WinHttpOpen(L"WinHTTP Example/1.0",

	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_1CI@POKKGHLI@?$AAW?$AAi?$AAn?$AAH?$AAT?$AAT?$AAP?$AA?5?$AAE?$AAx?$AAa?$AAm?$AAp?$AAl?$AAe@
	call	QWORD PTR __imp_WinHttpOpen
	mov	QWORD PTR hSession$[rsp], rax

; 899  : 			WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
; 900  : 			WINHTTP_NO_PROXY_NAME,
; 901  : 			WINHTTP_NO_PROXY_BYPASS, 0);
; 902  : 		if (!hSession) {

	cmp	QWORD PTR hSession$[rsp], 0
	jne	$LN5@SimpleHttp

; 903  : 			CONSOLE_INFO("WinHttpOpen failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv129[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0BH@FHIJFMJL@WinHttpOpen?5failed?3?5?$CFx@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T29[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv65[rsp], rax
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR tv560[rsp], rax
	mov	rcx, QWORD PTR tv560[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv95[rsp], rax
	mov	edx, DWORD PTR tv129[rsp]
	mov	rcx, QWORD PTR tv95[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T29[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 904  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN5@SimpleHttp:

; 905  : 		}
; 906  : 
; 907  : 		// Split the URL into components
; 908  : 		URL_COMPONENTS urlComp;
; 909  : 		ZeroMemory(&urlComp, sizeof(urlComp));

	mov	r8d, 104				; 00000068H
	xor	edx, edx
	lea	rcx, QWORD PTR urlComp$[rsp]
	call	memset

; 910  : 		urlComp.dwStructSize = sizeof(urlComp);

	mov	DWORD PTR urlComp$[rsp], 104		; 00000068H

; 911  : 
; 912  : 		// Set required component lengths to non-zero 
; 913  : 		urlComp.dwSchemeLength = (DWORD)-1;

	mov	DWORD PTR urlComp$[rsp+16], -1		; ffffffffH

; 914  : 		urlComp.dwHostNameLength = (DWORD)-1;

	mov	DWORD PTR urlComp$[rsp+32], -1		; ffffffffH

; 915  : 		urlComp.dwUrlPathLength = (DWORD)-1;

	mov	DWORD PTR urlComp$[rsp+80], -1		; ffffffffH

; 916  : 		urlComp.dwExtraInfoLength = (DWORD)-1;

	mov	DWORD PTR urlComp$[rsp+96], -1		; ffffffffH

; 917  : 
; 918  : 		std::wstring wUrl(url.begin(), url.end());

	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	QWORD PTR tv153[rsp], rax
	lea	rdx, QWORD PTR $T15[rsp]
	mov	rcx, QWORD PTR url$[rsp]
	call	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rdx, QWORD PTR $T16[rsp]
	mov	rcx, QWORD PTR url$[rsp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T7[rsp], rax
	mov	r9, QWORD PTR tv153[rsp]
	mov	r8, QWORD PTR $T6[rsp]
	mov	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>
	npad	1

; 919  : 		if (!WinHttpCrackUrl(wUrl.c_str(), (DWORD)wUrl.length(), 0, &urlComp)) {

	lea	rcx, QWORD PTR wUrl$[rsp]
	call	?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
	mov	DWORD PTR tv169[rsp], eax
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	QWORD PTR tv167[rsp], rax
	lea	r9, QWORD PTR urlComp$[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR tv169[rsp]
	mov	rcx, QWORD PTR tv167[rsp]
	call	QWORD PTR __imp_WinHttpCrackUrl
	test	eax, eax
	jne	$LN6@SimpleHttp

; 920  : 			CONSOLE_INFO("WinHttpCrackUrl failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv194[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0BL@NNCNJHDB@WinHttpCrackUrl?5failed?3?5?$CFx@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T20[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR tv137[rsp]
	mov	QWORD PTR tv568[rsp], rax
	mov	rcx, QWORD PTR tv568[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv192[rsp], rax
	mov	edx, DWORD PTR tv194[rsp]
	mov	rcx, QWORD PTR tv192[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T20[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 921  : 			WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 922  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN6@SimpleHttp:

; 923  : 		}
; 924  : 
; 925  : 		std::wstring hostName(urlComp.lpszHostName, urlComp.dwHostNameLength);

	mov	eax, DWORD PTR urlComp$[rsp+32]
	mov	r8d, eax
	mov	rdx, QWORD PTR urlComp$[rsp+24]
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 926  : 		std::wstring urlPath(urlComp.lpszUrlPath, urlComp.dwUrlPathLength + urlComp.dwExtraInfoLength);

	mov	eax, DWORD PTR urlComp$[rsp+96]
	mov	ecx, DWORD PTR urlComp$[rsp+80]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR urlComp$[rsp+72]
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 927  : 
; 928  : 		// Create an HTTP connection
; 929  : 		HINTERNET hConnect = WinHttpConnect(hSession, hostName.c_str(), urlComp.nPort, 0);

	lea	rcx, QWORD PTR hostName$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	xor	r9d, r9d
	movzx	r8d, WORD PTR urlComp$[rsp+36]
	mov	rdx, rax
	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpConnect
	mov	QWORD PTR hConnect$[rsp], rax

; 930  : 		if (!hConnect) {

	cmp	QWORD PTR hConnect$[rsp], 0
	jne	$LN7@SimpleHttp

; 931  : 			CONSOLE_INFO("WinHttpConnect failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv275[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0BK@IHJKAELJ@WinHttpConnect?5failed?3?5?$CFx@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T21[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv206[rsp], rax
	mov	rax, QWORD PTR tv206[rsp]
	mov	QWORD PTR tv575[rsp], rax
	mov	rcx, QWORD PTR tv575[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv273[rsp], rax
	mov	edx, DWORD PTR tv275[rsp]
	mov	rcx, QWORD PTR tv273[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T21[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 932  : 			WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 933  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN7@SimpleHttp:

; 934  : 		}
; 935  : 
; 936  : 		// Open an HTTP request handle
; 937  : 		HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", urlPath.c_str(), NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES,

	cmp	DWORD PTR urlComp$[rsp+20], 2
	jne	SHORT $LN18@SimpleHttp
	mov	DWORD PTR tv282[rsp], 8388608		; 00800000H
	jmp	SHORT $LN19@SimpleHttp
$LN18@SimpleHttp:
	mov	DWORD PTR tv282[rsp], 0
$LN19@SimpleHttp:
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	ecx, DWORD PTR tv282[rsp]
	mov	DWORD PTR [rsp+48], ecx
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_17KCHPOIEI@?$AAG?$AAE?$AAT@
	mov	rcx, QWORD PTR hConnect$[rsp]
	call	QWORD PTR __imp_WinHttpOpenRequest
	mov	QWORD PTR hRequest$[rsp], rax

; 938  : 			(urlComp.nScheme == INTERNET_SCHEME_HTTPS) ? WINHTTP_FLAG_SECURE : 0);
; 939  : 		if (!hRequest) {

	cmp	QWORD PTR hRequest$[rsp], 0
	jne	$LN8@SimpleHttp

; 940  : 			CONSOLE_INFO("WinHttpOpenRequest failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv316[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0BO@DLFGADJM@WinHttpOpenRequest?5failed?3?5?$CFx@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T22[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv277[rsp], rax
	mov	rax, QWORD PTR tv277[rsp]
	mov	QWORD PTR tv582[rsp], rax
	mov	rcx, QWORD PTR tv582[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv314[rsp], rax
	mov	edx, DWORD PTR tv316[rsp]
	mov	rcx, QWORD PTR tv314[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T22[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 941  : 			WinHttpCloseHandle(hConnect);

	mov	rcx, QWORD PTR hConnect$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 942  : 			WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 943  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN8@SimpleHttp:

; 944  : 		}
; 945  : 
; 946  : 		// Add additional headers if provided
; 947  : 		if (!additionalHeaders.empty()) {

	mov	rcx, QWORD PTR additionalHeaders$[rsp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	$LN9@SimpleHttp

; 948  : 			std::wstring wHeaders(additionalHeaders.begin(), additionalHeaders.end());

	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	QWORD PTR tv343[rsp], rax
	lea	rdx, QWORD PTR $T17[rsp]
	mov	rcx, QWORD PTR additionalHeaders$[rsp]
	call	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T8[rsp], rax
	mov	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T10[rsp], rax
	lea	rdx, QWORD PTR $T18[rsp]
	mov	rcx, QWORD PTR additionalHeaders$[rsp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T9[rsp], rax
	mov	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR $T11[rsp], rax
	mov	r9, QWORD PTR tv343[rsp]
	mov	r8, QWORD PTR $T10[rsp]
	mov	rdx, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR wHeaders$19[rsp]
	call	??$?0V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >,0>
	npad	1

; 949  : 			if (!WinHttpAddRequestHeaders(hRequest, wHeaders.c_str(), (DWORD)-1, WINHTTP_ADDREQ_FLAG_ADD)) {

	lea	rcx, QWORD PTR wHeaders$19[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	r9d, 536870912				; 20000000H
	mov	r8d, -1					; ffffffffH
	mov	rdx, rax
	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpAddRequestHeaders
	test	eax, eax
	jne	$LN10@SimpleHttp

; 950  : 				CONSOLE_INFO("WinHttpAddRequestHeaders failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv377[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0CE@DNKGMBPP@WinHttpAddRequestHeaders?5failed@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T23[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv327[rsp], rax
	mov	rax, QWORD PTR tv327[rsp]
	mov	QWORD PTR tv590[rsp], rax
	mov	rcx, QWORD PTR tv590[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv375[rsp], rax
	mov	edx, DWORD PTR tv377[rsp]
	mov	rcx, QWORD PTR tv375[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T23[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 951  : 				WinHttpCloseHandle(hRequest);

	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 952  : 				WinHttpCloseHandle(hConnect);

	mov	rcx, QWORD PTR hConnect$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 953  : 				WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 954  : 				return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR wHeaders$19[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN10@SimpleHttp:

; 955  : 			}
; 956  : 		}

	lea	rcx, QWORD PTR wHeaders$19[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
$LN9@SimpleHttp:

; 957  : 
; 958  : 		// Send a request
; 959  : 		if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0)) {

	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpSendRequest
	test	eax, eax
	jne	$LN11@SimpleHttp

; 960  : 			CONSOLE_INFO("WinHttpSendRequest failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv416[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0BO@NBEGPBEP@WinHttpSendRequest?5failed?3?5?$CFx@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T24[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv381[rsp], rax
	mov	rax, QWORD PTR tv381[rsp]
	mov	QWORD PTR tv598[rsp], rax
	mov	rcx, QWORD PTR tv598[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv414[rsp], rax
	mov	edx, DWORD PTR tv416[rsp]
	mov	rcx, QWORD PTR tv414[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T24[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 961  : 			WinHttpCloseHandle(hRequest);

	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 962  : 			WinHttpCloseHandle(hConnect);

	mov	rcx, QWORD PTR hConnect$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 963  : 			WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 964  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN11@SimpleHttp:

; 965  : 		}
; 966  : 
; 967  : 		// Receive a response
; 968  : 		if (!WinHttpReceiveResponse(hRequest, NULL)) {

	xor	edx, edx
	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpReceiveResponse
	test	eax, eax
	jne	$LN12@SimpleHttp

; 969  : 			CONSOLE_INFO("WinHttpReceiveResponse failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv450[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0CC@CGBDJCIK@WinHttpReceiveResponse?5failed?3?5@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T25[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv420[rsp], rax
	mov	rax, QWORD PTR tv420[rsp]
	mov	QWORD PTR tv605[rsp], rax
	mov	rcx, QWORD PTR tv605[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv448[rsp], rax
	mov	edx, DWORD PTR tv450[rsp]
	mov	rcx, QWORD PTR tv448[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T25[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 970  : 			WinHttpCloseHandle(hRequest);

	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 971  : 			WinHttpCloseHandle(hConnect);

	mov	rcx, QWORD PTR hConnect$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 972  : 			WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 973  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@SimpleHttp
$LN12@SimpleHttp:

; 974  : 		}
; 975  : 
; 976  : 		// Read the data
; 977  : 		DWORD dwSize = 0;

	mov	DWORD PTR dwSize$[rsp], 0

; 978  : 		DWORD dwDownloaded = 0;

	mov	DWORD PTR dwDownloaded$[rsp], 0

; 979  : 		LPSTR pszOutBuffer = nullptr;

	mov	QWORD PTR pszOutBuffer$[rsp], 0
$LN4@SimpleHttp:

; 980  : 
; 981  : 		do {
; 982  : 			dwSize = 0;

	mov	DWORD PTR dwSize$[rsp], 0

; 983  : 			if (!WinHttpQueryDataAvailable(hRequest, &dwSize)) {

	lea	rdx, QWORD PTR dwSize$[rsp]
	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpQueryDataAvailable
	test	eax, eax
	jne	$LN13@SimpleHttp

; 984  : 				CONSOLE_INFO("WinHttpQueryDataAvailable failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv484[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0CF@HJMNAIEA@WinHttpQueryDataAvailable?5faile@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T26[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv454[rsp], rax
	mov	rax, QWORD PTR tv454[rsp]
	mov	QWORD PTR tv612[rsp], rax
	mov	rcx, QWORD PTR tv612[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv482[rsp], rax
	mov	edx, DWORD PTR tv484[rsp]
	mov	rcx, QWORD PTR tv482[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T26[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 985  : 				break;

	jmp	$LN3@SimpleHttp
$LN13@SimpleHttp:

; 986  : 			}
; 987  : 
; 988  : 			if (dwSize == 0)

	cmp	DWORD PTR dwSize$[rsp], 0
	jne	SHORT $LN14@SimpleHttp

; 989  : 				break;

	jmp	$LN3@SimpleHttp
$LN14@SimpleHttp:

; 990  : 
; 991  : 			pszOutBuffer = new char[dwSize + 1];

	mov	eax, DWORD PTR dwSize$[rsp]
	inc	eax
	mov	eax, eax
	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T12[rsp], rax
	mov	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR pszOutBuffer$[rsp], rax

; 992  : 			if (!pszOutBuffer) {

	cmp	QWORD PTR pszOutBuffer$[rsp], 0
	jne	$LN15@SimpleHttp

; 993  : 				CONSOLE_INFO("Out of memory");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0O@NALGGDJF@Out?5of?5memory@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T27[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv319[rsp], rax
	mov	rax, QWORD PTR tv319[rsp]
	mov	QWORD PTR tv614[rsp], rax
	mov	rcx, QWORD PTR tv614[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T27[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 994  : 				break;

	jmp	$LN3@SimpleHttp
$LN15@SimpleHttp:

; 995  : 			}
; 996  : 
; 997  : 			ZeroMemory(pszOutBuffer, dwSize + 1);

	mov	eax, DWORD PTR dwSize$[rsp]
	inc	eax
	mov	eax, eax
	mov	r8d, eax
	xor	edx, edx
	mov	rcx, QWORD PTR pszOutBuffer$[rsp]
	call	memset
	npad	1

; 998  : 
; 999  : 			if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded)) {

	lea	r9, QWORD PTR dwDownloaded$[rsp]
	mov	r8d, DWORD PTR dwSize$[rsp]
	mov	rdx, QWORD PTR pszOutBuffer$[rsp]
	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpReadData
	test	eax, eax
	jne	$LN16@SimpleHttp

; 1000 : 				CONSOLE_INFO("WinHttpReadData failed: %x", GetLastError());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR tv544[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_0BL@EBICDIGF@WinHttpReadData?5failed?3?5?$CFx@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T28[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv200[rsp], rax
	mov	rax, QWORD PTR tv200[rsp]
	mov	QWORD PTR tv616[rsp], rax
	mov	rcx, QWORD PTR tv616[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv542[rsp], rax
	mov	edx, DWORD PTR tv544[rsp]
	mov	rcx, QWORD PTR tv542[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T28[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1001 : 				delete[] pszOutBuffer;

	mov	rax, QWORD PTR pszOutBuffer$[rsp]
	mov	QWORD PTR $T13[rsp], rax
	mov	rcx, QWORD PTR $T13[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1

; 1002 : 				break;

	jmp	SHORT $LN3@SimpleHttp
$LN16@SimpleHttp:

; 1003 : 			}
; 1004 : 
; 1005 : 			result.append(pszOutBuffer, dwDownloaded);

	mov	eax, DWORD PTR dwDownloaded$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR pszOutBuffer$[rsp]
	lea	rcx, QWORD PTR result$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 1006 : 			delete[] pszOutBuffer;

	mov	rax, QWORD PTR pszOutBuffer$[rsp]
	mov	QWORD PTR $T14[rsp], rax
	mov	rcx, QWORD PTR $T14[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1

; 1007 : 
; 1008 : 		} while (dwSize > 0);

	cmp	DWORD PTR dwSize$[rsp], 0
	ja	$LN4@SimpleHttp
$LN3@SimpleHttp:

; 1009 : 
; 1010 : 		// Cleanup
; 1011 : 		WinHttpCloseHandle(hRequest);

	mov	rcx, QWORD PTR hRequest$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 1012 : 		WinHttpCloseHandle(hConnect);

	mov	rcx, QWORD PTR hConnect$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 1013 : 		WinHttpCloseHandle(hSession);

	mov	rcx, QWORD PTR hSession$[rsp]
	call	QWORD PTR __imp_WinHttpCloseHandle

; 1014 : 		return result;

	lea	rdx, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR urlPath$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR hostName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR wUrl$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@SimpleHttp:

; 1015 : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1160				; 00000488H
	ret	0
	int	3
?SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z ENDP ; IronMan::Utils::SimpleHttpGet
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR result$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T29[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN23@dtor$2
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN23@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR wUrl$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T20[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR hostName$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR urlPath$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T21[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T22[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR wHeaders$19[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T23[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$11
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T24[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$11@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$12
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T25[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$12@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T26[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$14
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T27[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$14@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
dwSize$ = 68
hRequest$ = 72
hSession$ = 80
$T2 = 88
$T3 = 89
pszOutBuffer$ = 96
hConnect$ = 104
tv282 = 112
dwDownloaded$ = 116
tv129 = 120
tv169 = 124
tv194 = 128
tv275 = 132
tv316 = 136
tv377 = 140
tv416 = 144
tv450 = 148
tv484 = 152
tv544 = 156
tv65 = 160
tv560 = 168
tv95 = 176
$T4 = 184
$T5 = 192
tv153 = 200
$T6 = 208
$T7 = 216
tv167 = 224
tv137 = 232
tv568 = 240
tv192 = 248
tv206 = 256
tv575 = 264
tv273 = 272
tv277 = 280
tv582 = 288
tv314 = 296
$T8 = 304
$T9 = 312
tv343 = 320
$T10 = 328
$T11 = 336
tv327 = 344
tv590 = 352
tv375 = 360
tv381 = 368
tv598 = 376
tv414 = 384
tv420 = 392
tv605 = 400
tv448 = 408
tv454 = 416
tv612 = 424
tv482 = 432
$T12 = 440
tv319 = 448
tv614 = 456
tv200 = 464
tv616 = 472
tv542 = 480
$T13 = 488
$T14 = 496
urlComp$ = 512
$T15 = 624
$T16 = 632
$T17 = 640
$T18 = 648
result$ = 656
wUrl$ = 688
urlPath$ = 720
hostName$ = 752
wHeaders$19 = 784
$T20 = 816
$T21 = 848
$T22 = 880
$T23 = 912
$T24 = 944
$T25 = 976
$T26 = 1008
$T27 = 1040
$T28 = 1072
$T29 = 1104
__$ArrayPad$ = 1136
__$ReturnUdt$ = 1168
url$ = 1176
additionalHeaders$ = 1184
?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA PROC ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$15
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T28[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$15@?0??SimpleHttpGet@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z@4HA ENDP ; `IronMan::Utils::SimpleHttpGet'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
tv69 = 32
ptr$ = 64
size$ = 72
?IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z PROC	; IronMan::Utils::IsSafeWritePtr

; 877  : 	bool Utils::IsSafeWritePtr(void* ptr, size_t size) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 878  : 		if (!ptr)

	cmp	QWORD PTR ptr$[rsp], 0
	jne	SHORT $LN2@IsSafeWrit

; 879  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@IsSafeWrit
$LN2@IsSafeWrit:

; 880  : 		__try {
; 881  : 			// Attempt to read the memory block
; 882  : 			//volatile char temp;
; 883  : 			//for (size_t i = 0; i < size; ++i) {
; 884  : 			//	temp = static_cast<volatile char*>(ptr)[i];
; 885  : 			//}
; 886  : 			//return false;
; 887  : 			return IsBadWritePtr(ptr, size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	QWORD PTR __imp_IsBadWritePtr
	test	eax, eax
	je	SHORT $LN5@IsSafeWrit
	mov	BYTE PTR tv69[rsp], 1
	jmp	SHORT $LN6@IsSafeWrit
$LN5@IsSafeWrit:
	mov	BYTE PTR tv69[rsp], 0
$LN6@IsSafeWrit:
	movzx	eax, BYTE PTR tv69[rsp]
	jmp	SHORT $LN7@IsSafeWrit

; 888  : 		}
; 889  : 		__except (EXCEPTION_EXECUTE_HANDLER) {

$LN9@IsSafeWrit:

; 890  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@IsSafeWrit
$LN7@IsSafeWrit:

; 891  : 		}
; 892  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z ENDP	; IronMan::Utils::IsSafeWritePtr
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv69 = 32
ptr$ = 64
size$ = 72
?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA PROC ; `IronMan::Utils::IsSafeWritePtr'::`1'::filt$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
$LN8@filt$0:

; 889  : 		__except (EXCEPTION_EXECUTE_HANDLER) {

	mov	eax, 1
$LN10@filt$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?filt$0@?0??IsSafeWritePtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA ENDP ; `IronMan::Utils::IsSafeWritePtr'::`1'::filt$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
tv69 = 32
ptr$ = 64
size$ = 72
?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z PROC		; IronMan::Utils::IsSafeReadPtr

; 860  : 	bool Utils::IsSafeReadPtr(void* ptr, size_t size) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 861  : 		if (!ptr)

	cmp	QWORD PTR ptr$[rsp], 0
	jne	SHORT $LN2@IsSafeRead

; 862  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@IsSafeRead
$LN2@IsSafeRead:

; 863  : 		__try {
; 864  : 			// Attempt to read the memory block
; 865  : 			//volatile char temp;
; 866  : 			//for (size_t i = 0; i < size; ++i) {
; 867  : 			//	temp = static_cast<volatile char*>(ptr)[i];
; 868  : 			//}
; 869  : 			//return false;
; 870  : 			return IsBadReadPtr(ptr, size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	QWORD PTR __imp_IsBadReadPtr
	test	eax, eax
	je	SHORT $LN5@IsSafeRead
	mov	BYTE PTR tv69[rsp], 1
	jmp	SHORT $LN6@IsSafeRead
$LN5@IsSafeRead:
	mov	BYTE PTR tv69[rsp], 0
$LN6@IsSafeRead:
	movzx	eax, BYTE PTR tv69[rsp]
	jmp	SHORT $LN7@IsSafeRead

; 871  : 		}
; 872  : 		__except (EXCEPTION_EXECUTE_HANDLER) {

$LN9@IsSafeRead:

; 873  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@IsSafeRead
$LN7@IsSafeRead:

; 874  : 		}
; 875  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ENDP		; IronMan::Utils::IsSafeReadPtr
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv69 = 32
ptr$ = 64
size$ = 72
?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA PROC ; `IronMan::Utils::IsSafeReadPtr'::`1'::filt$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
$LN8@filt$0:

; 872  : 		__except (EXCEPTION_EXECUTE_HANDLER) {

	mov	eax, 1
$LN10@filt$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?filt$0@?0??IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z@4HA ENDP ; `IronMan::Utils::IsSafeReadPtr'::`1'::filt$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
directoryPath$ = 48
?checkAndCreateDirectory@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Utils::checkAndCreateDirectory

; 801  : 	bool Utils::checkAndCreateDirectory(const std::string& directoryPath) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 802  : 		// 
; 803  : 		if (_access(directoryPath.c_str(), 0) == 0) {

	mov	rcx, QWORD PTR directoryPath$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	xor	edx, edx
	mov	rcx, rax
	call	_access
	test	eax, eax
	jne	SHORT $LN2@checkAndCr

; 804  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@checkAndCr

; 805  : 		}

	jmp	SHORT $LN3@checkAndCr
$LN2@checkAndCr:

; 806  : 		else {
; 807  : 			// 
; 808  : 			if (_mkdir(directoryPath.c_str()) == 0) {

	mov	rcx, QWORD PTR directoryPath$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	_mkdir
	test	eax, eax
	jne	SHORT $LN4@checkAndCr

; 809  : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@checkAndCr

; 810  : 			}

	jmp	SHORT $LN5@checkAndCr
$LN4@checkAndCr:

; 811  : 			else {
; 812  : 				return false;

	xor	al, al
$LN5@checkAndCr:
$LN3@checkAndCr:
$LN1@checkAndCr:

; 813  : 			}
; 814  : 		}
; 815  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?checkAndCreateDirectory@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Utils::checkAndCreateDirectory
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv76 = 40
tv74 = 48
tv86 = 56
tv84 = 64
s$ = 96
?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Utils::StringIsValid2

; 829  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 830  : 		hasNullTerminator(s.data(), s.size() + 1);

	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	inc	rax
	mov	QWORD PTR tv76[rsp], rax
	mov	rcx, QWORD PTR s$[rsp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z ; IronMan::Utils::hasNullTerminator
	npad	1

; 831  : 		if (Utils::IsSafeReadPtr(s.data(), s.size()) || s.size() < 1 || s.size() >= 256 || s.find("Unknown") != std::string::npos || s.find("None") != std::string::npos
; 832  : 			|| !Utils::isAlphanumericWithSpecialChars(s))

	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv86[rsp], rax
	mov	rcx, QWORD PTR s$[rsp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	QWORD PTR tv84[rsp], rax
	mov	rdx, QWORD PTR tv86[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@StringIsVa
	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	rax, 1
	jb	SHORT $LN3@StringIsVa
	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	rax, 256				; 00000100H
	jae	SHORT $LN3@StringIsVa
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
	mov	rcx, QWORD PTR s$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	jne	SHORT $LN3@StringIsVa
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_04OHJIHAFH@None@
	mov	rcx, QWORD PTR s$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	jne	SHORT $LN3@StringIsVa
	mov	rcx, QWORD PTR s$[rsp]
	call	?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::isAlphanumericWithSpecialChars
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@StringIsVa
$LN3@StringIsVa:

; 833  : 		{
; 834  : 			return false;

	mov	BYTE PTR $T1[rsp], 0
	mov	rcx, QWORD PTR s$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@StringIsVa
$LN2@StringIsVa:

; 835  : 		}
; 836  : 		return true;

	mov	BYTE PTR $T2[rsp], 1
	mov	rcx, QWORD PTR s$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@StringIsVa:

; 837  : 	}

	add	rsp, 88					; 00000058H
	ret	0
?StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Utils::StringIsValid2
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv76 = 40
tv74 = 48
tv86 = 56
tv84 = 64
s$ = 96
?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::StringIsValid2'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR s$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StringIsValid2@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::StringIsValid2'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv76 = 40
tv74 = 48
tv86 = 56
tv84 = 64
s$ = 96
?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Utils::StringIsValid

; 818  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 819  : 		hasNullTerminator(s.data(), s.size() + 1);

	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	inc	rax
	mov	QWORD PTR tv76[rsp], rax
	mov	rcx, QWORD PTR s$[rsp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z ; IronMan::Utils::hasNullTerminator
	npad	1

; 820  : 		if (Utils::IsSafeReadPtr(s.data(), s.size()) || s.size() <= 3 || s.size() >= 256 || s.find("Unknown") != std::string::npos || s.find("None") != std::string::npos
; 821  : 			|| !Utils::isAlphanumericWithSpecialChars(s))

	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv86[rsp], rax
	mov	rcx, QWORD PTR s$[rsp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	QWORD PTR tv84[rsp], rax
	mov	rdx, QWORD PTR tv86[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@StringIsVa
	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	rax, 3
	jbe	SHORT $LN3@StringIsVa
	mov	rcx, QWORD PTR s$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	rax, 256				; 00000100H
	jae	SHORT $LN3@StringIsVa
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
	mov	rcx, QWORD PTR s$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	jne	SHORT $LN3@StringIsVa
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_04OHJIHAFH@None@
	mov	rcx, QWORD PTR s$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	jne	SHORT $LN3@StringIsVa
	mov	rcx, QWORD PTR s$[rsp]
	call	?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Utils::isAlphanumericWithSpecialChars
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@StringIsVa
$LN3@StringIsVa:

; 822  : 		{
; 823  : 			return false;

	mov	BYTE PTR $T1[rsp], 0
	mov	rcx, QWORD PTR s$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@StringIsVa
$LN2@StringIsVa:

; 824  : 		}
; 825  : 		return true;

	mov	BYTE PTR $T2[rsp], 1
	mov	rcx, QWORD PTR s$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@StringIsVa:

; 826  : 	}

	add	rsp, 88					; 00000058H
	ret	0
?StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Utils::StringIsValid
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv76 = 40
tv74 = 48
tv86 = 56
tv84 = 64
s$ = 96
?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::StringIsValid'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR s$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StringIsValid@Utils@IronMan@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::StringIsValid'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
<begin>$L0$1 = 32
c$2 = 40
<range>$L0$3 = 48
<end>$L0$4 = 56
str$ = 80
?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Utils::isAlphanumericWithSpecialChars

; 787  : 	bool Utils::isAlphanumericWithSpecialChars(const std::string& str) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 788  : 		for (char const& c : str) {

	mov	rax, QWORD PTR str$[rsp]
	mov	QWORD PTR <range>$L0$3[rsp], rax
	mov	rcx, QWORD PTR <range>$L0$3[rsp]
	call	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
	mov	QWORD PTR <begin>$L0$1[rsp], rax
	mov	rcx, QWORD PTR <range>$L0$3[rsp]
	call	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
	mov	QWORD PTR <end>$L0$4[rsp], rax
	jmp	SHORT $LN4@isAlphanum
$LN2@isAlphanum:
	mov	rax, QWORD PTR <begin>$L0$1[rsp]
	inc	rax
	mov	QWORD PTR <begin>$L0$1[rsp], rax
$LN4@isAlphanum:
	mov	rax, QWORD PTR <end>$L0$4[rsp]
	cmp	QWORD PTR <begin>$L0$1[rsp], rax
	je	SHORT $LN3@isAlphanum
	mov	rax, QWORD PTR <begin>$L0$1[rsp]
	mov	QWORD PTR c$2[rsp], rax

; 789  : 			//  ASCII 0
; 790  : 			if (!std::isalnum(static_cast<unsigned char>(c)) && c != '-' && c != '_') {

	mov	rax, QWORD PTR c$2[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN5@isAlphanum
	mov	rax, QWORD PTR c$2[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN5@isAlphanum
	mov	rax, QWORD PTR c$2[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN5@isAlphanum

; 791  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@isAlphanum
$LN5@isAlphanum:

; 792  : 			}
; 793  : 			//  ASCII 0
; 794  : 			if (c <= 0) {

	mov	rax, QWORD PTR c$2[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jg	SHORT $LN6@isAlphanum

; 795  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@isAlphanum
$LN6@isAlphanum:

; 796  : 			}
; 797  : 		}

	jmp	SHORT $LN2@isAlphanum
$LN3@isAlphanum:

; 798  : 		return true; // 

	mov	al, 1
$LN1@isAlphanum:

; 799  : 	};

	add	rsp, 72					; 00000048H
	ret	0
?isAlphanumericWithSpecialChars@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Utils::isAlphanumericWithSpecialChars
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
Temp$1 = 32
min$ = 64
max$ = 72
?RandomRange@Utils@IronMan@@YAMMM@Z PROC		; IronMan::Utils::RandomRange

; 1062 : 	float RandomRange(float min, float max) {

$LN4:
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 1063 : 		if (min > max) {

	movss	xmm0, DWORD PTR min$[rsp]
	comiss	xmm0, DWORD PTR max$[rsp]
	jbe	SHORT $LN2@RandomRang

; 1064 : 			float Temp = min;

	movss	xmm0, DWORD PTR min$[rsp]
	movss	DWORD PTR Temp$1[rsp], xmm0

; 1065 : 			min = max;

	movss	xmm0, DWORD PTR max$[rsp]
	movss	DWORD PTR min$[rsp], xmm0

; 1066 : 			max = Temp;

	movss	xmm0, DWORD PTR Temp$1[rsp]
	movss	DWORD PTR max$[rsp], xmm0
$LN2@RandomRang:

; 1067 : 		}
; 1068 : 		return RandomFloat() * (max - min) + min;

	call	?RandomFloat@Utils@IronMan@@YAMXZ	; IronMan::Utils::RandomFloat
	movss	xmm1, DWORD PTR max$[rsp]
	subss	xmm1, DWORD PTR min$[rsp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR min$[rsp]

; 1069 : 	}

	add	rsp, 56					; 00000038H
	ret	0
?RandomRange@Utils@IronMan@@YAMMM@Z ENDP		; IronMan::Utils::RandomRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
rd$ = 32
dis$ = 40
gen$ = 48
__$ArrayPad$ = 5056
?RandomFloat@Utils@IronMan@@YAMXZ PROC			; IronMan::Utils::RandomFloat

; 1055 : 	float RandomFloat() {

$LN3:
	mov	eax, 5080				; 000013d8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1056 : 		std::random_device rd;
; 1057 : 		std::mt19937 gen(rd());

	lea	rcx, QWORD PTR rd$[rsp]
	call	??Rrandom_device@std@@QEAAIXZ		; std::random_device::operator()
	mov	edx, eax
	lea	rcx, QWORD PTR gen$[rsp]
	call	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>

; 1058 : 		std::uniform_real_distribution<float> dis(0.0f, 1.0f);

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR dis$[rsp]
	call	??0?$uniform_real_distribution@M@std@@QEAA@MM@Z ; std::uniform_real_distribution<float>::uniform_real_distribution<float>

; 1059 : 		return dis(gen);

	lea	rdx, QWORD PTR gen$[rsp]
	lea	rcx, QWORD PTR dis$[rsp]
	call	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_real_distribution@M@std@@QEAAMAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_real_distribution<float>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >

; 1060 : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 5080				; 000013d8H
	ret	0
?RandomFloat@Utils@IronMan@@YAMXZ ENDP			; IronMan::Utils::RandomFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
fp$ = 32
result$ = 40
tv145 = 48
tv144 = 56
read$ = 64
$T1 = 72
__$ArrayPad$ = 104
Name$ = 128
pSize$ = 136
?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z PROC	; IronMan::Utils::ReadLibrary

; 1017 : 	void* ReadLibrary(const char* Name, size_t* pSize) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1018 : 		size_t read;
; 1019 : 		void* result;
; 1020 : 		FILE* fp;
; 1021 : 
; 1022 : 		fp = fopen(Name, "rb");

	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, QWORD PTR Name$[rsp]
	call	fopen
	mov	QWORD PTR fp$[rsp], rax

; 1023 : 		if (fp == NULL)

	cmp	QWORD PTR fp$[rsp], 0
	jne	$LN2@ReadLibrar

; 1024 : 		{
; 1025 : 			CONSOLE_INFO("Can't open DLL file \"%s\".", Name);

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BK@ENBLOMCO@Can?8t?5open?5DLL?5file?5?$CC?$CFs?$CC?4@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T1[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv145[rsp], rax
	mov	rax, QWORD PTR tv145[rsp]
	mov	QWORD PTR tv144[rsp], rax
	mov	rcx, QWORD PTR tv144[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rdx, QWORD PTR Name$[rsp]
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1026 : 			return NULL;

	xor	eax, eax
	jmp	$LN1@ReadLibrar
$LN2@ReadLibrar:

; 1027 : 		}
; 1028 : 
; 1029 : 		fseek(fp, 0, SEEK_END);

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR fp$[rsp]
	call	fseek

; 1030 : 		*pSize = static_cast<size_t>(ftell(fp));

	mov	rcx, QWORD PTR fp$[rsp]
	call	ftell
	cdqe
	mov	rcx, QWORD PTR pSize$[rsp]
	mov	QWORD PTR [rcx], rax

; 1031 : 		if (*pSize == 0)

	mov	rax, QWORD PTR pSize$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@ReadLibrar

; 1032 : 		{
; 1033 : 			fclose(fp);

	mov	rcx, QWORD PTR fp$[rsp]
	call	fclose

; 1034 : 			return NULL;

	xor	eax, eax
	jmp	$LN1@ReadLibrar
$LN3@ReadLibrar:

; 1035 : 		}
; 1036 : 
; 1037 : 		result = (unsigned char*)malloc(*pSize);

	mov	rax, QWORD PTR pSize$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	malloc
	mov	QWORD PTR result$[rsp], rax

; 1038 : 		if (result == NULL)

	cmp	QWORD PTR result$[rsp], 0
	jne	SHORT $LN4@ReadLibrar

; 1039 : 		{
; 1040 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@ReadLibrar
$LN4@ReadLibrar:

; 1041 : 		}
; 1042 : 
; 1043 : 		fseek(fp, 0, SEEK_SET);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR fp$[rsp]
	call	fseek

; 1044 : 		read = fread(result, 1, *pSize, fp);

	mov	r9, QWORD PTR fp$[rsp]
	mov	rax, QWORD PTR pSize$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	edx, 1
	mov	rcx, QWORD PTR result$[rsp]
	call	fread
	mov	QWORD PTR read$[rsp], rax

; 1045 : 		fclose(fp);

	mov	rcx, QWORD PTR fp$[rsp]
	call	fclose
	npad	1

; 1046 : 		if (read != *pSize)

	mov	rax, QWORD PTR pSize$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR read$[rsp], rax
	je	SHORT $LN5@ReadLibrar

; 1047 : 		{
; 1048 : 			free(result);

	mov	rcx, QWORD PTR result$[rsp]
	call	free

; 1049 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@ReadLibrar
$LN5@ReadLibrar:

; 1050 : 		}
; 1051 : 
; 1052 : 		return result;

	mov	rax, QWORD PTR result$[rsp]
$LN1@ReadLibrar:

; 1053 : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z ENDP	; IronMan::Utils::ReadLibrary
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
fp$ = 32
result$ = 40
tv145 = 48
tv144 = 56
read$ = 64
$T1 = 72
__$ArrayPad$ = 104
Name$ = 128
pSize$ = 136
?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA PROC ; `IronMan::Utils::ReadLibrary'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ReadLibrary@Utils@IronMan@@YAPEAXPEBDPEA_K@Z@4HA ENDP ; `IronMan::Utils::ReadLibrary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
psdAdmin$ = 96
bReturn$ = 104
pACL$ = 112
psidAdmin$ = 120
dwACLSize$ = 128
dwAccessMask$ = 132
dwStructureSize$ = 136
dwAccessDesired$ = 140
hToken$ = 144
dwStatus$ = 152
SystemSidAuthority$ = 156
GenericMapping$ = 168
ps$ = 184
__$ArrayPad$ = 208
?IsAdministratorRun@Utils@IronMan@@YAHXZ PROC		; IronMan::Utils::IsAdministratorRun

; 691  : 	{

$LN38:
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 692  : #define ACCESS_READ 1 
; 693  : #define ACCESS_WRITE 2 
; 694  : 
; 695  : 		// if(g_bIsNT==FALSE)  return TRUE; 
; 696  : 		HANDLE hToken;
; 697  : 		DWORD dwStatus;
; 698  : 		DWORD dwAccessMask;
; 699  : 		DWORD dwAccessDesired;
; 700  : 		DWORD dwACLSize;
; 701  : 		DWORD dwStructureSize = sizeof(PRIVILEGE_SET);

	mov	DWORD PTR dwStructureSize$[rsp], 20

; 702  : 		PACL pACL = NULL;

	mov	QWORD PTR pACL$[rsp], 0

; 703  : 		PSID psidAdmin = NULL;

	mov	QWORD PTR psidAdmin$[rsp], 0

; 704  : 		BOOL bReturn = FALSE;

	mov	DWORD PTR bReturn$[rsp], 0

; 705  : 		PRIVILEGE_SET ps;
; 706  : 		GENERIC_MAPPING GenericMapping;
; 707  : 		PSECURITY_DESCRIPTOR psdAdmin = NULL;

	mov	QWORD PTR psdAdmin$[rsp], 0

; 708  : 		SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

	mov	BYTE PTR SystemSidAuthority$[rsp], 0
	mov	BYTE PTR SystemSidAuthority$[rsp+1], 0
	mov	BYTE PTR SystemSidAuthority$[rsp+2], 0
	mov	BYTE PTR SystemSidAuthority$[rsp+3], 0
	mov	BYTE PTR SystemSidAuthority$[rsp+4], 0
	mov	BYTE PTR SystemSidAuthority$[rsp+5], 5

; 709  : 
; 710  : 		if (!ImpersonateSelf(SecurityImpersonation))

	mov	ecx, 2
	call	QWORD PTR __imp_ImpersonateSelf
	test	eax, eax
	jne	SHORT $LN2@IsAdminist

; 711  : 			goto LeaveIsAdmin;

	jmp	$LN3@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN2@IsAdminist:

; 712  : 
; 713  : 		if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))

	call	QWORD PTR __imp_GetCurrentThread
	lea	r9, QWORD PTR hToken$[rsp]
	xor	r8d, r8d
	mov	edx, 8
	mov	rcx, rax
	call	QWORD PTR __imp_OpenThreadToken
	test	eax, eax
	jne	SHORT $LN4@IsAdminist

; 714  : 		{
; 715  : 			if (GetLastError() != ERROR_NO_TOKEN)

	call	QWORD PTR __imp_GetLastError
	cmp	eax, 1008				; 000003f0H
	je	SHORT $LN5@IsAdminist

; 716  : 				goto LeaveIsAdmin;

	jmp	$LN6@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN5@IsAdminist:

; 717  : 
; 718  : 			if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))

	call	QWORD PTR __imp_GetCurrentProcess
	lea	r8, QWORD PTR hToken$[rsp]
	mov	edx, 8
	mov	rcx, rax
	call	QWORD PTR __imp_OpenProcessToken
	test	eax, eax
	jne	SHORT $LN7@IsAdminist

; 719  : 				goto LeaveIsAdmin;

	jmp	$LN8@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN7@IsAdminist:

; 720  : 
; 721  : 			if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))

	call	QWORD PTR __imp_GetCurrentProcess
	lea	r8, QWORD PTR hToken$[rsp]
	mov	edx, 8
	mov	rcx, rax
	call	QWORD PTR __imp_OpenProcessToken
	test	eax, eax
	jne	SHORT $LN9@IsAdminist

; 722  : 				goto LeaveIsAdmin;

	jmp	$LN10@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN9@IsAdminist:
$LN4@IsAdminist:

; 723  : 		}
; 724  : 
; 725  : 		if (!AllocateAndInitializeSid(&SystemSidAuthority, 2,

	lea	rax, QWORD PTR psidAdmin$[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	DWORD PTR [rsp+72], 0
	mov	DWORD PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 544				; 00000220H
	mov	r8d, 32					; 00000020H
	mov	dl, 2
	lea	rcx, QWORD PTR SystemSidAuthority$[rsp]
	call	QWORD PTR __imp_AllocateAndInitializeSid
	test	eax, eax
	jne	SHORT $LN11@IsAdminist

; 726  : 			SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
; 727  : 			0, 0, 0, 0, 0, 0, &psidAdmin))
; 728  : 			goto LeaveIsAdmin;

	jmp	$LN12@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN11@IsAdminist:

; 729  : 
; 730  : 		psdAdmin = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

	mov	edx, 40					; 00000028H
	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_LocalAlloc
	mov	QWORD PTR psdAdmin$[rsp], rax

; 731  : 		if (psdAdmin == NULL)

	cmp	QWORD PTR psdAdmin$[rsp], 0
	jne	SHORT $LN13@IsAdminist

; 732  : 			goto LeaveIsAdmin;

	jmp	$LN14@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN13@IsAdminist:

; 733  : 
; 734  : 		if (!InitializeSecurityDescriptor(psdAdmin,

	mov	edx, 1
	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_InitializeSecurityDescriptor
	test	eax, eax
	jne	SHORT $LN15@IsAdminist

; 735  : 			SECURITY_DESCRIPTOR_REVISION))
; 736  : 			goto LeaveIsAdmin;

	jmp	$LN16@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN15@IsAdminist:

; 737  : 
; 738  : 		dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +

	mov	rcx, QWORD PTR psidAdmin$[rsp]
	call	QWORD PTR __imp_GetLengthSid
	mov	eax, eax
	add	rax, 16
	mov	DWORD PTR dwACLSize$[rsp], eax

; 739  : 			GetLengthSid(psidAdmin) - sizeof(DWORD);
; 740  : 
; 741  : 		pACL = (PACL)LocalAlloc(LPTR, dwACLSize);

	mov	eax, DWORD PTR dwACLSize$[rsp]
	mov	edx, eax
	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_LocalAlloc
	mov	QWORD PTR pACL$[rsp], rax

; 742  : 		if (pACL == NULL)

	cmp	QWORD PTR pACL$[rsp], 0
	jne	SHORT $LN17@IsAdminist

; 743  : 			goto LeaveIsAdmin;

	jmp	$LN18@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN17@IsAdminist:

; 744  : 
; 745  : 		if (!InitializeAcl(pACL, dwACLSize, ACL_REVISION2))

	mov	r8d, 2
	mov	edx, DWORD PTR dwACLSize$[rsp]
	mov	rcx, QWORD PTR pACL$[rsp]
	call	QWORD PTR __imp_InitializeAcl
	test	eax, eax
	jne	SHORT $LN19@IsAdminist

; 746  : 			goto LeaveIsAdmin;

	jmp	$LN20@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN19@IsAdminist:

; 747  : 
; 748  : 		dwAccessMask = ACCESS_READ | ACCESS_WRITE;

	mov	DWORD PTR dwAccessMask$[rsp], 3

; 749  : 
; 750  : 		if (!AddAccessAllowedAce(pACL, ACL_REVISION2, dwAccessMask, psidAdmin))

	mov	r9, QWORD PTR psidAdmin$[rsp]
	mov	r8d, DWORD PTR dwAccessMask$[rsp]
	mov	edx, 2
	mov	rcx, QWORD PTR pACL$[rsp]
	call	QWORD PTR __imp_AddAccessAllowedAce
	test	eax, eax
	jne	SHORT $LN21@IsAdminist

; 751  : 			goto LeaveIsAdmin;

	jmp	$LN22@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN21@IsAdminist:

; 752  : 
; 753  : 		if (!SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE))

	xor	r9d, r9d
	mov	r8, QWORD PTR pACL$[rsp]
	mov	edx, 1
	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_SetSecurityDescriptorDacl
	test	eax, eax
	jne	SHORT $LN23@IsAdminist

; 754  : 			goto LeaveIsAdmin;

	jmp	$LN24@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN23@IsAdminist:

; 755  : 
; 756  : 		if (!SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE))

	xor	r8d, r8d
	mov	rdx, QWORD PTR psidAdmin$[rsp]
	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_SetSecurityDescriptorGroup
	test	eax, eax
	jne	SHORT $LN25@IsAdminist

; 757  : 			goto LeaveIsAdmin;

	jmp	$LN26@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN25@IsAdminist:

; 758  : 		if (!SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE))

	xor	r8d, r8d
	mov	rdx, QWORD PTR psidAdmin$[rsp]
	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_SetSecurityDescriptorOwner
	test	eax, eax
	jne	SHORT $LN27@IsAdminist

; 759  : 			goto LeaveIsAdmin;

	jmp	$LN28@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN27@IsAdminist:

; 760  : 
; 761  : 		if (!IsValidSecurityDescriptor(psdAdmin))

	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_IsValidSecurityDescriptor
	test	eax, eax
	jne	SHORT $LN29@IsAdminist

; 762  : 			goto LeaveIsAdmin;

	jmp	$LN30@IsAdminist
	jmp	$LeaveIsAdmin$39
$LN29@IsAdminist:

; 763  : 
; 764  : 		dwAccessDesired = ACCESS_READ;

	mov	DWORD PTR dwAccessDesired$[rsp], 1

; 765  : 
; 766  : 		GenericMapping.GenericRead = ACCESS_READ;

	mov	DWORD PTR GenericMapping$[rsp], 1

; 767  : 		GenericMapping.GenericWrite = ACCESS_WRITE;

	mov	DWORD PTR GenericMapping$[rsp+4], 2

; 768  : 		GenericMapping.GenericExecute = 0;

	mov	DWORD PTR GenericMapping$[rsp+8], 0

; 769  : 		GenericMapping.GenericAll = ACCESS_READ | ACCESS_WRITE;

	mov	DWORD PTR GenericMapping$[rsp+12], 3

; 770  : 
; 771  : 		if (!AccessCheck(psdAdmin, hToken, dwAccessDesired,

	lea	rax, QWORD PTR bReturn$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR dwStatus$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR dwStructureSize$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR ps$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR GenericMapping$[rsp]
	mov	r8d, DWORD PTR dwAccessDesired$[rsp]
	mov	rdx, QWORD PTR hToken$[rsp]
	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_AccessCheck
	test	eax, eax
	jne	SHORT $LN31@IsAdminist

; 772  : 			&GenericMapping, &ps, &dwStructureSize, &dwStatus, &bReturn))
; 773  : 			goto LeaveIsAdmin;

	jmp	SHORT $LN32@IsAdminist
	jmp	SHORT $LeaveIsAdmin$39
$LN31@IsAdminist:

; 774  : 
; 775  : 		if (!RevertToSelf())

	call	QWORD PTR __imp_RevertToSelf
	test	eax, eax
	jne	SHORT $LN33@IsAdminist

; 776  : 			bReturn = FALSE;

	mov	DWORD PTR bReturn$[rsp], 0
$LN33@IsAdminist:
$LN3@IsAdminist:
$LN6@IsAdminist:
$LN8@IsAdminist:
$LN10@IsAdminist:
$LN12@IsAdminist:
$LN14@IsAdminist:
$LN16@IsAdminist:
$LN18@IsAdminist:
$LN20@IsAdminist:
$LN22@IsAdminist:
$LN24@IsAdminist:
$LN26@IsAdminist:
$LN28@IsAdminist:
$LN30@IsAdminist:
$LN32@IsAdminist:
$LeaveIsAdmin$39:

; 777  : 
; 778  : 	LeaveIsAdmin:
; 779  : 
; 780  : 		if (pACL) LocalFree(pACL);

	cmp	QWORD PTR pACL$[rsp], 0
	je	SHORT $LN34@IsAdminist
	mov	rcx, QWORD PTR pACL$[rsp]
	call	QWORD PTR __imp_LocalFree
	npad	1
$LN34@IsAdminist:

; 781  : 		if (psdAdmin) LocalFree(psdAdmin);

	cmp	QWORD PTR psdAdmin$[rsp], 0
	je	SHORT $LN35@IsAdminist
	mov	rcx, QWORD PTR psdAdmin$[rsp]
	call	QWORD PTR __imp_LocalFree
	npad	1
$LN35@IsAdminist:

; 782  : 		if (psidAdmin) FreeSid(psidAdmin);

	cmp	QWORD PTR psidAdmin$[rsp], 0
	je	SHORT $LN36@IsAdminist
	mov	rcx, QWORD PTR psidAdmin$[rsp]
	call	QWORD PTR __imp_FreeSid
	npad	1
$LN36@IsAdminist:

; 783  : 
; 784  : 		return bReturn;

	mov	eax, DWORD PTR bReturn$[rsp]

; 785  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	ret	0
?IsAdministratorRun@Utils@IronMan@@YAHXZ ENDP		; IronMan::Utils::IsAdministratorRun
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
hClipboardData$ = 32
pClipboardData$ = 40
tv225 = 48
tv216 = 56
tv226 = 64
tv218 = 72
tv227 = 80
tv220 = 88
tv228 = 96
tv222 = 104
tv195 = 112
tv193 = 120
tv229 = 128
tv224 = 136
$T1 = 144
$T2 = 176
$T3 = 208
$T4 = 240
$T5 = 272
__$ArrayPad$ = 304
text$ = 336
?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Utils::writeToClipboard

; 645  : 	void Utils::writeToClipboard(const std::string& text) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 328				; 00000148H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 646  : 		// 
; 647  : 		if (!OpenClipboard(nullptr)) {

	xor	ecx, ecx
	call	QWORD PTR __imp_OpenClipboard
	test	eax, eax
	jne	$LN2@writeToCli

; 648  : 			CONSOLE_INFO2("Failed to open clipboard");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BJ@ONFBAHNE@Failed?5to?5open?5clipboard@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T1[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv225[rsp], rax
	mov	rax, QWORD PTR tv225[rsp]
	mov	QWORD PTR tv216[rsp], rax
	mov	rcx, QWORD PTR tv216[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 649  : 			return;

	jmp	$LN1@writeToCli
$LN2@writeToCli:

; 650  : 		}
; 651  : 
; 652  : 		// 
; 653  : 		if (!EmptyClipboard()) {

	call	QWORD PTR __imp_EmptyClipboard
	test	eax, eax
	jne	$LN3@writeToCli

; 654  : 			CONSOLE_INFO2("Failed to empty clipboard");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BK@DPKMAAKB@Failed?5to?5empty?5clipboard@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T2[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv226[rsp], rax
	mov	rax, QWORD PTR tv226[rsp]
	mov	QWORD PTR tv218[rsp], rax
	mov	rcx, QWORD PTR tv218[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 655  : 			CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard
	npad	1

; 656  : 			return;

	jmp	$LN1@writeToCli
$LN3@writeToCli:

; 657  : 		}
; 658  : 
; 659  : 		// 
; 660  : 		HGLOBAL hClipboardData = GlobalAlloc(GMEM_DDESHARE, text.length() + 1);

	mov	rcx, QWORD PTR text$[rsp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	inc	rax
	mov	rdx, rax
	mov	ecx, 8192				; 00002000H
	call	QWORD PTR __imp_GlobalAlloc
	mov	QWORD PTR hClipboardData$[rsp], rax

; 661  : 		if (hClipboardData == nullptr) {

	cmp	QWORD PTR hClipboardData$[rsp], 0
	jne	$LN4@writeToCli

; 662  : 			CONSOLE_INFO2("Failed to allocate memory for clipboard data");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0CN@CKEHACNA@Failed?5to?5allocate?5memory?5for?5c@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv227[rsp], rax
	mov	rax, QWORD PTR tv227[rsp]
	mov	QWORD PTR tv220[rsp], rax
	mov	rcx, QWORD PTR tv220[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 663  : 			CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard
	npad	1

; 664  : 			return;

	jmp	$LN1@writeToCli
$LN4@writeToCli:

; 665  : 		}
; 666  : 
; 667  : 		// 
; 668  : 		char* pClipboardData = static_cast<char*>(GlobalLock(hClipboardData));

	mov	rcx, QWORD PTR hClipboardData$[rsp]
	call	QWORD PTR __imp_GlobalLock
	mov	QWORD PTR pClipboardData$[rsp], rax

; 669  : 		if (pClipboardData == nullptr) {

	cmp	QWORD PTR pClipboardData$[rsp], 0
	jne	$LN5@writeToCli

; 670  : 			CONSOLE_INFO2("Failed to lock memory for clipboard data");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0CJ@IEFDILKB@Failed?5to?5lock?5memory?5for?5clipb@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv228[rsp], rax
	mov	rax, QWORD PTR tv228[rsp]
	mov	QWORD PTR tv222[rsp], rax
	mov	rcx, QWORD PTR tv222[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 671  : 			GlobalFree(hClipboardData);

	mov	rcx, QWORD PTR hClipboardData$[rsp]
	call	QWORD PTR __imp_GlobalFree

; 672  : 			CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard
	npad	1

; 673  : 			return;

	jmp	$LN1@writeToCli
$LN5@writeToCli:

; 674  : 		}
; 675  : 
; 676  : 		// 
; 677  : 		strcpy_s(pClipboardData, text.length() + 1, text.c_str());

	mov	rcx, QWORD PTR text$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv195[rsp], rax
	mov	rcx, QWORD PTR text$[rsp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	inc	rax
	mov	QWORD PTR tv193[rsp], rax
	mov	r8, QWORD PTR tv195[rsp]
	mov	rdx, QWORD PTR tv193[rsp]
	mov	rcx, QWORD PTR pClipboardData$[rsp]
	call	strcpy_s

; 678  : 
; 679  : 		// 
; 680  : 		GlobalUnlock(hClipboardData);

	mov	rcx, QWORD PTR hClipboardData$[rsp]
	call	QWORD PTR __imp_GlobalUnlock

; 681  : 
; 682  : 		// 
; 683  : 		SetClipboardData(CF_TEXT, hClipboardData);

	mov	rdx, QWORD PTR hClipboardData$[rsp]
	mov	ecx, 1
	call	QWORD PTR __imp_SetClipboardData

; 684  : 
; 685  : 		// 
; 686  : 		CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard

; 687  : 		CONSOLE_INFO2("Copy the URL successfully,Press CTRL+V To Browser");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0DC@LOMALFKN@Copy?5the?5URL?5successfully?0Press@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T5[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv229[rsp], rax
	mov	rax, QWORD PTR tv229[rsp]
	mov	QWORD PTR tv224[rsp], rax
	mov	rcx, QWORD PTR tv224[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN1@writeToCli:

; 688  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 328				; 00000148H
	ret	0
?writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Utils::writeToClipboard
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
hClipboardData$ = 32
pClipboardData$ = 40
tv225 = 48
tv216 = 56
tv226 = 64
tv218 = 72
tv227 = 80
tv220 = 88
tv228 = 96
tv222 = 104
tv195 = 112
tv193 = 120
tv229 = 128
tv224 = 136
$T1 = 144
$T2 = 176
$T3 = 208
$T4 = 240
$T5 = 272
__$ArrayPad$ = 304
text$ = 336
?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::writeToClipboard'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::writeToClipboard'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
hClipboardData$ = 32
pClipboardData$ = 40
tv225 = 48
tv216 = 56
tv226 = 64
tv218 = 72
tv227 = 80
tv220 = 88
tv228 = 96
tv222 = 104
tv195 = 112
tv193 = 120
tv229 = 128
tv224 = 136
$T1 = 144
$T2 = 176
$T3 = 208
$T4 = 240
$T5 = 272
__$ArrayPad$ = 304
text$ = 336
?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::writeToClipboard'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::writeToClipboard'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
hClipboardData$ = 32
pClipboardData$ = 40
tv225 = 48
tv216 = 56
tv226 = 64
tv218 = 72
tv227 = 80
tv220 = 88
tv228 = 96
tv222 = 104
tv195 = 112
tv193 = 120
tv229 = 128
tv224 = 136
$T1 = 144
$T2 = 176
$T3 = 208
$T4 = 240
$T5 = 272
__$ArrayPad$ = 304
text$ = 336
?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::writeToClipboard'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::writeToClipboard'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
hClipboardData$ = 32
pClipboardData$ = 40
tv225 = 48
tv216 = 56
tv226 = 64
tv218 = 72
tv227 = 80
tv220 = 88
tv228 = 96
tv222 = 104
tv195 = 112
tv193 = 120
tv229 = 128
tv224 = 136
$T1 = 144
$T2 = 176
$T3 = 208
$T4 = 240
$T5 = 272
__$ArrayPad$ = 304
text$ = 336
?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::writeToClipboard'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::writeToClipboard'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
hClipboardData$ = 32
pClipboardData$ = 40
tv225 = 48
tv216 = 56
tv226 = 64
tv218 = 72
tv227 = 80
tv220 = 88
tv228 = 96
tv222 = 104
tv195 = 112
tv193 = 120
tv229 = 128
tv224 = 136
$T1 = 144
$T2 = 176
$T3 = 208
$T4 = 240
$T5 = 272
__$ArrayPad$ = 304
text$ = 336
?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Utils::writeToClipboard'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??writeToClipboard@Utils@IronMan@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Utils::writeToClipboard'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
text$ = 48
caption$ = 56
?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z PROC ; IronMan::Utils::MessageBoxTermination

; 642  : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 643  : 	}

	mov	rcx, QWORD PTR text$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	rcx, QWORD PTR caption$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z ENDP ; IronMan::Utils::MessageBoxTermination
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
text$ = 48
caption$ = 56
?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA PROC ; `IronMan::Utils::MessageBoxTermination'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR caption$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??MessageBoxTermination@Utils@IronMan@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@0@Z@4HA ENDP ; `IronMan::Utils::MessageBoxTermination'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
pImageDosHeader$ = 0
pImage$ = 8
pImageNtHeader$ = 16
hModule$ = 48
?GetModuleLen@Utils@IronMan@@YAKPEAUHINSTANCE__@@@Z PROC ; IronMan::Utils::GetModuleLen

; 624  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 625  : 		PBYTE pImage = (PBYTE)hModule;

	mov	rax, QWORD PTR hModule$[rsp]
	mov	QWORD PTR pImage$[rsp], rax

; 626  : 		PIMAGE_DOS_HEADER pImageDosHeader;
; 627  : 		PIMAGE_NT_HEADERS pImageNtHeader;
; 628  : 		pImageDosHeader = (PIMAGE_DOS_HEADER)pImage;

	mov	rax, QWORD PTR pImage$[rsp]
	mov	QWORD PTR pImageDosHeader$[rsp], rax

; 629  : 		if (pImageDosHeader->e_magic != IMAGE_DOS_SIGNATURE)

	mov	rax, QWORD PTR pImageDosHeader$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 23117				; 00005a4dH
	je	SHORT $LN2@GetModuleL

; 630  : 		{
; 631  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetModuleL
$LN2@GetModuleL:

; 632  : 		}
; 633  : 		pImageNtHeader = (PIMAGE_NT_HEADERS)&pImage[pImageDosHeader->e_lfanew];

	mov	rax, QWORD PTR pImageDosHeader$[rsp]
	movsxd	rax, DWORD PTR [rax+60]
	mov	rcx, QWORD PTR pImage$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pImageNtHeader$[rsp], rax

; 634  : 		if (pImageNtHeader->Signature != IMAGE_NT_SIGNATURE)

	mov	rax, QWORD PTR pImageNtHeader$[rsp]
	cmp	DWORD PTR [rax], 17744			; 00004550H
	je	SHORT $LN3@GetModuleL

; 635  : 		{
; 636  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetModuleL
$LN3@GetModuleL:

; 637  : 		}
; 638  : 		return pImageNtHeader->OptionalHeader.SizeOfImage;

	mov	rax, QWORD PTR pImageNtHeader$[rsp]
	mov	eax, DWORD PTR [rax+80]
$LN1@GetModuleL:

; 639  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?GetModuleLen@Utils@IronMan@@YAKPEAUHINSTANCE__@@@Z ENDP ; IronMan::Utils::GetModuleLen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
len$ = 32
$T1 = 36
pFunc$ = 40
tv77 = 48
tv86 = 56
$T2 = 64
imgName$ = 96
__$ArrayPad$ = 624
__$ReturnUdt$ = 656
?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ PROC ; IronMan::Utils::GetExePath

; 610  : 	{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 640				; 00000280H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 611  : 		wchar_t imgName[MAX_PATH] = { 0 };

	lea	rax, QWORD PTR imgName$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 520				; 00000208H
	rep stosb

; 612  : 		DWORD len = ARRAYSIZE(imgName);

	mov	DWORD PTR len$[rsp], 260		; 00000104H

; 613  : 
; 614  : 		auto pFunc = GET_IMPORT(QueryFullProcessImageNameW);

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv77[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_0BL@DJAAHBPE@QueryFullProcessImageNameW@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$get@P6AHPEAXKPEA_WPEAK@Z@DynImport@IronMan@@QEAAP6AHPEAXKPEA_WPEAK@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<int (__cdecl*)(void *,unsigned long,wchar_t *,unsigned long *)>
	mov	QWORD PTR pFunc$[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 615  : 		if (pFunc != nullptr)

	cmp	QWORD PTR pFunc$[rsp], 0
	je	SHORT $LN2@GetExePath

; 616  : 			pFunc(GetCurrentProcess(), 0, imgName, &len);

	mov	rax, QWORD PTR pFunc$[rsp]
	mov	QWORD PTR tv86[rsp], rax
	call	QWORD PTR __imp_GetCurrentProcess
	lea	r9, QWORD PTR len$[rsp]
	lea	r8, QWORD PTR imgName$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR tv86[rsp]
	npad	1
	jmp	SHORT $LN3@GetExePath
$LN2@GetExePath:

; 617  : 		else
; 618  : 			GetModuleFileNameW(NULL, imgName, len);

	mov	r8d, DWORD PTR len$[rsp]
	lea	rdx, QWORD PTR imgName$[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleFileNameW
	npad	1
$LN3@GetExePath:

; 619  : 
; 620  : 		return imgName;

	lea	rdx, QWORD PTR imgName$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 621  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 640				; 00000280H
	pop	rdi
	ret	0
	int	3
?GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ENDP ; IronMan::Utils::GetExePath
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
len$ = 32
$T1 = 36
pFunc$ = 40
tv77 = 48
tv86 = 56
$T2 = 64
imgName$ = 96
__$ArrayPad$ = 624
__$ReturnUdt$ = 656
?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetExePath'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetExePath'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
len$ = 32
$T1 = 36
pFunc$ = 40
tv77 = 48
tv86 = 56
$T2 = 64
imgName$ = 96
__$ArrayPad$ = 624
__$ReturnUdt$ = 656
?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA PROC ; `IronMan::Utils::GetExePath'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN7@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetExePath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ@4HA ENDP ; `IronMan::Utils::GetExePath'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
tv69 = 32
path$ = 64
?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Utils::FileExists

; 479  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 480  : 		return (GetFileAttributesA(path.c_str()) != 0xFFFFFFFF);

	mov	rcx, QWORD PTR path$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	QWORD PTR __imp_GetFileAttributesA
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN3@FileExists
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@FileExists
$LN3@FileExists:
	mov	DWORD PTR tv69[rsp], 0
$LN4@FileExists:
	movzx	eax, BYTE PTR tv69[rsp]

; 481  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Utils::FileExists
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
tv69 = 32
path$ = 64
?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IronMan::Utils::FileExists

; 475  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 476  : 		return (GetFileAttributesW(path.c_str()) != 0xFFFFFFFF);

	mov	rcx, QWORD PTR path$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	rcx, rax
	call	QWORD PTR __imp_GetFileAttributesW
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN3@FileExists
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@FileExists
$LN3@FileExists:
	mov	DWORD PTR tv69[rsp], 0
$LN4@FileExists:
	movzx	eax, BYTE PTR tv69[rsp]

; 477  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?FileExists@Utils@IronMan@@YA_NAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IronMan::Utils::FileExists
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
i$1 = 0
str$ = 32
maxLength$ = 40
?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z PROC	; IronMan::Utils::hasNullTerminator

; 839  : 	bool Utils::hasNullTerminator(char* str, size_t maxLength) {

$LN14:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 840  : 		__try
; 841  : 		{
; 842  : 			for (size_t i = 0; i < maxLength; ++i) {

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@hasNullTer
$LN2@hasNullTer:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN4@hasNullTer:
	mov	rax, QWORD PTR maxLength$[rsp]
	cmp	QWORD PTR i$1[rsp], rax
	jae	SHORT $LN3@hasNullTer

; 843  : 				if (str[i] == '\0') {

	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN6@hasNullTer

; 844  : 					return true;

	mov	al, 1
	jmp	SHORT $LN9@hasNullTer
$LN6@hasNullTer:

; 845  : 				}
; 846  : 			}

	jmp	SHORT $LN2@hasNullTer
$LN3@hasNullTer:

; 847  : 			// 
; 848  : 			if (maxLength > 0) {

	cmp	QWORD PTR maxLength$[rsp], 0
	jbe	SHORT $LN7@hasNullTer

; 849  : 				str[maxLength - 1] = '\0';

	mov	rax, QWORD PTR maxLength$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax-1], 0

; 850  : 				return false;

	xor	al, al
	jmp	SHORT $LN9@hasNullTer
$LN7@hasNullTer:

; 851  : 			}
; 852  : 		}

	jmp	SHORT $LN13@hasNullTer

; 853  : 		__except (1)
; 854  : 		{

$LN11@hasNullTer:
$LN13@hasNullTer:

; 855  : 
; 856  : 		}
; 857  : 		return false;

	xor	al, al
$LN9@hasNullTer:

; 858  : 	}

	add	rsp, 24
	ret	0
?hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z ENDP	; IronMan::Utils::hasNullTerminator
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 0
str$ = 32
maxLength$ = 40
?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA PROC ; `IronMan::Utils::hasNullTerminator'::`1'::filt$0
	push	rbp
	mov	rbp, rdx
$LN10@filt$0:

; 853  : 		__except (1)

	mov	eax, 1
$LN12@filt$0:
	pop	rbp
	ret	0
	int	3
?filt$0@?0??hasNullTerminator@Utils@IronMan@@YA_NPEAD_K@Z@4HA ENDP ; `IronMan::Utils::hasNullTerminator'::`1'::filt$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z PROC ; IronMan::Utils::ToUpper

; 462  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	DWORD PTR $T1[rsp], 0

; 463  : 
; 464  : 		std::transform(str.begin(), str.end(), str.begin(), ::toupper);

	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rsp], rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, OFFSET FLAT:toupper
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR $T5[rsp]
	mov	r8, QWORD PTR $T6[rsp]
	mov	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
	npad	1

; 465  : 
; 466  : 		return str;

	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 467  : 	}

	add	rsp, 152				; 00000098H
	ret	0
	int	3
?ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ENDP ; IronMan::Utils::ToUpper
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToUpper'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToUpper'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToUpper'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToUpper'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z PROC ; IronMan::Utils::ToLower

; 449  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	DWORD PTR $T1[rsp], 0

; 450  : 
; 451  : 		std::transform(str.begin(), str.end(), str.begin(), ::tolower);

	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rsp], rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, OFFSET FLAT:tolower
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR $T5[rsp]
	mov	r8, QWORD PTR $T6[rsp]
	mov	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
	npad	1

; 452  : 
; 453  : 		return str;

	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 454  : 	}

	add	rsp, 152				; 00000098H
	ret	0
	int	3
?ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ENDP ; IronMan::Utils::ToLower
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToLower'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToLower'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToLower'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToLower'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z PROC ; IronMan::Utils::ToUpper

; 436  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	DWORD PTR $T1[rsp], 0

; 437  : 
; 438  : 		std::transform(str.begin(), str.end(), str.begin(), ::towupper);

	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rsp], rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, OFFSET FLAT:towupper
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR $T5[rsp]
	mov	r8, QWORD PTR $T6[rsp]
	mov	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,unsigned short (__cdecl*)(unsigned short)>
	npad	1

; 439  : 
; 440  : 		return str;

	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 441  : 	}

	add	rsp, 152				; 00000098H
	ret	0
	int	3
?ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z ENDP ; IronMan::Utils::ToUpper
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToUpper'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToUpper'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToUpper'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ToUpper@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToUpper'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z PROC ; IronMan::Utils::ToLower

; 423  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	DWORD PTR $T1[rsp], 0

; 424  : 
; 425  : 		std::transform(str.begin(), str.end(), str.begin(), ::towlower);

	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rsp], rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, OFFSET FLAT:towlower
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR $T5[rsp]
	mov	r8, QWORD PTR $T6[rsp]
	mov	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AGG@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@0V10@P6AGG@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,unsigned short (__cdecl*)(unsigned short)>
	npad	1

; 426  : 
; 427  : 		return str;

	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 428  : 	}

	add	rsp, 152				; 00000098H
	ret	0
	int	3
?ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z ENDP ; IronMan::Utils::ToLower
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToLower'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToLower'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
$T11 = 128
__$ReturnUdt$ = 160
str$ = 168
?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA PROC ; `IronMan::Utils::ToLower'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ToLower@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V34@@Z@4HA ENDP ; `IronMan::Utils::ToLower'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
idx$ = 40
fileName$2 = 48
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
path$ = 120
ext$ = 128
?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z PROC ; IronMan::Utils::StripPath

; 390  : 	{

$LN14:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 391  : 
; 392  : 		if (path.empty())

	mov	rcx, QWORD PTR path$[rsp]
	call	?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@StripPath

; 393  : 			return path;

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@StripPath
$LN2@StripPath:

; 394  : 
; 395  : 		auto idx = path.rfind('\\');

	mov	r8, -1
	mov	dx, 92					; 0000005cH
	mov	rcx, QWORD PTR path$[rsp]
	call	?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::rfind
	mov	QWORD PTR idx$[rsp], rax

; 396  : 		if (idx == path.npos)

	cmp	QWORD PTR idx$[rsp], -1
	jne	SHORT $LN3@StripPath

; 397  : 			idx = path.rfind('/');

	mov	r8, -1
	mov	dx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::rfind
	mov	QWORD PTR idx$[rsp], rax
$LN3@StripPath:

; 398  : 		if (idx != path.npos)

	cmp	QWORD PTR idx$[rsp], -1
	je	$LN4@StripPath

; 399  : 		{
; 400  : 			auto fileName = path.substr(idx + 1);

	mov	rax, QWORD PTR idx$[rsp]
	inc	rax
	mov	r9, -1
	mov	r8, rax
	lea	rdx, QWORD PTR fileName$2[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
	npad	1

; 401  : 			if (!ext)

	movzx	eax, BYTE PTR ext$[rsp]
	test	eax, eax
	jne	$LN6@StripPath

; 402  : 			{
; 403  : 				idx = fileName.rfind('.');

	mov	r8, -1
	mov	dx, 46					; 0000002eH
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::rfind
	mov	QWORD PTR idx$[rsp], rax

; 404  : 				if (idx != path.npos)

	cmp	QWORD PTR idx$[rsp], -1
	je	SHORT $LN8@StripPath

; 405  : 					return fileName.substr(static_cast<std::wstring::size_type>(0), idx);

	mov	r9, QWORD PTR idx$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@StripPath
	jmp	SHORT $LN9@StripPath
$LN8@StripPath:

; 406  : 				else
; 407  : 					return fileName;

	lea	rdx, QWORD PTR fileName$2[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@StripPath
$LN9@StripPath:

; 408  : 			}

	jmp	SHORT $LN7@StripPath
$LN6@StripPath:

; 409  : 			else
; 410  : 				return fileName;

	lea	rdx, QWORD PTR fileName$2[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@StripPath
$LN7@StripPath:

; 411  : 		}

	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	jmp	SHORT $LN1@StripPath
$LN4@StripPath:

; 412  : 		else
; 413  : 			return path;

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@StripPath:

; 414  : 
; 415  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	int	3
?StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z ENDP ; IronMan::Utils::StripPath
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
idx$ = 40
fileName$2 = 48
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
path$ = 120
ext$ = 128
?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA PROC ; `IronMan::Utils::StripPath'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN12@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA ENDP ; `IronMan::Utils::StripPath'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
idx$ = 40
fileName$2 = 48
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
path$ = 120
ext$ = 128
?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA PROC ; `IronMan::Utils::StripPath'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR fileName$2[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV34@_N@Z@4HA ENDP ; `IronMan::Utils::StripPath'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
idx$ = 40
fileName$2 = 48
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
path$ = 120
ext$ = 128
?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z PROC ; IronMan::Utils::StripPath

; 356  : 	{

$LN14:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 357  : 
; 358  : 		if (path.empty())

	mov	rcx, QWORD PTR path$[rsp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@StripPath

; 359  : 			return path;

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@StripPath
$LN2@StripPath:

; 360  : 
; 361  : 		auto idx = path.rfind('\\');

	mov	r8, -1
	mov	dl, 92					; 0000005cH
	mov	rcx, QWORD PTR path$[rsp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
	mov	QWORD PTR idx$[rsp], rax

; 362  : 		if (idx == path.npos)

	cmp	QWORD PTR idx$[rsp], -1
	jne	SHORT $LN3@StripPath

; 363  : 			idx = path.rfind('/');

	mov	r8, -1
	mov	dl, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
	mov	QWORD PTR idx$[rsp], rax
$LN3@StripPath:

; 364  : 		if (idx != path.npos)

	cmp	QWORD PTR idx$[rsp], -1
	je	$LN4@StripPath

; 365  : 		{
; 366  : 			auto fileName = path.substr(idx + 1);

	mov	rax, QWORD PTR idx$[rsp]
	inc	rax
	mov	r9, -1
	mov	r8, rax
	lea	rdx, QWORD PTR fileName$2[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	npad	1

; 367  : 			if (!ext)

	movzx	eax, BYTE PTR ext$[rsp]
	test	eax, eax
	jne	$LN6@StripPath

; 368  : 			{
; 369  : 				idx = fileName.rfind('.');

	mov	r8, -1
	mov	dl, 46					; 0000002eH
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
	mov	QWORD PTR idx$[rsp], rax

; 370  : 				if (idx != path.npos)

	cmp	QWORD PTR idx$[rsp], -1
	je	SHORT $LN8@StripPath

; 371  : 					return fileName.substr(static_cast<std::string::size_type>(0), idx);

	mov	r9, QWORD PTR idx$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@StripPath
	jmp	SHORT $LN9@StripPath
$LN8@StripPath:

; 372  : 				else
; 373  : 					return fileName;

	lea	rdx, QWORD PTR fileName$2[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@StripPath
$LN9@StripPath:

; 374  : 			}

	jmp	SHORT $LN7@StripPath
$LN6@StripPath:

; 375  : 			else
; 376  : 				return fileName;

	lea	rdx, QWORD PTR fileName$2[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@StripPath
$LN7@StripPath:

; 377  : 		}

	lea	rcx, QWORD PTR fileName$2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN1@StripPath
$LN4@StripPath:

; 378  : 		else
; 379  : 			return path;

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@StripPath:

; 380  : 
; 381  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	int	3
?StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z ENDP ; IronMan::Utils::StripPath
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
idx$ = 40
fileName$2 = 48
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
path$ = 120
ext$ = 128
?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA PROC ; `IronMan::Utils::StripPath'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN12@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA ENDP ; `IronMan::Utils::StripPath'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
idx$ = 40
fileName$2 = 48
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
path$ = 120
ext$ = 128
?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA PROC ; `IronMan::Utils::StripPath'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR fileName$2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??StripPath@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@_N@Z@4HA ENDP ; `IronMan::Utils::StripPath'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z PROC ; IronMan::Utils::SplitText

; 291  : 	{

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 292  : 
; 293  : 		std::vector<std::string> result;

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1

; 294  : 		std::string::size_type pos1, pos2, pos3;
; 295  : 		pos2 = str.find(splitter1);

	xor	r8d, r8d
	mov	rdx, QWORD PTR splitter1$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR pos2$[rsp], rax

; 296  : 		pos1 = 0;

	mov	QWORD PTR pos1$[rsp], 0
$LN2@SplitText:

; 297  : 		while (std::string::npos != pos2)

	cmp	QWORD PTR pos2$[rsp], -1
	je	$LN3@SplitText

; 298  : 		{
; 299  : 			pos3 = str.find(splitter2, pos1);

	mov	r8, QWORD PTR pos1$[rsp]
	mov	rdx, QWORD PTR splitter2$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR pos3$[rsp], rax

; 300  : 			if (std::string::npos != pos3)

	cmp	QWORD PTR pos3$[rsp], -1
	je	$LN4@SplitText

; 301  : 			{
; 302  : 				result.push_back(str.substr(pos2 + splitter1.size(), pos3 - pos2 - splitter1.size()));

	mov	rax, QWORD PTR pos2$[rsp]
	mov	rcx, QWORD PTR pos3$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv83[rsp], rax
	mov	rcx, QWORD PTR splitter1$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR tv83[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv128[rsp], rax
	mov	rcx, QWORD PTR splitter1$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR pos2$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv94[rsp], rax
	mov	r9, QWORD PTR tv128[rsp]
	mov	r8, QWORD PTR tv94[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	QWORD PTR tv68[rsp], rax
	mov	rax, QWORD PTR tv68[rsp]
	mov	QWORD PTR tv148[rsp], rax
	mov	rdx, QWORD PTR tv148[rsp]
	lea	rcx, QWORD PTR result$[rsp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 303  : 				pos1 = pos3 + splitter2.size();

	mov	rcx, QWORD PTR splitter2$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR pos3$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pos1$[rsp], rax

; 304  : 				pos2 = str.find(splitter1, pos1);

	mov	r8, QWORD PTR pos1$[rsp]
	mov	rdx, QWORD PTR splitter1$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR pos2$[rsp], rax
$LN4@SplitText:

; 305  : 			}
; 306  : 		}

	jmp	$LN2@SplitText
$LN3@SplitText:

; 307  : 		return result;

	lea	rdx, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR splitter1$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR splitter2$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 308  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	ret	0
	int	3
?SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z ENDP ; IronMan::Utils::SplitText
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA PROC ; `IronMan::Utils::SplitText'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR splitter2$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA ENDP ; `IronMan::Utils::SplitText'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA PROC ; `IronMan::Utils::SplitText'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR splitter1$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA ENDP ; `IronMan::Utils::SplitText'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA PROC ; `IronMan::Utils::SplitText'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA ENDP ; `IronMan::Utils::SplitText'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA PROC ; `IronMan::Utils::SplitText'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR result$[rbp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA ENDP ; `IronMan::Utils::SplitText'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA PROC ; `IronMan::Utils::SplitText'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA ENDP ; `IronMan::Utils::SplitText'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
pos2$ = 40
pos3$ = 48
pos1$ = 56
tv83 = 64
tv128 = 72
tv94 = 80
tv68 = 88
tv148 = 96
result$ = 104
$T2 = 128
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
str$ = 200
splitter1$ = 208
splitter2$ = 216
?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA PROC ; `IronMan::Utils::SplitText'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@dtor$5
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN12@dtor$5:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??SplitText@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@V54@1@Z@4HA ENDP ; `IronMan::Utils::SplitText'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z PROC ; IronMan::Utils::SplitString

; 271  : 	{

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 272  : 
; 273  : 		std::vector<std::string> result;

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1

; 274  : 		std::string::size_type pos1, pos2;
; 275  : 		pos2 = str.find(splitter);

	xor	r8d, r8d
	mov	rdx, QWORD PTR splitter$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR pos2$[rsp], rax

; 276  : 		pos1 = 0;

	mov	QWORD PTR pos1$[rsp], 0
$LN2@SplitStrin:

; 277  : 		while (std::string::npos != pos2)

	cmp	QWORD PTR pos2$[rsp], -1
	je	$LN3@SplitStrin

; 278  : 		{
; 279  : 			result.push_back(str.substr(pos1, pos2 - pos1));

	mov	rax, QWORD PTR pos1$[rsp]
	mov	rcx, QWORD PTR pos2$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR pos1$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	QWORD PTR tv67[rsp], rax
	mov	rax, QWORD PTR tv67[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rdx, QWORD PTR tv143[rsp]
	lea	rcx, QWORD PTR result$[rsp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 280  : 
; 281  : 			pos1 = pos2 + splitter.size();

	mov	rcx, QWORD PTR splitter$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR pos2$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pos1$[rsp], rax

; 282  : 			pos2 = str.find(splitter, pos1);

	mov	r8, QWORD PTR pos1$[rsp]
	mov	rdx, QWORD PTR splitter$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR pos2$[rsp], rax

; 283  : 		}

	jmp	$LN2@SplitStrin
$LN3@SplitStrin:

; 284  : 		if (pos1 != str.length())

	mov	rcx, QWORD PTR str$[rsp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	cmp	QWORD PTR pos1$[rsp], rax
	je	SHORT $LN4@SplitStrin

; 285  : 			result.push_back(str.substr(pos1));

	mov	r9, -1
	mov	r8, QWORD PTR pos1$[rsp]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	QWORD PTR tv153[rsp], rax
	mov	rax, QWORD PTR tv153[rsp]
	mov	QWORD PTR tv145[rsp], rax
	mov	rdx, QWORD PTR tv145[rsp]
	lea	rcx, QWORD PTR result$[rsp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	npad	1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN4@SplitStrin:

; 286  : 
; 287  : 		return result;

	lea	rdx, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR splitter$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 288  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	ret	0
	int	3
?SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z ENDP ; IronMan::Utils::SplitString
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::SplitString'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR splitter$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::SplitString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::SplitString'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::SplitString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::SplitString'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR result$[rbp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::SplitString'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::SplitString'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::SplitString'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::SplitString'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::SplitString'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
pos1$ = 32
$T1 = 40
pos2$ = 48
tv67 = 56
tv143 = 64
tv153 = 72
tv145 = 80
result$ = 88
$T2 = 112
$T3 = 144
__$ArrayPad$ = 176
__$ReturnUdt$ = 208
str$ = 216
splitter$ = 224
?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::SplitString'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@dtor$5
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN12@dtor$5:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??SplitString@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::SplitString'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv74 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
str$ = 120
?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z PROC ; IronMan::Utils::ANSIToUTF8

; 266  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 267  : 		return UnicodeToUTF8(ANSIToUnicode(str));

	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; IronMan::Utils::ANSIToUnicode
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; IronMan::Utils::UnicodeToUTF8
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 268  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	int	3
?ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z ENDP ; IronMan::Utils::ANSIToUTF8
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv79 = 40
tv74 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
str$ = 120
?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA PROC ; `IronMan::Utils::ANSIToUTF8'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA ENDP ; `IronMan::Utils::ANSIToUTF8'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv79 = 40
tv74 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
str$ = 120
?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA PROC ; `IronMan::Utils::ANSIToUTF8'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ANSIToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA ENDP ; `IronMan::Utils::ANSIToUTF8'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv74 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
str$ = 120
?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z PROC ; IronMan::Utils::UTF8ToANSI

; 261  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 262  : 		return  UnicodeToANSI(UTF8ToUnicode(str));

	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; IronMan::Utils::UTF8ToUnicode
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; IronMan::Utils::UnicodeToANSI
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 263  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	int	3
?UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z ENDP ; IronMan::Utils::UTF8ToANSI
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv79 = 40
tv74 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
str$ = 120
?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA PROC ; `IronMan::Utils::UTF8ToANSI'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA ENDP ; `IronMan::Utils::UTF8ToANSI'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv79 = 40
tv74 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
str$ = 120
?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA PROC ; `IronMan::Utils::UTF8ToANSI'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??UTF8ToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z@4HA ENDP ; `IronMan::Utils::UTF8ToANSI'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
num$ = 48
$T1 = 52
wide$ = 56
tv76 = 64
$T2 = 72
$T3 = 80
w_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 144
str$ = 152
?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z PROC ; IronMan::Utils::ANSIToUnicode

; 249  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 250  : 
; 251  : 		int num = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);

	mov	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, -1
	mov	r8, rax
	xor	edx, edx
	mov	ecx, 65001				; 0000fde9H
	call	QWORD PTR __imp_MultiByteToWideChar
	mov	DWORD PTR num$[rsp], eax

; 252  : 		wchar_t* wide = new wchar_t[num];

	movsxd	rax, DWORD PTR num$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	eax, 2
	mov	rcx, QWORD PTR tv76[rsp]
	mul	rcx
	mov	rcx, -1
	cmovb	rax, rcx
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR wide$[rsp], rax

; 253  : 		MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, wide, num);

	mov	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	ecx, DWORD PTR num$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR wide$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, -1
	mov	r8, rax
	xor	edx, edx
	mov	ecx, 65001				; 0000fde9H
	call	QWORD PTR __imp_MultiByteToWideChar

; 254  : 		std::wstring w_str(wide);

	mov	rdx, QWORD PTR wide$[rsp]
	lea	rcx, QWORD PTR w_str$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 255  : 		delete[] wide;

	mov	rax, QWORD PTR wide$[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, QWORD PTR $T3[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1

; 256  : 
; 257  : 		return w_str;

	lea	rdx, QWORD PTR w_str$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR w_str$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 258  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
	int	3
?ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ENDP ; IronMan::Utils::ANSIToUnicode
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
num$ = 48
$T1 = 52
wide$ = 56
tv76 = 64
$T2 = 72
$T3 = 80
w_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 144
str$ = 152
?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA PROC ; `IronMan::Utils::ANSIToUnicode'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR w_str$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA ENDP ; `IronMan::Utils::ANSIToUnicode'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
num$ = 48
$T1 = 52
wide$ = 56
tv76 = 64
$T2 = 72
$T3 = 80
w_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 144
str$ = 152
?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA PROC ; `IronMan::Utils::ANSIToUnicode'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ANSIToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA ENDP ; `IronMan::Utils::ANSIToUnicode'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 64
nLen$ = 68
nResult$ = 72
tv91 = 80
tv89 = 88
str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 160
wstr$ = 168
?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z PROC ; IronMan::Utils::UnicodeToANSI

; 236  : 	{

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 237  : 		std::string str;

	lea	rcx, QWORD PTR str$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 238  : 		int nLen = (int)wstr.length() + 1;

	mov	rcx, QWORD PTR wstr$[rsp]
	call	?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
	inc	eax
	mov	DWORD PTR nLen$[rsp], eax

; 239  : 		str.resize(nLen, ' ');

	movsxd	rax, DWORD PTR nLen$[rsp]
	mov	r8b, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR str$[rsp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 240  : 		int nResult = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)wstr.c_str(), nLen, (LPSTR)str.c_str(), nLen, NULL, NULL);

	lea	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv91[rsp], rax
	mov	rcx, QWORD PTR wstr$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	QWORD PTR tv89[rsp], rax
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], 0
	mov	eax, DWORD PTR nLen$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv91[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR nLen$[rsp]
	mov	r8, QWORD PTR tv89[rsp]
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_WideCharToMultiByte
	mov	DWORD PTR nResult$[rsp], eax

; 241  : 		if (nResult == 0)

	cmp	DWORD PTR nResult$[rsp], 0
	jne	SHORT $LN2@UnicodeToA

; 242  : 		{
; 243  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@UnicodeToA
$LN2@UnicodeToA:

; 244  : 		}
; 245  : 		return str;

	lea	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@UnicodeToA:

; 246  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
	int	3
?UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ENDP ; IronMan::Utils::UnicodeToANSI
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
nLen$ = 68
nResult$ = 72
tv91 = 80
tv89 = 88
str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 160
wstr$ = 168
?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA PROC ; `IronMan::Utils::UnicodeToANSI'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA ENDP ; `IronMan::Utils::UnicodeToANSI'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 64
nLen$ = 68
nResult$ = 72
tv91 = 80
tv89 = 88
str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 160
wstr$ = 168
?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA PROC ; `IronMan::Utils::UnicodeToANSI'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??UnicodeToANSI@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA ENDP ; `IronMan::Utils::UnicodeToANSI'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
unicodeLen$ = 48
$T1 = 52
pUnicode$ = 56
tv77 = 64
$T2 = 72
$T3 = 80
wstrReturn$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 144
str$ = 152
?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z PROC ; IronMan::Utils::UTF8ToUnicode

; 221  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 222  : 
; 223  : 		//int len = str.length();
; 224  : 		int unicodeLen = ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);

	mov	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, -1
	mov	r8, rax
	xor	edx, edx
	mov	ecx, 65001				; 0000fde9H
	call	QWORD PTR __imp_MultiByteToWideChar
	mov	DWORD PTR unicodeLen$[rsp], eax

; 225  : 		wchar_t* pUnicode;
; 226  : 		pUnicode = new wchar_t[unicodeLen + 1];

	mov	eax, DWORD PTR unicodeLen$[rsp]
	inc	eax
	cdqe
	mov	QWORD PTR tv77[rsp], rax
	mov	eax, 2
	mov	rcx, QWORD PTR tv77[rsp]
	mul	rcx
	mov	rcx, -1
	cmovb	rax, rcx
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR pUnicode$[rsp], rax

; 227  : 		memset((void*)pUnicode, 0, (unicodeLen + 1) * sizeof(wchar_t));

	mov	eax, DWORD PTR unicodeLen$[rsp]
	inc	eax
	cdqe
	shl	rax, 1
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR pUnicode$[rsp]
	call	memset

; 228  : 		::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, (LPWSTR)pUnicode, unicodeLen);

	mov	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	ecx, DWORD PTR unicodeLen$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR pUnicode$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, -1
	mov	r8, rax
	xor	edx, edx
	mov	ecx, 65001				; 0000fde9H
	call	QWORD PTR __imp_MultiByteToWideChar

; 229  : 		std::wstring wstrReturn(pUnicode);

	mov	rdx, QWORD PTR pUnicode$[rsp]
	lea	rcx, QWORD PTR wstrReturn$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 230  : 		delete[] pUnicode;

	mov	rax, QWORD PTR pUnicode$[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, QWORD PTR $T3[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1

; 231  : 
; 232  : 		return wstrReturn;

	lea	rdx, QWORD PTR wstrReturn$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR wstrReturn$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 233  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
	int	3
?UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ENDP ; IronMan::Utils::UTF8ToUnicode
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
unicodeLen$ = 48
$T1 = 52
pUnicode$ = 56
tv77 = 64
$T2 = 72
$T3 = 80
wstrReturn$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 144
str$ = 152
?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA PROC ; `IronMan::Utils::UTF8ToUnicode'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR wstrReturn$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA ENDP ; `IronMan::Utils::UTF8ToUnicode'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
unicodeLen$ = 48
$T1 = 52
pUnicode$ = 56
tv77 = 64
$T2 = 72
$T3 = 80
wstrReturn$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 144
str$ = 152
?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA PROC ; `IronMan::Utils::UTF8ToUnicode'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??UTF8ToUnicode@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z@4HA ENDP ; `IronMan::Utils::UTF8ToUnicode'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
iTextLen$ = 64
$T1 = 68
pElementText$ = 72
$T2 = 80
$T3 = 88
strReturn$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 160
wstr$ = 168
?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z PROC ; IronMan::Utils::UnicodeToUTF8

; 207  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 208  : 
; 209  : 		char* pElementText;
; 210  : 		int iTextLen = ::WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)wstr.c_str(), -1, NULL, 0, NULL, NULL);

	mov	rcx, QWORD PTR wstr$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, -1
	mov	r8, rax
	xor	edx, edx
	mov	ecx, 65001				; 0000fde9H
	call	QWORD PTR __imp_WideCharToMultiByte
	mov	DWORD PTR iTextLen$[rsp], eax

; 211  : 		pElementText = new char[iTextLen + 1];

	mov	eax, DWORD PTR iTextLen$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR pElementText$[rsp], rax

; 212  : 		memset((void*)pElementText, 0, (iTextLen + 1) * sizeof(char));

	mov	eax, DWORD PTR iTextLen$[rsp]
	inc	eax
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR pElementText$[rsp]
	call	memset

; 213  : 		::WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)wstr.c_str(), -1, pElementText, iTextLen, NULL, NULL);

	mov	rcx, QWORD PTR wstr$[rsp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], 0
	mov	ecx, DWORD PTR iTextLen$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR pElementText$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, -1
	mov	r8, rax
	xor	edx, edx
	mov	ecx, 65001				; 0000fde9H
	call	QWORD PTR __imp_WideCharToMultiByte

; 214  : 		std::string strReturn(pElementText);

	mov	rdx, QWORD PTR pElementText$[rsp]
	lea	rcx, QWORD PTR strReturn$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 215  : 		delete[] pElementText;

	mov	rax, QWORD PTR pElementText$[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, QWORD PTR $T3[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1

; 216  : 
; 217  : 		return strReturn;

	lea	rdx, QWORD PTR strReturn$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR strReturn$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 218  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
	int	3
?UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ENDP ; IronMan::Utils::UnicodeToUTF8
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
iTextLen$ = 64
$T1 = 68
pElementText$ = 72
$T2 = 80
$T3 = 88
strReturn$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 160
wstr$ = 168
?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA PROC ; `IronMan::Utils::UnicodeToUTF8'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR strReturn$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA ENDP ; `IronMan::Utils::UnicodeToUTF8'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
iTextLen$ = 64
$T1 = 68
pElementText$ = 72
$T2 = 80
$T3 = 88
strReturn$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 160
wstr$ = 168
?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA PROC ; `IronMan::Utils::UnicodeToUTF8'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??UnicodeToUTF8@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z@4HA ENDP ; `IronMan::Utils::UnicodeToUTF8'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
vl$ = 40
buf$ = 48
__$ArrayPad$ = 4144
__$ReturnUdt$ = 4176
fmt$ = 4184
?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ PROC ; IronMan::Utils::FormatString

; 194  : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	mov	eax, 4160				; 00001040H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 195  : 
; 196  : 		char buf[4096] = { 0 };

	lea	rax, QWORD PTR buf$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 4096				; 00001000H
	rep stosb

; 197  : 
; 198  : 		va_list vl;
; 199  : 		va_start(vl, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR vl$[rsp], rax

; 200  : 		_vsnprintf_s(buf, 4096, fmt, vl);

	mov	r9, QWORD PTR vl$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 4096				; 00001000H
	lea	rcx, QWORD PTR buf$[rsp]
	call	??$_vsnprintf_s@$0BAAA@@@YAHAEAY0BAAA@D_KPEBDPEAD@Z ; _vsnprintf_s<4096>

; 201  : 		va_end(vl);

	mov	QWORD PTR vl$[rsp], 0

; 202  : 
; 203  : 		return buf;

	lea	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 204  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4160				; 00001040H
	pop	rdi
	ret	0
	int	3
?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ENDP ; IronMan::Utils::FormatString
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
vl$ = 40
buf$ = 48
__$ArrayPad$ = 4144
__$ReturnUdt$ = 4176
fmt$ = 4184
?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA PROC ; `IronMan::Utils::FormatString'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ@4HA ENDP ; `IronMan::Utils::FormatString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
vl$ = 40
buf$ = 48
__$ArrayPad$ = 8240
__$ReturnUdt$ = 8272
fmt$ = 8280
?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ PROC ; IronMan::Utils::FormatString

; 175  : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	mov	eax, 8256				; 00002040H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 176  : 
; 177  : 		wchar_t buf[4096] = { 0 };

	lea	rax, QWORD PTR buf$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8192				; 00002000H
	rep stosb

; 178  : 
; 179  : 		va_list vl;
; 180  : 		va_start(vl, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR vl$[rsp], rax

; 181  : 		vswprintf_s(buf, fmt, vl);

	mov	r8, QWORD PTR vl$[rsp]
	mov	rdx, QWORD PTR fmt$[rsp]
	lea	rcx, QWORD PTR buf$[rsp]
	call	??$vswprintf_s@$0BAAA@@@YAHAEAY0BAAA@_WPEB_WPEAD@Z ; vswprintf_s<4096>

; 182  : 		va_end(vl);

	mov	QWORD PTR vl$[rsp], 0

; 183  : 
; 184  : 		return buf;

	lea	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 185  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 8256				; 00002040H
	pop	rdi
	ret	0
	int	3
?FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ ENDP ; IronMan::Utils::FormatString
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
vl$ = 40
buf$ = 48
__$ArrayPad$ = 8240
__$ReturnUdt$ = 8272
fmt$ = 8280
?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA PROC ; `IronMan::Utils::FormatString'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??FormatString@Utils@IronMan@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEB_WZZ@4HA ENDP ; `IronMan::Utils::FormatString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
index$2 = 40
tv94 = 48
bufStr$ = 56
subStr$3 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
str$ = 152
pat$ = 160
?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z PROC ; IronMan::Utils::split

; 331  : 	{

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 332  : 		std::vector<std::string> bufStr;

	lea	rcx, QWORD PTR bufStr$[rsp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN2@split:

; 333  : 
; 334  : 		while (true)

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@split

; 335  : 		{
; 336  : 			size_t index = str.find(pat);

	xor	r8d, r8d
	mov	rdx, QWORD PTR pat$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR index$2[rsp], rax

; 337  : 
; 338  : 			std::string subStr = str.substr(0, index);

	mov	r9, QWORD PTR index$2[rsp]
	xor	r8d, r8d
	lea	rdx, QWORD PTR subStr$3[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	npad	1

; 339  : 			if (!subStr.empty())

	lea	rcx, QWORD PTR subStr$3[rsp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@split

; 340  : 				bufStr.push_back(subStr);

	lea	rdx, QWORD PTR subStr$3[rsp]
	lea	rcx, QWORD PTR bufStr$[rsp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	npad	1
$LN4@split:

; 341  : 
; 342  : 			str.erase(0, index + pat.size());

	mov	rcx, QWORD PTR pat$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR index$2[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv94[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR str$[rsp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	npad	1

; 343  : 
; 344  : 			if (index == -1)

	cmp	QWORD PTR index$2[rsp], -1
	jne	SHORT $LN5@split

; 345  : 				break;

	lea	rcx, QWORD PTR subStr$3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN3@split
$LN5@split:

; 346  : 		}

	lea	rcx, QWORD PTR subStr$3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	$LN2@split
$LN3@split:

; 347  : 		return bufStr;

	lea	rdx, QWORD PTR bufStr$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR bufStr$[rsp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
	mov	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR pat$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 348  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
	int	3
?split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z ENDP ; IronMan::Utils::split
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
index$2 = 40
tv94 = 48
bufStr$ = 56
subStr$3 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
str$ = 152
pat$ = 160
?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::split'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR pat$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::split'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
index$2 = 40
tv94 = 48
bufStr$ = 56
subStr$3 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
str$ = 152
pat$ = 160
?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::split'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::split'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
index$2 = 40
tv94 = 48
bufStr$ = 56
subStr$3 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
str$ = 152
pat$ = 160
?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::split'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR bufStr$[rbp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::split'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
index$2 = 40
tv94 = 48
bufStr$ = 56
subStr$3 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
str$ = 152
pat$ = 160
?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::split'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR subStr$3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::split'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
index$2 = 40
tv94 = 48
bufStr$ = 56
subStr$3 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
str$ = 152
pat$ = 160
?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA PROC ; `IronMan::Utils::split'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@dtor$4
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN12@dtor$4:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??split@Utils@IronMan@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@0@Z@4HA ENDP ; `IronMan::Utils::split'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 32
FindStr$ = 40
res$ = 48
tv92 = 56
tv156 = 64
NewStr$ = 72
$T2 = 104
__$ArrayPad$ = 136
__$ReturnUdt$ = 160
Str$ = 168
Begin$ = 176
End$ = 184
outPos$ = 192
inPos$ = 200
?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z PROC ; IronMan::Utils::GetTextBetween

; 311  : 	{

$LN12:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 312  : 		if (outPos)

	cmp	QWORD PTR outPos$[rsp], 0
	je	SHORT $LN2@GetTextBet

; 313  : 			*outPos = 0;

	mov	rax, QWORD PTR outPos$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@GetTextBet:

; 314  : 		auto FindStr = Str.find(Begin, inPos);

	mov	r8, QWORD PTR inPos$[rsp]
	mov	rdx, QWORD PTR Begin$[rsp]
	mov	rcx, QWORD PTR Str$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR FindStr$[rsp], rax

; 315  : 		if (FindStr == std::string::npos)

	cmp	QWORD PTR FindStr$[rsp], -1
	jne	SHORT $LN3@GetTextBet

; 316  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetTextBet
$LN3@GetTextBet:

; 317  : 		FindStr += strlen(Begin);

	mov	rcx, QWORD PTR Begin$[rsp]
	call	strlen
	mov	rcx, QWORD PTR FindStr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR FindStr$[rsp], rax

; 318  : 		std::string NewStr = Str.substr(FindStr, Str.size() - FindStr);

	mov	rcx, QWORD PTR Str$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	rax, QWORD PTR FindStr$[rsp]
	mov	r9, rax
	mov	r8, QWORD PTR FindStr$[rsp]
	lea	rdx, QWORD PTR NewStr$[rsp]
	mov	rcx, QWORD PTR Str$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	npad	1

; 319  : 		auto res = NewStr.find(End);

	xor	r8d, r8d
	mov	rdx, QWORD PTR End$[rsp]
	lea	rcx, QWORD PTR NewStr$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR res$[rsp], rax

; 320  : 		if (res == std::string::npos)

	cmp	QWORD PTR res$[rsp], -1
	jne	SHORT $LN4@GetTextBet

; 321  : 			return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR NewStr$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetTextBet
$LN4@GetTextBet:

; 322  : 		if (outPos)

	cmp	QWORD PTR outPos$[rsp], 0
	je	SHORT $LN5@GetTextBet

; 323  : 			*outPos = FindStr;

	mov	rax, QWORD PTR outPos$[rsp]
	mov	rcx, QWORD PTR FindStr$[rsp]
	mov	QWORD PTR [rax], rcx
$LN5@GetTextBet:

; 324  : 		NewStr = NewStr.substr(0, res);

	mov	r9, QWORD PTR res$[rsp]
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR NewStr$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	QWORD PTR tv92[rsp], rax
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR tv156[rsp], rax
	mov	rdx, QWORD PTR tv156[rsp]
	lea	rcx, QWORD PTR NewStr$[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 325  : 		if (NewStr.size() > 0)

	lea	rcx, QWORD PTR NewStr$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	test	rax, rax
	jbe	SHORT $LN6@GetTextBet

; 326  : 			return NewStr;

	lea	rdx, QWORD PTR NewStr$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR NewStr$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetTextBet
$LN6@GetTextBet:

; 327  : 		return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR NewStr$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetTextBet:

; 328  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
	int	3
?GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z ENDP ; IronMan::Utils::GetTextBetween
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
FindStr$ = 40
res$ = 48
tv92 = 56
tv156 = 64
NewStr$ = 72
$T2 = 104
__$ArrayPad$ = 136
__$ReturnUdt$ = 160
Str$ = 168
Begin$ = 176
End$ = 184
outPos$ = 192
inPos$ = 200
?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA PROC ; `IronMan::Utils::GetTextBetween'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA ENDP ; `IronMan::Utils::GetTextBetween'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
FindStr$ = 40
res$ = 48
tv92 = 56
tv156 = 64
NewStr$ = 72
$T2 = 104
__$ArrayPad$ = 136
__$ReturnUdt$ = 160
Str$ = 168
Begin$ = 176
End$ = 184
outPos$ = 192
inPos$ = 200
?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA PROC ; `IronMan::Utils::GetTextBetween'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR NewStr$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA ENDP ; `IronMan::Utils::GetTextBetween'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
FindStr$ = 40
res$ = 48
tv92 = 56
tv156 = 64
NewStr$ = 72
$T2 = 104
__$ArrayPad$ = 136
__$ReturnUdt$ = 160
Str$ = 168
Begin$ = 176
End$ = 184
outPos$ = 192
inPos$ = 200
?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA PROC ; `IronMan::Utils::GetTextBetween'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GetTextBetween@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@PEBD1PEA_K_K@Z@4HA ENDP ; `IronMan::Utils::GetTextBetween'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
tv77 = 64
$T3 = 72
__$ArrayPad$ = 104
lpAddress$ = 128
lpBuffer$ = 136
?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z PROC ; IronMan::Utils::QueryMemory

; 163  : 	{

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 164  : 		SetLastNtStatus(STATUS_SUCCESS);

	xor	ecx, ecx
	call	?SetLastNtStatus@@YAJJ@Z		; SetLastNtStatus
	npad	1

; 165  : 		SAFE_CALL(VirtualQuery, reinterpret_cast<LPCVOID>(lpAddress), lpBuffer, sizeof(MEMORY_BASIC_INFORMATION));

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv77[rsp], rax
	mov	QWORD PTR $T1[rsp], 48			; 00000030H
	mov	rax, QWORD PTR lpAddress$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_0N@MAAAEOL@VirtualQuery@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR lpBuffer$[rsp]
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$safeCall@P6A_KPEBXPEAU_MEMORY_BASIC_INFORMATION@@_K@ZPEBXAEAPEAU1@_K@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEBXAEAPEAU_MEMORY_BASIC_INFORMATION@@$$QEA_K@Z ; IronMan::DynImport::safeCall<unsigned __int64 (__cdecl*)(void const *,_MEMORY_BASIC_INFORMATION *,unsigned __int64),void const *,_MEMORY_BASIC_INFORMATION * &,unsigned __int64>
	npad	1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 166  : 		return LastNtStatus();

	call	?LastNtStatus@@YAJXZ			; LastNtStatus

; 167  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z ENDP ; IronMan::Utils::QueryMemory
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
$T2 = 56
tv77 = 64
$T3 = 72
__$ArrayPad$ = 104
lpAddress$ = 128
lpBuffer$ = 136
?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA PROC ; `IronMan::Utils::QueryMemory'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??QueryMemory@Utils@IronMan@@YAJ_KPEAU_MEMORY_BASIC_INFORMATION@@@Z@4HA ENDP ; `IronMan::Utils::QueryMemory'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
s$ = 64
?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; hash_, COMDAT

; 216  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 217  : 	return hash_(s.c_str());

	mov	rcx, QWORD PTR s$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR s$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR $T1[rsp]

; 218  : }

	add	rsp, 56					; 00000038H
	ret	0
?hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; hash_
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
s$ = 64
?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `hash_'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR s$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??hash_@@YA?B_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `hash_'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?hash_@@YA?B_KPEBD@Z
_TEXT	SEGMENT
ret$ = 0
str$ = 32
?hash_@@YA?B_KPEBD@Z PROC				; hash_, COMDAT

; 203  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 204  : 	hash_t ret{ basis };

	mov	rax, -3750763034361777355		; cbf29ce484333335H
	mov	QWORD PTR ret$[rsp], rax
$LN2@hash_:

; 205  : 
; 206  : 	while (*str) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@hash_

; 207  : 		ret ^= *str;

	mov	rax, QWORD PTR str$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR ret$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 208  : 		ret *= prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR ret$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 209  : 		str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 210  : 	}

	jmp	SHORT $LN2@hash_
$LN3@hash_:

; 211  : 
; 212  : 	return ret;

	mov	rax, QWORD PTR ret$[rsp]

; 213  : }

	add	rsp, 24
	ret	0
?hash_@@YA?B_KPEBD@Z ENDP				; hash_
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?SetLastNtStatus@@YAJJ@Z
_TEXT	SEGMENT
status$ = 48
?SetLastNtStatus@@YAJJ@Z PROC				; SetLastNtStatus, COMDAT

; 171  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 172  : 	return *(NTSTATUS*)((unsigned char*)NtCurrentTeb() + LAST_STATUS_OFS) = status;

	call	NtCurrentTeb
	mov	ecx, DWORD PTR status$[rsp]
	mov	DWORD PTR [rax+4688], ecx
	mov	eax, DWORD PTR status$[rsp]

; 173  : }

	add	rsp, 40					; 00000028H
	ret	0
?SetLastNtStatus@@YAJJ@Z ENDP				; SetLastNtStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?LastNtStatus@@YAJXZ
_TEXT	SEGMENT
?LastNtStatus@@YAJXZ PROC				; LastNtStatus, COMDAT

; 160  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 161  : 	return *(NTSTATUS*)((unsigned char*)NtCurrentTeb() + LAST_STATUS_OFS);

	call	NtCurrentTeb
	mov	eax, DWORD PTR [rax+4688]

; 162  : }

	add	rsp, 40					; 00000028H
	ret	0
?LastNtStatus@@YAJXZ ENDP				; LastNtStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winnt.h
;	COMDAT NtCurrentTeb
_TEXT	SEGMENT
NtCurrentTeb PROC					; COMDAT

; 25650:     return (struct _TEB *)__readgsqword(FIELD_OFFSET(NT_TIB, Self));

	mov	rax, QWORD PTR gs:48

; 25651: }

	ret	0
NtCurrentTeb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\string
;	COMDAT ??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
_Buff_end$ = 40
_RNext$ = 48
_Buff$ = 56
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
_Val$ = 120
??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z PROC ; std::_UIntegral_to_string<char,unsigned long>, COMDAT

; 461  : _NODISCARD basic_string<_Elem> _UIntegral_to_string(const _Ty _Val) {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 462  :     // convert _Val to string
; 463  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 464  :     static_assert(is_unsigned_v<_Ty>, "_Ty must be unsigned");
; 465  :     _Elem _Buff[21]; // can hold 2^64 - 1, plus NUL
; 466  :     _Elem* const _Buff_end = _STD end(_Buff);

	lea	rcx, QWORD PTR _Buff$[rsp]
	call	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z	; std::end<char,21>
	mov	QWORD PTR _Buff_end$[rsp], rax

; 467  :     _Elem* const _RNext    = _UIntegral_to_buff(_Buff_end, _Val);

	mov	edx, DWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _Buff_end$[rsp]
	call	??$_UIntegral_to_buff@DK@std@@YAPEADPEADK@Z ; std::_UIntegral_to_buff<char,unsigned long>
	mov	QWORD PTR _RNext$[rsp], rax

; 468  :     return basic_string<_Elem>(_RNext, _Buff_end);

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	r9, rax
	mov	r8, QWORD PTR _Buff_end$[rsp]
	mov	rdx, QWORD PTR _RNext$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 469  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	int	3
??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z ENDP ; std::_UIntegral_to_string<char,unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
_Buff_end$ = 40
_RNext$ = 48
_Buff$ = 56
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
_Val$ = 120
?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA PROC ; `std::_UIntegral_to_string<char,unsigned long>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z@4HA ENDP ; `std::_UIntegral_to_string<char,unsigned long>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Val$ = 72
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z PROC ; std::to_string, COMDAT

; 483  : _EXPORT_STD _NODISCARD inline string to_string(unsigned long _Val) {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 484  :     return _UIntegral_to_string<char>(_Val);

	mov	edx, DWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$_UIntegral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z ; std::_UIntegral_to_string<char,unsigned long>
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 485  : }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Val$ = 72
?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA PROC ; `std::to_string'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z@4HA ENDP ; `std::to_string'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
_RNext$ = 32
$T1 = 40
_UVal$ = 44
$T2 = 48
_Buff_end$ = 56
_Buff$ = 64
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Val$ = 120
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 441  : _NODISCARD basic_string<_Elem> _Integral_to_string(const _Ty _Val) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 442  :     // convert _Val to string
; 443  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 444  :     using _UTy = make_unsigned_t<_Ty>;
; 445  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 446  :     _Elem* const _Buff_end = _STD end(_Buff);

	lea	rcx, QWORD PTR _Buff$[rsp]
	call	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z	; std::end<char,21>
	mov	QWORD PTR _Buff_end$[rsp], rax

; 447  :     _Elem* _RNext          = _Buff_end;

	mov	rax, QWORD PTR _Buff_end$[rsp]
	mov	QWORD PTR _RNext$[rsp], rax

; 448  :     const auto _UVal       = static_cast<_UTy>(_Val);

	mov	eax, DWORD PTR _Val$[rsp]
	mov	DWORD PTR _UVal$[rsp], eax

; 449  :     if (_Val < 0) {

	cmp	DWORD PTR _Val$[rsp], 0
	jge	SHORT $LN2@Integral_t

; 450  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

	xor	eax, eax
	sub	eax, DWORD PTR _UVal$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _RNext$[rsp]
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
	mov	QWORD PTR _RNext$[rsp], rax

; 451  :         *--_RNext = '-';

	mov	rax, QWORD PTR _RNext$[rsp]
	dec	rax
	mov	QWORD PTR _RNext$[rsp], rax
	mov	rax, QWORD PTR _RNext$[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 452  :     } else {

	jmp	SHORT $LN3@Integral_t
$LN2@Integral_t:

; 453  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

	mov	edx, DWORD PTR _UVal$[rsp]
	mov	rcx, QWORD PTR _RNext$[rsp]
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
	mov	QWORD PTR _RNext$[rsp], rax
$LN3@Integral_t:

; 454  :     }
; 455  : 
; 456  :     return basic_string<_Elem>(_RNext, _Buff_end);

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	r9, rax
	mov	r8, QWORD PTR _Buff_end$[rsp]
	mov	rdx, QWORD PTR _RNext$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 457  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	int	3
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_RNext$ = 32
$T1 = 40
_UVal$ = 44
$T2 = 48
_Buff_end$ = 56
_Buff$ = 64
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Val$ = 120
?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA PROC ; `std::_Integral_to_string<char,int>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z@4HA ENDP ; `std::_Integral_to_string<char,int>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Val$ = 72
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 471  : _EXPORT_STD _NODISCARD inline string to_string(int _Val) {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 472  :     return _Integral_to_string<char>(_Val);

	mov	edx, DWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 473  : }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Val$ = 72
?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::to_string'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::to_string'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators, COMDAT

; 3066 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3067 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 3068 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 2954 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2955 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth

; 2956 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 7
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr, COMDAT

; 2798 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T2[rsp], 0

; 2799 :         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
; 2800 :         return basic_string{*this, _Off, _Count};

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Count$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2801 :     }

	add	rsp, 72					; 00000048H
	ret	0
	int	3
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z
_TEXT	SEGMENT
tv79 = 32
tv77 = 40
this$ = 64
_Ch$ = 72
_Off$ = 80
?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::rfind, COMDAT

; 2626 :     _NODISCARD _CONSTEXPR20 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2627 :         // look for _Ch before _Off
; 2628 :         return static_cast<size_type>(

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	QWORD PTR tv77[rsp], rax
	movzx	r9d, WORD PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$_Traits_rfind_ch@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K1_W@Z ; std::_Traits_rfind_ch<std::char_traits<wchar_t> >

; 2629 :             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
; 2630 :     }

	add	rsp, 56					; 00000038H
	ret	0
?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::rfind
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty, COMDAT

; 2457 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2458 :         return _Mypair._Myval2._Mysize == 0;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv68[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv68[rsp]

; 2459 :     }

	add	rsp, 24
	ret	0
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_NXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 8
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length, COMDAT

; 2341 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2342 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 2343 :     }

	ret	0
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end, COMDAT

; 2145 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2146 :         return iterator(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	rcx, rax
	call	??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ; std::_Refancy<wchar_t *,0>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2147 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 2148 :             _STD addressof(_Mypair._Myval2));
; 2149 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv85 = 32
tv83 = 40
this$ = 64
__$ReturnUdt$ = 72
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin, COMDAT

; 2137 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2138 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	rcx, rax
	call	??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ; std::_Refancy<wchar_t *,0>
	mov	QWORD PTR tv83[rsp], rax
	mov	r8, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2139 :     }

	add	rsp, 56					; 00000038H
	ret	0
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 34
_Right_data$ = 40
_My_data$ = 48
_Right_data_mem$3 = 56
_My_data_mem$4 = 64
tv148 = 72
this$ = 96
_Right$ = 104
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT

; 1234 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1235 :         // assign by stealing _Right's buffer
; 1236 :         // pre: this != &_Right
; 1237 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1238 :         // pre: *this owns no memory, iterators orphaned
; 1239 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1240 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1241 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1242 : 
; 1243 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1244 :         if constexpr (_Can_memcpy_val) {
; 1245 : #if _HAS_CXX20
; 1246 :             if (!_STD is_constant_evaluated())
; 1247 : #endif // _HAS_CXX20
; 1248 :             {
; 1249 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1250 :                 if (_Right_data._Large_mode_engaged()) {
; 1251 :                     // take ownership of _Right's iterators along with its buffer
; 1252 :                     _Swap_proxy_and_iterators(_Right);
; 1253 :                 } else {
; 1254 :                     _Right_data._Orphan_all();
; 1255 :                 }
; 1256 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1257 : 
; 1258 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
	mov	QWORD PTR _My_data_mem$4[rsp], rax

; 1259 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1260 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
	mov	QWORD PTR _Right_data_mem$3[rsp], rax

; 1261 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$3[rsp]
	mov	rcx, QWORD PTR _My_data_mem$4[rsp]
	call	memcpy

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 1266 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
	npad	1

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1

; 1268 :                 return;

	jmp	$LN1@Take_conte

; 1269 :             }
; 1270 :         }
; 1271 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1272 : 
; 1273 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 1274 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators

; 1275 : 
; 1276 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>

; 1277 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
	npad	1

; 1278 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1279 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1280 : 
; 1281 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer

; 1282 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv148[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv148[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
	npad	1
$LN3@Take_conte:

; 1283 :         }
; 1284 : 
; 1285 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1286 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1287 : 
; 1288 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1289 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 1290 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	WORD PTR $T2[rsp], ax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1
$LN1@Take_conte:

; 1291 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1004 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
	mov	QWORD PTR tv75[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv75[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
	npad	1

; 1005 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv89[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1006 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
	npad	1

; 1007 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty, COMDAT

; 831  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 833  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 834  : 
; 835  :         // initialize basic_string data members
; 836  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 838  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
	npad	1

; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1

; 842  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z ; std::_WChar_traits<wchar_t>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 731  :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
	npad	1

; 732  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
	npad	1

; 733  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W_K@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv131 = 64
tv129 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 711  :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
	npad	1

; 712  :         _Right._Mypair._Myval2._Check_offset(_Roff);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Clamp_suffix_size
	mov	QWORD PTR tv131[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	rcx, QWORD PTR _Roff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR tv129[rsp], rax
	mov	r8, QWORD PTR tv131[rsp]
	mov	rdx, QWORD PTR tv129[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
	npad	1

; 714  :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 715  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv131 = 64
tv129 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 693  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
	mov	QWORD PTR tv76[rsp], rax
	movzx	eax, BYTE PTR $T3[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv76[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
	npad	1

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	mov	rdx, QWORD PTR tv92[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
	npad	1

; 695  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ; std::_Destroy_in_place<wchar_t *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Off$ = 72
_Size$ = 80
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Clamp_suffix_size, COMDAT

; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Size$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 469  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

$LN3:
	sub	rsp, 40					; 00000028H

; 463  :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	npad	1
$LN2@Xran:

; 464  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset, COMDAT

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN2@Check_offs

; 451  :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	npad	1
$LN2@Check_offs:
$LN3@Check_offs:

; 452  :         }
; 453  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 7
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 750  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$01@std@@YA_K_K@Z	; std::_Get_size_of_n<2>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3066 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3067 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 3068 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_size$ = 72
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 3038 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3039 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3040 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3041 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _New_size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3042 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2954 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2955 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2956 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 2798 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T2[rsp], 0

; 2799 :         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
; 2800 :         return basic_string{*this, _Off, _Count};

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Count$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2801 :     }

	add	rsp, 72					; 00000048H
	ret	0
	int	3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z
_TEXT	SEGMENT
tv79 = 32
tv77 = 40
this$ = 64
_Ch$ = 72
_Off$ = 80
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT

; 2626 :     _NODISCARD _CONSTEXPR20 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2627 :         // look for _Ch before _Off
; 2628 :         return static_cast<size_type>(

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv77[rsp], rax
	movzx	r9d, BYTE PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ; std::_Traits_rfind_ch<std::char_traits<char> >

; 2629 :             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
; 2630 :     }

	add	rsp, 56					; 00000038H
	ret	0
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
_TEXT	SEGMENT
tv84 = 48
tv82 = 56
tv80 = 64
this$ = 96
_Ptr$ = 104
_Off$ = 112
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 2583 :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2584 :         // look for [_Ptr, <null>) beginning at or after _Off
; 2585 :         return static_cast<size_type>(_Traits_find<_Traits>(

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR tv84[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 2586 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 2587 :     }

	add	rsp, 88					; 00000058H
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
tv91 = 48
tv89 = 56
tv87 = 64
tv85 = 72
this$ = 96
_Right$ = 104
_Off$ = 112
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 2569 :     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2570 :         // look for _Right beginning at or after _Off
; 2571 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv91[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv89[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv87[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR tv91[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv89[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv87[rsp]
	mov	rcx, QWORD PTR tv85[rsp]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 2572 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 2573 :     }

	add	rsp, 88					; 00000058H
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 2457 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2458 :         return _Mypair._Myval2._Mysize == 0;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv68[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv68[rsp]

; 2459 :     }

	add	rsp, 24
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
_TEXT	SEGMENT
_Old_size$ = 32
this$ = 64
_New_size$ = 72
_Ch$ = 80
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 2358 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2359 :         // determine new length, padding with _Ch elements as needed
; 2360 :         const size_type _Old_size = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR _Old_size$[rsp], rax

; 2361 :         if (_New_size <= _Old_size) {

	mov	rax, QWORD PTR _Old_size$[rsp]
	cmp	QWORD PTR _New_size$[rsp], rax
	ja	SHORT $LN2@resize

; 2362 :             _Eos(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	npad	1

; 2363 :         } else {

	jmp	SHORT $LN3@resize
$LN2@resize:

; 2364 :             append(_New_size - _Old_size, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN3@resize:

; 2365 :         }
; 2366 :     }

	add	rsp, 56					; 00000038H
	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 2345 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2346 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 2347 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT

; 2341 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2342 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 2343 :     }

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 2336 :     _NODISCARD _CONSTEXPR20 _Ret_z_ _Elem* data() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2337 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2338 :     }

	add	rsp, 40					; 00000028H
	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 2169 :     _NODISCARD _CONSTEXPR20 const _Elem* _Unchecked_end() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2170 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+16]

; 2171 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 2161 :     _NODISCARD _CONSTEXPR20 const _Elem* _Unchecked_begin() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2162 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2163 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv89 = 32
tv87 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT

; 2151 :     _NODISCARD _CONSTEXPR20 const_iterator end() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2152 :         return const_iterator(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
	mov	QWORD PTR tv89[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, rax
	call	??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z	; std::_Refancy<char const *,0>
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR tv87[rsp], rax
	mov	r8, QWORD PTR tv89[rsp]
	mov	rdx, QWORD PTR tv87[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2153 :             _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 2154 :             _STD addressof(_Mypair._Myval2));
; 2155 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv89 = 32
tv87 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT

; 2145 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2146 :         return iterator(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR tv89[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, rax
	call	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z	; std::_Refancy<char *,0>
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR tv87[rsp], rax
	mov	r8, QWORD PTR tv89[rsp]
	mov	rdx, QWORD PTR tv87[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2147 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 2148 :             _STD addressof(_Mypair._Myval2));
; 2149 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv85 = 32
tv83 = 40
this$ = 64
__$ReturnUdt$ = 72
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 2141 :     _NODISCARD _CONSTEXPR20 const_iterator begin() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2142 :         return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, rax
	call	??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z	; std::_Refancy<char const *,0>
	mov	QWORD PTR tv83[rsp], rax
	mov	r8, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2143 :     }

	add	rsp, 56					; 00000038H
	ret	0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv85 = 32
tv83 = 40
this$ = 64
__$ReturnUdt$ = 72
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 2137 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2138 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, rax
	call	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z	; std::_Refancy<char *,0>
	mov	QWORD PTR tv83[rsp], rax
	mov	r8, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2139 :     }

	add	rsp, 56					; 00000038H
	ret	0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Off$ = 72
_Count$ = 80
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1865 :     _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1866 :         // erase elements [_Off, _Off + _Count)
; 1867 :         _Mypair._Myval2._Check_offset(_Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 1868 :         return _Erase_noexcept(_Off, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept

; 1869 :     }

	add	rsp, 56					; 00000038H
	ret	0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
_Erase_at$ = 32
_New_size$ = 40
tv71 = 48
_My_ptr$ = 56
_Old_size$ = 64
this$ = 96
_Off$ = 104
_Count$ = 112
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept, COMDAT

; 1852 :     _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1853 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
	mov	QWORD PTR _Count$[rsp], rax

; 1854 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1855 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _My_ptr$[rsp], rax

; 1856 :         _Elem* const _Erase_at    = _My_ptr + _Off;

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _My_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Erase_at$[rsp], rax

; 1857 :         const size_type _New_size = _Old_size - _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 1858 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Erase_at$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR _Erase_at$[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1859 :         _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
; 1860 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1861 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1862 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Count$ = 104
_Ch$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1513 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 1514 :         // append _Count * _Ch
; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1516 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 1517 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1519 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1520 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1521 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1522 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1523 :         }
; 1524 : 
; 1525 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Count$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN1@append:

; 1526 :             _Count,
; 1527 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 1528 :                 const _Elem _Ch) _STATIC_CALL_OPERATOR {
; 1529 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1530 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 1531 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1532 :             },
; 1533 :             _Count, _Ch);
; 1534 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1509 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1510 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1511 :     }

	add	rsp, 40					; 00000028H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1486 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 1487 :         // append [_Ptr, _Ptr + _Count)
; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1492 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1493 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1495 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1496 :         }
; 1497 : 
; 1498 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN1@append:

; 1499 :             _Count,
; 1500 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1501 :                 const size_type _Count) _STATIC_CALL_OPERATOR {
; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1505 :             },
; 1506 :             _Ptr, _Count);
; 1507 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1449 :     _CONSTEXPR20 basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1450 :         return append(_Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1451 :     }

	add	rsp, 40					; 00000028H
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Right_data$ = 40
_My_data$ = 48
_Right_data_mem$3 = 56
_My_data_mem$4 = 64
tv148 = 72
this$ = 96
_Right$ = 104
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1234 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1235 :         // assign by stealing _Right's buffer
; 1236 :         // pre: this != &_Right
; 1237 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1238 :         // pre: *this owns no memory, iterators orphaned
; 1239 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1240 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1241 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1242 : 
; 1243 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1244 :         if constexpr (_Can_memcpy_val) {
; 1245 : #if _HAS_CXX20
; 1246 :             if (!_STD is_constant_evaluated())
; 1247 : #endif // _HAS_CXX20
; 1248 :             {
; 1249 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1250 :                 if (_Right_data._Large_mode_engaged()) {
; 1251 :                     // take ownership of _Right's iterators along with its buffer
; 1252 :                     _Swap_proxy_and_iterators(_Right);
; 1253 :                 } else {
; 1254 :                     _Right_data._Orphan_all();
; 1255 :                 }
; 1256 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1257 : 
; 1258 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _My_data_mem$4[rsp], rax

; 1259 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1260 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _Right_data_mem$3[rsp], rax

; 1261 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$3[rsp]
	mov	rcx, QWORD PTR _My_data_mem$4[rsp]
	call	memcpy

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1266 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1268 :                 return;

	jmp	$LN1@Take_conte

; 1269 :             }
; 1270 :         }
; 1271 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1272 : 
; 1273 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 1274 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1275 : 
; 1276 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 1277 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1278 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1279 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1280 : 
; 1281 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1282 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv148[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv148[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
$LN3@Take_conte:

; 1283 :         }
; 1284 : 
; 1285 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1286 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1287 : 
; 1288 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1289 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1290 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1
$LN1@Take_conte:

; 1291 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
_Pocma_val$ = 32
_Right_al$ = 40
_Al$ = 48
this$ = 80
_Right$ = 88
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 1201 :         noexcept(_Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1202 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 1203 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1204 :         }
; 1205 : 
; 1206 :         auto& _Al                 = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1207 :         auto& _Right_al           = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 1208 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

	mov	DWORD PTR _Pocma_val$[rsp], 0

; 1209 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1210 :             if (_Al != _Right_al) {
; 1211 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1212 :                 _Mypair._Myval2._Orphan_all();
; 1213 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1214 :             }
; 1215 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1216 :             if (_Al != _Right_al) {
; 1217 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1218 :                 return *this;
; 1219 :             }
; 1220 :         }
; 1221 : 
; 1222 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1223 :         _Pocma(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >

; 1224 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 1225 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 1226 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
_TEXT	SEGMENT
tv133 = 32
tv157 = 33
$T1 = 34
_Fits_in_left$ = 35
_Fits_in_right$ = 36
_Proxy$ = 37
_My_data$ = 40
_Left_size$ = 48
$T2 = 56
_Right_size$ = 64
_Left_data$ = 72
_Right_data$ = 80
_New_size$ = 88
_Ptr$3 = 96
_Left_capacity$ = 104
_Right_capacity$ = 112
_Max$ = 120
_New_capacity$ = 128
_Fancyptr$ = 136
_Ptr$ = 144
tv73 = 152
tv75 = 160
_Ptr$4 = 168
tv148 = 176
tv168 = 184
tv166 = 192
_Alproxy$ = 200
tv230 = 208
this$ = 240
__formal$ = 248
_Left$ = 256
_Right$ = 264
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1056 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

$LN12:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
	npad	1

; 1057 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1058 :         auto& _Left_data  = _Left._Mypair._Myval2;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR _Left_data$[rsp], rax

; 1059 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1060 :         _Left_data._Orphan_all();

	mov	rcx, QWORD PTR _Left_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1061 :         _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1062 :         const auto _Left_size  = _Left_data._Mysize;

	mov	rax, QWORD PTR _Left_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Left_size$[rsp], rax

; 1063 :         const auto _Right_size = _Right_data._Mysize;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Right_size$[rsp], rax

; 1064 : 
; 1065 :         const auto _Left_capacity  = _Left_data._Myres;

	mov	rax, QWORD PTR _Left_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Left_capacity$[rsp], rax

; 1066 :         const auto _Right_capacity = _Right_data._Myres;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Right_capacity$[rsp], rax

; 1067 :         // overflow is OK due to max_size() checks:
; 1068 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

	mov	rax, QWORD PTR _Right_size$[rsp]
	mov	rcx, QWORD PTR _Left_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 1069 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

	mov	rax, QWORD PTR _Left_size$[rsp]
	mov	rcx, QWORD PTR _Left_capacity$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Right_size$[rsp], rax
	ja	SHORT $LN6@basic_stri
	mov	BYTE PTR tv133[rsp], 1
	jmp	SHORT $LN7@basic_stri
$LN6@basic_stri:
	mov	BYTE PTR tv133[rsp], 0
$LN7@basic_stri:
	movzx	eax, BYTE PTR tv133[rsp]
	mov	BYTE PTR _Fits_in_left$[rsp], al

; 1070 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

	movzx	eax, BYTE PTR _Fits_in_left$[rsp]
	test	eax, eax
	je	$LN2@basic_stri
	mov	rax, QWORD PTR _Left_capacity$[rsp]
	cmp	QWORD PTR _Right_capacity$[rsp], rax
	ja	$LN2@basic_stri

; 1071 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 1072 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1073 :             _Take_contents(_Left);

	mov	rdx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 1074 :             const auto _Ptr = _My_data._Myptr();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Ptr$4[rsp], rax

; 1075 :             _ASAN_STRING_MODIFY(*this, _Left_size, _New_size);
; 1076 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

	mov	rax, QWORD PTR _Right_size$[rsp]
	inc	rax
	mov	QWORD PTR tv148[rsp], rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Left_size$[rsp]
	mov	rdx, QWORD PTR _Ptr$4[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR tv148[rsp]
	mov	r8, rdx
	mov	rdx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1077 :             _My_data._Mysize = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1078 :             return;

	jmp	$LN1@basic_stri
$LN2@basic_stri:

; 1079 :         }
; 1080 : 
; 1081 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

	mov	rax, QWORD PTR _Right_size$[rsp]
	mov	rcx, QWORD PTR _Right_capacity$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Left_size$[rsp], rax
	ja	SHORT $LN8@basic_stri
	mov	BYTE PTR tv157[rsp], 1
	jmp	SHORT $LN9@basic_stri
$LN8@basic_stri:
	mov	BYTE PTR tv157[rsp], 0
$LN9@basic_stri:
	movzx	eax, BYTE PTR tv157[rsp]
	mov	BYTE PTR _Fits_in_right$[rsp], al

; 1082 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv168[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv166[rsp], rax
	mov	rdx, QWORD PTR tv168[rsp]
	mov	rcx, QWORD PTR tv166[rsp]
	call	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
	movzx	eax, al
	test	eax, eax
	je	$LN3@basic_stri
	movzx	eax, BYTE PTR _Fits_in_right$[rsp]
	test	eax, eax
	je	$LN3@basic_stri

; 1083 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 1084 :             // At this point, we have tested:
; 1085 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 1086 :             // therefore: (by De Morgan's Laws)
; 1087 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 1088 :             // therefore: (by the distributive property)
; 1089 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 1090 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 1091 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_mode_engaged()
; 1092 :             _STL_INTERNAL_CHECK(_Right_data._Large_mode_engaged());
; 1093 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1094 :             _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 1095 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Ptr$3[rsp], rax

; 1096 :             _ASAN_STRING_MODIFY(*this, _Right_size, _New_size);
; 1097 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

	mov	rax, QWORD PTR _Right_size$[rsp]
	inc	rax
	mov	rcx, QWORD PTR _Left_size$[rsp]
	mov	rdx, QWORD PTR _Ptr$3[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$3[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1098 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

	mov	rcx, QWORD PTR _Left_data$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	r8, QWORD PTR _Left_size$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1099 :             _My_data._Mysize = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1100 :             return;

	jmp	$LN1@basic_stri
$LN3@basic_stri:

; 1101 :         }
; 1102 : 
; 1103 :         // can't use either buffer, reallocate
; 1104 :         const auto _Max = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1105 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

	mov	rax, QWORD PTR _Left_size$[rsp]
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR _Right_size$[rsp]
	jae	SHORT $LN4@basic_stri

; 1106 :             _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN4@basic_stri:

; 1107 :         }
; 1108 : 
; 1109 :         size_type _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, _Max);

	mov	r8, QWORD PTR _Max$[rsp]
	mov	edx, 15
	mov	rcx, QWORD PTR _New_size$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 1110 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1111 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1112 :         const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, rax
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _Fancyptr$[rsp], rax

; 1113 :         // nothrow hereafter
; 1114 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _Fancyptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 1115 :         _My_data._Mysize = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1116 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 1117 :         const auto _Ptr  = _Unfancy(_Fancyptr);

	mov	rcx, QWORD PTR _Fancyptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Ptr$[rsp], rax

; 1118 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

	mov	rcx, QWORD PTR _Left_data$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	r8, QWORD PTR _Left_size$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1119 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

	mov	rax, QWORD PTR _Right_size$[rsp]
	inc	rax
	mov	QWORD PTR tv230[rsp], rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Left_size$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR tv230[rsp]
	mov	r8, rdx
	mov	rdx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1120 :         _ASAN_STRING_CREATE(*this);
; 1121 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@basic_stri:

; 1122 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 232				; 000000e8H
	ret	0
$LN11@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv133 = 32
tv157 = 33
$T1 = 34
_Fits_in_left$ = 35
_Fits_in_right$ = 36
_Proxy$ = 37
_My_data$ = 40
_Left_size$ = 48
$T2 = 56
_Right_size$ = 64
_Left_data$ = 72
_Right_data$ = 80
_New_size$ = 88
_Ptr$3 = 96
_Left_capacity$ = 104
_Right_capacity$ = 112
_Max$ = 120
_New_capacity$ = 128
_Fancyptr$ = 136
_Ptr$ = 144
tv73 = 152
tv75 = 160
_Ptr$4 = 168
tv148 = 176
tv168 = 184
tv166 = 192
_Alproxy$ = 200
tv230 = 208
this$ = 240
__formal$ = 248
_Left$ = 256
_Right$ = 264
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1004 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	mov	QWORD PTR tv75[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv75[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1005 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv89[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1006 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1007 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 831  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 833  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 834  : 
; 835  :         // initialize basic_string data members
; 836  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 838  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 842  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv130 = 64
tv128 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 711  :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
	npad	1

; 712  :         _Right._Mypair._Myval2._Check_offset(_Roff);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
	mov	QWORD PTR tv130[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Roff$[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	r8, QWORD PTR tv130[rsp]
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 714  :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 715  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv130 = 64
tv128 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 693  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	mov	QWORD PTR tv76[rsp], rax
	movzx	eax, BYTE PTR $T3[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv76[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	mov	rdx, QWORD PTR tv92[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
	npad	1

; 695  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 684  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 685  :         _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 686  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Off$ = 72
_Size$ = 80
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Size$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 469  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

$LN3:
	sub	rsp, 40					; 00000028H

; 463  :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	npad	1
$LN2@Xran:

; 464  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN2@Check_offs

; 451  :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN2@Check_offs:
$LN3@Check_offs:

; 452  :         }
; 453  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 750  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 511  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 512  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 513  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1187 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z PROC		; std::_Narrow_char_traits<char,int>::eq, COMDAT

; 479  :     _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 480  :         return _Left == _Right;

	movsx	eax, BYTE PTR _Left$[rsp]
	movsx	ecx, BYTE PTR _Right$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN3@eq
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@eq
$LN3@eq:
	mov	DWORD PTR tv67[rsp], 0
$LN4@eq:
	movzx	eax, BYTE PTR tv67[rsp]

; 481  :     }

	add	rsp, 24
	ret	0
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ENDP		; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 459  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 460  :         // assign _Count * _Ch to [_First, ...)
; 461  : #if _HAS_CXX20
; 462  :         if (_STD is_constant_evaluated()) {
; 463  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 464  :         }
; 465  : #endif // _HAS_CXX20
; 466  : 
; 467  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memset
	npad	1

; 468  :     }

	add	rsp, 40					; 00000028H
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 438  :         const _Elem& _Ch) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 439  :         // look for _Ch in [_First, _First + _Count)
; 440  : #if _HAS_CXX17
; 441  : #ifdef __cpp_char8_t
; 442  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 443  : #if _HAS_U8_INTRINSICS
; 444  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 445  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 446  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 447  : #endif // ^^^ no u8 intrinsics ^^^
; 448  :         } else
; 449  : #endif // defined(__cpp_char8_t)
; 450  :         {
; 451  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rax, QWORD PTR _Ch$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memchr

; 452  :         }
; 453  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 454  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 455  : #endif // ^^^ !_HAS_CXX17 ^^^
; 456  :     }

	add	rsp, 40					; 00000028H
	ret	0
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 417  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 418  :         // find length of null-terminated string
; 419  : #if _HAS_CXX17
; 420  : #ifdef __cpp_char8_t
; 421  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 422  : #if _HAS_U8_INTRINSICS
; 423  :             return __builtin_u8strlen(_First);
; 424  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 425  :             return _Primary_char_traits::length(_First);
; 426  : #endif // ^^^ no u8 intrinsics ^^^
; 427  :         } else
; 428  : #endif // defined(__cpp_char8_t)
; 429  :         {
; 430  :             return __builtin_strlen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	QWORD PTR tv68[rsp], -1
$LL3@length:
	inc	QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL3@length
	mov	rax, QWORD PTR tv68[rsp]

; 431  :         }
; 432  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 434  : #endif // ^^^ !_HAS_CXX17 ^^^
; 435  :     }

	add	rsp, 24
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 408  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 409  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 410  : #if _HAS_CXX17
; 411  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcmp

; 412  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 413  :         return _CSTD memcmp(_First1, _First2, _Count);
; 414  : #endif // ^^^ !_HAS_CXX17 ^^^
; 415  :     }

	add	rsp, 40					; 00000028H
	ret	0
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 110  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 111  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 112  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 113  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 114  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 115  : #if _HAS_CXX20
; 116  :         if (_STD is_constant_evaluated()) {
; 117  :             // dest: [_First1, _First1 + _Count)
; 118  :             // src: [_First2, _First2 + _Count)
; 119  :             // We need to handle overlapping ranges.
; 120  :             // If _First1 is in the src range, we need a backward loop.
; 121  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 122  : 
; 123  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 124  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 125  :             bool _Loop_forward = true;
; 126  : 
; 127  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 128  :                 if (_First1 == _Src) {
; 129  :                     _Loop_forward = false;
; 130  :                     break;
; 131  :                 }
; 132  :             }
; 133  : 
; 134  :             if (_Loop_forward) {
; 135  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 136  :                     _First1[_Idx] = _First2[_Idx];
; 137  :                 }
; 138  :             } else {
; 139  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 140  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 141  :                 }
; 142  :             }
; 143  : 
; 144  :             return _First1;
; 145  :         }
; 146  : #endif // _HAS_CXX20
; 147  : 
; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 149  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 150  : 
; 151  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 152  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z PROC		; std::_WChar_traits<wchar_t>::eq, COMDAT

; 324  :     _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 24

; 325  :         return _Left == _Right;

	movzx	eax, WORD PTR _Left$[rsp]
	movzx	ecx, WORD PTR _Right$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN3@eq
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@eq
$LN3@eq:
	mov	DWORD PTR tv67[rsp], 0
$LN4@eq:
	movzx	eax, BYTE PTR tv67[rsp]

; 326  :     }

	add	rsp, 24
	ret	0
?eq@?$_WChar_traits@_W@std@@SA_N_W0@Z ENDP		; std::_WChar_traits<wchar_t>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 315  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 316  : #if _HAS_CXX20
; 317  :         if (_STD is_constant_evaluated()) {
; 318  :             return _Primary_char_traits::assign(_Left, _Right);
; 319  :         }
; 320  : #endif // _HAS_CXX20
; 321  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax], cx

; 322  :     }

	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
_TEXT	SEGMENT
tv74 = 32
tv73 = 40
_First$ = 64
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z PROC	; std::_WChar_traits<wchar_t>::length, COMDAT

; 272  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* _First) noexcept /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 273  :         // find length of null-terminated sequence
; 274  : #if _HAS_CXX17
; 275  :         if (_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@length

; 276  :             if constexpr (is_same_v<_Elem, wchar_t>) {
; 277  :                 return __builtin_wcslen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	QWORD PTR tv74[rsp], -1
$LL4@length:
	inc	QWORD PTR tv74[rsp]
	mov	rax, QWORD PTR tv73[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	cmp	WORD PTR [rax+rcx*2], 0
	jne	SHORT $LL4@length
	mov	rax, QWORD PTR tv74[rsp]
	jmp	SHORT $LN1@length
$LN2@length:

; 278  :             } else {
; 279  :                 return _Primary_char_traits::length(_First);
; 280  :             }
; 281  :         }
; 282  : #endif // _HAS_CXX17
; 283  : 
; 284  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	wcslen
	npad	1
$LN1@length:

; 285  :     }

	add	rsp, 56					; 00000038H
	ret	0
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_Char_traits<wchar_t,unsigned short>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
	mov	r8, rax
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_Char_traits<wchar_t,unsigned short>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Val$ = 32
_First$ = 40
_Count$ = 48
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2290 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2291 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Fnv1a_appe:
	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Idx$1[rsp], rax
	jae	SHORT $LN3@Fnv1a_appe

; 2292 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Val$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2293 :         _Val *= _FNV_prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR _Val$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2294 :     }

	jmp	SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2295 : 
; 2296 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2297 : }

	add	rsp, 24
	ret	0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtr1common
;	COMDAT ?_Is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?_Is_constant_evaluated@std@@YA_NXZ PROC		; std::_Is_constant_evaluated, COMDAT

; 178  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 179  : }

	ret	0
?_Is_constant_evaluated@std@@YA_NXZ ENDP		; std::_Is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1780 :     }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _MaxCount$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_s_l

; 1600 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Format$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _MaxCount$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vsnprintf_s
	mov	DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1583 :     }

	add	rsp, 88					; 00000058H
	ret	0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1460 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1397 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
;	COMDAT vswprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
vswprintf_s PROC					; COMDAT

; 1277 :         {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1278 :             return _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vswprintf_s_l

; 1279 :         }

	add	rsp, 56					; 00000038H
	ret	0
vswprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
;	COMDAT _vswprintf_s_l
_TEXT	SEGMENT
_Result$ = 48
tv73 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vswprintf_s_l PROC					; COMDAT

; 1256 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1257 :         int const _Result = __stdio_common_vswprintf_s(

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vswprintf_s
	mov	DWORD PTR _Result$[rsp], eax

; 1258 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1259 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1260 : 
; 1261 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vswprintf_
	mov	DWORD PTR tv73[rsp], -1
	jmp	SHORT $LN4@vswprintf_
$LN3@vswprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv73[rsp], eax
$LN4@vswprintf_:
	mov	eax, DWORD PTR tv73[rsp]

; 1262 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
