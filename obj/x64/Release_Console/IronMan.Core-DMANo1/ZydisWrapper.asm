; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	?mDecoder@Zydis@IronMan@@0UZydisDecoder_@@A	; IronMan::Zydis::mDecoder
PUBLIC	?mInitialized@Zydis@IronMan@@0_NA		; IronMan::Zydis::mInitialized
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
_BSS	SEGMENT
?mDecoder@Zydis@IronMan@@0UZydisDecoder_@@A DB 014H DUP (?) ; IronMan::Zydis::mDecoder
?mInitialized@Zydis@IronMan@@0_NA DB 01H DUP (?)	; IronMan::Zydis::mInitialized
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsprintf_s_l
PUBLIC	vsprintf_s
PUBLIC	_vsscanf_s_l
PUBLIC	vsscanf_s
PUBLIC	sscanf_s
PUBLIC	?_Is_constant_evaluated@std@@YA_NXZ		; std::_Is_constant_evaluated
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??$min@H@std@@YAAEBHAEBH0@Z			; std::min<int>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?Initialize@Zydis@IronMan@@SAXXZ		; IronMan::Zydis::Initialize
PUBLIC	??0Zydis@IronMan@@QEAA@XZ			; IronMan::Zydis::Zydis
PUBLIC	??1Zydis@IronMan@@QEAA@XZ			; IronMan::Zydis::~Zydis
PUBLIC	?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z	; IronMan::Zydis::Disassemble
PUBLIC	?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z	; IronMan::Zydis::Disassemble
PUBLIC	?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z	; IronMan::Zydis::DisassembleSafe
PUBLIC	?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ ; IronMan::Zydis::GetInstr
PUBLIC	?Success@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::Success
PUBLIC	?RegName@Zydis@IronMan@@QEBAPEBDW4ZydisRegister_@@@Z ; IronMan::Zydis::RegName
PUBLIC	?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; IronMan::Zydis::OperandText
PUBLIC	?Size@Zydis@IronMan@@QEBAHXZ			; IronMan::Zydis::Size
PUBLIC	?Address@Zydis@IronMan@@QEBA_KXZ		; IronMan::Zydis::Address
PUBLIC	?IsFilling@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::IsFilling
PUBLIC	?IsUnusual@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::IsUnusual
PUBLIC	?IsNop@Zydis@IronMan@@QEBA_NXZ			; IronMan::Zydis::IsNop
PUBLIC	?IsPushPop@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::IsPushPop
PUBLIC	?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ; IronMan::Zydis::GetId
PUBLIC	?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IronMan::Zydis::InstructionText
PUBLIC	?OpCount@Zydis@IronMan@@QEBAHXZ			; IronMan::Zydis::OpCount
PUBLIC	??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ; IronMan::Zydis::operator[]
PUBLIC	?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Zydis::Mnemonic
PUBLIC	?MemSizeName@Zydis@IronMan@@QEBAPEBDH@Z		; IronMan::Zydis::MemSizeName
PUBLIC	?BranchDestination@Zydis@IronMan@@QEBA_KXZ	; IronMan::Zydis::BranchDestination
PUBLIC	?ResolveOpValue@Zydis@IronMan@@QEBA_KHAEBV?$function@$$A6A_KW4ZydisRegister_@@@Z@std@@@Z ; IronMan::Zydis::ResolveOpValue
PUBLIC	?IsBranchGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z ; IronMan::Zydis::IsBranchGoingToExecute
PUBLIC	?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z ; IronMan::Zydis::IsBranchGoingToExecute
PUBLIC	?IsConditionalGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z ; IronMan::Zydis::IsConditionalGoingToExecute
PUBLIC	?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z ; IronMan::Zydis::IsConditionalGoingToExecute
PUBLIC	?BytesGroup@Zydis@IronMan@@QEBAXPEAE0000@Z	; IronMan::Zydis::BytesGroup
PUBLIC	?RegInfo@Zydis@IronMan@@QEBAXQEAE@Z		; IronMan::Zydis::RegInfo
PUBLIC	?FlagName@Zydis@IronMan@@QEBAPEBDW4ZydisCPUFlag_@@@Z ; IronMan::Zydis::FlagName
PUBLIC	?IsBranchType@Zydis@IronMan@@QEBA_NI@Z		; IronMan::Zydis::IsBranchType
PUBLIC	??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ		; sprintf_s<20>
PUBLIC	??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::operator()
PUBLIC	?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Empty
PUBLIC	?_Getimpl@?$_Func_class@_KW4ZydisRegister_@@@std@@AEBAPEAV?$_Func_base@_KW4ZydisRegister_@@@2@XZ ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Getimpl
PUBLIC	??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ; std::_Traits_rfind_ch<std::char_traits<char> >
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ; std::_Find_last_vectorized<char const ,char>
PUBLIC	??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ; std::_Search_vectorized<char const ,char const >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_05MKHCJKJG@st?$CI0?$CJ@			; `string'
PUBLIC	??_C@_05MLLAPAKB@st?$CI1?$CJ@			; `string'
PUBLIC	??_C@_05MJPGEOPI@st?$CI2?$CJ@			; `string'
PUBLIC	??_C@_05MIDECEMP@st?$CI3?$CJ@			; `string'
PUBLIC	??_C@_05MNHLDCEK@st?$CI4?$CJ@			; `string'
PUBLIC	??_C@_05MMLJFIHN@st?$CI5?$CJ@			; `string'
PUBLIC	??_C@_05MOPPOGCE@st?$CI6?$CJ@			; `string'
PUBLIC	??_C@_05MPDNIMBD@st?$CI7?$CJ@			; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP@			; `string'
PUBLIC	??_C@_07DOOBJCME@?$FLrip?5?$CL?5@		; `string'
PUBLIC	??_C@_07DKGMOOHG@?$FLrip?5?9?5@			; `string'
PUBLIC	??_C@_04HCKDAFDF@?$CFllX@			; `string'
PUBLIC	??_C@_06PDHLCDAK@0x?$CFllx@			; `string'
PUBLIC	??_C@_08ILNEEICH@?$CFd?$HM?$CFd?$HM?$CFd@	; `string'
PUBLIC	??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ ; `string'
PUBLIC	??_C@_04IHGKJMLH@byte@				; `string'
PUBLIC	??_C@_04EHIOMBPF@word@				; `string'
PUBLIC	??_C@_05KDALNKAH@dword@				; `string'
PUBLIC	??_C@_05OOMDHLAM@fword@				; `string'
PUBLIC	??_C@_05PABAEJCP@qword@				; `string'
PUBLIC	??_C@_05KANNNIJM@tword@				; `string'
PUBLIC	??_C@_03IJHEHDGN@m14@				; `string'
PUBLIC	??_C@_07MFDAFCAF@xmmword@			; `string'
PUBLIC	??_C@_03CHIHICDI@m28@				; `string'
PUBLIC	??_C@_05BMEDMLEC@yword@				; `string'
PUBLIC	??_C@_05JKNHLJOM@zword@				; `string'
PUBLIC	??_C@_02NEEBPNPH@CF@				; `string'
PUBLIC	??_C@_02MKCBOANO@PF@				; `string'
PUBLIC	??_C@_02NHMFCJJJ@AF@				; `string'
PUBLIC	??_C@_02MHLGGFAI@ZF@				; `string'
PUBLIC	??_C@_02MIGHFOIH@SF@				; `string'
PUBLIC	??_C@_02MNCIEIAC@TF@				; `string'
PUBLIC	??_C@_02NJNGHICB@IF@				; `string'
PUBLIC	??_C@_02NBAOOLHC@DF@				; `string'
PUBLIC	??_C@_02NNFLAEJD@OF@				; `string'
PUBLIC	??_C@_04JPDJFEAI@IOPL@				; `string'
PUBLIC	??_C@_02KEGNBOHH@NT@				; `string'
PUBLIC	??_C@_02MJKFDELA@RF@				; `string'
PUBLIC	??_C@_02CNFIEFKH@VM@				; `string'
PUBLIC	??_C@_02KKLCNNNM@AC@				; `string'
PUBLIC	??_C@_03OJLFCOFB@VIF@				; `string'
PUBLIC	??_C@_03PFCNJLIG@VIP@				; `string'
PUBLIC	??_C@_02OLOABKKD@ID@				; `string'
PUBLIC	??_C@_02KNCECDIH@C0@				; `string'
PUBLIC	??_C@_02LEDPBCMG@C1@				; `string'
PUBLIC	??_C@_02JPBCEBAF@C2@				; `string'
PUBLIC	??_C@_02IGAJHAEE@C3@				; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	__stdio_common_vsprintf_s:PROC
EXTRN	__stdio_common_vsscanf:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__std_find_last_trivial_1:PROC
EXTRN	__std_search_1:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_DebugBreak:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	?_Xbad_function_call@std@@YAXXZ:PROC		; std::_Xbad_function_call
EXTRN	?Print@Console@IronMan@@YA_NPEBDZZ:PROC		; IronMan::Console::Print
EXTRN	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ:PROC ; IronMan::Utils::FormatString
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	ZydisRegisterGetString:PROC
EXTRN	ZydisDecoderInit:PROC
EXTRN	ZydisDecoderDecodeBuffer:PROC
EXTRN	ZydisCalcAbsoluteAddress:PROC
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+110
	DD	imagerel $unwind$_vsprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsprintf_s DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$vsprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_s_l DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$_vsscanf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsscanf_s DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$vsscanf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf_s DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$sscanf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+172
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+411
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN11
	DD	imagerel $LN11+1010
	DD	imagerel $unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA DD imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@H@std@@YAAEBHAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$??$min@H@std@@YAAEBHAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Initialize@Zydis@IronMan@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$?Initialize@Zydis@IronMan@@SAXXZ
$pdata$??0Zydis@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0Zydis@IronMan@@QEAA@XZ
$pdata$?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z
$pdata$?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z DD imagerel $LN13
	DD	imagerel $LN13+418
	DD	imagerel $unwind$?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z
$pdata$?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z DD imagerel $LN3
	DD	imagerel $LN3+141
	DD	imagerel $unwind$?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z
$pdata$?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ
$pdata$?RegName@Zydis@IronMan@@QEBAPEBDW4ZydisRegister_@@@Z DD imagerel $LN15
	DD	imagerel $LN15+184
	DD	imagerel $unwind$?RegName@Zydis@IronMan@@QEBAPEBDW4ZydisRegister_@@@Z
$pdata$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA DD imagerel ?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
	DD	imagerel ?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?Size@Zydis@IronMan@@QEBAHXZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$?Size@Zydis@IronMan@@QEBAHXZ
$pdata$?Address@Zydis@IronMan@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?Address@Zydis@IronMan@@QEBA_KXZ
$pdata$?IsFilling@Zydis@IronMan@@QEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+75
	DD	imagerel $unwind$?IsFilling@Zydis@IronMan@@QEBA_NXZ
$pdata$?IsUnusual@Zydis@IronMan@@QEBA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+183
	DD	imagerel $unwind$?IsUnusual@Zydis@IronMan@@QEBA_NXZ
$pdata$?IsNop@Zydis@IronMan@@QEBA_NXZ DD imagerel $LN82
	DD	imagerel $LN82+1627
	DD	imagerel $unwind$?IsNop@Zydis@IronMan@@QEBA_NXZ
$pdata$?IsPushPop@Zydis@IronMan@@QEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+72
	DD	imagerel $unwind$?IsPushPop@Zydis@IronMan@@QEBA_NXZ
$pdata$?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ
$pdata$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD imagerel $LN14
	DD	imagerel $LN14+732
	DD	imagerel $unwind$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD imagerel ?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DD	imagerel ?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
$pdata$?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD imagerel ?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DD	imagerel ?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
$pdata$?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD imagerel ?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DD	imagerel ?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
$pdata$?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD imagerel ?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DD	imagerel ?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?OpCount@Zydis@IronMan@@QEBAHXZ DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?OpCount@Zydis@IronMan@@QEBAHXZ
$pdata$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+313
	DD	imagerel $unwind$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA DD imagerel ?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA
	DD	imagerel ?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN6
	DD	imagerel $LN6+114
	DD	imagerel $unwind$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?MemSizeName@Zydis@IronMan@@QEBAPEBDH@Z DD imagerel $LN19
	DD	imagerel $LN19+288
	DD	imagerel $unwind$?MemSizeName@Zydis@IronMan@@QEBAPEBDH@Z
$pdata$?BranchDestination@Zydis@IronMan@@QEBA_KXZ DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?BranchDestination@Zydis@IronMan@@QEBA_KXZ
$pdata$?ResolveOpValue@Zydis@IronMan@@QEBA_KHAEBV?$function@$$A6A_KW4ZydisRegister_@@@Z@std@@@Z DD imagerel $LN11
	DD	imagerel $LN11+293
	DD	imagerel $unwind$?ResolveOpValue@Zydis@IronMan@@QEBA_KHAEBV?$function@$$A6A_KW4ZydisRegister_@@@Z@std@@@Z
$pdata$?IsBranchGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?IsBranchGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z
$pdata$?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z DD imagerel $LN74
	DD	imagerel $LN74+1375
	DD	imagerel $unwind$?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z
$pdata$?IsConditionalGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?IsConditionalGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z
$pdata$?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z DD imagerel $LN114
	DD	imagerel $LN114+1900
	DD	imagerel $unwind$?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z
$pdata$?BytesGroup@Zydis@IronMan@@QEBAXPEAE0000@Z DD imagerel $LN5
	DD	imagerel $LN5+279
	DD	imagerel $unwind$?BytesGroup@Zydis@IronMan@@QEBAXPEAE0000@Z
$pdata$?RegInfo@Zydis@IronMan@@QEBAXQEAE@Z DD imagerel $LN27
	DD	imagerel $LN27+600
	DD	imagerel $unwind$?RegInfo@Zydis@IronMan@@QEBAXQEAE@Z
$pdata$?FlagName@Zydis@IronMan@@QEBAPEBDW4ZydisCPUFlag_@@@Z DD imagerel $LN28
	DD	imagerel $LN28+356
	DD	imagerel $unwind$?FlagName@Zydis@IronMan@@QEBAPEBDW4ZydisCPUFlag_@@@Z
$pdata$?IsBranchType@Zydis@IronMan@@QEBA_NI@Z DD imagerel $LN53
	DD	imagerel $LN53+855
	DD	imagerel $unwind$?IsBranchType@Zydis@IronMan@@QEBA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ
pdata	ENDS
pdata	SEGMENT
$pdata$?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z DD imagerel ?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z
	DD	imagerel ?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z+148
	DD	imagerel $unwind$?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z DD imagerel $LN12
	DD	imagerel $LN12+286
	DD	imagerel $unwind$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN14
	DD	imagerel $LN14+385
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD imagerel $LN6
	DD	imagerel $LN6+515
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02IGAJHAEE@C3@
CONST	SEGMENT
??_C@_02IGAJHAEE@C3@ DB 'C3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JPBCEBAF@C2@
CONST	SEGMENT
??_C@_02JPBCEBAF@C2@ DB 'C2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LEDPBCMG@C1@
CONST	SEGMENT
??_C@_02LEDPBCMG@C1@ DB 'C1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNCECDIH@C0@
CONST	SEGMENT
??_C@_02KNCECDIH@C0@ DB 'C0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OLOABKKD@ID@
CONST	SEGMENT
??_C@_02OLOABKKD@ID@ DB 'ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFCNJLIG@VIP@
CONST	SEGMENT
??_C@_03PFCNJLIG@VIP@ DB 'VIP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJLFCOFB@VIF@
CONST	SEGMENT
??_C@_03OJLFCOFB@VIF@ DB 'VIF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KKLCNNNM@AC@
CONST	SEGMENT
??_C@_02KKLCNNNM@AC@ DB 'AC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CNFIEFKH@VM@
CONST	SEGMENT
??_C@_02CNFIEFKH@VM@ DB 'VM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJKFDELA@RF@
CONST	SEGMENT
??_C@_02MJKFDELA@RF@ DB 'RF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNBOHH@NT@
CONST	SEGMENT
??_C@_02KEGNBOHH@NT@ DB 'NT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JPDJFEAI@IOPL@
CONST	SEGMENT
??_C@_04JPDJFEAI@IOPL@ DB 'IOPL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NNFLAEJD@OF@
CONST	SEGMENT
??_C@_02NNFLAEJD@OF@ DB 'OF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBAOOLHC@DF@
CONST	SEGMENT
??_C@_02NBAOOLHC@DF@ DB 'DF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNGHICB@IF@
CONST	SEGMENT
??_C@_02NJNGHICB@IF@ DB 'IF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MNCIEIAC@TF@
CONST	SEGMENT
??_C@_02MNCIEIAC@TF@ DB 'TF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHFOIH@SF@
CONST	SEGMENT
??_C@_02MIGHFOIH@SF@ DB 'SF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MHLGGFAI@ZF@
CONST	SEGMENT
??_C@_02MHLGGFAI@ZF@ DB 'ZF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NHMFCJJJ@AF@
CONST	SEGMENT
??_C@_02NHMFCJJJ@AF@ DB 'AF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBOANO@PF@
CONST	SEGMENT
??_C@_02MKCBOANO@PF@ DB 'PF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEEBPNPH@CF@
CONST	SEGMENT
??_C@_02NEEBPNPH@CF@ DB 'CF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKNHLJOM@zword@
CONST	SEGMENT
??_C@_05JKNHLJOM@zword@ DB 'zword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMEDMLEC@yword@
CONST	SEGMENT
??_C@_05BMEDMLEC@yword@ DB 'yword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHIHICDI@m28@
CONST	SEGMENT
??_C@_03CHIHICDI@m28@ DB 'm28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFDAFCAF@xmmword@
CONST	SEGMENT
??_C@_07MFDAFCAF@xmmword@ DB 'xmmword', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IJHEHDGN@m14@
CONST	SEGMENT
??_C@_03IJHEHDGN@m14@ DB 'm14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KANNNIJM@tword@
CONST	SEGMENT
??_C@_05KANNNIJM@tword@ DB 'tword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PABAEJCP@qword@
CONST	SEGMENT
??_C@_05PABAEJCP@qword@ DB 'qword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OOMDHLAM@fword@
CONST	SEGMENT
??_C@_05OOMDHLAM@fword@ DB 'fword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDALNKAH@dword@
CONST	SEGMENT
??_C@_05KDALNKAH@dword@ DB 'dword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHIOMBPF@word@
CONST	SEGMENT
??_C@_04EHIOMBPF@word@ DB 'word', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHGKJMLH@byte@
CONST	SEGMENT
??_C@_04IHGKJMLH@byte@ DB 'byte', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ DB '['
	DB	0e8H, 0beH, 093H, 0e5H, 087H, 0baH, 0e4H, 0bfH, 0a1H, 0e6H, 081H
	DB	0afH, '] %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILNEEICH@?$CFd?$HM?$CFd?$HM?$CFd@
CONST	SEGMENT
??_C@_08ILNEEICH@?$CFd?$HM?$CFd?$HM?$CFd@ DB '%d|%d|%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDHLCDAK@0x?$CFllx@
CONST	SEGMENT
??_C@_06PDHLCDAK@0x?$CFllx@ DB '0x%llx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCKDAFDF@?$CFllX@
CONST	SEGMENT
??_C@_04HCKDAFDF@?$CFllX@ DB '%llX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DKGMOOHG@?$FLrip?5?9?5@
CONST	SEGMENT
??_C@_07DKGMOOHG@?$FLrip?5?9?5@ DB '[rip - ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOOBJCME@?$FLrip?5?$CL?5@
CONST	SEGMENT
??_C@_07DOOBJCME@?$FLrip?5?$CL?5@ DB '[rip + ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPDNIMBD@st?$CI7?$CJ@
CONST	SEGMENT
??_C@_05MPDNIMBD@st?$CI7?$CJ@ DB 'st(7)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MOPPOGCE@st?$CI6?$CJ@
CONST	SEGMENT
??_C@_05MOPPOGCE@st?$CI6?$CJ@ DB 'st(6)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MMLJFIHN@st?$CI5?$CJ@
CONST	SEGMENT
??_C@_05MMLJFIHN@st?$CI5?$CJ@ DB 'st(5)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNHLDCEK@st?$CI4?$CJ@
CONST	SEGMENT
??_C@_05MNHLDCEK@st?$CI4?$CJ@ DB 'st(4)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIDECEMP@st?$CI3?$CJ@
CONST	SEGMENT
??_C@_05MIDECEMP@st?$CI3?$CJ@ DB 'st(3)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJPGEOPI@st?$CI2?$CJ@
CONST	SEGMENT
??_C@_05MJPGEOPI@st?$CI2?$CJ@ DB 'st(2)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MLLAPAKB@st?$CI1?$CJ@
CONST	SEGMENT
??_C@_05MLLAPAKB@st?$CI1?$CJ@ DB 'st(1)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKHCJKJG@st?$CI0?$CJ@
CONST	SEGMENT
??_C@_05MKHCJKJG@st?$CI0?$CJ@ DB 'st(0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ DB 040H
	DD	imagerel $ip2state$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ DD 011819H
	DD	06218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z
	DD	017H
	DD	0127H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	020H
	DD	02c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?IsNop@Zydis@IronMan@@QEBA_NXZ
	DD	018H
	DD	044cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z
	DD	022H
	DD	07bH
voltbl	ENDS
xdata	SEGMENT
$unwind$?Initialize@Zydis@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$??0Zydis@IronMan@@QEAA@XZ DD 010901H
	DD	04209H
$unwind$?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z DD 011301H
	DD	04213H
$unwind$?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z DD 011801H
	DD	06218H
$unwind$?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ DD 010901H
	DD	04209H
$unwind$?RegName@Zydis@IronMan@@QEBAPEBDW4ZydisRegister_@@@Z DD 010d01H
	DD	0620dH
$unwind$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
$cppxdata$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 08H
	DD	imagerel $stateUnwindMap$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	imagerel $ip2state$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
$stateUnwindMap$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
$ip2state$?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 04H
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
$unwind$?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA DD 020601H
	DD	050023206H
$unwind$?Size@Zydis@IronMan@@QEBAHXZ DD 010901H
	DD	04209H
$unwind$?Address@Zydis@IronMan@@QEBA_KXZ DD 010901H
	DD	04209H
$unwind$?IsFilling@Zydis@IronMan@@QEBA_NXZ DD 010901H
	DD	06209H
$unwind$?IsUnusual@Zydis@IronMan@@QEBA_NXZ DD 010901H
	DD	06209H
$unwind$?IsNop@Zydis@IronMan@@QEBA_NXZ DD 042019H
	DD	013010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$?IsPushPop@Zydis@IronMan@@QEBA_NXZ DD 010901H
	DD	06209H
$unwind$?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ DD 010901H
	DD	04209H
$unwind$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 022819H
	DD	0210116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	0f2H
$cppxdata$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DB 08H
	DD	imagerel $stateUnwindMap$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	imagerel $ip2state$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
$stateUnwindMap$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA
$ip2state$?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DB 012H
	DB	00H
	DB	00H
	DB	0b2H
	DB	02H
	DB	'0'
	DB	00H
	DB	'8'
	DB	04H
	DB	05H, 03H
	DB	06H
	DB	08eH
	DB	08H
	DB	'>'
	DB	06H
	DB	'I', 03H
	DB	04H
	DB	'V'
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?OpCount@Zydis@IronMan@@QEBAHXZ DD 010901H
	DD	04209H
$unwind$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z DD 011c19H
	DD	0e20dH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z
	DD	062H
$cppxdata$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z DB 08H
	DD	imagerel $stateUnwindMap$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z
	DD	imagerel $ip2state$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z
$stateUnwindMap$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA
$ip2state$??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z DB 06H
	DB	00H
	DB	00H
	DB	'E', 03H
	DB	02H
	DB	'V'
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA DD 020601H
	DD	050023206H
$unwind$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$cppxdata$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$stateUnwindMap$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$ip2state$?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 04H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
$unwind$?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?MemSizeName@Zydis@IronMan@@QEBAPEBDH@Z DD 010d01H
	DD	0220dH
$unwind$?BranchDestination@Zydis@IronMan@@QEBA_KXZ DD 010901H
	DD	04209H
$unwind$?ResolveOpValue@Zydis@IronMan@@QEBA_KHAEBV?$function@$$A6A_KW4ZydisRegister_@@@Z@std@@@Z DD 011201H
	DD	0a212H
$unwind$?IsBranchGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z DD 011301H
	DD	04213H
$unwind$?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z DD 011201H
	DD	0c212H
$unwind$?IsConditionalGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z DD 011301H
	DD	04213H
$unwind$?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z DD 021501H
	DD	0130115H
$unwind$?BytesGroup@Zydis@IronMan@@QEBAXPEAE0000@Z DD 011801H
	DD	04218H
$unwind$?RegInfo@Zydis@IronMan@@QEBAXQEAE@Z DD 010e01H
	DD	0820eH
$unwind$?FlagName@Zydis@IronMan@@QEBAPEBDW4ZydisCPUFlag_@@@Z DD 010d01H
	DD	0220dH
$unwind$?IsBranchType@Zydis@IronMan@@QEBA_NI@Z DD 010d01H
	DD	0820dH
$unwind$?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@H@std@@YAAEBHAEBH0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 04H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 08H
	DD	imagerel $stateUnwindMap$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
	DD	imagerel $ip2state$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 031c01H
	DD	016011cH
	DD	07015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 040H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	09aH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	't'
	DB	02H
	DB	0d0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD 010c01H
	DD	0220cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsscanf_s DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_s_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_s_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 123  : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z
_TEXT	SEGMENT
_First1$ = 48
_Last1$ = 56
_First2$ = 64
_Count2$ = 72
??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z PROC ; std::_Search_vectorized<char const ,char const >, COMDAT

; 277  : _Ty1* _Search_vectorized(_Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 278  :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Ty1) == sizeof(_Ty2));
; 279  :     if constexpr (sizeof(_Ty1) == 1) {
; 280  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_1(_First1, _Last1, _First2, _Count2)));

	mov	r9, QWORD PTR _Count2$[rsp]
	mov	r8, QWORD PTR _First2$[rsp]
	mov	rdx, QWORD PTR _Last1$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	__std_search_1

; 281  :     } else if constexpr (sizeof(_Ty1) == 2) {
; 282  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));
; 283  :     } else {
; 284  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 285  :     }
; 286  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ENDP ; std::_Search_vectorized<char const ,char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z PROC ; std::_Find_last_vectorized<char const ,char>, COMDAT

; 226  : _Ty* _Find_last_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 228  : #ifdef _WIN64
; 229  :         return const_cast<_Ty*>(
; 230  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 231  : #else
; 232  :         return const_cast<_Ty*>(
; 233  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 234  : #endif
; 235  :     } else if constexpr (sizeof(_Ty) == 1) {
; 236  :         return const_cast<_Ty*>(

	movzx	r8d, BYTE PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	__std_find_last_trivial_1

; 237  :             static_cast<const _Ty*>(::__std_find_last_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 238  :     } else if constexpr (sizeof(_Ty) == 2) {
; 239  :         return const_cast<_Ty*>(
; 240  :             static_cast<const _Ty*>(::__std_find_last_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 241  :     } else if constexpr (sizeof(_Ty) == 4) {
; 242  :         return const_cast<_Ty*>(
; 243  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 244  :     } else if constexpr (sizeof(_Ty) == 8) {
; 245  :         return const_cast<_Ty*>(
; 246  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 247  :     } else {
; 248  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 249  :     }
; 250  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ENDP ; std::_Find_last_vectorized<char const ,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
_TEXT	SEGMENT
_My_data$ = 64
_Old_size$ = 72
_New_ptr$ = 80
_New_size$ = 88
_New_capacity$ = 96
_Old_capacity$ = 104
_Old_ptr$1 = 112
_Al$ = 120
_Raw_new$ = 128
this$ = 160
_Size_increase$ = 168
_Fn$ = 176
<_Args_0>$ = 184
<_Args_1>$ = 192
<_Args_2>$ = 200
<_Args_3>$ = 208
??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	$LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_3>$[rsp]
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_3>$[rsp]
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 152				; 00000098H
	ret	0
??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z
_TEXT	SEGMENT
tv80 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Off$ = 96
_Nx$ = 104
_Ptr$ = 112
_Count$ = 120
??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z PROC ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator(), COMDAT

; 1993 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1990 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1991 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1992 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);

	mov	rax, QWORD PTR _Nx$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sub	rax, QWORD PTR _Off$[rsp]
	inc	rax
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	add	rcx, QWORD PTR _Nx$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	r8, QWORD PTR _New_ptr$[rsp]
	add	r8, rdx
	mov	rdx, r8
	add	rdx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR tv80[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv80[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1993 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z ENDP ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Possible_matches_end$ = 56
_Haystack$ = 80
_Hay_size$ = 88
_Start_at$ = 96
_Needle$ = 104
_Needle_size$ = 112
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 613  :     const size_t _Needle_size) noexcept {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 614  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 615  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rax, QWORD PTR _Hay_size$[rsp]
	cmp	QWORD PTR _Needle_size$[rsp], rax
	ja	SHORT $LN6@Traits_fin
	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Start_at$[rsp], rax
	jbe	SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 616  :         // xpos cannot exist, report failure
; 617  :         // N4950 [string.view.find]/3 says:
; 618  :         // 1. _Start_at <= xpos
; 619  :         // 2. xpos + _Needle_size <= _Hay_size;
; 620  :         // therefore:
; 621  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 622  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 623  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 624  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN5@Traits_fin:

; 625  :     }
; 626  : 
; 627  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	cmp	QWORD PTR _Needle_size$[rsp], 0
	jne	SHORT $LN7@Traits_fin

; 628  :         return _Start_at;

	mov	rax, QWORD PTR _Start_at$[rsp]
	jmp	$LN1@Traits_fin
$LN7@Traits_fin:

; 629  :     }
; 630  : 
; 631  : #if _USE_STD_VECTOR_ALGORITHMS
; 632  :     if constexpr (_Is_implementation_handled_char_traits<_Traits> && sizeof(typename _Traits::char_type) <= 2) {
; 633  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@Traits_fin

; 634  :             const auto _End = _Haystack + _Hay_size;

	mov	rax, QWORD PTR _Hay_size$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _End$2[rsp], rax

; 635  :             const auto _Ptr = _STD _Search_vectorized(_Haystack + _Start_at, _End, _Needle, _Needle_size);

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR _Needle_size$[rsp]
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, rax
	call	??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ; std::_Search_vectorized<char const ,char const >
	mov	QWORD PTR _Ptr$3[rsp], rax

; 636  : 
; 637  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN9@Traits_fin

; 638  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	$LN1@Traits_fin

; 639  :             } else {

	jmp	SHORT $LN10@Traits_fin
$LN9@Traits_fin:

; 640  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN10@Traits_fin:
$LN8@Traits_fin:

; 641  :             }
; 642  :         }
; 643  :     }
; 644  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 645  : 
; 646  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Haystack$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR _Possible_matches_end$[rsp], rax

; 647  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_fin
$LN2@Traits_fin:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	inc	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_fin:

; 648  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	mov	rax, QWORD PTR _Match_try$1[rsp]
	mov	rcx, QWORD PTR _Possible_matches_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
	mov	QWORD PTR _Match_try$1[rsp], rax

; 649  :         if (!_Match_try) { // didn't find first character; report failure

	cmp	QWORD PTR _Match_try$1[rsp], 0
	jne	SHORT $LN11@Traits_fin

; 650  :             return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_fin
$LN11@Traits_fin:

; 651  :         }
; 652  : 
; 653  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	mov	r8, QWORD PTR _Needle_size$[rsp]
	mov	rdx, QWORD PTR _Needle$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
	test	eax, eax
	jne	SHORT $LN12@Traits_fin

; 654  :             return static_cast<size_t>(_Match_try - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_fin
$LN12@Traits_fin:

; 655  :         }
; 656  :     }

	jmp	SHORT $LN2@Traits_fin
$LN1@Traits_fin:

; 657  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Actual_start_at$ = 56
$T4 = 64
_Haystack$ = 96
_Hay_size$ = 104
_Start_at$ = 112
_Ch$ = 120
??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z PROC ; std::_Traits_rfind_ch<std::char_traits<char> >, COMDAT

; 720  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {

$LN12:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 721  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 722  : 
; 723  :     if (_Hay_size == 0) { // no room for match

	cmp	QWORD PTR _Hay_size$[rsp], 0
	jne	SHORT $LN5@Traits_rfi

; 724  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_rfi
$LN5@Traits_rfi:

; 725  :     }
; 726  : 
; 727  :     const size_t _Actual_start_at = (_STD min)(_Start_at, _Hay_size - 1);

	mov	rax, QWORD PTR _Hay_size$[rsp]
	dec	rax
	mov	QWORD PTR $T4[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR _Start_at$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Actual_start_at$[rsp], rax

; 728  : 
; 729  : #if _USE_STD_VECTOR_ALGORITHMS
; 730  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 731  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Traits_rfi

; 732  :             const auto _End = _Haystack + _Actual_start_at + 1;

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Actual_start_at$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR _End$2[rsp], rax

; 733  :             const auto _Ptr = _STD _Find_last_vectorized(_Haystack, _End, _Ch);

	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	call	??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ; std::_Find_last_vectorized<char const ,char>
	mov	QWORD PTR _Ptr$3[rsp], rax

; 734  : 
; 735  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN7@Traits_rfi

; 736  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_rfi

; 737  :             } else {

	jmp	SHORT $LN8@Traits_rfi
$LN7@Traits_rfi:

; 738  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN8@Traits_rfi:
$LN6@Traits_rfi:

; 739  :             }
; 740  :         }
; 741  :     }
; 742  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 743  : 
; 744  :     for (auto _Match_try = _Haystack + _Actual_start_at;; --_Match_try) {

	mov	rax, QWORD PTR _Actual_start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_rfi
$LN2@Traits_rfi:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	dec	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_rfi:

; 745  :         if (_Traits::eq(*_Match_try, _Ch)) {

	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rax, QWORD PTR _Match_try$1[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ; std::_Narrow_char_traits<char,int>::eq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Traits_rfi

; 746  :             return static_cast<size_t>(_Match_try - _Haystack); // found a match

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_rfi
$LN9@Traits_rfi:

; 747  :         }
; 748  : 
; 749  :         if (_Match_try == _Haystack) {

	mov	rax, QWORD PTR _Haystack$[rsp]
	cmp	QWORD PTR _Match_try$1[rsp], rax
	jne	SHORT $LN10@Traits_rfi

; 750  :             return static_cast<size_t>(-1); // at beginning, no more chance for match

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN10@Traits_rfi:

; 751  :         }
; 752  :     }

	jmp	SHORT $LN2@Traits_rfi
$LN1@Traits_rfi:

; 753  : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ENDP ; std::_Traits_rfind_ch<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z PROC ; std::forward<enum ZydisRegister_>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ENDP ; std::forward<enum ZydisRegister_>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@_KW4ZydisRegister_@@@std@@AEBAPEAV?$_Func_base@_KW4ZydisRegister_@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getimpl@?$_Func_class@_KW4ZydisRegister_@@@std@@AEBAPEAV?$_Func_base@_KW4ZydisRegister_@@@2@XZ PROC ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Getimpl, COMDAT

; 1044 :     _Ptrt* _Getimpl() const noexcept { // get pointer to object

	mov	QWORD PTR [rsp+8], rcx

; 1045 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax]

; 1046 :     }

	ret	0
?_Getimpl@?$_Func_class@_KW4ZydisRegister_@@@std@@AEBAPEAV?$_Func_base@_KW4ZydisRegister_@@@2@XZ ENDP ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ PROC ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Empty, COMDAT

; 938  :     bool _Empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 939  :         return !_Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@_KW4ZydisRegister_@@@std@@AEBAPEAV?$_Func_base@_KW4ZydisRegister_@@@2@XZ ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Getimpl
	test	rax, rax
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv67[rsp], 0
$LN4@Empty:
	movzx	eax, BYTE PTR tv67[rsp]

; 940  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ ENDP ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z
_TEXT	SEGMENT
_Impl$ = 32
tv78 = 40
tv80 = 48
this$ = 80
<_Args_0>$ = 88
??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z PROC ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::operator(), COMDAT

; 920  :     _Ret operator()(_Types... _Args) const {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 921  :         if (_Empty()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@_KW4ZydisRegister_@@@std@@IEBA_NXZ ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator

; 922  :             _Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
	npad	1
$LN2@operator:

; 923  :         }
; 924  :         const auto _Impl = _Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@_KW4ZydisRegister_@@@std@@AEBAPEAV?$_Func_base@_KW4ZydisRegister_@@@2@XZ ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::_Getimpl
	mov	QWORD PTR _Impl$[rsp], rax

; 925  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Impl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv80[rsp], rax
	lea	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@W4ZydisRegister_@@@std@@YA$$QEAW4ZydisRegister_@@AEAW41@@Z ; std::forward<enum ZydisRegister_>
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR _Impl$[rsp]
	call	QWORD PTR tv80[rsp]
$LN3@operator:

; 926  :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z ENDP ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv68 = 0
op$ = 32
?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z PROC ; IronMan::isSafe64NopRegOp

; 396  : 	{

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 397  : #ifdef _WIN64
; 398  : 		if (op.type != ZYDIS_OPERAND_TYPE_REGISTER)

	mov	rax, QWORD PTR op$[rsp]
	cmp	DWORD PTR [rax+4], 1
	je	SHORT $LN4@isSafe64No

; 399  : 			return true; //a non-register is safe

	mov	al, 1
	jmp	SHORT $LN1@isSafe64No
$LN4@isSafe64No:

; 400  : 		switch (op.reg.value)

	mov	rax, QWORD PTR op$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv68[rsp], eax
	mov	eax, DWORD PTR tv68[rsp]
	sub	eax, 37					; 00000025H
	mov	DWORD PTR tv68[rsp], eax
	cmp	DWORD PTR tv68[rsp], 15
	ja	SHORT $LN21@isSafe64No
	movsxd	rax, DWORD PTR tv68[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN23@isSafe64No[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN5@isSafe64No:
$LN6@isSafe64No:
$LN7@isSafe64No:
$LN8@isSafe64No:
$LN9@isSafe64No:
$LN10@isSafe64No:
$LN11@isSafe64No:
$LN12@isSafe64No:
$LN13@isSafe64No:
$LN14@isSafe64No:
$LN15@isSafe64No:
$LN16@isSafe64No:
$LN17@isSafe64No:
$LN18@isSafe64No:
$LN19@isSafe64No:
$LN20@isSafe64No:

; 401  : 		{
; 402  : 		case ZYDIS_REGISTER_EAX:
; 403  : 		case ZYDIS_REGISTER_EBX:
; 404  : 		case ZYDIS_REGISTER_ECX:
; 405  : 		case ZYDIS_REGISTER_EDX:
; 406  : 		case ZYDIS_REGISTER_EBP:
; 407  : 		case ZYDIS_REGISTER_ESP:
; 408  : 		case ZYDIS_REGISTER_ESI:
; 409  : 		case ZYDIS_REGISTER_EDI:
; 410  : 		case ZYDIS_REGISTER_R8D:
; 411  : 		case ZYDIS_REGISTER_R9D:
; 412  : 		case ZYDIS_REGISTER_R10D:
; 413  : 		case ZYDIS_REGISTER_R11D:
; 414  : 		case ZYDIS_REGISTER_R12D:
; 415  : 		case ZYDIS_REGISTER_R13D:
; 416  : 		case ZYDIS_REGISTER_R14D:
; 417  : 		case ZYDIS_REGISTER_R15D:
; 418  : 			return false; //32 bit register modifications clear the high part of the 64 bit register

	xor	al, al
	jmp	SHORT $LN1@isSafe64No
$LN21@isSafe64No:

; 419  : 		default:
; 420  : 			return true; //all other registers are safe

	mov	al, 1
$LN1@isSafe64No:

; 421  : 		}
; 422  : #else
; 423  : 		return true;
; 424  : #endif //_WIN64
; 425  : 	}

	add	rsp, 24
	ret	0
$LN23@isSafe64No:
	DD	$LN5@isSafe64No
	DD	$LN7@isSafe64No
	DD	$LN8@isSafe64No
	DD	$LN6@isSafe64No
	DD	$LN10@isSafe64No
	DD	$LN9@isSafe64No
	DD	$LN11@isSafe64No
	DD	$LN12@isSafe64No
	DD	$LN13@isSafe64No
	DD	$LN14@isSafe64No
	DD	$LN15@isSafe64No
	DD	$LN16@isSafe64No
	DD	$LN17@isSafe64No
	DD	$LN18@isSafe64No
	DD	$LN19@isSafe64No
	DD	$LN20@isSafe64No
?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z ENDP ; IronMan::isSafe64NopRegOp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ
_TEXT	SEGMENT
_ArgList$ = 32
_Buffer$ = 64
_Format$ = 72
??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ PROC		; sprintf_s<20>, COMDAT

; 1840 :         )

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1835 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax
	mov	r9, QWORD PTR _ArgList$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	edx, 20
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	vsprintf_s
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ ENDP		; sprintf_s<20>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv74 = 32
ref$ = 36
tv92 = 40
op0$ = 48
this$ = 80
bt$ = 88
?IsBranchType@Zydis@IronMan@@QEBA_NI@Z PROC		; IronMan::Zydis::IsBranchType

; 249  : 	{

$LN53:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 250  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsBranchTy

; 251  : 			return false;

	xor	al, al
	jmp	$LN1@IsBranchTy
$LN4@IsBranchTy:

; 252  : 
; 253  : 		std::underlying_type_t<BranchType> ref = 0;

	mov	DWORD PTR ref$[rsp], 0

; 254  : 		const auto& op0 = mInstr.operands[0];

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR op0$[rsp], rax

; 255  : 
; 256  : 		switch (mInstr.mnemonic)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv74[rsp], eax
	cmp	DWORD PTR tv74[rsp], 391		; 00000187H
	jg	SHORT $LN47@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 391		; 00000187H
	je	$LN42@IsBranchTy
	mov	eax, DWORD PTR tv74[rsp]
	sub	eax, 59					; 0000003bH
	mov	DWORD PTR tv74[rsp], eax
	cmp	DWORD PTR tv74[rsp], 246		; 000000f6H
	ja	$LN45@IsBranchTy
	movsxd	rax, DWORD PTR tv74[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN51@IsBranchTy[rcx+rax]
	mov	eax, DWORD PTR $LN52@IsBranchTy[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN47@IsBranchTy:
	cmp	DWORD PTR tv74[rsp], 745		; 000002e9H
	jg	SHORT $LN48@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 745		; 000002e9H
	je	$LN30@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 392		; 00000188H
	je	$LN43@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 393		; 00000189H
	je	$LN44@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 661		; 00000295H
	je	SHORT $LN5@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 669		; 0000029dH
	je	$LN41@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 744		; 000002e8H
	je	SHORT $LN29@IsBranchTy
	jmp	$LN45@IsBranchTy
$LN48@IsBranchTy:
	cmp	DWORD PTR tv74[rsp], 746		; 000002eaH
	je	SHORT $LN32@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 747		; 000002ebH
	je	SHORT $LN31@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 1566		; 0000061eH
	je	$LN40@IsBranchTy
	cmp	DWORD PTR tv74[rsp], 1568		; 00000620H
	je	SHORT $LN39@IsBranchTy
	jmp	$LN45@IsBranchTy
$LN5@IsBranchTy:

; 257  : 		{
; 258  : 		case ZYDIS_MNEMONIC_RET:
; 259  : 			ref = BTRet;

	mov	DWORD PTR ref$[rsp], 1

; 260  : 			//ref = (mInstr.attributes & ZYDIS_ATTRIB_IS_FAR_BRANCH) ? BTFarRet : BTRet;
; 261  : 			break;

	jmp	$LN2@IsBranchTy
$LN6@IsBranchTy:

; 262  : 		case ZYDIS_MNEMONIC_CALL:
; 263  : 			ref = BTCall;

	mov	DWORD PTR ref$[rsp], 2

; 264  : 			//ref = (mInstr.attributes & ZYDIS_ATTRIB_IS_FAR_BRANCH) ? BTFarCall : BTCall;
; 265  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN7@IsBranchTy:

; 266  : 		case ZYDIS_MNEMONIC_JMP:
; 267  : 			ref = BTUncondJmp;

	mov	DWORD PTR ref$[rsp], 2048		; 00000800H

; 268  : 			//ref = (mInstr.attributes & ZYDIS_ATTRIB_IS_FAR_BRANCH) ? BTFarJmp : BTUncondJmp;
; 269  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN8@IsBranchTy:
$LN9@IsBranchTy:
$LN10@IsBranchTy:
$LN11@IsBranchTy:
$LN12@IsBranchTy:
$LN13@IsBranchTy:
$LN14@IsBranchTy:
$LN15@IsBranchTy:
$LN16@IsBranchTy:
$LN17@IsBranchTy:
$LN18@IsBranchTy:
$LN19@IsBranchTy:
$LN20@IsBranchTy:
$LN21@IsBranchTy:
$LN22@IsBranchTy:
$LN23@IsBranchTy:
$LN24@IsBranchTy:
$LN25@IsBranchTy:
$LN26@IsBranchTy:
$LN27@IsBranchTy:
$LN28@IsBranchTy:

; 270  : 		case ZYDIS_MNEMONIC_JB:
; 271  : 		case ZYDIS_MNEMONIC_JBE:
; 272  : 		case ZYDIS_MNEMONIC_JCXZ:
; 273  : 		case ZYDIS_MNEMONIC_JECXZ:
; 274  : 		case ZYDIS_MNEMONIC_JKNZD:
; 275  : 		case ZYDIS_MNEMONIC_JKZD:
; 276  : 		case ZYDIS_MNEMONIC_JL:
; 277  : 		case ZYDIS_MNEMONIC_JLE:
; 278  : 		case ZYDIS_MNEMONIC_JNB:
; 279  : 		case ZYDIS_MNEMONIC_JNBE:
; 280  : 		case ZYDIS_MNEMONIC_JNL:
; 281  : 		case ZYDIS_MNEMONIC_JNLE:
; 282  : 		case ZYDIS_MNEMONIC_JNO:
; 283  : 		case ZYDIS_MNEMONIC_JNP:
; 284  : 		case ZYDIS_MNEMONIC_JNS:
; 285  : 		case ZYDIS_MNEMONIC_JNZ:
; 286  : 		case ZYDIS_MNEMONIC_JO:
; 287  : 		case ZYDIS_MNEMONIC_JP:
; 288  : 		case ZYDIS_MNEMONIC_JRCXZ:
; 289  : 		case ZYDIS_MNEMONIC_JS:
; 290  : 		case ZYDIS_MNEMONIC_JZ:
; 291  : 			ref = BTCondJmp;

	mov	DWORD PTR ref$[rsp], 1024		; 00000400H

; 292  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN29@IsBranchTy:
$LN30@IsBranchTy:

; 293  : 		case ZYDIS_MNEMONIC_SYSCALL:
; 294  : 		case ZYDIS_MNEMONIC_SYSENTER:
; 295  : 			ref = BTSyscall;

	mov	DWORD PTR ref$[rsp], 16

; 296  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN31@IsBranchTy:
$LN32@IsBranchTy:

; 297  : 		case ZYDIS_MNEMONIC_SYSRET:
; 298  : 		case ZYDIS_MNEMONIC_SYSEXIT:
; 299  : 			ref = BTSysret;

	mov	DWORD PTR ref$[rsp], 32			; 00000020H

; 300  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN33@IsBranchTy:

; 301  : 		case ZYDIS_MNEMONIC_INT:
; 302  : 			ref = BTInt;

	mov	DWORD PTR ref$[rsp], 64			; 00000040H

; 303  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN34@IsBranchTy:

; 304  : 		case ZYDIS_MNEMONIC_INT3:
; 305  : 			ref = BTInt3;

	mov	DWORD PTR ref$[rsp], 128		; 00000080H

; 306  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN35@IsBranchTy:

; 307  : 		case ZYDIS_MNEMONIC_INT1:
; 308  : 			ref = BTInt1;

	mov	DWORD PTR ref$[rsp], 256		; 00000100H

; 309  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN36@IsBranchTy:
$LN37@IsBranchTy:
$LN38@IsBranchTy:

; 310  : 		case ZYDIS_MNEMONIC_IRET:
; 311  : 		case ZYDIS_MNEMONIC_IRETD:
; 312  : 		case ZYDIS_MNEMONIC_IRETQ:
; 313  : 			ref = BTIret;

	mov	DWORD PTR ref$[rsp], 512		; 00000200H

; 314  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN39@IsBranchTy:

; 315  : 		case ZYDIS_MNEMONIC_XBEGIN:
; 316  : 			ref = BTXbegin;

	mov	DWORD PTR ref$[rsp], 8192		; 00002000H

; 317  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN40@IsBranchTy:

; 318  : 		case ZYDIS_MNEMONIC_XABORT:
; 319  : 			ref = BTXabort;

	mov	DWORD PTR ref$[rsp], 16384		; 00004000H

; 320  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN41@IsBranchTy:

; 321  : 		case ZYDIS_MNEMONIC_RSM:
; 322  : 			ref = BTRsm;

	mov	DWORD PTR ref$[rsp], 32768		; 00008000H

; 323  : 			break;

	jmp	SHORT $LN2@IsBranchTy
$LN42@IsBranchTy:
$LN43@IsBranchTy:
$LN44@IsBranchTy:

; 324  : 		case ZYDIS_MNEMONIC_LOOP:
; 325  : 		case ZYDIS_MNEMONIC_LOOPE:
; 326  : 		case ZYDIS_MNEMONIC_LOOPNE:
; 327  : 			ref = BTLoop;

	mov	DWORD PTR ref$[rsp], 65536		; 00010000H
$LN45@IsBranchTy:
$LN2@IsBranchTy:

; 328  : 		default:
; 329  : 			;
; 330  : 		}
; 331  : 
; 332  : 		return (bt & ref) != 0;

	mov	eax, DWORD PTR ref$[rsp]
	mov	ecx, DWORD PTR bt$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN49@IsBranchTy
	mov	DWORD PTR tv92[rsp], 1
	jmp	SHORT $LN50@IsBranchTy
$LN49@IsBranchTy:
	mov	DWORD PTR tv92[rsp], 0
$LN50@IsBranchTy:
	movzx	eax, BYTE PTR tv92[rsp]
$LN1@IsBranchTy:

; 333  : 	}

	add	rsp, 72					; 00000048H
	ret	0
	npad	1
$LN52@IsBranchTy:
	DD	$LN6@IsBranchTy
	DD	$LN33@IsBranchTy
	DD	$LN35@IsBranchTy
	DD	$LN34@IsBranchTy
	DD	$LN36@IsBranchTy
	DD	$LN37@IsBranchTy
	DD	$LN38@IsBranchTy
	DD	$LN8@IsBranchTy
	DD	$LN9@IsBranchTy
	DD	$LN10@IsBranchTy
	DD	$LN11@IsBranchTy
	DD	$LN12@IsBranchTy
	DD	$LN13@IsBranchTy
	DD	$LN14@IsBranchTy
	DD	$LN15@IsBranchTy
	DD	$LN7@IsBranchTy
	DD	$LN16@IsBranchTy
	DD	$LN17@IsBranchTy
	DD	$LN18@IsBranchTy
	DD	$LN19@IsBranchTy
	DD	$LN20@IsBranchTy
	DD	$LN21@IsBranchTy
	DD	$LN22@IsBranchTy
	DD	$LN23@IsBranchTy
	DD	$LN24@IsBranchTy
	DD	$LN25@IsBranchTy
	DD	$LN26@IsBranchTy
	DD	$LN27@IsBranchTy
	DD	$LN28@IsBranchTy
	DD	$LN45@IsBranchTy
$LN51@IsBranchTy:
	DB	0
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	1
	DB	2
	DB	3
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	29
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	16
	DB	17
	DB	18
	DB	19
	DB	20
	DB	21
	DB	22
	DB	23
	DB	24
	DB	25
	DB	26
	DB	27
	DB	28
?IsBranchType@Zydis@IronMan@@QEBA_NI@Z ENDP		; IronMan::Zydis::IsBranchType
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv64 = 0
this$ = 32
flag$ = 40
?FlagName@Zydis@IronMan@@QEBAPEBDW4ZydisCPUFlag_@@@Z PROC ; IronMan::Zydis::FlagName

; 854  : 	{

$LN28:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 855  : 		switch (flag)

	mov	eax, DWORD PTR flag$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 20
	ja	$LN25@FlagName
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN27@FlagName[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@FlagName:

; 856  : 		{
; 857  : 		case ZYDIS_CPUFLAG_CF:
; 858  : 			return "CF";

	lea	rax, OFFSET FLAT:??_C@_02NEEBPNPH@CF@
	jmp	$LN1@FlagName
$LN5@FlagName:

; 859  : 		case ZYDIS_CPUFLAG_PF:
; 860  : 			return "PF";

	lea	rax, OFFSET FLAT:??_C@_02MKCBOANO@PF@
	jmp	$LN1@FlagName
$LN6@FlagName:

; 861  : 		case ZYDIS_CPUFLAG_AF:
; 862  : 			return "AF";

	lea	rax, OFFSET FLAT:??_C@_02NHMFCJJJ@AF@
	jmp	$LN1@FlagName
$LN7@FlagName:

; 863  : 		case ZYDIS_CPUFLAG_ZF:
; 864  : 			return "ZF";

	lea	rax, OFFSET FLAT:??_C@_02MHLGGFAI@ZF@
	jmp	$LN1@FlagName
$LN8@FlagName:

; 865  : 		case ZYDIS_CPUFLAG_SF:
; 866  : 			return "SF";

	lea	rax, OFFSET FLAT:??_C@_02MIGHFOIH@SF@
	jmp	$LN1@FlagName
$LN9@FlagName:

; 867  : 		case ZYDIS_CPUFLAG_TF:
; 868  : 			return "TF";

	lea	rax, OFFSET FLAT:??_C@_02MNCIEIAC@TF@
	jmp	$LN1@FlagName
$LN10@FlagName:

; 869  : 		case ZYDIS_CPUFLAG_IF:
; 870  : 			return "IF";

	lea	rax, OFFSET FLAT:??_C@_02NJNGHICB@IF@
	jmp	$LN1@FlagName
$LN11@FlagName:

; 871  : 		case ZYDIS_CPUFLAG_DF:
; 872  : 			return "DF";

	lea	rax, OFFSET FLAT:??_C@_02NBAOOLHC@DF@
	jmp	SHORT $LN1@FlagName
$LN12@FlagName:

; 873  : 		case ZYDIS_CPUFLAG_OF:
; 874  : 			return "OF";

	lea	rax, OFFSET FLAT:??_C@_02NNFLAEJD@OF@
	jmp	SHORT $LN1@FlagName
$LN13@FlagName:

; 875  : 		case ZYDIS_CPUFLAG_IOPL:
; 876  : 			return "IOPL";

	lea	rax, OFFSET FLAT:??_C@_04JPDJFEAI@IOPL@
	jmp	SHORT $LN1@FlagName
$LN14@FlagName:

; 877  : 		case ZYDIS_CPUFLAG_NT:
; 878  : 			return "NT";

	lea	rax, OFFSET FLAT:??_C@_02KEGNBOHH@NT@
	jmp	SHORT $LN1@FlagName
$LN15@FlagName:

; 879  : 		case ZYDIS_CPUFLAG_RF:
; 880  : 			return "RF";

	lea	rax, OFFSET FLAT:??_C@_02MJKFDELA@RF@
	jmp	SHORT $LN1@FlagName
$LN16@FlagName:

; 881  : 		case ZYDIS_CPUFLAG_VM:
; 882  : 			return "VM";

	lea	rax, OFFSET FLAT:??_C@_02CNFIEFKH@VM@
	jmp	SHORT $LN1@FlagName
$LN17@FlagName:

; 883  : 		case ZYDIS_CPUFLAG_AC:
; 884  : 			return "AC";

	lea	rax, OFFSET FLAT:??_C@_02KKLCNNNM@AC@
	jmp	SHORT $LN1@FlagName
$LN18@FlagName:

; 885  : 		case ZYDIS_CPUFLAG_VIF:
; 886  : 			return "VIF";

	lea	rax, OFFSET FLAT:??_C@_03OJLFCOFB@VIF@
	jmp	SHORT $LN1@FlagName
$LN19@FlagName:

; 887  : 		case ZYDIS_CPUFLAG_VIP:
; 888  : 			return "VIP";

	lea	rax, OFFSET FLAT:??_C@_03PFCNJLIG@VIP@
	jmp	SHORT $LN1@FlagName
$LN20@FlagName:

; 889  : 		case ZYDIS_CPUFLAG_ID:
; 890  : 			return "ID";

	lea	rax, OFFSET FLAT:??_C@_02OLOABKKD@ID@
	jmp	SHORT $LN1@FlagName
$LN21@FlagName:

; 891  : 		case ZYDIS_CPUFLAG_C0:
; 892  : 			return "C0";

	lea	rax, OFFSET FLAT:??_C@_02KNCECDIH@C0@
	jmp	SHORT $LN1@FlagName
$LN22@FlagName:

; 893  : 		case ZYDIS_CPUFLAG_C1:
; 894  : 			return "C1";

	lea	rax, OFFSET FLAT:??_C@_02LEDPBCMG@C1@
	jmp	SHORT $LN1@FlagName
$LN23@FlagName:

; 895  : 		case ZYDIS_CPUFLAG_C2:
; 896  : 			return "C2";

	lea	rax, OFFSET FLAT:??_C@_02JPBCEBAF@C2@
	jmp	SHORT $LN1@FlagName
$LN24@FlagName:

; 897  : 		case ZYDIS_CPUFLAG_C3:
; 898  : 			return "C3";

	lea	rax, OFFSET FLAT:??_C@_02IGAJHAEE@C3@
	jmp	SHORT $LN1@FlagName
$LN25@FlagName:

; 899  : 		default:
; 900  : 			return nullptr;

	xor	eax, eax
$LN1@FlagName:

; 901  : 		}
; 902  : 	}

	add	rsp, 24
	ret	0
	npad	2
$LN27@FlagName:
	DD	$LN4@FlagName
	DD	$LN5@FlagName
	DD	$LN6@FlagName
	DD	$LN7@FlagName
	DD	$LN8@FlagName
	DD	$LN9@FlagName
	DD	$LN10@FlagName
	DD	$LN11@FlagName
	DD	$LN12@FlagName
	DD	$LN13@FlagName
	DD	$LN14@FlagName
	DD	$LN15@FlagName
	DD	$LN16@FlagName
	DD	$LN17@FlagName
	DD	$LN18@FlagName
	DD	$LN19@FlagName
	DD	$LN20@FlagName
	DD	$LN21@FlagName
	DD	$LN22@FlagName
	DD	$LN23@FlagName
	DD	$LN24@FlagName
?FlagName@Zydis@IronMan@@QEBAPEBDW4ZydisCPUFlag_@@@Z ENDP ; IronMan::Zydis::FlagName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv170 = 32
i$1 = 36
tv89 = 40
tv86 = 44
op$2 = 48
this$ = 80
regs$ = 88
?RegInfo@Zydis@IronMan@@QEBAXQEAE@Z PROC		; IronMan::Zydis::RegInfo

; 803  : 	{

$LN27:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 804  : 		memset(regs, 0, sizeof(uint8_t) * (ZYDIS_REGISTER_MAX_VALUE + 1));

	mov	r8d, 257				; 00000101H
	xor	edx, edx
	mov	rcx, QWORD PTR regs$[rsp]
	call	memset
	npad	1

; 805  : 		if (!Success() || IsNop())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@RegInfo
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsNop@Zydis@IronMan@@QEBA_NXZ		; IronMan::Zydis::IsNop
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@RegInfo
$LN10@RegInfo:

; 806  : 			return;

	jmp	$LN1@RegInfo
$LN9@RegInfo:

; 807  : 
; 808  : 		for (int i = 0; i < mInstr.operand_count; ++i)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@RegInfo
$LN2@RegInfo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@RegInfo:
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@RegInfo

; 809  : 		{
; 810  : 			const auto& op = mInstr.operands[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR op$2[rsp], rax

; 811  : 
; 812  : 			switch (op.type)

	mov	rax, QWORD PTR op$2[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv86[rsp], eax
	cmp	DWORD PTR tv86[rsp], 1
	je	SHORT $LN11@RegInfo
	cmp	DWORD PTR tv86[rsp], 2
	je	$LN19@RegInfo
	jmp	$LN22@RegInfo
$LN11@RegInfo:

; 813  : 			{
; 814  : 			case ZYDIS_OPERAND_TYPE_REGISTER:
; 815  : 			{
; 816  : 				switch (op.actions)

	mov	rax, QWORD PTR op$2[rsp]
	movzx	eax, BYTE PTR [rax+12]
	mov	DWORD PTR tv89[rsp], eax
	mov	eax, DWORD PTR tv89[rsp]
	dec	eax
	mov	DWORD PTR tv89[rsp], eax
	cmp	DWORD PTR tv89[rsp], 8
	ja	$LN7@RegInfo
	movsxd	rax, DWORD PTR tv89[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN26@RegInfo[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN12@RegInfo:
$LN13@RegInfo:

; 817  : 				{
; 818  : 				case ZYDIS_OPERAND_ACTION_READ:
; 819  : 				case ZYDIS_OPERAND_ACTION_CONDREAD:
; 820  : 					regs[op.reg.value] |= RAIRead;

	mov	rax, QWORD PTR op$2[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR regs$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	eax, 1
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 821  : 					break;

	jmp	SHORT $LN7@RegInfo
$LN14@RegInfo:
$LN15@RegInfo:

; 822  : 				case ZYDIS_OPERAND_ACTION_WRITE:
; 823  : 				case ZYDIS_OPERAND_ACTION_CONDWRITE:
; 824  : 					regs[op.reg.value] |= RAIWrite;

	mov	rax, QWORD PTR op$2[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR regs$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	eax, 2
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 825  : 					break;

	jmp	SHORT $LN7@RegInfo
$LN16@RegInfo:
$LN17@RegInfo:
$LN18@RegInfo:

; 826  : 				case ZYDIS_OPERAND_ACTION_READWRITE:
; 827  : 				case ZYDIS_OPERAND_ACTION_READ_CONDWRITE:
; 828  : 				case ZYDIS_OPERAND_ACTION_CONDREAD_WRITE:
; 829  : 					regs[op.reg.value] |= RAIRead | RAIWrite;

	mov	rax, QWORD PTR op$2[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR regs$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	eax, 3
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN7@RegInfo:

; 830  : 					break;
; 831  : 				}
; 832  : 				regs[op.reg.value] |= op.visibility == ZYDIS_OPERAND_VISIBILITY_HIDDEN ?

	mov	rax, QWORD PTR op$2[rsp]
	cmp	DWORD PTR [rax+8], 3
	jne	SHORT $LN24@RegInfo
	mov	BYTE PTR tv170[rsp], 4
	jmp	SHORT $LN25@RegInfo
$LN24@RegInfo:
	mov	BYTE PTR tv170[rsp], 8
$LN25@RegInfo:
	movzx	eax, BYTE PTR tv170[rsp]
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR regs$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 833  : 					RAIImplicit : RAIExplicit;
; 834  : 			}
; 835  : 			break;

	jmp	$LN5@RegInfo
$LN19@RegInfo:

; 836  : 
; 837  : 			case ZYDIS_OPERAND_TYPE_MEMORY:
; 838  : 			{
; 839  : 				regs[op.mem.segment] |= RAIRead | RAIExplicit;

	mov	rax, QWORD PTR op$2[rsp]
	movsxd	rax, DWORD PTR [rax+44]
	mov	rcx, QWORD PTR regs$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	eax, 9
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+44]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 840  : 				if (op.mem.base != ZYDIS_REGISTER_NONE)

	mov	rax, QWORD PTR op$2[rsp]
	cmp	DWORD PTR [rax+48], 0
	je	SHORT $LN20@RegInfo

; 841  : 					regs[op.mem.base] |= RAIRead | RAIExplicit;

	mov	rax, QWORD PTR op$2[rsp]
	movsxd	rax, DWORD PTR [rax+48]
	mov	rcx, QWORD PTR regs$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	eax, 9
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+48]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN20@RegInfo:

; 842  : 				if (op.mem.index != ZYDIS_REGISTER_NONE)

	mov	rax, QWORD PTR op$2[rsp]
	cmp	DWORD PTR [rax+52], 0
	je	SHORT $LN21@RegInfo

; 843  : 					regs[op.mem.index] |= RAIRead | RAIExplicit;

	mov	rax, QWORD PTR op$2[rsp]
	movsxd	rax, DWORD PTR [rax+52]
	mov	rcx, QWORD PTR regs$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	eax, 9
	mov	rcx, QWORD PTR op$2[rsp]
	movsxd	rcx, DWORD PTR [rcx+52]
	mov	rdx, QWORD PTR regs$[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN21@RegInfo:
$LN22@RegInfo:
$LN5@RegInfo:

; 844  : 			}
; 845  : 			break;
; 846  : 
; 847  : 			default:
; 848  : 				break;
; 849  : 			}
; 850  : 		}

	jmp	$LN2@RegInfo
$LN3@RegInfo:
$LN1@RegInfo:

; 851  : 	}

	add	rsp, 72					; 00000048H
	ret	0
$LN26@RegInfo:
	DD	$LN12@RegInfo
	DD	$LN14@RegInfo
	DD	$LN16@RegInfo
	DD	$LN13@RegInfo
	DD	$LN7@RegInfo
	DD	$LN18@RegInfo
	DD	$LN7@RegInfo
	DD	$LN15@RegInfo
	DD	$LN17@RegInfo
?RegInfo@Zydis@IronMan@@QEBAXQEAE@Z ENDP		; IronMan::Zydis::RegInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
prefixSize$ = 56
opcodeSize$ = 64
group1Size$ = 72
group2Size$ = 80
group3Size$ = 88
?BytesGroup@Zydis@IronMan@@QEBAXPEAE0000@Z PROC		; IronMan::Zydis::BytesGroup

; 905  : 	{

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 906  : 		if (Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	je	$LN2@BytesGroup

; 907  : 		{
; 908  : 			*prefixSize = mInstr.raw.prefix_count;

	mov	rax, QWORD PTR prefixSize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+1224]
	mov	BYTE PTR [rax], cl

; 909  : 			*group1Size = mInstr.raw.disp.size / 8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1416]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	rcx, QWORD PTR group1Size$[rsp]
	mov	BYTE PTR [rcx], al

; 910  : 			*group2Size = mInstr.raw.imm[0].size / 8;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1440]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	rcx, QWORD PTR group2Size$[rsp]
	mov	BYTE PTR [rcx], al

; 911  : 			*group3Size = mInstr.raw.imm[1].size / 8;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1440]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	rcx, QWORD PTR group3Size$[rsp]
	mov	BYTE PTR [rcx], al

; 912  : 			*opcodeSize = mInstr.length - *prefixSize - *group1Size - *group2Size - *group3Size;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	mov	rcx, QWORD PTR prefixSize$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	mov	rcx, QWORD PTR group1Size$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	mov	rcx, QWORD PTR group2Size$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	mov	rcx, QWORD PTR group3Size$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	mov	rcx, QWORD PTR opcodeSize$[rsp]
	mov	BYTE PTR [rcx], al

; 913  : 		}

	jmp	SHORT $LN3@BytesGroup
$LN2@BytesGroup:

; 914  : 		else
; 915  : 		{
; 916  : 			*prefixSize = 0;

	mov	rax, QWORD PTR prefixSize$[rsp]
	mov	BYTE PTR [rax], 0

; 917  : 			*opcodeSize = mInstr.length;

	mov	rax, QWORD PTR opcodeSize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	mov	BYTE PTR [rax], cl

; 918  : 			*group1Size = 0;

	mov	rax, QWORD PTR group1Size$[rsp]
	mov	BYTE PTR [rax], 0

; 919  : 			*group2Size = 0;

	mov	rax, QWORD PTR group2Size$[rsp]
	mov	BYTE PTR [rax], 0

; 920  : 			*group3Size = 0;

	mov	rax, QWORD PTR group3Size$[rsp]
	mov	BYTE PTR [rax], 0
$LN3@BytesGroup:

; 921  : 		}
; 922  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?BytesGroup@Zydis@IronMan@@QEBAXPEAE0000@Z ENDP		; IronMan::Zydis::BytesGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
bZF$ = 0
bCF$ = 1
bOF$ = 2
bSF$ = 3
bPF$ = 4
tv84 = 8
tv66 = 12
tv70 = 16
tv74 = 20
tv78 = 24
tv82 = 28
tv89 = 32
tv93 = 36
tv131 = 40
tv138 = 44
tv143 = 48
tv148 = 52
tv155 = 56
tv159 = 60
tv163 = 64
tv167 = 68
tv171 = 72
tv177 = 76
tv183 = 80
tv187 = 84
tv191 = 88
tv195 = 92
tv201 = 96
tv205 = 100
tv211 = 104
tv218 = 108
tv223 = 112
tv228 = 116
tv235 = 120
tv239 = 124
tv243 = 128
tv247 = 132
tv251 = 136
id$ = 160
cflags$ = 168
ccx$ = 176
?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z PROC ; IronMan::Zydis::IsConditionalGoingToExecute

; 709  : 	{

$LN114:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 152				; 00000098H

; 710  : 		auto bCF = (cflags & (1 << 0)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN46@IsConditio
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN47@IsConditio
$LN46@IsConditio:
	mov	DWORD PTR tv66[rsp], 0
$LN47@IsConditio:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR bCF$[rsp], al

; 711  : 		auto bPF = (cflags & (1 << 2)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 4
	test	rax, rax
	je	SHORT $LN48@IsConditio
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN49@IsConditio
$LN48@IsConditio:
	mov	DWORD PTR tv70[rsp], 0
$LN49@IsConditio:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR bPF$[rsp], al

; 712  : 		auto bZF = (cflags & (1 << 6)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 64					; 00000040H
	test	rax, rax
	je	SHORT $LN50@IsConditio
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN51@IsConditio
$LN50@IsConditio:
	mov	DWORD PTR tv74[rsp], 0
$LN51@IsConditio:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR bZF$[rsp], al

; 713  : 		auto bSF = (cflags & (1 << 7)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 128				; 00000080H
	test	rax, rax
	je	SHORT $LN52@IsConditio
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN53@IsConditio
$LN52@IsConditio:
	mov	DWORD PTR tv78[rsp], 0
$LN53@IsConditio:
	movzx	eax, BYTE PTR tv78[rsp]
	mov	BYTE PTR bSF$[rsp], al

; 714  : 		auto bOF = (cflags & (1 << 11)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 2048				; 00000800H
	test	rax, rax
	je	SHORT $LN54@IsConditio
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN55@IsConditio
$LN54@IsConditio:
	mov	DWORD PTR tv82[rsp], 0
$LN55@IsConditio:
	movzx	eax, BYTE PTR tv82[rsp]
	mov	BYTE PTR bOF$[rsp], al

; 715  : 		switch (id)

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR tv84[rsp], eax
	cmp	DWORD PTR tv84[rsp], 683		; 000002abH
	jg	SHORT $LN110@IsConditio
	cmp	DWORD PTR tv84[rsp], 683		; 000002abH
	je	$LN30@IsConditio
	mov	eax, DWORD PTR tv84[rsp]
	sub	eax, 78					; 0000004eH
	mov	DWORD PTR tv84[rsp], eax
	cmp	DWORD PTR tv84[rsp], 90			; 0000005aH
	ja	$LN44@IsConditio
	movsxd	rax, DWORD PTR tv84[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN112@IsConditio[rcx+rax]
	mov	eax, DWORD PTR $LN113@IsConditio[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN110@IsConditio:
	mov	eax, DWORD PTR tv84[rsp]
	sub	eax, 684				; 000002acH
	mov	DWORD PTR tv84[rsp], eax
	cmp	DWORD PTR tv84[rsp], 15
	ja	$LN44@IsConditio
	movsxd	rax, DWORD PTR tv84[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN111@IsConditio[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@IsConditio:

; 716  : 		{
; 717  : 		case ZYDIS_MNEMONIC_CMOVNBE: //conditional move - above/not below nor equal
; 718  : 			return !bCF && !bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN56@IsConditio
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN56@IsConditio
	mov	DWORD PTR tv89[rsp], 1
	jmp	SHORT $LN57@IsConditio
$LN56@IsConditio:
	mov	DWORD PTR tv89[rsp], 0
$LN57@IsConditio:
	movzx	eax, BYTE PTR tv89[rsp]
	jmp	$LN1@IsConditio
$LN5@IsConditio:

; 719  : 		case ZYDIS_MNEMONIC_CMOVNB: //conditional move - above or equal/not below/not carry
; 720  : 			return !bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN58@IsConditio
	mov	DWORD PTR tv93[rsp], 1
	jmp	SHORT $LN59@IsConditio
$LN58@IsConditio:
	mov	DWORD PTR tv93[rsp], 0
$LN59@IsConditio:
	movzx	eax, BYTE PTR tv93[rsp]
	jmp	$LN1@IsConditio
$LN6@IsConditio:

; 721  : 		case ZYDIS_MNEMONIC_CMOVB: //conditional move - below/not above nor equal/carry
; 722  : 			return bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	jmp	$LN1@IsConditio
$LN7@IsConditio:

; 723  : 		case ZYDIS_MNEMONIC_CMOVBE: //conditional move - below or equal/not above
; 724  : 			return bCF || bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN60@IsConditio
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN60@IsConditio
	mov	DWORD PTR tv131[rsp], 0
	jmp	SHORT $LN61@IsConditio
$LN60@IsConditio:
	mov	DWORD PTR tv131[rsp], 1
$LN61@IsConditio:
	movzx	eax, BYTE PTR tv131[rsp]
	jmp	$LN1@IsConditio
$LN8@IsConditio:

; 725  : 		case ZYDIS_MNEMONIC_CMOVZ: //conditional move - equal/zero
; 726  : 			return bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	jmp	$LN1@IsConditio
$LN9@IsConditio:

; 727  : 		case ZYDIS_MNEMONIC_CMOVNLE: //conditional move - greater/not less nor equal
; 728  : 			return !bZF && bSF == bOF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN62@IsConditio
	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN62@IsConditio
	mov	DWORD PTR tv138[rsp], 1
	jmp	SHORT $LN63@IsConditio
$LN62@IsConditio:
	mov	DWORD PTR tv138[rsp], 0
$LN63@IsConditio:
	movzx	eax, BYTE PTR tv138[rsp]
	jmp	$LN1@IsConditio
$LN10@IsConditio:

; 729  : 		case ZYDIS_MNEMONIC_CMOVNL: //conditional move - greater or equal/not less
; 730  : 			return bSF == bOF;

	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN64@IsConditio
	mov	DWORD PTR tv143[rsp], 1
	jmp	SHORT $LN65@IsConditio
$LN64@IsConditio:
	mov	DWORD PTR tv143[rsp], 0
$LN65@IsConditio:
	movzx	eax, BYTE PTR tv143[rsp]
	jmp	$LN1@IsConditio
$LN11@IsConditio:

; 731  : 		case ZYDIS_MNEMONIC_CMOVL: //conditional move - less/not greater nor equal
; 732  : 			return bSF != bOF;

	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	je	SHORT $LN66@IsConditio
	mov	DWORD PTR tv148[rsp], 1
	jmp	SHORT $LN67@IsConditio
$LN66@IsConditio:
	mov	DWORD PTR tv148[rsp], 0
$LN67@IsConditio:
	movzx	eax, BYTE PTR tv148[rsp]
	jmp	$LN1@IsConditio
$LN12@IsConditio:

; 733  : 		case ZYDIS_MNEMONIC_CMOVLE: //conditional move - less or equal/not greater
; 734  : 			return bZF || bSF != bOF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN68@IsConditio
	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN68@IsConditio
	mov	DWORD PTR tv155[rsp], 0
	jmp	SHORT $LN69@IsConditio
$LN68@IsConditio:
	mov	DWORD PTR tv155[rsp], 1
$LN69@IsConditio:
	movzx	eax, BYTE PTR tv155[rsp]
	jmp	$LN1@IsConditio
$LN13@IsConditio:

; 735  : 		case ZYDIS_MNEMONIC_CMOVNZ: //conditional move - not equal/not zero
; 736  : 			return !bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN70@IsConditio
	mov	DWORD PTR tv159[rsp], 1
	jmp	SHORT $LN71@IsConditio
$LN70@IsConditio:
	mov	DWORD PTR tv159[rsp], 0
$LN71@IsConditio:
	movzx	eax, BYTE PTR tv159[rsp]
	jmp	$LN1@IsConditio
$LN14@IsConditio:

; 737  : 		case ZYDIS_MNEMONIC_CMOVNO: //conditional move - not overflow
; 738  : 			return !bOF;

	movzx	eax, BYTE PTR bOF$[rsp]
	test	eax, eax
	jne	SHORT $LN72@IsConditio
	mov	DWORD PTR tv163[rsp], 1
	jmp	SHORT $LN73@IsConditio
$LN72@IsConditio:
	mov	DWORD PTR tv163[rsp], 0
$LN73@IsConditio:
	movzx	eax, BYTE PTR tv163[rsp]
	jmp	$LN1@IsConditio
$LN15@IsConditio:

; 739  : 		case ZYDIS_MNEMONIC_CMOVNP: //conditional move - not parity/parity odd
; 740  : 			return !bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	test	eax, eax
	jne	SHORT $LN74@IsConditio
	mov	DWORD PTR tv167[rsp], 1
	jmp	SHORT $LN75@IsConditio
$LN74@IsConditio:
	mov	DWORD PTR tv167[rsp], 0
$LN75@IsConditio:
	movzx	eax, BYTE PTR tv167[rsp]
	jmp	$LN1@IsConditio
$LN16@IsConditio:

; 741  : 		case ZYDIS_MNEMONIC_CMOVNS: //conditional move - not sign
; 742  : 			return !bSF;

	movzx	eax, BYTE PTR bSF$[rsp]
	test	eax, eax
	jne	SHORT $LN76@IsConditio
	mov	DWORD PTR tv171[rsp], 1
	jmp	SHORT $LN77@IsConditio
$LN76@IsConditio:
	mov	DWORD PTR tv171[rsp], 0
$LN77@IsConditio:
	movzx	eax, BYTE PTR tv171[rsp]
	jmp	$LN1@IsConditio
$LN17@IsConditio:

; 743  : 		case ZYDIS_MNEMONIC_CMOVO: //conditional move - overflow
; 744  : 			return bOF;

	movzx	eax, BYTE PTR bOF$[rsp]
	jmp	$LN1@IsConditio
$LN18@IsConditio:

; 745  : 		case ZYDIS_MNEMONIC_CMOVP: //conditional move - parity/parity even
; 746  : 			return bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	jmp	$LN1@IsConditio
$LN19@IsConditio:

; 747  : 		case ZYDIS_MNEMONIC_CMOVS: //conditional move - sign
; 748  : 			return bSF;

	movzx	eax, BYTE PTR bSF$[rsp]
	jmp	$LN1@IsConditio
$LN20@IsConditio:

; 749  : 		case ZYDIS_MNEMONIC_FCMOVBE: //fp conditional move - below or equal
; 750  : 			return bCF || bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN78@IsConditio
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN78@IsConditio
	mov	DWORD PTR tv177[rsp], 0
	jmp	SHORT $LN79@IsConditio
$LN78@IsConditio:
	mov	DWORD PTR tv177[rsp], 1
$LN79@IsConditio:
	movzx	eax, BYTE PTR tv177[rsp]
	jmp	$LN1@IsConditio
$LN21@IsConditio:

; 751  : 		case ZYDIS_MNEMONIC_FCMOVB: //fp conditional move - below
; 752  : 			return bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	jmp	$LN1@IsConditio
$LN22@IsConditio:

; 753  : 		case ZYDIS_MNEMONIC_FCMOVE: //fp conditional move - equal
; 754  : 			return bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	jmp	$LN1@IsConditio
$LN23@IsConditio:

; 755  : 		case ZYDIS_MNEMONIC_FCMOVNBE: //fp conditional move - not below or equal
; 756  : 			return !bCF && !bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN80@IsConditio
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN80@IsConditio
	mov	DWORD PTR tv183[rsp], 1
	jmp	SHORT $LN81@IsConditio
$LN80@IsConditio:
	mov	DWORD PTR tv183[rsp], 0
$LN81@IsConditio:
	movzx	eax, BYTE PTR tv183[rsp]
	jmp	$LN1@IsConditio
$LN24@IsConditio:

; 757  : 		case ZYDIS_MNEMONIC_FCMOVNB: //fp conditional move - not below
; 758  : 			return !bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN82@IsConditio
	mov	DWORD PTR tv187[rsp], 1
	jmp	SHORT $LN83@IsConditio
$LN82@IsConditio:
	mov	DWORD PTR tv187[rsp], 0
$LN83@IsConditio:
	movzx	eax, BYTE PTR tv187[rsp]
	jmp	$LN1@IsConditio
$LN25@IsConditio:

; 759  : 		case ZYDIS_MNEMONIC_FCMOVNE: //fp conditional move - not equal
; 760  : 			return !bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN84@IsConditio
	mov	DWORD PTR tv191[rsp], 1
	jmp	SHORT $LN85@IsConditio
$LN84@IsConditio:
	mov	DWORD PTR tv191[rsp], 0
$LN85@IsConditio:
	movzx	eax, BYTE PTR tv191[rsp]
	jmp	$LN1@IsConditio
$LN26@IsConditio:

; 761  : 		case ZYDIS_MNEMONIC_FCMOVNU: //fp conditional move - not unordered
; 762  : 			return !bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	test	eax, eax
	jne	SHORT $LN86@IsConditio
	mov	DWORD PTR tv195[rsp], 1
	jmp	SHORT $LN87@IsConditio
$LN86@IsConditio:
	mov	DWORD PTR tv195[rsp], 0
$LN87@IsConditio:
	movzx	eax, BYTE PTR tv195[rsp]
	jmp	$LN1@IsConditio
$LN27@IsConditio:

; 763  : 		case ZYDIS_MNEMONIC_FCMOVU: //fp conditional move - unordered
; 764  : 			return bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	jmp	$LN1@IsConditio
$LN28@IsConditio:

; 765  : 		case ZYDIS_MNEMONIC_SETNBE: //set byte on condition - above/not below nor equal
; 766  : 			return !bCF && !bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN88@IsConditio
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN88@IsConditio
	mov	DWORD PTR tv201[rsp], 1
	jmp	SHORT $LN89@IsConditio
$LN88@IsConditio:
	mov	DWORD PTR tv201[rsp], 0
$LN89@IsConditio:
	movzx	eax, BYTE PTR tv201[rsp]
	jmp	$LN1@IsConditio
$LN29@IsConditio:

; 767  : 		case ZYDIS_MNEMONIC_SETNB: //set byte on condition - above or equal/not below/not carry
; 768  : 			return !bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN90@IsConditio
	mov	DWORD PTR tv205[rsp], 1
	jmp	SHORT $LN91@IsConditio
$LN90@IsConditio:
	mov	DWORD PTR tv205[rsp], 0
$LN91@IsConditio:
	movzx	eax, BYTE PTR tv205[rsp]
	jmp	$LN1@IsConditio
$LN30@IsConditio:

; 769  : 		case ZYDIS_MNEMONIC_SETB: //set byte on condition - below/not above nor equal/carry
; 770  : 			return bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	jmp	$LN1@IsConditio
$LN31@IsConditio:

; 771  : 		case ZYDIS_MNEMONIC_SETBE: //set byte on condition - below or equal/not above
; 772  : 			return bCF || bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN92@IsConditio
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN92@IsConditio
	mov	DWORD PTR tv211[rsp], 0
	jmp	SHORT $LN93@IsConditio
$LN92@IsConditio:
	mov	DWORD PTR tv211[rsp], 1
$LN93@IsConditio:
	movzx	eax, BYTE PTR tv211[rsp]
	jmp	$LN1@IsConditio
$LN32@IsConditio:

; 773  : 		case ZYDIS_MNEMONIC_SETZ: //set byte on condition - equal/zero
; 774  : 			return bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	jmp	$LN1@IsConditio
$LN33@IsConditio:

; 775  : 		case ZYDIS_MNEMONIC_SETNLE: //set byte on condition - greater/not less nor equal
; 776  : 			return !bZF && bSF == bOF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN94@IsConditio
	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN94@IsConditio
	mov	DWORD PTR tv218[rsp], 1
	jmp	SHORT $LN95@IsConditio
$LN94@IsConditio:
	mov	DWORD PTR tv218[rsp], 0
$LN95@IsConditio:
	movzx	eax, BYTE PTR tv218[rsp]
	jmp	$LN1@IsConditio
$LN34@IsConditio:

; 777  : 		case ZYDIS_MNEMONIC_SETNL: //set byte on condition - greater or equal/not less
; 778  : 			return bSF == bOF;

	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN96@IsConditio
	mov	DWORD PTR tv223[rsp], 1
	jmp	SHORT $LN97@IsConditio
$LN96@IsConditio:
	mov	DWORD PTR tv223[rsp], 0
$LN97@IsConditio:
	movzx	eax, BYTE PTR tv223[rsp]
	jmp	$LN1@IsConditio
$LN35@IsConditio:

; 779  : 		case ZYDIS_MNEMONIC_SETL: //set byte on condition - less/not greater nor equal
; 780  : 			return bSF != bOF;

	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	je	SHORT $LN98@IsConditio
	mov	DWORD PTR tv228[rsp], 1
	jmp	SHORT $LN99@IsConditio
$LN98@IsConditio:
	mov	DWORD PTR tv228[rsp], 0
$LN99@IsConditio:
	movzx	eax, BYTE PTR tv228[rsp]
	jmp	$LN1@IsConditio
$LN36@IsConditio:

; 781  : 		case ZYDIS_MNEMONIC_SETLE: //set byte on condition - less or equal/not greater
; 782  : 			return bZF || bSF != bOF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN100@IsConditio
	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN100@IsConditio
	mov	DWORD PTR tv235[rsp], 0
	jmp	SHORT $LN101@IsConditio
$LN100@IsConditio:
	mov	DWORD PTR tv235[rsp], 1
$LN101@IsConditio:
	movzx	eax, BYTE PTR tv235[rsp]
	jmp	$LN1@IsConditio
$LN37@IsConditio:

; 783  : 		case ZYDIS_MNEMONIC_SETNZ: //set byte on condition - not equal/not zero
; 784  : 			return !bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN102@IsConditio
	mov	DWORD PTR tv239[rsp], 1
	jmp	SHORT $LN103@IsConditio
$LN102@IsConditio:
	mov	DWORD PTR tv239[rsp], 0
$LN103@IsConditio:
	movzx	eax, BYTE PTR tv239[rsp]
	jmp	$LN1@IsConditio
$LN38@IsConditio:

; 785  : 		case ZYDIS_MNEMONIC_SETNO: //set byte on condition - not overflow
; 786  : 			return !bOF;

	movzx	eax, BYTE PTR bOF$[rsp]
	test	eax, eax
	jne	SHORT $LN104@IsConditio
	mov	DWORD PTR tv243[rsp], 1
	jmp	SHORT $LN105@IsConditio
$LN104@IsConditio:
	mov	DWORD PTR tv243[rsp], 0
$LN105@IsConditio:
	movzx	eax, BYTE PTR tv243[rsp]
	jmp	SHORT $LN1@IsConditio
$LN39@IsConditio:

; 787  : 		case ZYDIS_MNEMONIC_SETNP: //set byte on condition - not parity/parity odd
; 788  : 			return !bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	test	eax, eax
	jne	SHORT $LN106@IsConditio
	mov	DWORD PTR tv247[rsp], 1
	jmp	SHORT $LN107@IsConditio
$LN106@IsConditio:
	mov	DWORD PTR tv247[rsp], 0
$LN107@IsConditio:
	movzx	eax, BYTE PTR tv247[rsp]
	jmp	SHORT $LN1@IsConditio
$LN40@IsConditio:

; 789  : 		case ZYDIS_MNEMONIC_SETNS: //set byte on condition - not sign
; 790  : 			return !bSF;

	movzx	eax, BYTE PTR bSF$[rsp]
	test	eax, eax
	jne	SHORT $LN108@IsConditio
	mov	DWORD PTR tv251[rsp], 1
	jmp	SHORT $LN109@IsConditio
$LN108@IsConditio:
	mov	DWORD PTR tv251[rsp], 0
$LN109@IsConditio:
	movzx	eax, BYTE PTR tv251[rsp]
	jmp	SHORT $LN1@IsConditio
$LN41@IsConditio:

; 791  : 		case ZYDIS_MNEMONIC_SETO: //set byte on condition - overflow
; 792  : 			return bOF;

	movzx	eax, BYTE PTR bOF$[rsp]
	jmp	SHORT $LN1@IsConditio
$LN42@IsConditio:

; 793  : 		case ZYDIS_MNEMONIC_SETP: //set byte on condition - parity/parity even
; 794  : 			return bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	jmp	SHORT $LN1@IsConditio
$LN43@IsConditio:

; 795  : 		case ZYDIS_MNEMONIC_SETS: //set byte on condition - sign
; 796  : 			return bSF;

	movzx	eax, BYTE PTR bSF$[rsp]
	jmp	SHORT $LN1@IsConditio
$LN44@IsConditio:

; 797  : 		default:
; 798  : 			return true;

	mov	al, 1
$LN1@IsConditio:

; 799  : 		}
; 800  : 	}

	add	rsp, 152				; 00000098H
	ret	0
	npad	1
$LN113@IsConditio:
	DD	$LN6@IsConditio
	DD	$LN7@IsConditio
	DD	$LN11@IsConditio
	DD	$LN12@IsConditio
	DD	$LN5@IsConditio
	DD	$LN4@IsConditio
	DD	$LN10@IsConditio
	DD	$LN9@IsConditio
	DD	$LN14@IsConditio
	DD	$LN15@IsConditio
	DD	$LN16@IsConditio
	DD	$LN13@IsConditio
	DD	$LN17@IsConditio
	DD	$LN18@IsConditio
	DD	$LN19@IsConditio
	DD	$LN8@IsConditio
	DD	$LN21@IsConditio
	DD	$LN20@IsConditio
	DD	$LN22@IsConditio
	DD	$LN24@IsConditio
	DD	$LN23@IsConditio
	DD	$LN25@IsConditio
	DD	$LN26@IsConditio
	DD	$LN27@IsConditio
	DD	$LN44@IsConditio
$LN112@IsConditio:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	16
	DB	17
	DB	18
	DB	19
	DB	20
	DB	21
	DB	22
	DB	23
	npad	1
$LN111@IsConditio:
	DD	$LN31@IsConditio
	DD	$LN35@IsConditio
	DD	$LN36@IsConditio
	DD	$LN29@IsConditio
	DD	$LN28@IsConditio
	DD	$LN34@IsConditio
	DD	$LN33@IsConditio
	DD	$LN38@IsConditio
	DD	$LN39@IsConditio
	DD	$LN40@IsConditio
	DD	$LN37@IsConditio
	DD	$LN41@IsConditio
	DD	$LN42@IsConditio
	DD	$LN43@IsConditio
	DD	$LN44@IsConditio
	DD	$LN32@IsConditio
?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z ENDP ; IronMan::Zydis::IsConditionalGoingToExecute
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
cflags$ = 56
ccx$ = 64
?IsConditionalGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z PROC ; IronMan::Zydis::IsConditionalGoingToExecute

; 702  : 	{

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 703  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsConditio

; 704  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsConditio
$LN2@IsConditio:

; 705  : 		return IsConditionalGoingToExecute(mInstr.mnemonic, cflags, ccx);

	mov	r8, QWORD PTR ccx$[rsp]
	mov	rdx, QWORD PTR cflags$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+4]
	call	?IsConditionalGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z ; IronMan::Zydis::IsConditionalGoingToExecute
$LN1@IsConditio:

; 706  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?IsConditionalGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z ENDP ; IronMan::Zydis::IsConditionalGoingToExecute
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
bZF$ = 0
bOF$ = 1
bSF$ = 2
bCF$ = 3
bPF$ = 4
tv84 = 8
tv66 = 12
tv70 = 16
tv74 = 20
tv78 = 24
tv82 = 28
tv87 = 32
tv93 = 36
tv131 = 40
tv134 = 44
tv139 = 48
tv146 = 52
tv153 = 56
tv158 = 60
tv162 = 64
tv166 = 68
tv170 = 72
tv174 = 76
tv177 = 80
tv182 = 84
tv187 = 88
id$ = 112
cflags$ = 120
ccx$ = 128
?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z PROC ; IronMan::Zydis::IsBranchGoingToExecute

; 642  : 	{

$LN74:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 643  : 		auto bCF = (cflags & (1 << 0)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN31@IsBranchGo
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN32@IsBranchGo
$LN31@IsBranchGo:
	mov	DWORD PTR tv66[rsp], 0
$LN32@IsBranchGo:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR bCF$[rsp], al

; 644  : 		auto bPF = (cflags & (1 << 2)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 4
	test	rax, rax
	je	SHORT $LN33@IsBranchGo
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN34@IsBranchGo
$LN33@IsBranchGo:
	mov	DWORD PTR tv70[rsp], 0
$LN34@IsBranchGo:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR bPF$[rsp], al

; 645  : 		auto bZF = (cflags & (1 << 6)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 64					; 00000040H
	test	rax, rax
	je	SHORT $LN35@IsBranchGo
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN36@IsBranchGo
$LN35@IsBranchGo:
	mov	DWORD PTR tv74[rsp], 0
$LN36@IsBranchGo:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR bZF$[rsp], al

; 646  : 		auto bSF = (cflags & (1 << 7)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 128				; 00000080H
	test	rax, rax
	je	SHORT $LN37@IsBranchGo
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN38@IsBranchGo
$LN37@IsBranchGo:
	mov	DWORD PTR tv78[rsp], 0
$LN38@IsBranchGo:
	movzx	eax, BYTE PTR tv78[rsp]
	mov	BYTE PTR bSF$[rsp], al

; 647  : 		auto bOF = (cflags & (1 << 11)) != 0;

	mov	rax, QWORD PTR cflags$[rsp]
	and	rax, 2048				; 00000800H
	test	rax, rax
	je	SHORT $LN39@IsBranchGo
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN40@IsBranchGo
$LN39@IsBranchGo:
	mov	DWORD PTR tv82[rsp], 0
$LN40@IsBranchGo:
	movzx	eax, BYTE PTR tv82[rsp]
	mov	BYTE PTR bOF$[rsp], al

; 648  : 		switch (id)

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR tv84[rsp], eax
	cmp	DWORD PTR tv84[rsp], 391		; 00000187H
	jg	SHORT $LN71@IsBranchGo
	cmp	DWORD PTR tv84[rsp], 391		; 00000187H
	je	$LN26@IsBranchGo
	mov	eax, DWORD PTR tv84[rsp]
	sub	eax, 59					; 0000003bH
	mov	DWORD PTR tv84[rsp], eax
	cmp	DWORD PTR tv84[rsp], 246		; 000000f6H
	ja	$LN29@IsBranchGo
	movsxd	rax, DWORD PTR tv84[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN72@IsBranchGo[rcx+rax]
	mov	eax, DWORD PTR $LN73@IsBranchGo[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN71@IsBranchGo:
	cmp	DWORD PTR tv84[rsp], 392		; 00000188H
	je	$LN27@IsBranchGo
	cmp	DWORD PTR tv84[rsp], 393		; 00000189H
	je	$LN28@IsBranchGo
	cmp	DWORD PTR tv84[rsp], 661		; 00000295H
	je	SHORT $LN6@IsBranchGo
	jmp	$LN29@IsBranchGo
$LN4@IsBranchGo:
$LN5@IsBranchGo:
$LN6@IsBranchGo:

; 649  : 		{
; 650  : 		case ZYDIS_MNEMONIC_CALL:
; 651  : 		case ZYDIS_MNEMONIC_JMP:
; 652  : 		case ZYDIS_MNEMONIC_RET:
; 653  : 			return true;

	mov	al, 1
	jmp	$LN1@IsBranchGo
$LN7@IsBranchGo:

; 654  : 		case ZYDIS_MNEMONIC_JNB: //jump short if above or equal
; 655  : 			return !bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN41@IsBranchGo
	mov	DWORD PTR tv87[rsp], 1
	jmp	SHORT $LN42@IsBranchGo
$LN41@IsBranchGo:
	mov	DWORD PTR tv87[rsp], 0
$LN42@IsBranchGo:
	movzx	eax, BYTE PTR tv87[rsp]
	jmp	$LN1@IsBranchGo
$LN8@IsBranchGo:

; 656  : 		case ZYDIS_MNEMONIC_JNBE: //jump short if above
; 657  : 			return !bCF && !bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN43@IsBranchGo
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN43@IsBranchGo
	mov	DWORD PTR tv93[rsp], 1
	jmp	SHORT $LN44@IsBranchGo
$LN43@IsBranchGo:
	mov	DWORD PTR tv93[rsp], 0
$LN44@IsBranchGo:
	movzx	eax, BYTE PTR tv93[rsp]
	jmp	$LN1@IsBranchGo
$LN9@IsBranchGo:

; 658  : 		case ZYDIS_MNEMONIC_JBE: //jump short if below or equal/not above
; 659  : 			return bCF || bZF;

	movzx	eax, BYTE PTR bCF$[rsp]
	test	eax, eax
	jne	SHORT $LN45@IsBranchGo
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN45@IsBranchGo
	mov	DWORD PTR tv131[rsp], 0
	jmp	SHORT $LN46@IsBranchGo
$LN45@IsBranchGo:
	mov	DWORD PTR tv131[rsp], 1
$LN46@IsBranchGo:
	movzx	eax, BYTE PTR tv131[rsp]
	jmp	$LN1@IsBranchGo
$LN10@IsBranchGo:

; 660  : 		case ZYDIS_MNEMONIC_JB: //jump short if below/not above nor equal/carry
; 661  : 			return bCF;

	movzx	eax, BYTE PTR bCF$[rsp]
	jmp	$LN1@IsBranchGo
$LN11@IsBranchGo:
$LN12@IsBranchGo:
$LN13@IsBranchGo:

; 662  : 		case ZYDIS_MNEMONIC_JCXZ: //jump short if ecx register is zero
; 663  : 		case ZYDIS_MNEMONIC_JECXZ: //jump short if ecx register is zero
; 664  : 		case ZYDIS_MNEMONIC_JRCXZ: //jump short if rcx register is zero
; 665  : 			return ccx == 0;

	cmp	QWORD PTR ccx$[rsp], 0
	jne	SHORT $LN47@IsBranchGo
	mov	DWORD PTR tv134[rsp], 1
	jmp	SHORT $LN48@IsBranchGo
$LN47@IsBranchGo:
	mov	DWORD PTR tv134[rsp], 0
$LN48@IsBranchGo:
	movzx	eax, BYTE PTR tv134[rsp]
	jmp	$LN1@IsBranchGo
$LN14@IsBranchGo:

; 666  : 		case ZYDIS_MNEMONIC_JZ: //jump short if equal
; 667  : 			return bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	jmp	$LN1@IsBranchGo
$LN15@IsBranchGo:

; 668  : 		case ZYDIS_MNEMONIC_JNL: //jump short if greater or equal
; 669  : 			return bSF == bOF;

	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN49@IsBranchGo
	mov	DWORD PTR tv139[rsp], 1
	jmp	SHORT $LN50@IsBranchGo
$LN49@IsBranchGo:
	mov	DWORD PTR tv139[rsp], 0
$LN50@IsBranchGo:
	movzx	eax, BYTE PTR tv139[rsp]
	jmp	$LN1@IsBranchGo
$LN16@IsBranchGo:

; 670  : 		case ZYDIS_MNEMONIC_JNLE: //jump short if greater
; 671  : 			return !bZF && bSF == bOF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN51@IsBranchGo
	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN51@IsBranchGo
	mov	DWORD PTR tv146[rsp], 1
	jmp	SHORT $LN52@IsBranchGo
$LN51@IsBranchGo:
	mov	DWORD PTR tv146[rsp], 0
$LN52@IsBranchGo:
	movzx	eax, BYTE PTR tv146[rsp]
	jmp	$LN1@IsBranchGo
$LN17@IsBranchGo:

; 672  : 		case ZYDIS_MNEMONIC_JLE: //jump short if less or equal/not greater
; 673  : 			return bZF || bSF != bOF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN53@IsBranchGo
	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN53@IsBranchGo
	mov	DWORD PTR tv153[rsp], 0
	jmp	SHORT $LN54@IsBranchGo
$LN53@IsBranchGo:
	mov	DWORD PTR tv153[rsp], 1
$LN54@IsBranchGo:
	movzx	eax, BYTE PTR tv153[rsp]
	jmp	$LN1@IsBranchGo
$LN18@IsBranchGo:

; 674  : 		case ZYDIS_MNEMONIC_JL: //jump short if less/not greater
; 675  : 			return bSF != bOF;

	movzx	eax, BYTE PTR bSF$[rsp]
	movzx	ecx, BYTE PTR bOF$[rsp]
	cmp	eax, ecx
	je	SHORT $LN55@IsBranchGo
	mov	DWORD PTR tv158[rsp], 1
	jmp	SHORT $LN56@IsBranchGo
$LN55@IsBranchGo:
	mov	DWORD PTR tv158[rsp], 0
$LN56@IsBranchGo:
	movzx	eax, BYTE PTR tv158[rsp]
	jmp	$LN1@IsBranchGo
$LN19@IsBranchGo:

; 676  : 		case ZYDIS_MNEMONIC_JNZ: //jump short if not equal/not zero
; 677  : 			return !bZF;

	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN57@IsBranchGo
	mov	DWORD PTR tv162[rsp], 1
	jmp	SHORT $LN58@IsBranchGo
$LN57@IsBranchGo:
	mov	DWORD PTR tv162[rsp], 0
$LN58@IsBranchGo:
	movzx	eax, BYTE PTR tv162[rsp]
	jmp	$LN1@IsBranchGo
$LN20@IsBranchGo:

; 678  : 		case ZYDIS_MNEMONIC_JNO: //jump short if not overflow
; 679  : 			return !bOF;

	movzx	eax, BYTE PTR bOF$[rsp]
	test	eax, eax
	jne	SHORT $LN59@IsBranchGo
	mov	DWORD PTR tv166[rsp], 1
	jmp	SHORT $LN60@IsBranchGo
$LN59@IsBranchGo:
	mov	DWORD PTR tv166[rsp], 0
$LN60@IsBranchGo:
	movzx	eax, BYTE PTR tv166[rsp]
	jmp	$LN1@IsBranchGo
$LN21@IsBranchGo:

; 680  : 		case ZYDIS_MNEMONIC_JNP: //jump short if not parity/parity odd
; 681  : 			return !bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	test	eax, eax
	jne	SHORT $LN61@IsBranchGo
	mov	DWORD PTR tv170[rsp], 1
	jmp	SHORT $LN62@IsBranchGo
$LN61@IsBranchGo:
	mov	DWORD PTR tv170[rsp], 0
$LN62@IsBranchGo:
	movzx	eax, BYTE PTR tv170[rsp]
	jmp	$LN1@IsBranchGo
$LN22@IsBranchGo:

; 682  : 		case ZYDIS_MNEMONIC_JNS: //jump short if not sign
; 683  : 			return !bSF;

	movzx	eax, BYTE PTR bSF$[rsp]
	test	eax, eax
	jne	SHORT $LN63@IsBranchGo
	mov	DWORD PTR tv174[rsp], 1
	jmp	SHORT $LN64@IsBranchGo
$LN63@IsBranchGo:
	mov	DWORD PTR tv174[rsp], 0
$LN64@IsBranchGo:
	movzx	eax, BYTE PTR tv174[rsp]
	jmp	$LN1@IsBranchGo
$LN23@IsBranchGo:

; 684  : 		case ZYDIS_MNEMONIC_JO: //jump short if overflow
; 685  : 			return bOF;

	movzx	eax, BYTE PTR bOF$[rsp]
	jmp	$LN1@IsBranchGo
$LN24@IsBranchGo:

; 686  : 		case ZYDIS_MNEMONIC_JP: //jump short if parity/parity even
; 687  : 			return bPF;

	movzx	eax, BYTE PTR bPF$[rsp]
	jmp	$LN1@IsBranchGo
$LN25@IsBranchGo:

; 688  : 		case ZYDIS_MNEMONIC_JS: //jump short if sign
; 689  : 			return bSF;

	movzx	eax, BYTE PTR bSF$[rsp]
	jmp	SHORT $LN1@IsBranchGo
$LN26@IsBranchGo:

; 690  : 		case ZYDIS_MNEMONIC_LOOP: //decrement count; jump short if ecx!=0
; 691  : 			return ccx != 0;

	cmp	QWORD PTR ccx$[rsp], 0
	je	SHORT $LN65@IsBranchGo
	mov	DWORD PTR tv177[rsp], 1
	jmp	SHORT $LN66@IsBranchGo
$LN65@IsBranchGo:
	mov	DWORD PTR tv177[rsp], 0
$LN66@IsBranchGo:
	movzx	eax, BYTE PTR tv177[rsp]
	jmp	SHORT $LN1@IsBranchGo
$LN27@IsBranchGo:

; 692  : 		case ZYDIS_MNEMONIC_LOOPE: //decrement count; jump short if ecx!=0 and zf=1
; 693  : 			return ccx != 0 && bZF;

	cmp	QWORD PTR ccx$[rsp], 0
	je	SHORT $LN67@IsBranchGo
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	je	SHORT $LN67@IsBranchGo
	mov	DWORD PTR tv182[rsp], 1
	jmp	SHORT $LN68@IsBranchGo
$LN67@IsBranchGo:
	mov	DWORD PTR tv182[rsp], 0
$LN68@IsBranchGo:
	movzx	eax, BYTE PTR tv182[rsp]
	jmp	SHORT $LN1@IsBranchGo
$LN28@IsBranchGo:

; 694  : 		case ZYDIS_MNEMONIC_LOOPNE: //decrement count; jump short if ecx!=0 and zf=0
; 695  : 			return ccx != 0 && !bZF;

	cmp	QWORD PTR ccx$[rsp], 0
	je	SHORT $LN69@IsBranchGo
	movzx	eax, BYTE PTR bZF$[rsp]
	test	eax, eax
	jne	SHORT $LN69@IsBranchGo
	mov	DWORD PTR tv187[rsp], 1
	jmp	SHORT $LN70@IsBranchGo
$LN69@IsBranchGo:
	mov	DWORD PTR tv187[rsp], 0
$LN70@IsBranchGo:
	movzx	eax, BYTE PTR tv187[rsp]
	jmp	SHORT $LN1@IsBranchGo
$LN29@IsBranchGo:

; 696  : 		default:
; 697  : 			return false;

	xor	al, al
$LN1@IsBranchGo:

; 698  : 		}
; 699  : 	}

	add	rsp, 104				; 00000068H
	ret	0
	npad	1
$LN73@IsBranchGo:
	DD	$LN4@IsBranchGo
	DD	$LN10@IsBranchGo
	DD	$LN9@IsBranchGo
	DD	$LN11@IsBranchGo
	DD	$LN12@IsBranchGo
	DD	$LN18@IsBranchGo
	DD	$LN17@IsBranchGo
	DD	$LN5@IsBranchGo
	DD	$LN7@IsBranchGo
	DD	$LN8@IsBranchGo
	DD	$LN15@IsBranchGo
	DD	$LN16@IsBranchGo
	DD	$LN20@IsBranchGo
	DD	$LN21@IsBranchGo
	DD	$LN22@IsBranchGo
	DD	$LN19@IsBranchGo
	DD	$LN23@IsBranchGo
	DD	$LN24@IsBranchGo
	DD	$LN13@IsBranchGo
	DD	$LN25@IsBranchGo
	DD	$LN14@IsBranchGo
	DD	$LN29@IsBranchGo
$LN72@IsBranchGo:
	DB	0
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	21
	DB	1
	DB	2
	DB	3
	DB	4
	DB	21
	DB	21
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	16
	DB	17
	DB	18
	DB	19
	DB	20
?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z ENDP ; IronMan::Zydis::IsBranchGoingToExecute
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
cflags$ = 56
ccx$ = 64
?IsBranchGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z PROC	; IronMan::Zydis::IsBranchGoingToExecute

; 635  : 	{

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 636  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsBranchGo

; 637  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsBranchGo
$LN2@IsBranchGo:

; 638  : 		return IsBranchGoingToExecute(mInstr.mnemonic, cflags, ccx);

	mov	r8, QWORD PTR ccx$[rsp]
	mov	rdx, QWORD PTR cflags$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+4]
	call	?IsBranchGoingToExecute@Zydis@IronMan@@SA_NW4ZydisMnemonic_@@_K1@Z ; IronMan::Zydis::IsBranchGoingToExecute
$LN1@IsBranchGo:

; 639  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?IsBranchGoingToExecute@Zydis@IronMan@@QEBA_N_K0@Z ENDP	; IronMan::Zydis::IsBranchGoingToExecute
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv70 = 32
op$ = 40
dest$ = 48
tv90 = 56
tv133 = 64
this$ = 96
opindex$ = 104
resolveReg$ = 112
?ResolveOpValue@Zydis@IronMan@@QEBA_KHAEBV?$function@$$A6A_KW4ZydisRegister_@@@Z@std@@@Z PROC ; IronMan::Zydis::ResolveOpValue

; 610  : 	{

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 611  : 		size_t dest = 0;

	mov	QWORD PTR dest$[rsp], 0

; 612  : 		const auto& op = mInstr.operands[opindex];

	movsxd	rax, DWORD PTR opindex$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR op$[rsp], rax

; 613  : 		switch (op.type)

	mov	rax, QWORD PTR op$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 1
	je	SHORT $LN5@ResolveOpV
	cmp	DWORD PTR tv70[rsp], 2
	je	SHORT $LN6@ResolveOpV
	cmp	DWORD PTR tv70[rsp], 4
	je	SHORT $LN4@ResolveOpV
	jmp	$LN9@ResolveOpV
$LN4@ResolveOpV:

; 614  : 		{
; 615  : 		case ZYDIS_OPERAND_TYPE_IMMEDIATE:
; 616  : 			dest = size_t(op.imm.value.u);

	mov	rax, QWORD PTR op$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR dest$[rsp], rax

; 617  : 			break;

	jmp	$LN2@ResolveOpV
$LN5@ResolveOpV:

; 618  : 		case ZYDIS_OPERAND_TYPE_REGISTER:
; 619  : 			dest = resolveReg(op.reg.value);

	mov	rax, QWORD PTR op$[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR resolveReg$[rsp]
	call	??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::operator()
	mov	QWORD PTR dest$[rsp], rax

; 620  : 			break;

	jmp	$LN2@ResolveOpV
$LN6@ResolveOpV:

; 621  : 		case ZYDIS_OPERAND_TYPE_MEMORY:
; 622  : 			dest = size_t(op.mem.disp.value);

	mov	rax, QWORD PTR op$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR dest$[rsp], rax

; 623  : 			if (op.mem.base == ZYDIS_REGISTER_RIP) //rip-relative

	mov	rax, QWORD PTR op$[rsp]
	cmp	DWORD PTR [rax+48], 189			; 000000bdH
	jne	SHORT $LN7@ResolveOpV

; 624  : 				dest += Address() + Size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Address@Zydis@IronMan@@QEBA_KXZ	; IronMan::Zydis::Address
	mov	QWORD PTR tv90[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Size@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::Size
	cdqe
	add	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	add	rax, rcx
	mov	QWORD PTR dest$[rsp], rax
	jmp	SHORT $LN8@ResolveOpV
$LN7@ResolveOpV:

; 625  : 			else
; 626  : 				dest += resolveReg(op.mem.base) + resolveReg(op.mem.index) * op.mem.scale;

	mov	rax, QWORD PTR op$[rsp]
	mov	edx, DWORD PTR [rax+48]
	mov	rcx, QWORD PTR resolveReg$[rsp]
	call	??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::operator()
	mov	QWORD PTR tv133[rsp], rax
	mov	rcx, QWORD PTR op$[rsp]
	mov	edx, DWORD PTR [rcx+52]
	mov	rcx, QWORD PTR resolveReg$[rsp]
	call	??R?$_Func_class@_KW4ZydisRegister_@@@std@@QEBA_KW4ZydisRegister_@@@Z ; std::_Func_class<unsigned __int64,enum ZydisRegister_>::operator()
	mov	rcx, QWORD PTR op$[rsp]
	movzx	ecx, BYTE PTR [rcx+56]
	imul	rax, rcx
	add	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	add	rax, rcx
	mov	QWORD PTR dest$[rsp], rax
$LN8@ResolveOpV:
$LN9@ResolveOpV:
$LN2@ResolveOpV:

; 627  : 			break;
; 628  : 		default:
; 629  : 			break;
; 630  : 		}
; 631  : 		return dest;

	mov	rax, QWORD PTR dest$[rsp]

; 632  : 	}

	add	rsp, 88					; 00000058H
	ret	0
?ResolveOpValue@Zydis@IronMan@@QEBA_KHAEBV?$function@$$A6A_KW4ZydisRegister_@@@Z@std@@@Z ENDP ; IronMan::Zydis::ResolveOpValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
?BranchDestination@Zydis@IronMan@@QEBA_KXZ PROC		; IronMan::Zydis::BranchDestination

; 600  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 601  : 		if (!Success()
; 602  : 			|| mInstr.operands[0].type != ZYDIS_OPERAND_TYPE_IMMEDIATE

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@BranchDest
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rcx+rax+36], 4
	je	SHORT $LN2@BranchDest
$LN3@BranchDest:

; 603  : 			/*|| !mInstr.operands[0].imm.isRelative HACKED*/)
; 604  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@BranchDest
$LN2@BranchDest:

; 605  : 
; 606  : 		return size_t(mInstr.operands[0].imm.value.u);

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax+128]
$LN1@BranchDest:

; 607  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?BranchDestination@Zydis@IronMan@@QEBA_KXZ ENDP		; IronMan::Zydis::BranchDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv64 = 0
this$ = 32
size$ = 40
?MemSizeName@Zydis@IronMan@@QEBAPEBDH@Z PROC		; IronMan::Zydis::MemSizeName

; 569  : 	{

$LN19:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 570  : 		switch (size)

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	mov	eax, DWORD PTR tv64[rsp]
	dec	eax
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 63			; 0000003fH
	ja	$LN15@MemSizeNam
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN17@MemSizeNam[rcx+rax]
	mov	eax, DWORD PTR $LN18@MemSizeNam[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@MemSizeNam:

; 571  : 		{
; 572  : 		case 1:
; 573  : 			return "byte";

	lea	rax, OFFSET FLAT:??_C@_04IHGKJMLH@byte@
	jmp	SHORT $LN1@MemSizeNam
$LN5@MemSizeNam:

; 574  : 		case 2:
; 575  : 			return "word";

	lea	rax, OFFSET FLAT:??_C@_04EHIOMBPF@word@
	jmp	SHORT $LN1@MemSizeNam
$LN6@MemSizeNam:

; 576  : 		case 4:
; 577  : 			return "dword";

	lea	rax, OFFSET FLAT:??_C@_05KDALNKAH@dword@
	jmp	SHORT $LN1@MemSizeNam
$LN7@MemSizeNam:

; 578  : 		case 6:
; 579  : 			return "fword";

	lea	rax, OFFSET FLAT:??_C@_05OOMDHLAM@fword@
	jmp	SHORT $LN1@MemSizeNam
$LN8@MemSizeNam:

; 580  : 		case 8:
; 581  : 			return "qword";

	lea	rax, OFFSET FLAT:??_C@_05PABAEJCP@qword@
	jmp	SHORT $LN1@MemSizeNam
$LN9@MemSizeNam:

; 582  : 		case 10:
; 583  : 			return "tword";

	lea	rax, OFFSET FLAT:??_C@_05KANNNIJM@tword@
	jmp	SHORT $LN1@MemSizeNam
$LN10@MemSizeNam:

; 584  : 		case 14:
; 585  : 			return "m14";

	lea	rax, OFFSET FLAT:??_C@_03IJHEHDGN@m14@
	jmp	SHORT $LN1@MemSizeNam
$LN11@MemSizeNam:

; 586  : 		case 16:
; 587  : 			return "xmmword";

	lea	rax, OFFSET FLAT:??_C@_07MFDAFCAF@xmmword@
	jmp	SHORT $LN1@MemSizeNam
$LN12@MemSizeNam:

; 588  : 		case 28:
; 589  : 			return "m28";

	lea	rax, OFFSET FLAT:??_C@_03CHIHICDI@m28@
	jmp	SHORT $LN1@MemSizeNam
$LN13@MemSizeNam:

; 590  : 		case 32:
; 591  : 			return "yword";

	lea	rax, OFFSET FLAT:??_C@_05BMEDMLEC@yword@
	jmp	SHORT $LN1@MemSizeNam
$LN14@MemSizeNam:

; 592  : 		case 64:
; 593  : 			return "zword";

	lea	rax, OFFSET FLAT:??_C@_05JKNHLJOM@zword@
	jmp	SHORT $LN1@MemSizeNam
$LN15@MemSizeNam:

; 594  : 		default:
; 595  : 			return nullptr;

	xor	eax, eax
$LN1@MemSizeNam:

; 596  : 		}
; 597  : 	}

	add	rsp, 24
	ret	0
	npad	1
$LN18@MemSizeNam:
	DD	$LN4@MemSizeNam
	DD	$LN5@MemSizeNam
	DD	$LN6@MemSizeNam
	DD	$LN7@MemSizeNam
	DD	$LN8@MemSizeNam
	DD	$LN9@MemSizeNam
	DD	$LN10@MemSizeNam
	DD	$LN11@MemSizeNam
	DD	$LN12@MemSizeNam
	DD	$LN13@MemSizeNam
	DD	$LN14@MemSizeNam
	DD	$LN15@MemSizeNam
$LN17@MemSizeNam:
	DB	0
	DB	1
	DB	11
	DB	2
	DB	11
	DB	3
	DB	11
	DB	4
	DB	11
	DB	5
	DB	11
	DB	11
	DB	11
	DB	6
	DB	11
	DB	7
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	8
	DB	11
	DB	11
	DB	11
	DB	9
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	10
?MemSizeName@Zydis@IronMan@@QEBAPEBDH@Z ENDP		; IronMan::Zydis::MemSizeName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Zydis::Mnemonic

; 561  : 	{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 562  : 		return "???";

	lea	rdx, OFFSET FLAT:??_C@_03BBKEAIF@?$DP?$DP?$DP@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Mnemonic

; 563  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@Mnemonic

; 564  : 			return "???";

	lea	rdx, OFFSET FLAT:??_C@_03BBKEAIF@?$DP?$DP?$DP@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Mnemonic:

; 565  : 		//return ZydisMnemonicGetStringHook(mInstr.mnemonic);
; 566  : 	}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
?Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Zydis::Mnemonic
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Zydis::Mnemonic'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Mnemonic@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Zydis::Mnemonic'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv135 = 32
tv133 = 36
tv142 = 40
tv141 = 48
tv131 = 56
$T1 = 64
__$ArrayPad$ = 96
this$ = 128
index$ = 136
??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z PROC ; IronMan::Zydis::operator[]

; 386  : 	{

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 387  : 		if (!Success() || index < 0 || index >= OpCount())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	cmp	DWORD PTR index$[rsp], 0
	jl	SHORT $LN3@operator
	mov	rcx, QWORD PTR this$[rsp]
	call	?OpCount@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::OpCount
	cmp	DWORD PTR index$[rsp], eax
	jl	$LN2@operator
$LN3@operator:

; 388  : 		{
; 389  : 			CONSOLE_INFO("%d|%d|%d", Success(), index, OpCount());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	mov	rcx, QWORD PTR this$[rsp]
	call	?OpCount@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::OpCount
	mov	DWORD PTR tv135[rsp], eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	mov	DWORD PTR tv133[rsp], eax
	lea	r8, OFFSET FLAT:??_C@_08ILNEEICH@?$CFd?$HM?$CFd?$HM?$CFd@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T1[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR tv142[rsp]
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR tv141[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv131[rsp], rax
	mov	r9d, DWORD PTR tv135[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	edx, DWORD PTR tv133[rsp]
	mov	rcx, QWORD PTR tv131[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 390  : 			DebugBreak();

	call	QWORD PTR __imp_DebugBreak
	npad	1
$LN2@operator:

; 391  : 		}
; 392  : 		return mInstr.operands[index];

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]

; 393  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
??AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z ENDP ; IronMan::Zydis::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv135 = 32
tv133 = 36
tv142 = 40
tv141 = 48
tv131 = 56
$T1 = 64
__$ArrayPad$ = 96
this$ = 128
index$ = 136
?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA PROC ; `IronMan::Zydis::operator[]'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???AZydis@IronMan@@QEBAAEBUZydisDecodedOperand_@@H@Z@4HA ENDP ; `IronMan::Zydis::operator[]'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
?OpCount@Zydis@IronMan@@QEBAHXZ PROC			; IronMan::Zydis::OpCount

; 379  : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 380  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@OpCount

; 381  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@OpCount
$LN2@OpCount:

; 382  : 		return mVisibleOpCount;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1729]
$LN1@OpCount:

; 383  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?OpCount@Zydis@IronMan@@QEBAHXZ ENDP			; IronMan::Zydis::OpCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
ripPlus$1 = 32
$T2 = 36
found$3 = 40
offset$4 = 48
wVA$5 = 56
tv165 = 64
end$6 = 72
tv128 = 80
tv187 = 88
tv136 = 96
tv158 = 104
dest$7 = 112
result$ = 120
ripStr$8 = 152
$T9 = 184
buf$10 = 216
__$ArrayPad$ = 240
this$ = 272
__$ReturnUdt$ = 280
replaceRipRelative$ = 288
?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; IronMan::Zydis::InstructionText

; 343  : 	{

$LN14:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 344  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Instructio

; 345  : 			return "???";

	lea	rdx, OFFSET FLAT:??_C@_03BBKEAIF@?$DP?$DP?$DP@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Instructio
$LN2@Instructio:

; 346  : 
; 347  : 		std::string result = mInstrText;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1472				; 000005c0H
	mov	rdx, rax
	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 348  : #ifdef _WIN64
; 349  : 		// TODO (ath): We can do that a whole lot sexier using formatter hooks
; 350  : 		if (replaceRipRelative)

	movzx	eax, BYTE PTR replaceRipRelative$[rsp]
	test	eax, eax
	je	$LN3@Instructio

; 351  : 		{
; 352  : 			//replace [rip +/- 0x?] with the actual address
; 353  : 			bool ripPlus = true;

	mov	BYTE PTR ripPlus$1[rsp], 1

; 354  : 			auto found = result.find("[rip + ");

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_07DOOBJCME@?$FLrip?5?$CL?5@
	lea	rcx, QWORD PTR result$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR found$3[rsp], rax

; 355  : 			if (found == std::string::npos)

	cmp	QWORD PTR found$3[rsp], -1
	jne	SHORT $LN4@Instructio

; 356  : 			{
; 357  : 				ripPlus = false;

	mov	BYTE PTR ripPlus$1[rsp], 0

; 358  : 				found = result.find("[rip - ");

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_07DKGMOOHG@?$FLrip?5?9?5@
	lea	rcx, QWORD PTR result$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR found$3[rsp], rax
$LN4@Instructio:

; 359  : 			}
; 360  : 			if (found != std::string::npos)

	cmp	QWORD PTR found$3[rsp], -1
	je	$LN3@Instructio

; 361  : 			{
; 362  : 				auto wVA = Address();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Address@Zydis@IronMan@@QEBA_KXZ	; IronMan::Zydis::Address
	mov	QWORD PTR wVA$5[rsp], rax

; 363  : 				auto end = result.find("]", found);

	mov	r8, QWORD PTR found$3[rsp]
	lea	rdx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN@
	lea	rcx, QWORD PTR result$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	mov	QWORD PTR end$6[rsp], rax

; 364  : 				auto ripStr = result.substr(found + 1, end - found - 1);

	mov	rax, QWORD PTR found$3[rsp]
	mov	rcx, QWORD PTR end$6[rsp]
	sub	rcx, rax
	mov	rax, rcx
	dec	rax
	mov	rcx, QWORD PTR found$3[rsp]
	inc	rcx
	mov	r9, rax
	mov	r8, rcx
	lea	rdx, QWORD PTR ripStr$8[rsp]
	lea	rcx, QWORD PTR result$[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	npad	1

; 365  : 				uint64_t offset;
; 366  : 				sscanf_s(ripStr.substr(ripStr.rfind(' ') + 1).c_str(), "%llX", &offset);

	mov	r8, -1
	mov	dl, 32					; 00000020H
	lea	rcx, QWORD PTR ripStr$8[rsp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
	inc	rax
	mov	r9, -1
	mov	r8, rax
	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, QWORD PTR ripStr$8[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	QWORD PTR tv128[rsp], rax
	mov	rax, QWORD PTR tv128[rsp]
	mov	QWORD PTR tv187[rsp], rax
	mov	rcx, QWORD PTR tv187[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	lea	r8, QWORD PTR offset$4[rsp]
	lea	rdx, OFFSET FLAT:??_C@_04HCKDAFDF@?$CFllX@
	mov	rcx, rax
	call	sscanf_s
	npad	1
	lea	rcx, QWORD PTR $T9[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 367  : 				auto dest = ripPlus ? (wVA + offset + Size()) : (wVA - offset + Size());

	movzx	eax, BYTE PTR ripPlus$1[rsp]
	test	eax, eax
	je	SHORT $LN7@Instructio
	mov	rax, QWORD PTR offset$4[rsp]
	mov	rcx, QWORD PTR wVA$5[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv136[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Size@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::Size
	cdqe
	mov	rcx, QWORD PTR tv136[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv165[rsp], rax
	jmp	SHORT $LN8@Instructio
$LN7@Instructio:
	mov	rax, QWORD PTR offset$4[rsp]
	mov	rcx, QWORD PTR wVA$5[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv158[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Size@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::Size
	cdqe
	mov	rcx, QWORD PTR tv158[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv165[rsp], rax
$LN8@Instructio:
	mov	rax, QWORD PTR tv165[rsp]
	mov	QWORD PTR dest$7[rsp], rax

; 368  : 				char buf[20];
; 369  : 				sprintf_s(buf, "0x%llx", dest);

	mov	r8, QWORD PTR dest$7[rsp]
	lea	rdx, OFFSET FLAT:??_C@_06PDHLCDAK@0x?$CFllx@
	lea	rcx, QWORD PTR buf$10[rsp]
	call	??$sprintf_s@$0BE@@@YAHAEAY0BE@DPEBDZZ	; sprintf_s<20>

; 370  : 				result.replace(found + 1, ripStr.length(), buf);

	lea	rcx, QWORD PTR ripStr$8[rsp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	mov	rcx, QWORD PTR found$3[rsp]
	inc	rcx
	lea	r9, QWORD PTR buf$10[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR result$[rsp]
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
	npad	1

; 371  : 			}

	lea	rcx, QWORD PTR ripStr$8[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN3@Instructio:

; 372  : 		}
; 373  : #endif //_WIN64
; 374  : 
; 375  : 		return result;

	lea	rdx, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	lea	rcx, QWORD PTR result$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Instructio:

; 376  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	ret	0
	int	3
?InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; IronMan::Zydis::InstructionText
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
ripPlus$1 = 32
$T2 = 36
found$3 = 40
offset$4 = 48
wVA$5 = 56
tv165 = 64
end$6 = 72
tv128 = 80
tv187 = 88
tv136 = 96
tv158 = 104
dest$7 = 112
result$ = 120
ripStr$8 = 152
$T9 = 184
buf$10 = 216
__$ArrayPad$ = 240
this$ = 272
__$ReturnUdt$ = 280
replaceRipRelative$ = 288
?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA PROC ; `IronMan::Zydis::InstructionText'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA ENDP ; `IronMan::Zydis::InstructionText'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
ripPlus$1 = 32
$T2 = 36
found$3 = 40
offset$4 = 48
wVA$5 = 56
tv165 = 64
end$6 = 72
tv128 = 80
tv187 = 88
tv136 = 96
tv158 = 104
dest$7 = 112
result$ = 120
ripStr$8 = 152
$T9 = 184
buf$10 = 216
__$ArrayPad$ = 240
this$ = 272
__$ReturnUdt$ = 280
replaceRipRelative$ = 288
?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA PROC ; `IronMan::Zydis::InstructionText'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR result$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA ENDP ; `IronMan::Zydis::InstructionText'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
ripPlus$1 = 32
$T2 = 36
found$3 = 40
offset$4 = 48
wVA$5 = 56
tv165 = 64
end$6 = 72
tv128 = 80
tv187 = 88
tv136 = 96
tv158 = 104
dest$7 = 112
result$ = 120
ripStr$8 = 152
$T9 = 184
buf$10 = 216
__$ArrayPad$ = 240
this$ = 272
__$ReturnUdt$ = 280
replaceRipRelative$ = 288
?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA PROC ; `IronMan::Zydis::InstructionText'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR ripStr$8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA ENDP ; `IronMan::Zydis::InstructionText'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
ripPlus$1 = 32
$T2 = 36
found$3 = 40
offset$4 = 48
wVA$5 = 56
tv165 = 64
end$6 = 72
tv128 = 80
tv187 = 88
tv136 = 96
tv158 = 104
dest$7 = 112
result$ = 120
ripStr$8 = 152
$T9 = 184
buf$10 = 216
__$ArrayPad$ = 240
this$ = 272
__$ReturnUdt$ = 280
replaceRipRelative$ = 288
?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA PROC ; `IronMan::Zydis::InstructionText'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T9[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??InstructionText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z@4HA ENDP ; `IronMan::Zydis::InstructionText'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ PROC	; IronMan::Zydis::GetId

; 336  : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 337  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetId

; 338  : 			DebugBreak();

	call	QWORD PTR __imp_DebugBreak
	npad	1
$LN2@GetId:

; 339  : 		return mInstr.mnemonic;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]

; 340  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?GetId@Zydis@IronMan@@QEBA?AW4ZydisMnemonic_@@XZ ENDP	; IronMan::Zydis::GetId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv71 = 32
this$ = 64
?IsPushPop@Zydis@IronMan@@QEBA_NXZ PROC			; IronMan::Zydis::IsPushPop

; 527  : 	{

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 528  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsPushPop

; 529  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsPushPop
$LN4@IsPushPop:

; 530  : 
; 531  : 		switch (mInstr.meta.category)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+1200]
	mov	DWORD PTR tv71[rsp], eax
	cmp	DWORD PTR tv71[rsp], 57			; 00000039H
	je	SHORT $LN6@IsPushPop
	cmp	DWORD PTR tv71[rsp], 61			; 0000003dH
	je	SHORT $LN5@IsPushPop
	jmp	SHORT $LN7@IsPushPop
$LN5@IsPushPop:
$LN6@IsPushPop:

; 532  : 		{
; 533  : 		case ZYDIS_CATEGORY_PUSH:
; 534  : 		case ZYDIS_CATEGORY_POP:
; 535  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsPushPop
$LN7@IsPushPop:

; 536  : 		default:
; 537  : 			return false;

	xor	al, al
$LN1@IsPushPop:

; 538  : 		}
; 539  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsPushPop@Zydis@IronMan@@QEBA_NXZ ENDP			; IronMan::Zydis::IsPushPop
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv72 = 32
ops$ = 40
tv128 = 48
reg$1 = 52
tv159 = 56
tv177 = 60
tv195 = 64
tv219 = 68
tv171 = 72
tv165 = 80
mem$2 = 88
__$ArrayPad$ = 128
this$ = 176
?IsNop@Zydis@IronMan@@QEBA_NXZ PROC			; IronMan::Zydis::IsNop

; 428  : 	{

$LN82:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 429  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsNop

; 430  : 			return false;

	xor	al, al
	jmp	$LN1@IsNop
$LN4@IsNop:

; 431  : 
; 432  : 		const auto& ops = mInstr.operands;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR ops$[rsp], rax

; 433  : 
; 434  : 		switch (mInstr.mnemonic)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv72[rsp], eax
	cmp	DWORD PTR tv72[rsp], 376		; 00000178H
	jg	SHORT $LN75@IsNop
	cmp	DWORD PTR tv72[rsp], 376		; 00000178H
	je	$LN30@IsNop
	mov	eax, DWORD PTR tv72[rsp]
	sub	eax, 78					; 0000004eH
	mov	DWORD PTR tv72[rsp], eax
	cmp	DWORD PTR tv72[rsp], 227		; 000000e3H
	ja	$LN60@IsNop
	movsxd	rax, DWORD PTR tv72[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN80@IsNop[rcx+rax]
	mov	eax, DWORD PTR $LN81@IsNop[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN75@IsNop:
	cmp	DWORD PTR tv72[rsp], 662		; 00000296H
	jg	SHORT $LN76@IsNop
	cmp	DWORD PTR tv72[rsp], 662		; 00000296H
	je	$LN55@IsNop
	mov	eax, DWORD PTR tv72[rsp]
	sub	eax, 414				; 0000019eH
	mov	DWORD PTR tv72[rsp], eax
	cmp	DWORD PTR tv72[rsp], 78			; 0000004eH
	ja	$LN60@IsNop
	movsxd	rax, DWORD PTR tv72[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN78@IsNop[rcx+rax]
	mov	eax, DWORD PTR $LN79@IsNop[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN76@IsNop:
	cmp	DWORD PTR tv72[rsp], 710		; 000002c6H
	jg	SHORT $LN77@IsNop
	cmp	DWORD PTR tv72[rsp], 710		; 000002c6H
	je	$LN58@IsNop
	cmp	DWORD PTR tv72[rsp], 663		; 00000297H
	je	$LN56@IsNop
	cmp	DWORD PTR tv72[rsp], 675		; 000002a3H
	je	$LN57@IsNop
	cmp	DWORD PTR tv72[rsp], 709		; 000002c5H
	je	$LN53@IsNop
	jmp	$LN60@IsNop
$LN77@IsNop:
	cmp	DWORD PTR tv72[rsp], 712		; 000002c8H
	je	$LN54@IsNop
	cmp	DWORD PTR tv72[rsp], 713		; 000002c9H
	je	$LN59@IsNop
	cmp	DWORD PTR tv72[rsp], 1569		; 00000621H
	je	SHORT $LN29@IsNop
	jmp	$LN60@IsNop
$LN5@IsNop:
$LN6@IsNop:
$LN7@IsNop:

; 435  : 		{
; 436  : 		case ZYDIS_MNEMONIC_NOP:
; 437  : 		case ZYDIS_MNEMONIC_PAUSE:
; 438  : 		case ZYDIS_MNEMONIC_FNOP:
; 439  : 			// nop
; 440  : 			return true;

	mov	al, 1
	jmp	$LN1@IsNop
$LN8@IsNop:
$LN9@IsNop:
$LN10@IsNop:
$LN11@IsNop:
$LN12@IsNop:
$LN13@IsNop:
$LN14@IsNop:
$LN15@IsNop:
$LN16@IsNop:
$LN17@IsNop:
$LN18@IsNop:
$LN19@IsNop:
$LN20@IsNop:
$LN21@IsNop:
$LN22@IsNop:
$LN23@IsNop:
$LN24@IsNop:
$LN25@IsNop:
$LN26@IsNop:
$LN27@IsNop:
$LN28@IsNop:
$LN29@IsNop:

; 441  : 		case ZYDIS_MNEMONIC_MOV:
; 442  : 		case ZYDIS_MNEMONIC_CMOVB:
; 443  : 		case ZYDIS_MNEMONIC_CMOVBE:
; 444  : 		case ZYDIS_MNEMONIC_CMOVL:
; 445  : 		case ZYDIS_MNEMONIC_CMOVLE:
; 446  : 		case ZYDIS_MNEMONIC_CMOVNB:
; 447  : 		case ZYDIS_MNEMONIC_CMOVNBE:
; 448  : 		case ZYDIS_MNEMONIC_CMOVNL:
; 449  : 		case ZYDIS_MNEMONIC_CMOVNLE:
; 450  : 		case ZYDIS_MNEMONIC_CMOVNO:
; 451  : 		case ZYDIS_MNEMONIC_CMOVNP:
; 452  : 		case ZYDIS_MNEMONIC_CMOVNS:
; 453  : 		case ZYDIS_MNEMONIC_CMOVNZ:
; 454  : 		case ZYDIS_MNEMONIC_CMOVO:
; 455  : 		case ZYDIS_MNEMONIC_CMOVP:
; 456  : 		case ZYDIS_MNEMONIC_CMOVS:
; 457  : 		case ZYDIS_MNEMONIC_CMOVZ:
; 458  : 		case ZYDIS_MNEMONIC_MOVAPS:
; 459  : 		case ZYDIS_MNEMONIC_MOVAPD:
; 460  : 		case ZYDIS_MNEMONIC_MOVUPS:
; 461  : 		case ZYDIS_MNEMONIC_MOVUPD:
; 462  : 		case ZYDIS_MNEMONIC_XCHG:
; 463  : 			// mov edi, edi
; 464  : 			return ops[0].type == ZYDIS_OPERAND_TYPE_REGISTER

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 1
	jne	SHORT $LN62@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 1
	jne	SHORT $LN62@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	ecx, 104				; 00000068H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR ops$[rsp]
	mov	r8, QWORD PTR ops$[rsp]
	mov	ecx, DWORD PTR [r8+rcx+32]
	cmp	DWORD PTR [rdx+rax+32], ecx
	jne	SHORT $LN62@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z ; IronMan::isSafe64NopRegOp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN62@IsNop
	mov	DWORD PTR tv128[rsp], 1
	jmp	SHORT $LN63@IsNop
$LN62@IsNop:
	mov	DWORD PTR tv128[rsp], 0
$LN63@IsNop:
	movzx	eax, BYTE PTR tv128[rsp]
	jmp	$LN1@IsNop
$LN30@IsNop:

; 465  : 				&& ops[1].type == ZYDIS_OPERAND_TYPE_REGISTER
; 466  : 				&& ops[0].reg.value == ops[1].reg.value
; 467  : 				&& isSafe64NopRegOp(ops[0]);
; 468  : 		case ZYDIS_MNEMONIC_LEA:
; 469  : 		{
; 470  : 			// lea eax, [eax + 0]
; 471  : 			auto reg = ops[0].reg.value;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR reg$1[rsp], eax

; 472  : 			auto mem = ops[1].mem;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	lea	rcx, QWORD PTR mem$2[rsp]
	mov	rdx, QWORD PTR ops$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+40]
	mov	ecx, 40					; 00000028H
	rep movsb

; 473  : 			return ops[0].type == ZYDIS_OPERAND_TYPE_REGISTER

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 1
	jne	SHORT $LN64@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 1
	jne	SHORT $LN64@IsNop
	cmp	QWORD PTR mem$2[rsp+32], 0
	jne	SHORT $LN64@IsNop
	cmp	DWORD PTR mem$2[rsp+12], 0
	jne	SHORT $LN65@IsNop
	mov	eax, DWORD PTR reg$1[rsp]
	cmp	DWORD PTR mem$2[rsp+8], eax
	je	SHORT $LN67@IsNop
$LN65@IsNop:
	mov	eax, DWORD PTR reg$1[rsp]
	cmp	DWORD PTR mem$2[rsp+12], eax
	jne	SHORT $LN66@IsNop
	cmp	DWORD PTR mem$2[rsp+8], 0
	jne	SHORT $LN66@IsNop
	movzx	eax, BYTE PTR mem$2[rsp+16]
	cmp	eax, 1
	jne	SHORT $LN64@IsNop
$LN67@IsNop:
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z ; IronMan::isSafe64NopRegOp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN64@IsNop
	mov	DWORD PTR tv159[rsp], 1
	jmp	SHORT $LN68@IsNop
$LN64@IsNop:
$LN66@IsNop:
	mov	DWORD PTR tv159[rsp], 0
$LN68@IsNop:
	movzx	eax, BYTE PTR tv159[rsp]
	jmp	$LN1@IsNop
$LN31@IsNop:
$LN32@IsNop:
$LN33@IsNop:
$LN34@IsNop:
$LN35@IsNop:
$LN36@IsNop:
$LN37@IsNop:
$LN38@IsNop:
$LN39@IsNop:
$LN40@IsNop:
$LN41@IsNop:
$LN42@IsNop:
$LN43@IsNop:
$LN44@IsNop:
$LN45@IsNop:
$LN46@IsNop:
$LN47@IsNop:
$LN48@IsNop:
$LN49@IsNop:
$LN50@IsNop:
$LN51@IsNop:
$LN52@IsNop:

; 474  : 				&& ops[1].type == ZYDIS_OPERAND_TYPE_REGISTER
; 475  : 				&& mem.disp.value == 0
; 476  : 				&& ((mem.index == ZYDIS_REGISTER_NONE && mem.base == reg) ||
; 477  : 					(mem.index == reg && mem.base == ZYDIS_REGISTER_NONE && mem.scale == 1))
; 478  : 				&& isSafe64NopRegOp(ops[0]);
; 479  : 		}
; 480  : 		case ZYDIS_MNEMONIC_JB:
; 481  : 		case ZYDIS_MNEMONIC_JBE:
; 482  : 		case ZYDIS_MNEMONIC_JCXZ:
; 483  : 		case ZYDIS_MNEMONIC_JECXZ:
; 484  : 		case ZYDIS_MNEMONIC_JKNZD:
; 485  : 		case ZYDIS_MNEMONIC_JKZD:
; 486  : 		case ZYDIS_MNEMONIC_JL:
; 487  : 		case ZYDIS_MNEMONIC_JLE:
; 488  : 		case ZYDIS_MNEMONIC_JMP:
; 489  : 		case ZYDIS_MNEMONIC_JNB:
; 490  : 		case ZYDIS_MNEMONIC_JNBE:
; 491  : 		case ZYDIS_MNEMONIC_JNL:
; 492  : 		case ZYDIS_MNEMONIC_JNLE:
; 493  : 		case ZYDIS_MNEMONIC_JNO:
; 494  : 		case ZYDIS_MNEMONIC_JNP:
; 495  : 		case ZYDIS_MNEMONIC_JNS:
; 496  : 		case ZYDIS_MNEMONIC_JNZ:
; 497  : 		case ZYDIS_MNEMONIC_JO:
; 498  : 		case ZYDIS_MNEMONIC_JP:
; 499  : 		case ZYDIS_MNEMONIC_JRCXZ:
; 500  : 		case ZYDIS_MNEMONIC_JS:
; 501  : 		case ZYDIS_MNEMONIC_JZ:
; 502  : 			// jmp 0
; 503  : 			return ops[0].type == ZYDIS_OPERAND_TYPE_IMMEDIATE

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 4
	jne	SHORT $LN69@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	QWORD PTR tv165[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Address@Zydis@IronMan@@QEBA_KXZ	; IronMan::Zydis::Address
	mov	QWORD PTR tv171[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Size@Zydis@IronMan@@QEBAHXZ		; IronMan::Zydis::Size
	cdqe
	mov	rcx, QWORD PTR tv171[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR ops$[rsp]
	mov	rdx, QWORD PTR tv165[rsp]
	cmp	QWORD PTR [rcx+rdx+96], rax
	jne	SHORT $LN69@IsNop
	mov	DWORD PTR tv177[rsp], 1
	jmp	SHORT $LN70@IsNop
$LN69@IsNop:
	mov	DWORD PTR tv177[rsp], 0
$LN70@IsNop:
	movzx	eax, BYTE PTR tv177[rsp]
	jmp	$LN1@IsNop
$LN53@IsNop:
$LN54@IsNop:
$LN55@IsNop:
$LN56@IsNop:
$LN57@IsNop:

; 504  : 				&& ops[0].imm.value.u == this->Address() + this->Size();
; 505  : 		case ZYDIS_MNEMONIC_SHL:
; 506  : 		case ZYDIS_MNEMONIC_SHR:
; 507  : 		case ZYDIS_MNEMONIC_ROL:
; 508  : 		case ZYDIS_MNEMONIC_ROR:
; 509  : 		case ZYDIS_MNEMONIC_SAR:
; 510  : 			// shl eax, 0
; 511  : 			return ops[1].type == ZYDIS_OPERAND_TYPE_IMMEDIATE

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 4
	jne	SHORT $LN71@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	QWORD PTR [rcx+rax+96], 0
	jne	SHORT $LN71@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z ; IronMan::isSafe64NopRegOp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@IsNop
	mov	DWORD PTR tv195[rsp], 1
	jmp	SHORT $LN72@IsNop
$LN71@IsNop:
	mov	DWORD PTR tv195[rsp], 0
$LN72@IsNop:
	movzx	eax, BYTE PTR tv195[rsp]
	jmp	$LN1@IsNop
$LN58@IsNop:
$LN59@IsNop:

; 512  : 				&& ops[1].imm.value.u == 0
; 513  : 				&& isSafe64NopRegOp(ops[0]);
; 514  : 		case ZYDIS_MNEMONIC_SHLD:
; 515  : 		case ZYDIS_MNEMONIC_SHRD:
; 516  : 			// shld eax, ebx, 0
; 517  : 			return ops[2].type == ZYDIS_OPERAND_TYPE_IMMEDIATE

	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	DWORD PTR [rcx+rax+4], 4
	jne	SHORT $LN73@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR ops$[rsp]
	cmp	QWORD PTR [rcx+rax+96], 0
	jne	SHORT $LN73@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ops$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z ; IronMan::isSafe64NopRegOp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN73@IsNop
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ops$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?isSafe64NopRegOp@IronMan@@YA_NAEBUZydisDecodedOperand_@@@Z ; IronMan::isSafe64NopRegOp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN73@IsNop
	mov	DWORD PTR tv219[rsp], 1
	jmp	SHORT $LN74@IsNop
$LN73@IsNop:
	mov	DWORD PTR tv219[rsp], 0
$LN74@IsNop:
	movzx	eax, BYTE PTR tv219[rsp]
	jmp	SHORT $LN1@IsNop
$LN60@IsNop:

; 518  : 				&& ops[2].imm.value.u == 0
; 519  : 				&& isSafe64NopRegOp(ops[0])
; 520  : 				&& isSafe64NopRegOp(ops[1]);
; 521  : 		default:
; 522  : 			return false;

	xor	al, al
$LN1@IsNop:

; 523  : 		}
; 524  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
	npad	2
$LN81@IsNop:
	DD	$LN9@IsNop
	DD	$LN10@IsNop
	DD	$LN11@IsNop
	DD	$LN12@IsNop
	DD	$LN13@IsNop
	DD	$LN14@IsNop
	DD	$LN15@IsNop
	DD	$LN16@IsNop
	DD	$LN17@IsNop
	DD	$LN18@IsNop
	DD	$LN19@IsNop
	DD	$LN20@IsNop
	DD	$LN21@IsNop
	DD	$LN22@IsNop
	DD	$LN23@IsNop
	DD	$LN24@IsNop
	DD	$LN7@IsNop
	DD	$LN31@IsNop
	DD	$LN32@IsNop
	DD	$LN33@IsNop
	DD	$LN34@IsNop
	DD	$LN35@IsNop
	DD	$LN36@IsNop
	DD	$LN37@IsNop
	DD	$LN38@IsNop
	DD	$LN39@IsNop
	DD	$LN40@IsNop
	DD	$LN41@IsNop
	DD	$LN42@IsNop
	DD	$LN43@IsNop
	DD	$LN44@IsNop
	DD	$LN45@IsNop
	DD	$LN46@IsNop
	DD	$LN47@IsNop
	DD	$LN48@IsNop
	DD	$LN49@IsNop
	DD	$LN50@IsNop
	DD	$LN51@IsNop
	DD	$LN52@IsNop
	DD	$LN60@IsNop
$LN80@IsNop:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	16
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	39					; 00000027H
	DB	17
	DB	18
	DB	19
	DB	20
	DB	21
	DB	22
	DB	23
	DB	24
	DB	25
	DB	26
	DB	27
	DB	28
	DB	29
	DB	30
	DB	31
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
$LN79@IsNop:
	DD	$LN8@IsNop
	DD	$LN26@IsNop
	DD	$LN25@IsNop
	DD	$LN28@IsNop
	DD	$LN27@IsNop
	DD	$LN5@IsNop
	DD	$LN6@IsNop
	DD	$LN60@IsNop
$LN78@IsNop:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
?IsNop@Zydis@IronMan@@QEBA_NXZ ENDP			; IronMan::Zydis::IsNop
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
id$ = 32
tv83 = 36
this$ = 64
?IsUnusual@Zydis@IronMan@@QEBA_NXZ PROC			; IronMan::Zydis::IsUnusual

; 543  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 544  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsUnusual

; 545  : 			return false;

	xor	al, al
	jmp	$LN1@IsUnusual
$LN2@IsUnusual:

; 546  : 
; 547  : 		auto id = mInstr.mnemonic;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR id$[rsp], eax

; 548  : 		return mInstr.attributes & ZYDIS_ATTRIB_IS_PRIVILEGED

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+1072]
	and	rax, 256				; 00000100H
	test	rax, rax
	jne	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 659			; 00000293H
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 744			; 000002e8H
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 745			; 000002e9H
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 107			; 0000006bH
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 660			; 00000294H
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 655			; 0000028fH
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 656			; 00000290H
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 757			; 000002f5H
	je	SHORT $LN4@IsUnusual
	cmp	DWORD PTR id$[rsp], 758			; 000002f6H
	je	SHORT $LN4@IsUnusual
	mov	DWORD PTR tv83[rsp], 0
	jmp	SHORT $LN5@IsUnusual
$LN4@IsUnusual:
	mov	DWORD PTR tv83[rsp], 1
$LN5@IsUnusual:
	movzx	eax, BYTE PTR tv83[rsp]
$LN1@IsUnusual:

; 549  : 			|| id == ZYDIS_MNEMONIC_RDTSC
; 550  : 			|| id == ZYDIS_MNEMONIC_SYSCALL
; 551  : 			|| id == ZYDIS_MNEMONIC_SYSENTER
; 552  : 			|| id == ZYDIS_MNEMONIC_CPUID
; 553  : 			|| id == ZYDIS_MNEMONIC_RDTSCP
; 554  : 			|| id == ZYDIS_MNEMONIC_RDRAND
; 555  : 			|| id == ZYDIS_MNEMONIC_RDSEED
; 556  : 			|| id == ZYDIS_MNEMONIC_UD1
; 557  : 			|| id == ZYDIS_MNEMONIC_UD2;
; 558  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsUnusual@Zydis@IronMan@@QEBA_NXZ ENDP			; IronMan::Zydis::IsUnusual
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv70 = 32
this$ = 64
?IsFilling@Zydis@IronMan@@QEBA_NXZ PROC			; IronMan::Zydis::IsFilling

; 234  : 	{

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 235  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsFilling

; 236  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsFilling
$LN4@IsFilling:

; 237  : 
; 238  : 		switch (mInstr.mnemonic)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 273		; 00000111H
	je	SHORT $LN6@IsFilling
	cmp	DWORD PTR tv70[rsp], 465		; 000001d1H
	je	SHORT $LN5@IsFilling
	jmp	SHORT $LN7@IsFilling
$LN5@IsFilling:
$LN6@IsFilling:

; 239  : 		{
; 240  : 		case ZYDIS_MNEMONIC_NOP:
; 241  : 		case ZYDIS_MNEMONIC_INT3:
; 242  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsFilling
$LN7@IsFilling:

; 243  : 		default:
; 244  : 			return false;

	xor	al, al
$LN1@IsFilling:

; 245  : 		}
; 246  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsFilling@Zydis@IronMan@@QEBA_NXZ ENDP			; IronMan::Zydis::IsFilling
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
?Address@Zydis@IronMan@@QEBA_KXZ PROC			; IronMan::Zydis::Address

; 226  : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Address

; 228  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@Address
$LN2@Address:

; 229  : 
; 230  : 		return m_RuntimeAddress;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+1736]
$LN1@Address:

; 231  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Address@Zydis@IronMan@@QEBA_KXZ ENDP			; IronMan::Zydis::Address
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
?Size@Zydis@IronMan@@QEBAHXZ PROC			; IronMan::Zydis::Size

; 219  : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 220  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Size

; 221  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Size
$LN2@Size:

; 222  : 		return GetInstr()->length;

	mov	rcx, QWORD PTR this$[rsp]
	call	?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ ; IronMan::Zydis::GetInstr
	movzx	eax, BYTE PTR [rax+8]
$LN1@Size:

; 223  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Size@Zydis@IronMan@@QEBAHXZ ENDP			; IronMan::Zydis::Size
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
opindex$ = 80
?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; IronMan::Zydis::OperandText

; 144  : 	{

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 145  : 		return "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 146  : 		/*if (!Success() || opindex >= mInstr.operand_count)
; 147  : 			return "";
; 148  : 
; 149  : 		auto & op = mInstr.operands[opindex];
; 150  : 
; 151  : 		ZydisFormatterFunction type;
; 152  : 		switch (op.type)
; 153  : 		{
; 154  : 		case ZYDIS_OPERAND_TYPE_IMMEDIATE:
; 155  : 			type = ZYDIS_FORMATTER_FUNC_FORMAT_OPERAND_IMM;
; 156  : 			break;
; 157  : 		case ZYDIS_OPERAND_TYPE_MEMORY:
; 158  : 			type = ZYDIS_FORMATTER_FUNC_FORMAT_OPERAND_MEM;
; 159  : 			break;
; 160  : 		case ZYDIS_OPERAND_TYPE_REGISTER:
; 161  : 			type = ZYDIS_FORMATTER_FUNC_FORMAT_OPERAND_REG;
; 162  : 			break;
; 163  : 		case ZYDIS_OPERAND_TYPE_POINTER:
; 164  : 			type = ZYDIS_FORMATTER_FUNC_FORMAT_OPERAND_PTR;
; 165  : 			break;
; 166  : 		default:
; 167  : 			return "";
; 168  : 		}
; 169  : 
; 170  : 		//Get the operand format function.
; 171  : 		ZydisFormatterFunc fmtFunc = nullptr;
; 172  : 		if (!ZYAN_SUCCESS(ZydisFormatterSetHook(&mFormatter, type, (const void**)&fmtFunc)))
; 173  : 			return "";
; 174  : 
; 175  : 
; 176  : 		ZydisFormatterContext context;
; 177  : 		context.instruction = &mInstr;
; 178  : 		context.runtime_address = m_RuntimeAddress;
; 179  : 		context.operand = &op;
; 180  : 		context.user_data = nullptr;
; 181  : 
; 182  : 		//Format the operand.
; 183  : 		char buf[256] = "";
; 184  : 		ZydisFormatterBuffer formatter_buffer;
; 185  : 		formatter_buffer.is_token_list = ZYAN_FALSE;
; 186  : 		formatter_buffer.string.flags = ZYAN_STRING_HAS_FIXED_CAPACITY;
; 187  : 		formatter_buffer.string.vector.allocator = nullptr;
; 188  : 		formatter_buffer.string.vector.element_size = sizeof(char);
; 189  : 		formatter_buffer.string.vector.size = 1;
; 190  : 		formatter_buffer.string.vector.capacity = sizeof(buf) - 1;
; 191  : 		formatter_buffer.string.vector.data = buf;
; 192  : 
; 193  : 		fmtFunc(
; 194  : 			&mFormatter,
; 195  : 			&formatter_buffer,
; 196  : 			&context);
; 197  : 
; 198  : 		//Extract only the part inside the []
; 199  : 		std::string result;
; 200  : 		if (op.type == ZYDIS_OPERAND_TYPE_MEMORY)
; 201  : 		{
; 202  : 			auto openBracket = strchr(buf, '[');
; 203  : 			if (openBracket)
; 204  : 			{
; 205  : 				result = openBracket + 1;
; 206  : 				result.pop_back();
; 207  : 			}
; 208  : 			else
; 209  : 				result = buf;
; 210  : 		}
; 211  : 		else
; 212  : 			result = buf;
; 213  : 
; 214  : 
; 215  : 		return std::move(result);*/
; 216  : 	}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
?OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; IronMan::Zydis::OperandText
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
opindex$ = 80
?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `IronMan::Zydis::OperandText'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??OperandText@Zydis@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `IronMan::Zydis::OperandText'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
tv64 = 32
this$ = 64
reg$ = 72
?RegName@Zydis@IronMan@@QEBAPEBDW4ZydisRegister_@@@Z PROC ; IronMan::Zydis::RegName

; 119  : 	{

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 120  : 		switch (reg)

	mov	eax, DWORD PTR reg$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 69					; 00000045H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 7
	ja	SHORT $LN12@RegName
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN14@RegName[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@RegName:

; 121  : 		{
; 122  : 		case ZYDIS_REGISTER_ST0:
; 123  : 			return "st(0)";

	lea	rax, OFFSET FLAT:??_C@_05MKHCJKJG@st?$CI0?$CJ@
	jmp	SHORT $LN1@RegName
$LN5@RegName:

; 124  : 		case ZYDIS_REGISTER_ST1:
; 125  : 			return "st(1)";

	lea	rax, OFFSET FLAT:??_C@_05MLLAPAKB@st?$CI1?$CJ@
	jmp	SHORT $LN1@RegName
$LN6@RegName:

; 126  : 		case ZYDIS_REGISTER_ST2:
; 127  : 			return "st(2)";

	lea	rax, OFFSET FLAT:??_C@_05MJPGEOPI@st?$CI2?$CJ@
	jmp	SHORT $LN1@RegName
$LN7@RegName:

; 128  : 		case ZYDIS_REGISTER_ST3:
; 129  : 			return "st(3)";

	lea	rax, OFFSET FLAT:??_C@_05MIDECEMP@st?$CI3?$CJ@
	jmp	SHORT $LN1@RegName
$LN8@RegName:

; 130  : 		case ZYDIS_REGISTER_ST4:
; 131  : 			return "st(4)";

	lea	rax, OFFSET FLAT:??_C@_05MNHLDCEK@st?$CI4?$CJ@
	jmp	SHORT $LN1@RegName
$LN9@RegName:

; 132  : 		case ZYDIS_REGISTER_ST5:
; 133  : 			return "st(5)";

	lea	rax, OFFSET FLAT:??_C@_05MMLJFIHN@st?$CI5?$CJ@
	jmp	SHORT $LN1@RegName
$LN10@RegName:

; 134  : 		case ZYDIS_REGISTER_ST6:
; 135  : 			return "st(6)";

	lea	rax, OFFSET FLAT:??_C@_05MOPPOGCE@st?$CI6?$CJ@
	jmp	SHORT $LN1@RegName
$LN11@RegName:

; 136  : 		case ZYDIS_REGISTER_ST7:
; 137  : 			return "st(7)";

	lea	rax, OFFSET FLAT:??_C@_05MPDNIMBD@st?$CI7?$CJ@
	jmp	SHORT $LN1@RegName
$LN12@RegName:

; 138  : 		default:
; 139  : 			return ZydisRegisterGetString(reg);

	mov	ecx, DWORD PTR reg$[rsp]
	call	ZydisRegisterGetString
$LN1@RegName:

; 140  : 		}
; 141  : 	}

	add	rsp, 56					; 00000038H
	ret	0
	npad	3
$LN14@RegName:
	DD	$LN4@RegName
	DD	$LN5@RegName
	DD	$LN6@RegName
	DD	$LN7@RegName
	DD	$LN8@RegName
	DD	$LN9@RegName
	DD	$LN10@RegName
	DD	$LN11@RegName
?RegName@Zydis@IronMan@@QEBAPEBDW4ZydisRegister_@@@Z ENDP ; IronMan::Zydis::RegName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 8
?Success@Zydis@IronMan@@QEBA_NXZ PROC			; IronMan::Zydis::Success

; 114  : 	{

	mov	QWORD PTR [rsp+8], rcx

; 115  : 		return mSuccess;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1728]

; 116  : 	}

	ret	0
?Success@Zydis@IronMan@@QEBA_NXZ ENDP			; IronMan::Zydis::Success
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ PROC ; IronMan::Zydis::GetInstr

; 107  : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 108  : 		if (!Success())

	mov	rcx, QWORD PTR this$[rsp]
	call	?Success@Zydis@IronMan@@QEBA_NXZ	; IronMan::Zydis::Success
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetInstr

; 109  : 			return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@GetInstr
$LN2@GetInstr:

; 110  : 		return &mInstr;

	mov	rax, QWORD PTR this$[rsp]
$LN1@GetInstr:

; 111  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?GetInstr@Zydis@IronMan@@QEBAPEBUZydisDecodedInstruction_@@XZ ENDP ; IronMan::Zydis::GetInstr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
$T1 = 32
dataSafe$ = 40
__$ArrayPad$ = 56
this$ = 80
addr$ = 88
data$ = 96
size$ = 104
?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z PROC	; IronMan::Zydis::DisassembleSafe

; 99   : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 100  : 		unsigned char dataSafe[MAX_DISASM_BUFFER];
; 101  : 		memset(dataSafe, 0, sizeof(dataSafe));

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR dataSafe$[rsp]
	call	memset
	npad	1

; 102  : 		memcpy(dataSafe, data, std::min(MAX_DISASM_BUFFER, size));

	mov	DWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$min@H@std@@YAAEBHAEBH0@Z		; std::min<int>
	movsxd	rax, DWORD PTR [rax]
	mov	r8, rax
	mov	rdx, QWORD PTR data$[rsp]
	lea	rcx, QWORD PTR dataSafe$[rsp]
	call	memcpy
	npad	1

; 103  : 		return Disassemble(addr, dataSafe);

	lea	r8, QWORD PTR dataSafe$[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z ; IronMan::Zydis::Disassemble

; 104  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	ret	0
?DisassembleSafe@Zydis@IronMan@@QEAA_N_KPEBEH@Z ENDP	; IronMan::Zydis::DisassembleSafe
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
op$1 = 32
i$2 = 40
this$ = 64
addr$ = 72
data$ = 80
size$ = 88
?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z PROC	; IronMan::Zydis::Disassemble

; 44   : 	{

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 45   : 		if (!data || !size)

	cmp	QWORD PTR data$[rsp], 0
	je	SHORT $LN6@Disassembl
	cmp	DWORD PTR size$[rsp], 0
	jne	SHORT $LN5@Disassembl
$LN6@Disassembl:

; 46   : 			return false;

	xor	al, al
	jmp	$LN1@Disassembl
$LN5@Disassembl:

; 47   : 
; 48   : 		mSuccess = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1728], 0

; 49   : 		m_RuntimeAddress = addr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	mov	QWORD PTR [rax+1736], rcx

; 50   : 		// Decode instruction.
; 51   : 		if (!ZYAN_SUCCESS(ZydisDecoderDecodeBuffer(&mDecoder, data, size, &mInstr)))

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR size$[rsp]
	mov	r9, rax
	mov	r8, rcx
	mov	rdx, QWORD PTR data$[rsp]
	lea	rcx, OFFSET FLAT:?mDecoder@Zydis@IronMan@@0UZydisDecoder_@@A ; IronMan::Zydis::mDecoder
	call	ZydisDecoderDecodeBuffer
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN7@Disassembl

; 52   : 			return false;

	xor	al, al
	jmp	$LN1@Disassembl
$LN7@Disassembl:

; 53   : 
; 54   : 		// Format it to human readable representation.
; 55   : 		/*if (!ZYAN_SUCCESS(ZydisFormatterFormatInstruction(
; 56   : 			&mFormatter,
; 57   : 			const_cast<ZydisDecodedInstruction*>(&mInstr),
; 58   : 			mInstrText,
; 59   : 			sizeof(mInstrText), m_RuntimeAddress)))
; 60   : 			return false;*/
; 61   : 
; 62   : 			//CONSOLE_INFO("%016" PRIX64 "	%s", m_RuntimeAddress, &mInstrText[0]);
; 63   : 
; 64   : 			// Count explicit operands.
; 65   : 		mVisibleOpCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1729], 0

; 66   : 		for (size_t i = 0; i < mInstr.operand_count; ++i)

	mov	QWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@Disassembl
$LN2@Disassembl:
	mov	rax, QWORD PTR i$2[rsp]
	inc	rax
	mov	QWORD PTR i$2[rsp], rax
$LN4@Disassembl:
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	cmp	QWORD PTR i$2[rsp], rax
	jae	$LN3@Disassembl

; 67   : 		{
; 68   : 			auto& op = mInstr.operands[i];

	imul	rax, QWORD PTR i$2[rsp], 104		; 00000068H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR op$1[rsp], rax

; 69   : 
; 70   : 			// Rebase IMM if relative and DISP if absolute (codebase expects it this way).
; 71   : 			// Once, at some point in time, the disassembler is abstracted away more and more,
; 72   : 			// we should probably refrain from hacking the Zydis data structure and perform
; 73   : 			// such transformations in the getters instead.
; 74   : 			if (op.type == ZYDIS_OPERAND_TYPE_IMMEDIATE && op.imm.is_relative)

	mov	rax, QWORD PTR op$1[rsp]
	cmp	DWORD PTR [rax+4], 4
	jne	SHORT $LN8@Disassembl
	mov	rax, QWORD PTR op$1[rsp]
	movzx	eax, BYTE PTR [rax+89]
	test	eax, eax
	je	SHORT $LN8@Disassembl

; 75   : 			{
; 76   : 				ZydisCalcAbsoluteAddress(&mInstr, &op, addr, &op.imm.value.u);

	mov	rax, QWORD PTR op$1[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, QWORD PTR this$[rsp]
	mov	r9, rax
	mov	r8, QWORD PTR addr$[rsp]
	mov	rdx, QWORD PTR op$1[rsp]
	call	ZydisCalcAbsoluteAddress

; 77   : 				op.imm.is_relative = false; //hack to prevent OperandText from returning bogus values

	mov	rax, QWORD PTR op$1[rsp]
	mov	BYTE PTR [rax+89], 0

; 78   : 			}

	jmp	SHORT $LN9@Disassembl
$LN8@Disassembl:

; 79   : 			else if (op.type == ZYDIS_OPERAND_TYPE_MEMORY &&
; 80   : 				op.mem.base == ZYDIS_REGISTER_NONE &&
; 81   : 				op.mem.index == ZYDIS_REGISTER_NONE &&

	mov	rax, QWORD PTR op$1[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	SHORT $LN10@Disassembl
	mov	rax, QWORD PTR op$1[rsp]
	cmp	DWORD PTR [rax+48], 0
	jne	SHORT $LN10@Disassembl
	mov	rax, QWORD PTR op$1[rsp]
	cmp	DWORD PTR [rax+52], 0
	jne	SHORT $LN10@Disassembl
	mov	rax, QWORD PTR op$1[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN10@Disassembl

; 82   : 				op.mem.disp.value != 0)
; 83   : 			{
; 84   : 				//TODO: what is this used for?
; 85   : 				ZydisCalcAbsoluteAddress(&mInstr, &op, addr, (uint64_t*)&op.mem.disp.value);

	mov	rax, QWORD PTR op$1[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, QWORD PTR this$[rsp]
	mov	r9, rax
	mov	r8, QWORD PTR addr$[rsp]
	mov	rdx, QWORD PTR op$1[rsp]
	call	ZydisCalcAbsoluteAddress
	npad	1
$LN10@Disassembl:
$LN9@Disassembl:

; 86   : 			}
; 87   : 
; 88   : 			if (op.visibility == ZYDIS_OPERAND_VISIBILITY_HIDDEN)

	mov	rax, QWORD PTR op$1[rsp]
	cmp	DWORD PTR [rax+8], 3
	jne	SHORT $LN11@Disassembl

; 89   : 				break;

	jmp	SHORT $LN3@Disassembl
$LN11@Disassembl:

; 90   : 
; 91   : 			++mVisibleOpCount;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1729]
	inc	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+1729], al

; 92   : 		}

	jmp	$LN2@Disassembl
$LN3@Disassembl:

; 93   : 
; 94   : 		mSuccess = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1728], 1

; 95   : 		return mSuccess;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1728]
$LN1@Disassembl:

; 96   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z ENDP	; IronMan::Zydis::Disassemble
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
addr$ = 56
data$ = 64
?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z PROC		; IronMan::Zydis::Disassemble

; 39   : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 40   : 		return Disassemble(addr, data, MAX_DISASM_BUFFER);

	mov	r9d, 16
	mov	r8, QWORD PTR data$[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Disassemble@Zydis@IronMan@@QEAA_N_KPEBEH@Z ; IronMan::Zydis::Disassemble

; 41   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Disassemble@Zydis@IronMan@@QEAA_N_KQEBE@Z ENDP		; IronMan::Zydis::Disassemble
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 8
??1Zydis@IronMan@@QEAA@XZ PROC				; IronMan::Zydis::~Zydis

; 35   : 	{

	mov	QWORD PTR [rsp+8], rcx

; 36   : 	}

	ret	0
??1Zydis@IronMan@@QEAA@XZ ENDP				; IronMan::Zydis::~Zydis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
this$ = 48
??0Zydis@IronMan@@QEAA@XZ PROC				; IronMan::Zydis::Zydis

; 29   : 	{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 26   : 		: mSuccess(false),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1728], 0

; 27   : 		mVisibleOpCount(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1729], 0

; 28   : 		m_RuntimeAddress()

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+1736], 0

; 30   : 		Initialize();

	call	?Initialize@Zydis@IronMan@@SAXXZ	; IronMan::Zydis::Initialize

; 31   : 		memset(&mInstr, 0, sizeof(mInstr));

	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, 1472				; 000005c0H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 32   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0Zydis@IronMan@@QEAA@XZ ENDP				; IronMan::Zydis::Zydis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\ZydisWrapper.cpp
_TEXT	SEGMENT
?Initialize@Zydis@IronMan@@SAXXZ PROC			; IronMan::Zydis::Initialize

; 13   : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 14   : 		if (!mInitialized)

	movzx	eax, BYTE PTR ?mInitialized@Zydis@IronMan@@0_NA ; IronMan::Zydis::mInitialized
	test	eax, eax
	jne	SHORT $LN2@Initialize

; 15   : 		{
; 16   : 			mInitialized = true;

	mov	BYTE PTR ?mInitialized@Zydis@IronMan@@0_NA, 1 ; IronMan::Zydis::mInitialized

; 17   : 			ZydisDecoderInit(&mDecoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_ADDRESS_WIDTH_64);

	mov	r8d, 2
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?mDecoder@Zydis@IronMan@@0UZydisDecoder_@@A ; IronMan::Zydis::mDecoder
	call	ZydisDecoderInit
	npad	1
$LN2@Initialize:

; 18   : 			/*ZydisFormatterInit(&mFormatter, ZYDIS_FORMATTER_STYLE_INTEL);
; 19   : 			ZydisFormatterSetProperty(&mFormatter, ZYDIS_FORMATTER_PROP_FORCE_SEGMENT, ZYAN_TRUE);
; 20   : 			ZydisFormatterSetProperty(&mFormatter, ZYDIS_FORMATTER_PROP_FORCE_SIZE, ZYAN_TRUE);*/
; 21   : 		}
; 22   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Initialize@Zydis@IronMan@@SAXXZ ENDP			; IronMan::Zydis::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@H@std@@YAAEBHAEBH0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@H@std@@YAAEBHAEBH0@Z PROC			; std::min<int>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@H@std@@YAAEBHAEBH0@Z ENDP			; std::min<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3066 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3067 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 3068 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2954 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2955 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2956 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 2798 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T2[rsp], 0

; 2799 :         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
; 2800 :         return basic_string{*this, _Off, _Count};

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Count$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2801 :     }

	add	rsp, 72					; 00000048H
	ret	0
	int	3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z
_TEXT	SEGMENT
tv79 = 32
tv77 = 40
this$ = 64
_Ch$ = 72
_Off$ = 80
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT

; 2626 :     _NODISCARD _CONSTEXPR20 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2627 :         // look for _Ch before _Off
; 2628 :         return static_cast<size_type>(

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv77[rsp], rax
	movzx	r9d, BYTE PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ; std::_Traits_rfind_ch<std::char_traits<char> >

; 2629 :             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
; 2630 :     }

	add	rsp, 56					; 00000038H
	ret	0
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
_TEXT	SEGMENT
tv84 = 48
tv82 = 56
tv80 = 64
this$ = 96
_Ptr$ = 104
_Off$ = 112
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 2583 :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2584 :         // look for [_Ptr, <null>) beginning at or after _Off
; 2585 :         return static_cast<size_type>(_Traits_find<_Traits>(

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR tv84[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 2586 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 2587 :     }

	add	rsp, 88					; 00000058H
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT

; 2341 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2342 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 2343 :     }

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z
_TEXT	SEGMENT
this$ = 64
_Off$ = 72
_Nx$ = 80
_Ptr$ = 88
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT

; 1997 :     _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, _In_z_ const _Elem* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1998 :         // replace [_Off, _Off + _Nx) with [_Ptr, <null>)
; 1999 :         return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	mov	r8, QWORD PTR _Nx$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 2000 :     }

	add	rsp, 56					; 00000038H
	ret	0
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
_TEXT	SEGMENT
$T1 = 64
_Ptr_shifted_after$2 = 72
_Old_size$ = 80
_Growth$ = 88
_Suffix_at$3 = 96
_Insert_at$4 = 104
_Insert_at$5 = 112
_Old_ptr$6 = 120
_Suffix_size$ = 128
tv69 = 136
tv77 = 144
_Old_ptr$7 = 152
_New_size$8 = 160
tv179 = 168
this$ = 192
_Off$ = 200
_Nx$ = 208
_Ptr$ = 216
_Count$ = 224
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT

; 1926 :         const size_type _Off, size_type _Nx, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 176				; 000000b0H

; 1927 :         // replace [_Off, _Off + _Nx) with [_Ptr, _Ptr + _Count)
; 1928 :         _Mypair._Myval2._Check_offset(_Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 1929 :         _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR _Nx$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
	mov	QWORD PTR _Nx$[rsp], rax

; 1930 :         if (_Nx == _Count) { // size doesn't change, so a single move does the trick

	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Nx$[rsp], rax
	jne	SHORT $LN2@replace

; 1931 :             _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Off$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1932 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	$LN1@replace
$LN2@replace:

; 1933 :         }
; 1934 : 
; 1935 :         const size_type _Old_size    = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1936 :         const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;

	mov	rax, QWORD PTR _Nx$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sub	rax, QWORD PTR _Off$[rsp]
	inc	rax
	mov	QWORD PTR _Suffix_size$[rsp], rax

; 1937 :         if (_Count < _Nx) { // suffix shifts backwards; we don't have to move anything out of the way

	mov	rax, QWORD PTR _Nx$[rsp]
	cmp	QWORD PTR _Count$[rsp], rax
	jae	$LN3@replace

; 1938 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$7[rsp], rax

; 1939 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Insert_at$5[rsp], rax

; 1940 :             _Traits::move(_Insert_at, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Insert_at$5[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1941 :             _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);

	mov	rax, QWORD PTR _Nx$[rsp]
	mov	rcx, QWORD PTR _Insert_at$5[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Insert_at$5[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, QWORD PTR _Suffix_size$[rsp]
	mov	rdx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1942 : 
; 1943 :             const auto _New_size = _Old_size - (_Nx - _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Nx$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$8[rsp], rax

; 1944 :             _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
; 1945 :             _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$8[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1946 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	$LN1@replace
$LN3@replace:

; 1947 :         }
; 1948 : 
; 1949 :         const size_type _Growth = static_cast<size_type>(_Count - _Nx);

	mov	rax, QWORD PTR _Nx$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Growth$[rsp], rax

; 1950 : 
; 1951 :         // checking for overlapping ranges is technically UB (considering string literals), so just always reallocate
; 1952 :         // and copy to the new buffer if constant evaluated
; 1953 : #if _HAS_CXX20
; 1954 :         if (!_STD is_constant_evaluated())
; 1955 : #endif // _HAS_CXX20
; 1956 :         {
; 1957 :             if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Growth$[rsp], rax
	ja	$LN4@replace

; 1958 :                 _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Growth);
; 1959 :                 _Mypair._Myval2._Mysize = _Old_size + _Growth;

	mov	rax, QWORD PTR _Growth$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1960 :                 _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$6[rsp], rax

; 1961 :                 _Elem* const _Insert_at = _Old_ptr + _Off;

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Insert_at$4[rsp], rax

; 1962 :                 _Elem* const _Suffix_at = _Insert_at + _Nx;

	mov	rax, QWORD PTR _Nx$[rsp]
	mov	rcx, QWORD PTR _Insert_at$4[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Suffix_at$3[rsp], rax

; 1963 : 
; 1964 :                 size_type _Ptr_shifted_after; // see rationale in insert
; 1965 :                 if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR _Insert_at$4[rsp]
	jbe	SHORT $LN7@replace
	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Ptr$[rsp], rax
	jbe	SHORT $LN5@replace
$LN7@replace:

; 1966 :                     _Ptr_shifted_after = _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Ptr_shifted_after$2[rsp], rax
	jmp	SHORT $LN6@replace
$LN5@replace:

; 1967 :                 } else if (_Suffix_at <= _Ptr) {

	mov	rax, QWORD PTR _Ptr$[rsp]
	cmp	QWORD PTR _Suffix_at$3[rsp], rax
	ja	SHORT $LN8@replace

; 1968 :                     _Ptr_shifted_after = 0;

	mov	QWORD PTR _Ptr_shifted_after$2[rsp], 0

; 1969 :                 } else {

	jmp	SHORT $LN9@replace
$LN8@replace:

; 1970 :                     _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Suffix_at$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Ptr_shifted_after$2[rsp], rax
$LN9@replace:
$LN6@replace:

; 1971 :                 }
; 1972 : 
; 1973 :                 _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);

	mov	rax, QWORD PTR _Growth$[rsp]
	mov	rcx, QWORD PTR _Suffix_at$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Suffix_size$[rsp]
	mov	rdx, QWORD PTR _Suffix_at$3[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1974 :                 // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
; 1975 :                 // this case doesn't occur in insert because the new content must come from outside the removed
; 1976 :                 // content there (because in insert there is no removed content)
; 1977 :                 _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);

	mov	r8, QWORD PTR _Ptr_shifted_after$2[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Insert_at$4[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1978 :                 // the next case can be copy, because it comes from the chunk moved out of the way in the
; 1979 :                 // first move, and the hole we're filling can't alias the chunk we moved out of the way
; 1980 :                 _Traits::copy(

	mov	rax, QWORD PTR _Ptr_shifted_after$2[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Growth$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	add	rcx, QWORD PTR _Ptr_shifted_after$2[rsp]
	mov	rdx, QWORD PTR _Ptr_shifted_after$2[rsp]
	mov	r8, QWORD PTR _Insert_at$4[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv179[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv179[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1981 :                     _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 1982 :                 return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@replace
$LN4@replace:

; 1983 :             }
; 1984 :         }
; 1985 : 
; 1986 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR _Nx$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Off$[rsp]
	movzx	r8d, BYTE PTR $T1[rsp]
	mov	rdx, QWORD PTR _Growth$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>
$LN1@replace:

; 1987 :             _Growth,
; 1988 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 1989 :                 const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) _STATIC_CALL_OPERATOR {
; 1990 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 1991 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 1992 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
; 1993 :             },
; 1994 :             _Off, _Nx, _Ptr, _Count);
; 1995 :     }

	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Right_data$ = 40
_My_data$ = 48
_Right_data_mem$3 = 56
_My_data_mem$4 = 64
tv148 = 72
this$ = 96
_Right$ = 104
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1234 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1235 :         // assign by stealing _Right's buffer
; 1236 :         // pre: this != &_Right
; 1237 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1238 :         // pre: *this owns no memory, iterators orphaned
; 1239 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1240 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1241 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1242 : 
; 1243 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1244 :         if constexpr (_Can_memcpy_val) {
; 1245 : #if _HAS_CXX20
; 1246 :             if (!_STD is_constant_evaluated())
; 1247 : #endif // _HAS_CXX20
; 1248 :             {
; 1249 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1250 :                 if (_Right_data._Large_mode_engaged()) {
; 1251 :                     // take ownership of _Right's iterators along with its buffer
; 1252 :                     _Swap_proxy_and_iterators(_Right);
; 1253 :                 } else {
; 1254 :                     _Right_data._Orphan_all();
; 1255 :                 }
; 1256 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1257 : 
; 1258 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _My_data_mem$4[rsp], rax

; 1259 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1260 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _Right_data_mem$3[rsp], rax

; 1261 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$3[rsp]
	mov	rcx, QWORD PTR _My_data_mem$4[rsp]
	call	memcpy

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1266 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1268 :                 return;

	jmp	$LN1@Take_conte

; 1269 :             }
; 1270 :         }
; 1271 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1272 : 
; 1273 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 1274 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1275 : 
; 1276 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 1277 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1278 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1279 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1280 : 
; 1281 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1282 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv148[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv148[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
$LN3@Take_conte:

; 1283 :         }
; 1284 : 
; 1285 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1286 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1287 : 
; 1288 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1289 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1290 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1
$LN1@Take_conte:

; 1291 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1004 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	mov	QWORD PTR tv75[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv75[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1005 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv89[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1006 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1007 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv130 = 64
tv128 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 711  :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
	npad	1

; 712  :         _Right._Mypair._Myval2._Check_offset(_Roff);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
	mov	QWORD PTR tv130[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Roff$[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	r8, QWORD PTR tv130[rsp]
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 714  :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 715  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv130 = 64
tv128 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Off$ = 72
_Size$ = 80
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Size$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 469  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

$LN3:
	sub	rsp, 40					; 00000028H

; 463  :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	npad	1
$LN2@Xran:

; 464  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN2@Check_offs

; 451  :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN2@Check_offs:
$LN3@Check_offs:

; 452  :         }
; 453  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 511  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 512  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 513  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z PROC		; std::_Narrow_char_traits<char,int>::eq, COMDAT

; 479  :     _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 480  :         return _Left == _Right;

	movsx	eax, BYTE PTR _Left$[rsp]
	movsx	ecx, BYTE PTR _Right$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN3@eq
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@eq
$LN3@eq:
	mov	DWORD PTR tv67[rsp], 0
$LN4@eq:
	movzx	eax, BYTE PTR tv67[rsp]

; 481  :     }

	add	rsp, 24
	ret	0
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ENDP		; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 438  :         const _Elem& _Ch) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 439  :         // look for _Ch in [_First, _First + _Count)
; 440  : #if _HAS_CXX17
; 441  : #ifdef __cpp_char8_t
; 442  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 443  : #if _HAS_U8_INTRINSICS
; 444  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 445  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 446  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 447  : #endif // ^^^ no u8 intrinsics ^^^
; 448  :         } else
; 449  : #endif // defined(__cpp_char8_t)
; 450  :         {
; 451  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rax, QWORD PTR _Ch$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memchr

; 452  :         }
; 453  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 454  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 455  : #endif // ^^^ !_HAS_CXX17 ^^^
; 456  :     }

	add	rsp, 40					; 00000028H
	ret	0
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 417  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 418  :         // find length of null-terminated string
; 419  : #if _HAS_CXX17
; 420  : #ifdef __cpp_char8_t
; 421  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 422  : #if _HAS_U8_INTRINSICS
; 423  :             return __builtin_u8strlen(_First);
; 424  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 425  :             return _Primary_char_traits::length(_First);
; 426  : #endif // ^^^ no u8 intrinsics ^^^
; 427  :         } else
; 428  : #endif // defined(__cpp_char8_t)
; 429  :         {
; 430  :             return __builtin_strlen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	QWORD PTR tv68[rsp], -1
$LL3@length:
	inc	QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL3@length
	mov	rax, QWORD PTR tv68[rsp]

; 431  :         }
; 432  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 434  : #endif // ^^^ !_HAS_CXX17 ^^^
; 435  :     }

	add	rsp, 24
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 408  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 409  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 410  : #if _HAS_CXX17
; 411  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcmp

; 412  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 413  :         return _CSTD memcmp(_First1, _First2, _Count);
; 414  : #endif // ^^^ !_HAS_CXX17 ^^^
; 415  :     }

	add	rsp, 40					; 00000028H
	ret	0
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 110  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 111  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 112  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 113  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 114  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 115  : #if _HAS_CXX20
; 116  :         if (_STD is_constant_evaluated()) {
; 117  :             // dest: [_First1, _First1 + _Count)
; 118  :             // src: [_First2, _First2 + _Count)
; 119  :             // We need to handle overlapping ranges.
; 120  :             // If _First1 is in the src range, we need a backward loop.
; 121  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 122  : 
; 123  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 124  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 125  :             bool _Loop_forward = true;
; 126  : 
; 127  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 128  :                 if (_First1 == _Src) {
; 129  :                     _Loop_forward = false;
; 130  :                     break;
; 131  :                 }
; 132  :             }
; 133  : 
; 134  :             if (_Loop_forward) {
; 135  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 136  :                     _First1[_Idx] = _First2[_Idx];
; 137  :                 }
; 138  :             } else {
; 139  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 140  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 141  :                 }
; 142  :             }
; 143  : 
; 144  :             return _First1;
; 145  :         }
; 146  : #endif // _HAS_CXX20
; 147  : 
; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 149  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 150  : 
; 151  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 152  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtr1common
;	COMDAT ?_Is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?_Is_constant_evaluated@std@@YA_NXZ PROC		; std::_Is_constant_evaluated, COMDAT

; 178  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 179  : }

	ret	0
?_Is_constant_evaluated@std@@YA_NXZ ENDP		; std::_Is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT sscanf_s
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf_s PROC						; COMDAT

; 2286 :         {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 2287 :             int _Result;
; 2288 :             va_list _ArgList;
; 2289 :             __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 2290 : 
; 2291 :             _Result = vsscanf_s(_Buffer, _Format, _ArgList);

	mov	r8, QWORD PTR _ArgList$[rsp]
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	vsscanf_s
	mov	DWORD PTR _Result$[rsp], eax

; 2292 : 
; 2293 :             __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 2294 :             return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 2295 :         }

	add	rsp, 56					; 00000038H
	ret	0
sscanf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT vsscanf_s
_TEXT	SEGMENT
_Buffer$ = 48
_Format$ = 56
_ArgList$ = 64
vsscanf_s PROC						; COMDAT

; 2204 :         {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2205 :             return _vsscanf_s_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsscanf_s_l

; 2206 :         }

	add	rsp, 40					; 00000028H
	ret	0
vsscanf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsscanf_s_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_s_l PROC					; COMDAT

; 2183 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2184 :         return __stdio_common_vsscanf(

	call	__local_stdio_scanf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, -1
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsscanf

; 2185 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
; 2186 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2187 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsscanf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT vsprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
vsprintf_s PROC						; COMDAT

; 1512 :         {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1513 :             return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_s_l

; 1514 :         }

	add	rsp, 56					; 00000038H
	ret	0
vsprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsprintf_s_l
_TEXT	SEGMENT
_Result$ = 48
tv73 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsprintf_s_l PROC					; COMDAT

; 1490 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vsprintf_s
	mov	DWORD PTR _Result$[rsp], eax

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsprintf_s
	mov	DWORD PTR tv73[rsp], -1
	jmp	SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv73[rsp], eax
$LN4@vsprintf_s:
	mov	eax, DWORD PTR tv73[rsp]

; 1496 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

	ret	0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
