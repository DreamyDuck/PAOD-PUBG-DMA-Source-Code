; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
CONST	ENDS
PUBLIC	?alloc@Zone@asmjit@@QEAAPEAX_K@Z		; asmjit::Zone::alloc
PUBLIC	?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ	; asmjit::CodeGen::hasBaseAddress
PUBLIC	?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ	; asmjit::CodeGen::getBaseAddress
PUBLIC	?getData@PodVectorData@asmjit@@QEBAPEAXXZ	; asmjit::PodVectorData::getData
PUBLIC	??0PodVectorBase@asmjit@@QEAA@XZ		; asmjit::PodVectorBase::PodVectorBase
PUBLIC	??1PodVectorBase@asmjit@@QEAA@XZ		; asmjit::PodVectorBase::~PodVectorBase
PUBLIC	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z		; asmjit::IntUtil::pack32_4x8
PUBLIC	?pack64_2x32@IntUtil@asmjit@@SA_KII@Z		; asmjit::IntUtil::pack64_2x32
PUBLIC	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z	; asmjit::UInt64::setPacked_2x32
PUBLIC	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::Operand::Operand
PUBLIC	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id
PUBLIC	?getId@Operand@asmjit@@QEBAIXZ			; asmjit::Operand::getId
PUBLIC	?makeLabelId@OperandUtil@asmjit@@SAII@Z		; asmjit::OperandUtil::makeLabelId
PUBLIC	??0Imm@asmjit@@QEAA@_J@Z			; asmjit::Imm::Imm
PUBLIC	??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z	; asmjit::Assembler::Assembler
PUBLIC	??1Assembler@asmjit@@UEAA@XZ			; asmjit::Assembler::~Assembler
PUBLIC	?reset@Assembler@asmjit@@QEAAX_N@Z		; asmjit::Assembler::reset
PUBLIC	?getCapacity@Assembler@asmjit@@QEBA_KXZ		; asmjit::Assembler::getCapacity
PUBLIC	?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getRemainingSpace
PUBLIC	?getCursor@Assembler@asmjit@@QEBAPEAEXZ		; asmjit::Assembler::getCursor
PUBLIC	?setCursor@Assembler@asmjit@@QEAAXPEAE@Z	; asmjit::Assembler::setCursor
PUBLIC	?getOffset@Assembler@asmjit@@QEBA_KXZ		; asmjit::Assembler::getOffset
PUBLIC	?_grow@Assembler@asmjit@@QEAAI_K@Z		; asmjit::Assembler::_grow
PUBLIC	?_reserve@Assembler@asmjit@@QEAAI_K@Z		; asmjit::Assembler::_reserve
PUBLIC	?getByteAt@Assembler@asmjit@@QEBAE_K@Z		; asmjit::Assembler::getByteAt
PUBLIC	?setByteAt@Assembler@asmjit@@QEAAX_KE@Z		; asmjit::Assembler::setByteAt
PUBLIC	?setInt32At@Assembler@asmjit@@QEAAX_KH@Z	; asmjit::Assembler::setInt32At
PUBLIC	?getCodeSize@Assembler@asmjit@@QEBA_KXZ		; asmjit::Assembler::getCodeSize
PUBLIC	?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getTrampolineSize
PUBLIC	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
PUBLIC	?_registerIndexedLabels@Assembler@asmjit@@QEAAI_K@Z ; asmjit::Assembler::_registerIndexedLabels
PUBLIC	?_newLabel@Assembler@asmjit@@QEAAIPEAULabel@2@@Z ; asmjit::Assembler::_newLabel
PUBLIC	?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ ; asmjit::Assembler::_newLabelLink
PUBLIC	?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z	; asmjit::Assembler::bind
PUBLIC	?embed@Assembler@asmjit@@UEAAIPEBXI@Z		; asmjit::Assembler::embed
PUBLIC	?relocCode@Assembler@asmjit@@QEBA_KPEAX_K@Z	; asmjit::Assembler::relocCode
PUBLIC	?make@Assembler@asmjit@@UEAAPEAXXZ		; asmjit::Assembler::make
PUBLIC	?emit@Assembler@asmjit@@QEAAII@Z		; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@@Z	; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z	; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00@Z ; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIH@Z		; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAII_K@Z		; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@H@Z	; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z ; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0H@Z ; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0_K@Z ; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00H@Z ; asmjit::Assembler::emit
PUBLIC	?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00_K@Z ; asmjit::Assembler::emit
PUBLIC	??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::LabelData>::PodVector<asmjit::LabelData>
PUBLIC	??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>
PUBLIC	?getLength@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::LabelData>::getLength
PUBLIC	?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ ; asmjit::PodVector<asmjit::LabelData>::getData
PUBLIC	?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z ; asmjit::PodVector<asmjit::LabelData>::_grow
PUBLIC	?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z ; asmjit::PodVector<asmjit::LabelData>::append
PUBLIC	??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z ; asmjit::PodVector<asmjit::LabelData>::operator[]
PUBLIC	??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::RelocData>::PodVector<asmjit::RelocData>
PUBLIC	??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>
PUBLIC	?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ ; asmjit::PodVector<asmjit::RelocData>::getData
PUBLIC	??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ; asmjit::PodVector<asmjit::RelocData>::operator[]
PUBLIC	??_GAssembler@asmjit@@UEAAPEAXI@Z		; asmjit::Assembler::`scalar deleting destructor'
PUBLIC	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ		; asmjit::IntUtil::maxUInt<unsigned __int64>
PUBLIC	??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z ; asmjit::Zone::allocT<asmjit::LabelLink>
PUBLIC	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z		; asmjit::IntUtil::isInt8<int>
PUBLIC	??_7Assembler@asmjit@@6B@			; asmjit::Assembler::`vftable'
PUBLIC	??_R4Assembler@asmjit@@6B@			; asmjit::Assembler::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUAssembler@asmjit@@@8			; asmjit::Assembler `RTTI Type Descriptor'
PUBLIC	??_R3Assembler@asmjit@@8			; asmjit::Assembler::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Assembler@asmjit@@8			; asmjit::Assembler::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Assembler@asmjit@@8		; asmjit::Assembler::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CodeGen@asmjit@@8			; asmjit::CodeGen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUCodeGen@asmjit@@@8			; asmjit::CodeGen `RTTI Type Descriptor'
PUBLIC	??_R3CodeGen@asmjit@@8				; asmjit::CodeGen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CodeGen@asmjit@@8				; asmjit::CodeGen::`RTTI Base Class Array'
EXTRN	_purecall:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
EXTRN	memcpy:PROC
EXTRN	?reset@Zone@asmjit@@QEAAX_N@Z:PROC		; asmjit::Zone::reset
EXTRN	?_alloc@Zone@asmjit@@QEAAPEAX_K@Z:PROC		; asmjit::Zone::_alloc
EXTRN	??0CodeGen@asmjit@@QEAA@PEAURuntime@1@@Z:PROC	; asmjit::CodeGen::CodeGen
EXTRN	??1CodeGen@asmjit@@UEAA@XZ:PROC			; asmjit::CodeGen::~CodeGen
EXTRN	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z:PROC	; asmjit::CodeGen::setError
EXTRN	?reset@PodVectorBase@asmjit@@QEAAX_N@Z:PROC	; asmjit::PodVectorBase::reset
EXTRN	?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z:PROC	; asmjit::PodVectorBase::_grow
EXTRN	??_EAssembler@asmjit@@UEAAPEAXI@Z:PROC		; asmjit::Assembler::`vector deleting destructor'
EXTRN	__CxxFrameHandler4:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B:BYTE ; asmjit::PodVectorBase::_nullData
EXTRN	?noOperand@asmjit@@3UOperand@1@B:BYTE		; asmjit::noOperand
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@Zone@asmjit@@QEAAPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$?alloc@Zone@asmjit@@QEAAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1PodVectorBase@asmjit@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1PodVectorBase@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Imm@asmjit@@QEAA@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$??0Imm@asmjit@@QEAA@_J@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+170
	DD	imagerel $unwind$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA DD imagerel ?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
$pdata$?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA DD imagerel ?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
$pdata$?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA DD imagerel ?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
	DD	imagerel ?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1Assembler@asmjit@@UEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+91
	DD	imagerel $unwind$??1Assembler@asmjit@@UEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA
$pdata$?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA DD imagerel ?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA
$pdata$?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA DD imagerel ?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?reset@Assembler@asmjit@@QEAAX_N@Z DD imagerel $LN4
	DD	imagerel $LN4+263
	DD	imagerel $unwind$?reset@Assembler@asmjit@@QEAAX_N@Z
$pdata$?_grow@Assembler@asmjit@@QEAAI_K@Z DD imagerel $LN13
	DD	imagerel $LN13+275
	DD	imagerel $unwind$?_grow@Assembler@asmjit@@QEAAI_K@Z
$pdata$?_reserve@Assembler@asmjit@@QEAAI_K@Z DD imagerel $LN7
	DD	imagerel $LN7+213
	DD	imagerel $unwind$?_reserve@Assembler@asmjit@@QEAAI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getCodeSize@Assembler@asmjit@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?getCodeSize@Assembler@asmjit@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_registerIndexedLabels@Assembler@asmjit@@QEAAI_K@Z DD imagerel $LN8
	DD	imagerel $LN8+202
	DD	imagerel $unwind$?_registerIndexedLabels@Assembler@asmjit@@QEAAI_K@Z
$pdata$?_newLabel@Assembler@asmjit@@QEAAIPEAULabel@2@@Z DD imagerel $LN5
	DD	imagerel $LN5+157
	DD	imagerel $unwind$?_newLabel@Assembler@asmjit@@QEAAIPEAULabel@2@@Z
$pdata$?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ DD imagerel $LN6
	DD	imagerel $LN6+157
	DD	imagerel $unwind$?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ
$pdata$?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+564
	DD	imagerel $unwind$?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z
$pdata$?embed@Assembler@asmjit@@UEAAIPEBXI@Z DD imagerel $LN5
	DD	imagerel $LN5+156
	DD	imagerel $unwind$?embed@Assembler@asmjit@@UEAAIPEBXI@Z
$pdata$?relocCode@Assembler@asmjit@@QEBA_KPEAX_K@Z DD imagerel $LN8
	DD	imagerel $LN8+145
	DD	imagerel $unwind$?relocCode@Assembler@asmjit@@QEBA_KPEAX_K@Z
$pdata$?make@Assembler@asmjit@@UEAAPEAXXZ DD imagerel $LN6
	DD	imagerel $LN6+132
	DD	imagerel $unwind$?make@Assembler@asmjit@@UEAAPEAXXZ
$pdata$?emit@Assembler@asmjit@@QEAAII@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAII@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIH@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIH@Z
$pdata$?emit@Assembler@asmjit@@QEAAII_K@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAII_K@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@H@Z DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@H@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0H@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0H@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0_K@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00H@Z DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00H@Z
$pdata$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00_K@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+30
	DD	imagerel $unwind$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+30
	DD	imagerel $unwind$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GAssembler@asmjit@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GAssembler@asmjit@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isInt8@H@IntUtil@asmjit@@SA_NH@Z DD imagerel $LN11
	DD	imagerel $LN11+112
	DD	imagerel $unwind$??$isInt8@H@IntUtil@asmjit@@SA_NH@Z
pdata	ENDS
;	COMDAT ??_R2CodeGen@asmjit@@8
rdata$r	SEGMENT
??_R2CodeGen@asmjit@@8 DD imagerel ??_R1A@?0A@EA@CodeGen@asmjit@@8 ; asmjit::CodeGen::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3CodeGen@asmjit@@8
rdata$r	SEGMENT
??_R3CodeGen@asmjit@@8 DD 00H				; asmjit::CodeGen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2CodeGen@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUCodeGen@asmjit@@@8
data$rs	SEGMENT
??_R0?AUCodeGen@asmjit@@@8 DQ FLAT:??_7type_info@@6B@	; asmjit::CodeGen `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUCodeGen@asmjit@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CodeGen@asmjit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CodeGen@asmjit@@8 DD imagerel ??_R0?AUCodeGen@asmjit@@@8 ; asmjit::CodeGen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CodeGen@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Assembler@asmjit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Assembler@asmjit@@8 DD imagerel ??_R0?AUAssembler@asmjit@@@8 ; asmjit::Assembler::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Assembler@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R2Assembler@asmjit@@8
rdata$r	SEGMENT
??_R2Assembler@asmjit@@8 DD imagerel ??_R1A@?0A@EA@Assembler@asmjit@@8 ; asmjit::Assembler::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@CodeGen@asmjit@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3Assembler@asmjit@@8
rdata$r	SEGMENT
??_R3Assembler@asmjit@@8 DD 00H				; asmjit::Assembler::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Assembler@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUAssembler@asmjit@@@8
data$rs	SEGMENT
??_R0?AUAssembler@asmjit@@@8 DQ FLAT:??_7type_info@@6B@	; asmjit::Assembler `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUAssembler@asmjit@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Assembler@asmjit@@6B@
rdata$r	SEGMENT
??_R4Assembler@asmjit@@6B@ DD 01H			; asmjit::Assembler::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUAssembler@asmjit@@@8
	DD	imagerel ??_R3Assembler@asmjit@@8
	DD	imagerel ??_R4Assembler@asmjit@@6B@
rdata$r	ENDS
;	COMDAT ??_7Assembler@asmjit@@6B@
CONST	SEGMENT
??_7Assembler@asmjit@@6B@ DQ FLAT:??_R4Assembler@asmjit@@6B@ ; asmjit::Assembler::`vftable'
	DQ	FLAT:??_EAssembler@asmjit@@UEAAPEAXI@Z
	DQ	FLAT:?make@Assembler@asmjit@@UEAAPEAXXZ
	DQ	FLAT:?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z
	DQ	FLAT:?embed@Assembler@asmjit@@UEAAIPEBXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isInt8@H@IntUtil@asmjit@@SA_NH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GAssembler@asmjit@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
	DD	imagerel $ip2state$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
	DD	imagerel $ip2state$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
	DD	imagerel $ip2state$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
	DD	imagerel $ip2state$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getCodeSize@Assembler@asmjit@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
xdata	SEGMENT
$unwind$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z
$cppxdata$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z
	DD	imagerel $ip2state$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z
$stateUnwindMap$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA
$ip2state$??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0dcH
	DB	04H
	DB	'('
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1Assembler@asmjit@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Assembler@asmjit@@UEAA@XZ
$cppxdata$??1Assembler@asmjit@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1Assembler@asmjit@@UEAA@XZ
	DD	imagerel $ip2state$??1Assembler@asmjit@@UEAA@XZ
$stateUnwindMap$??1Assembler@asmjit@@UEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA
$ip2state$??1Assembler@asmjit@@UEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	'0'
	DB	06H
	DB	01aH
	DB	04H
	DB	'('
	DB	02H
	DB	'$'
	DB	00H
$unwind$?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?reset@Assembler@asmjit@@QEAAX_N@Z DD 010d01H
	DD	0820dH
$unwind$?_grow@Assembler@asmjit@@QEAAI_K@Z DD 010e01H
	DD	0820eH
$unwind$?_reserve@Assembler@asmjit@@QEAAI_K@Z DD 010e01H
	DD	0820eH
$unwind$?_registerIndexedLabels@Assembler@asmjit@@QEAAI_K@Z DD 010e01H
	DD	0a20eH
$unwind$?_newLabel@Assembler@asmjit@@QEAAIPEAULabel@2@@Z DD 010e01H
	DD	0820eH
$unwind$?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ DD 010901H
	DD	06209H
$unwind$?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z DD 010e01H
	DD	0e20eH
$unwind$?embed@Assembler@asmjit@@UEAAIPEBXI@Z DD 011301H
	DD	06213H
$unwind$?relocCode@Assembler@asmjit@@QEBA_KPEAX_K@Z DD 011301H
	DD	06213H
$unwind$?make@Assembler@asmjit@@UEAAPEAXXZ DD 010901H
	DD	08209H
$unwind$?emit@Assembler@asmjit@@QEAAII@Z DD 010d01H
	DD	0820dH
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@@Z DD 011201H
	DD	08212H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z DD 011701H
	DD	08217H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00@Z DD 011701H
	DD	08217H
$unwind$?emit@Assembler@asmjit@@QEAAIIH@Z DD 011201H
	DD	0a212H
$unwind$?emit@Assembler@asmjit@@QEAAII_K@Z DD 011201H
	DD	0a212H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@H@Z DD 011701H
	DD	0a217H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z DD 011701H
	DD	0a217H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0H@Z DD 011701H
	DD	0a217H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0_K@Z DD 011701H
	DD	0a217H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00H@Z DD 011701H
	DD	0a217H
$unwind$?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00_K@Z DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Imm@asmjit@@QEAA@_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1PodVectorBase@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1PodVectorBase@asmjit@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1PodVectorBase@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1PodVectorBase@asmjit@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1PodVectorBase@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@Zone@asmjit@@QEAAPEAX_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$isInt8@H@IntUtil@asmjit@@SA_NH@Z
_TEXT	SEGMENT
tv67 = 0
tv69 = 4
tv72 = 8
x$ = 32
??$isInt8@H@IntUtil@asmjit@@SA_NH@Z PROC		; asmjit::IntUtil::isInt8<int>, COMDAT

; 149  :   static ASMJIT_INLINE bool isInt8(T x) {

$LN11:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 150  :     if (IntTraits<T>::kIsSigned)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@isInt8

; 151  :       return sizeof(T) <= sizeof(int8_t) ? true : x >= T(-128) && x <= T(127);

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@isInt8
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN8@isInt8
$LN7@isInt8:
	cmp	DWORD PTR x$[rsp], -128			; ffffffffffffff80H
	jl	SHORT $LN5@isInt8
	cmp	DWORD PTR x$[rsp], 127			; 0000007fH
	jg	SHORT $LN5@isInt8
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN6@isInt8
$LN5@isInt8:
	mov	DWORD PTR tv67[rsp], 0
$LN6@isInt8:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR tv69[rsp], eax
$LN8@isInt8:
	movzx	eax, BYTE PTR tv69[rsp]
	jmp	SHORT $LN1@isInt8
	jmp	SHORT $LN3@isInt8
$LN2@isInt8:

; 152  :     else
; 153  :       return x <= T(127);

	cmp	DWORD PTR x$[rsp], 127			; 0000007fH
	jg	SHORT $LN9@isInt8
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN10@isInt8
$LN9@isInt8:
	mov	DWORD PTR tv72[rsp], 0
$LN10@isInt8:
	movzx	eax, BYTE PTR tv72[rsp]
$LN3@isInt8:
$LN1@isInt8:

; 154  :   }

	add	rsp, 24
	ret	0
??$isInt8@H@IntUtil@asmjit@@SA_NH@Z ENDP		; asmjit::IntUtil::isInt8<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z PROC ; asmjit::Zone::allocT<asmjit::LabelLink>, COMDAT

; 176  :   ASMJIT_INLINE T* allocT(size_t size = sizeof(T)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 177  :     return static_cast<T*>(alloc(size));

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::alloc

; 178  :   }

	add	rsp, 40					; 00000028H
	ret	0
??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z ENDP ; asmjit::Zone::allocT<asmjit::LabelLink>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ
_TEXT	SEGMENT
??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ PROC		; asmjit::IntUtil::maxUInt<unsigned __int64>, COMDAT

; 131  :   static ASMJIT_INLINE T maxUInt() { return ~T(0); }

	mov	rax, -1
	ret	0
??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ ENDP		; asmjit::IntUtil::maxUInt<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GAssembler@asmjit@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GAssembler@asmjit@@UEAAPEAXI@Z PROC			; asmjit::Assembler::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1Assembler@asmjit@@UEAA@XZ		; asmjit::Assembler::~Assembler
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 136				; 00000088H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GAssembler@asmjit@@UEAAPEAXI@Z ENDP			; asmjit::Assembler::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z PROC ; asmjit::PodVector<asmjit::RelocData>::operator[], COMDAT

; 247  :   ASMJIT_INLINE T& operator[](size_t i) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 248  :     ASMJIT_ASSERT(i < getLength());
; 249  :     return getData()[i];

	mov	rcx, QWORD PTR this$[rsp]
	call	?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ ; asmjit::PodVector<asmjit::RelocData>::getData
	imul	rcx, QWORD PTR i$[rsp], 24
	add	rax, rcx

; 250  :   }

	add	rsp, 40					; 00000028H
	ret	0
??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ENDP ; asmjit::PodVector<asmjit::RelocData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ
_TEXT	SEGMENT
this$ = 48
?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ PROC ; asmjit::PodVector<asmjit::RelocData>::getData, COMDAT

; 139  :   ASMJIT_INLINE T* getData() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 140  :     return static_cast<T*>(_d->getData());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData

; 141  :   }

	add	rsp, 40					; 00000028H
	ret	0
?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ ENDP ; asmjit::PodVector<asmjit::RelocData>::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ PROC	; asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>, COMDAT

; 117  :   ASMJIT_INLINE ~PodVector() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::~PodVectorBase
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ENDP	; asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA PROC ; `asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::~PodVectorBase
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA ENDP ; `asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ PROC	; asmjit::PodVector<asmjit::RelocData>::PodVector<asmjit::RelocData>, COMDAT

; 115  :   ASMJIT_INLINE PodVector() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::PodVectorBase
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ENDP	; asmjit::PodVector<asmjit::RelocData>::PodVector<asmjit::RelocData>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA PROC ; `asmjit::PodVector<asmjit::RelocData>::PodVector<asmjit::RelocData>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::~PodVectorBase
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ@4HA ENDP ; `asmjit::PodVector<asmjit::RelocData>::PodVector<asmjit::RelocData>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z PROC ; asmjit::PodVector<asmjit::LabelData>::operator[], COMDAT

; 253  :   ASMJIT_INLINE const T& operator[](size_t i) const {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 254  :     ASMJIT_ASSERT(i < getLength());
; 255  :     return getData()[i];

	mov	rcx, QWORD PTR this$[rsp]
	call	?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ ; asmjit::PodVector<asmjit::LabelData>::getData
	imul	rcx, QWORD PTR i$[rsp], 16
	add	rax, rcx

; 256  :   }

	add	rsp, 40					; 00000028H
	ret	0
??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z ENDP ; asmjit::PodVector<asmjit::LabelData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z
_TEXT	SEGMENT
errval_$1 = 32
d$ = 40
this$ = 64
item$ = 72
?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z PROC ; asmjit::PodVector<asmjit::LabelData>::append, COMDAT

; 201  :   Error append(const T& item) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :     PodVectorData* d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax

; 203  : 
; 204  :     if (d->length == d->capacity) {

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN5@append
$LN4@append:

; 205  :       ASMJIT_PROPAGATE_ERROR(_grow(1));

	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z ; asmjit::PodVector<asmjit::LabelData>::_grow
	mov	DWORD PTR errval_$1[rsp], eax
	cmp	DWORD PTR errval_$1[rsp], 0
	je	SHORT $LN6@append
	mov	eax, DWORD PTR errval_$1[rsp]
	jmp	SHORT $LN1@append
$LN6@append:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@append

; 206  :       d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax
$LN5@append:

; 207  :     }
; 208  : 
; 209  :     ::memcpy(static_cast<T*>(d->getData()) + d->length, &item, sizeof(T));

	mov	rcx, QWORD PTR d$[rsp]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData
	mov	rcx, QWORD PTR d$[rsp]
	imul	rcx, QWORD PTR [rcx+8], 16
	add	rax, rcx
	mov	r8d, 16
	mov	rdx, QWORD PTR item$[rsp]
	mov	rcx, rax
	call	memcpy

; 210  : 
; 211  :     d->length++;

	mov	rax, QWORD PTR d$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR d$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 212  :     return kErrorOk;

	xor	eax, eax
$LN1@append:

; 213  :   }

	add	rsp, 56					; 00000038H
	ret	0
?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z ENDP ; asmjit::PodVector<asmjit::LabelData>::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z
_TEXT	SEGMENT
this$ = 48
n$ = 56
?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z PROC ; asmjit::PodVector<asmjit::LabelData>::_grow, COMDAT

; 153  :   ASMJIT_INLINE Error _grow(size_t n) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 154  :     return PodVectorBase::_grow(n, sizeof(T));

	mov	r8d, 16
	mov	rdx, QWORD PTR n$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z	; asmjit::PodVectorBase::_grow

; 155  :   }

	add	rsp, 40					; 00000028H
	ret	0
?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z ENDP ; asmjit::PodVector<asmjit::LabelData>::_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ
_TEXT	SEGMENT
this$ = 48
?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ PROC ; asmjit::PodVector<asmjit::LabelData>::getData, COMDAT

; 144  :   ASMJIT_INLINE const T* getData() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 145  :     return static_cast<const T*>(_d->getData());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData

; 146  :   }

	add	rsp, 40					; 00000028H
	ret	0
?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ ENDP ; asmjit::PodVector<asmjit::LabelData>::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getLength@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getLength@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBA_KXZ PROC ; asmjit::PodVector<asmjit::LabelData>::getLength, COMDAT

; 129  :   ASMJIT_INLINE size_t getLength() const {

	mov	QWORD PTR [rsp+8], rcx

; 130  :     return _d->length;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]

; 131  :   }

	ret	0
?getLength@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBA_KXZ ENDP ; asmjit::PodVector<asmjit::LabelData>::getLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ PROC	; asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>, COMDAT

; 117  :   ASMJIT_INLINE ~PodVector() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::~PodVectorBase
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ENDP	; asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA PROC ; `asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::~PodVectorBase
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA ENDP ; `asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ PROC	; asmjit::PodVector<asmjit::LabelData>::PodVector<asmjit::LabelData>, COMDAT

; 115  :   ASMJIT_INLINE PodVector() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::PodVectorBase
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ENDP	; asmjit::PodVector<asmjit::LabelData>::PodVector<asmjit::LabelData>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA PROC ; `asmjit::PodVector<asmjit::LabelData>::PodVector<asmjit::LabelData>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1PodVectorBase@asmjit@@QEAA@XZ	; asmjit::PodVectorBase::~PodVectorBase
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ@4HA ENDP ; `asmjit::PodVector<asmjit::LabelData>::PodVector<asmjit::LabelData>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv80 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
o1$ = 120
o2$ = 128
o3$ = 136
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00_K@Z PROC	; asmjit::Assembler::emit

; 377  : Error Assembler::emit(uint32_t code, const Operand& o0, const Operand& o1, const Operand& o2, uint64_t o3) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 378  :   Imm imm(o3);

	mov	rdx, QWORD PTR o3$[rsp]
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 379  :   return _emit(code, o0, o1, o2, imm);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv80[rsp], rax
	lea	rax, QWORD PTR imm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR o2$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv80[rsp]

; 380  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00_K@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv81 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
o1$ = 120
o2$ = 128
o3$ = 136
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00H@Z PROC	; asmjit::Assembler::emit

; 372  : Error Assembler::emit(uint32_t code, const Operand& o0, const Operand& o1, const Operand& o2, int o3) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 373  :   Imm imm(o3);

	movsxd	rax, DWORD PTR o3$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 374  :   return _emit(code, o0, o1, o2, imm);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv81[rsp], rax
	lea	rax, QWORD PTR imm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR o2$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv81[rsp]

; 375  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00H@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv80 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
o1$ = 120
o2$ = 128
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0_K@Z PROC	; asmjit::Assembler::emit

; 367  : Error Assembler::emit(uint32_t code, const Operand& o0, const Operand& o1, uint64_t o2) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 368  :   Imm imm(o2);

	mov	rdx, QWORD PTR o2$[rsp]
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 369  :   return _emit(code, o0, o1, imm, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv80[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR imm$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv80[rsp]

; 370  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0_K@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv81 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
o1$ = 120
o2$ = 128
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0H@Z PROC	; asmjit::Assembler::emit

; 362  : Error Assembler::emit(uint32_t code, const Operand& o0, const Operand& o1, int o2) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 363  :   Imm imm(o2);

	movsxd	rax, DWORD PTR o2$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 364  :   return _emit(code, o0, o1, imm, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv81[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR imm$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv81[rsp]

; 365  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0H@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv80 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
o1$ = 120
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z PROC	; asmjit::Assembler::emit

; 357  : Error Assembler::emit(uint32_t code, const Operand& o0, uint64_t o1) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 358  :   Imm imm(o1);

	mov	rdx, QWORD PTR o1$[rsp]
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 359  :   return _emit(code, o0, imm, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv80[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR imm$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv80[rsp]

; 360  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@_K@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv81 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
o1$ = 120
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@H@Z PROC	; asmjit::Assembler::emit

; 352  : Error Assembler::emit(uint32_t code, const Operand& o0, int o1) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 353  :   Imm imm(o1);

	movsxd	rax, DWORD PTR o1$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 354  :   return _emit(code, o0, imm, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv81[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR imm$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv81[rsp]

; 355  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@H@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv80 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
?emit@Assembler@asmjit@@QEAAII_K@Z PROC			; asmjit::Assembler::emit

; 347  : Error Assembler::emit(uint32_t code, uint64_t o0) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 348  :   Imm imm(o0);

	mov	rdx, QWORD PTR o0$[rsp]
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 349  :   return _emit(code, imm, NA, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv80[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	lea	r8, QWORD PTR imm$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv80[rsp]

; 350  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAII_K@Z ENDP			; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv81 = 48
imm$ = 56
this$ = 96
code$ = 104
o0$ = 112
?emit@Assembler@asmjit@@QEAAIIH@Z PROC			; asmjit::Assembler::emit

; 342  : Error Assembler::emit(uint32_t code, int o0) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 343  :   Imm imm(o0);

	movsxd	rax, DWORD PTR o0$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR imm$[rsp]
	call	??0Imm@asmjit@@QEAA@_J@Z		; asmjit::Imm::Imm

; 344  :   return _emit(code, imm, NA, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv81[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	lea	r8, QWORD PTR imm$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv81[rsp]

; 345  : }

	add	rsp, 88					; 00000058H
	ret	0
?emit@Assembler@asmjit@@QEAAIIH@Z ENDP			; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv74 = 48
this$ = 80
code$ = 88
o0$ = 96
o1$ = 104
o2$ = 112
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00@Z PROC	; asmjit::Assembler::emit

; 338  : Error Assembler::emit(uint32_t code, const Operand& o0, const Operand& o1, const Operand& o2) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 339  :   return _emit(code, o0, o1, o2, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv74[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR o2$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv74[rsp]

; 340  : }

	add	rsp, 72					; 00000048H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@00@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv74 = 48
this$ = 80
code$ = 88
o0$ = 96
o1$ = 104
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z PROC	; asmjit::Assembler::emit

; 334  : Error Assembler::emit(uint32_t code, const Operand& o0, const Operand& o1) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 335  :   return _emit(code, o0, o1, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv74[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv74[rsp]

; 336  : }

	add	rsp, 72					; 00000048H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@0@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv74 = 48
this$ = 80
code$ = 88
o0$ = 96
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@@Z PROC	; asmjit::Assembler::emit

; 330  : Error Assembler::emit(uint32_t code, const Operand& o0) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 331  :   return _emit(code, o0, NA, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv74[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv74[rsp]

; 332  : }

	add	rsp, 72					; 00000048H
	ret	0
?emit@Assembler@asmjit@@QEAAIIAEBUOperand@2@@Z ENDP	; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv74 = 48
this$ = 80
code$ = 88
?emit@Assembler@asmjit@@QEAAII@Z PROC			; asmjit::Assembler::emit

; 326  : Error Assembler::emit(uint32_t code) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 327  :   return _emit(code, NA, NA, NA, NA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv74[rsp], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	lea	r8, OFFSET FLAT:?noOperand@asmjit@@3UOperand@1@B ; asmjit::noOperand
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv74[rsp]

; 328  : }

	add	rsp, 72					; 00000048H
	ret	0
?emit@Assembler@asmjit@@QEAAII@Z ENDP			; asmjit::Assembler::emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
error$ = 32
tv88 = 40
tv90 = 48
p$ = 56
this$ = 80
?make@Assembler@asmjit@@UEAAPEAXXZ PROC			; asmjit::Assembler::make

; 306  : void* Assembler::make() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 307  :   // Do nothing on error condition or if no instruction has been emitted.
; 308  :   if (_error != kErrorOk || getCodeSize() == 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+52], 0
	jne	SHORT $LN3@make
	mov	rcx, QWORD PTR this$[rsp]
	call	?getCodeSize@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getCodeSize
	test	rax, rax
	jne	SHORT $LN2@make
$LN3@make:

; 309  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@make
$LN2@make:

; 310  : 
; 311  :   void* p;
; 312  :   Error error = _runtime->add(&p, this);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv88[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv90[rsp], rax
	mov	r8, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR tv88[rsp]
	call	QWORD PTR tv90[rsp]
	mov	DWORD PTR error$[rsp], eax

; 313  : 
; 314  :   if (error != kErrorOk)

	cmp	DWORD PTR error$[rsp], 0
	je	SHORT $LN4@make

; 315  :     setError(error);

	xor	r8d, r8d
	mov	edx, DWORD PTR error$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	npad	1
$LN4@make:

; 316  : 
; 317  :   return p;

	mov	rax, QWORD PTR p$[rsp]
$LN1@make:

; 318  : }

	add	rsp, 72					; 00000048H
	ret	0
?make@Assembler@asmjit@@UEAAPEAXXZ ENDP			; asmjit::Assembler::make
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv79 = 32
tv94 = 40
this$ = 64
dst$ = 72
baseAddress$ = 80
?relocCode@Assembler@asmjit@@QEBA_KPEAX_K@Z PROC	; asmjit::Assembler::relocCode

; 293  : size_t Assembler::relocCode(void* dst, Ptr baseAddress) const {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 294  :   if (baseAddress == kNoBaseAddress)

	cmp	QWORD PTR baseAddress$[rsp], -1
	jne	SHORT $LN2@relocCode

; 295  :     baseAddress = hasBaseAddress() ? getBaseAddress() : static_cast<Ptr>((uintptr_t)dst);

	mov	rcx, QWORD PTR this$[rsp]
	call	?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ ; asmjit::CodeGen::hasBaseAddress
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@relocCode
	mov	rcx, QWORD PTR this$[rsp]
	call	?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ ; asmjit::CodeGen::getBaseAddress
	mov	QWORD PTR tv79[rsp], rax
	jmp	SHORT $LN7@relocCode
$LN6@relocCode:
	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR tv79[rsp], rax
$LN7@relocCode:
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR baseAddress$[rsp], rax
	jmp	SHORT $LN3@relocCode
$LN2@relocCode:

; 296  :   else if (getBaseAddress() != baseAddress)

	mov	rcx, QWORD PTR this$[rsp]
	call	?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ ; asmjit::CodeGen::getBaseAddress
	cmp	rax, QWORD PTR baseAddress$[rsp]
	je	SHORT $LN4@relocCode

; 297  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@relocCode
$LN4@relocCode:
$LN3@relocCode:

; 298  : 
; 299  :   return _relocCode(dst, baseAddress);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR tv94[rsp], rax
	mov	r8, QWORD PTR baseAddress$[rsp]
	mov	rdx, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv94[rsp]
$LN1@relocCode:

; 300  : }

	add	rsp, 56					; 00000038H
	ret	0
?relocCode@Assembler@asmjit@@QEBA_KPEAX_K@Z ENDP	; asmjit::Assembler::relocCode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
error$1 = 32
cursor$ = 40
this$ = 64
data$ = 72
size$ = 80
?embed@Assembler@asmjit@@UEAAIPEBXI@Z PROC		; asmjit::Assembler::embed

; 270  : Error Assembler::embed(const void* data, uint32_t size) {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 271  :   if (getRemainingSpace() < size) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ ; asmjit::Assembler::getRemainingSpace
	mov	ecx, DWORD PTR size$[rsp]
	cmp	rax, rcx
	jae	SHORT $LN2@embed

; 272  :     Error error = _grow(size);

	mov	eax, DWORD PTR size$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@Assembler@asmjit@@QEAAI_K@Z	; asmjit::Assembler::_grow
	mov	DWORD PTR error$1[rsp], eax

; 273  :     if (error != kErrorOk)

	cmp	DWORD PTR error$1[rsp], 0
	je	SHORT $LN3@embed

; 274  :       return setError(error);

	xor	r8d, r8d
	mov	edx, DWORD PTR error$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	SHORT $LN1@embed
$LN3@embed:
$LN2@embed:

; 275  :   }
; 276  : 
; 277  :   uint8_t* cursor = getCursor();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getCursor@Assembler@asmjit@@QEBAPEAEXZ	; asmjit::Assembler::getCursor
	mov	QWORD PTR cursor$[rsp], rax

; 278  :   ::memcpy(cursor, data, size);

	mov	eax, DWORD PTR size$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR cursor$[rsp]
	call	memcpy

; 279  :   setCursor(cursor + size);

	mov	eax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cursor$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?setCursor@Assembler@asmjit@@QEAAXPEAE@Z ; asmjit::Assembler::setCursor

; 280  : 
; 281  : #if !defined(ASMJIT_DISABLE_LOGGER)
; 282  :   if (_logger)
; 283  :     _logger->logBinary(kLoggerStyleData, data, size);
; 284  : #endif // !ASMJIT_DISABLE_LOGGER
; 285  : 
; 286  :   return kErrorOk;

	xor	eax, eax
$LN1@embed:

; 287  : }

	add	rsp, 56					; 00000038H
	ret	0
?embed@Assembler@asmjit@@UEAAIPEBXI@Z ENDP		; asmjit::Assembler::embed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
link$ = 32
error$ = 40
patchedValue$1 = 44
prev$ = 48
data$ = 56
offset$2 = 64
index$ = 72
size$3 = 76
pos$ = 80
tv130 = 88
tv128 = 96
this$ = 128
label$ = 136
?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z PROC	; asmjit::Assembler::bind

; 192  : Error Assembler::bind(const Label& label) {

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 193  :   // Get label data based on label id.
; 194  :   uint32_t index = label.getId();

	mov	rcx, QWORD PTR label$[rsp]
	call	?getId@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getId
	mov	DWORD PTR index$[rsp], eax

; 195  :   LabelData* data = getLabelData(index);

	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR data$[rsp], rax

; 196  : 
; 197  :   // Label can be bound only once.
; 198  :   if (data->offset != -1)

	mov	rax, QWORD PTR data$[rsp]
	cmp	QWORD PTR [rax], -1
	je	SHORT $LN4@bind

; 199  :     return setError(kErrorLabelAlreadyBound);

	xor	r8d, r8d
	mov	edx, 7
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@bind
$LN4@bind:

; 200  : 
; 201  : #if !defined(ASMJIT_DISABLE_LOGGER)
; 202  :   if (_logger)
; 203  :     _logger->logFormat(kLoggerStyleLabel, "L%u:\n", index);
; 204  : #endif // !ASMJIT_DISABLE_LOGGER
; 205  : 
; 206  :   Error error = kErrorOk;

	mov	DWORD PTR error$[rsp], 0

; 207  :   size_t pos = getOffset();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	QWORD PTR pos$[rsp], rax

; 208  : 
; 209  :   LabelLink* link = data->links;

	mov	rax, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR link$[rsp], rax

; 210  :   LabelLink* prev = NULL;

	mov	QWORD PTR prev$[rsp], 0
$LN2@bind:

; 211  : 
; 212  :   while (link) {

	cmp	QWORD PTR link$[rsp], 0
	je	$LN3@bind

; 213  :     intptr_t offset = link->offset;

	mov	rax, QWORD PTR link$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR offset$2[rsp], rax

; 214  : 
; 215  :     if (link->relocId != -1) {

	mov	rax, QWORD PTR link$[rsp]
	cmp	QWORD PTR [rax+24], -1
	je	SHORT $LN5@bind

; 216  :       // Handle RelocData - We have to update RelocData information instead of
; 217  :       // patching the displacement in LabelData.
; 218  :       _relocList[link->relocId].data += static_cast<Ptr>(pos);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv128[rsp], rax
	mov	rax, QWORD PTR link$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR tv128[rsp]
	call	??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ; asmjit::PodVector<asmjit::RelocData>::operator[]
	add	rax, 16
	mov	QWORD PTR tv130[rsp], rax
	mov	rax, QWORD PTR tv130[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	mov	QWORD PTR [rcx], rax

; 219  :     }

	jmp	$LN6@bind
$LN5@bind:

; 220  :     else {
; 221  :       // Not using relocId, this means that we are overwriting a real
; 222  :       // displacement in the binary stream.
; 223  :       int32_t patchedValue = static_cast<int32_t>(

	mov	rax, QWORD PTR offset$2[rsp]
	mov	rcx, QWORD PTR pos$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR link$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	DWORD PTR patchedValue$1[rsp], eax

; 224  :         static_cast<intptr_t>(pos) - offset + link->displacement);
; 225  : 
; 226  :       // Size of the value we are going to patch. Only BYTE/DWORD is allowed.
; 227  :       uint32_t size = getByteAt(offset);

	mov	rdx, QWORD PTR offset$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?getByteAt@Assembler@asmjit@@QEBAE_K@Z	; asmjit::Assembler::getByteAt
	movzx	eax, al
	mov	DWORD PTR size$3[rsp], eax

; 228  :       ASMJIT_ASSERT(size == 1 || size == 4);
; 229  : 
; 230  :       if (size == 4) {

	cmp	DWORD PTR size$3[rsp], 4
	jne	SHORT $LN7@bind

; 231  :         setInt32At(offset, patchedValue);

	mov	r8d, DWORD PTR patchedValue$1[rsp]
	mov	rdx, QWORD PTR offset$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setInt32At@Assembler@asmjit@@QEAAX_KH@Z ; asmjit::Assembler::setInt32At
	npad	1

; 232  :       }

	jmp	SHORT $LN8@bind
$LN7@bind:

; 233  :       else {
; 234  :         ASMJIT_ASSERT(size == 1);
; 235  :         if (IntUtil::isInt8(patchedValue))

	mov	ecx, DWORD PTR patchedValue$1[rsp]
	call	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z	; asmjit::IntUtil::isInt8<int>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@bind

; 236  :           setByteAt(offset, static_cast<uint8_t>(patchedValue & 0xFF));

	mov	eax, DWORD PTR patchedValue$1[rsp]
	and	eax, 255				; 000000ffH
	movzx	r8d, al
	mov	rdx, QWORD PTR offset$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setByteAt@Assembler@asmjit@@QEAAX_KE@Z	; asmjit::Assembler::setByteAt
	npad	1
	jmp	SHORT $LN10@bind
$LN9@bind:

; 237  :         else
; 238  :           error = kErrorIllegalDisplacement;

	mov	DWORD PTR error$[rsp], 11
$LN10@bind:
$LN8@bind:
$LN6@bind:

; 239  :       }
; 240  :     }
; 241  : 
; 242  :     prev = link->prev;

	mov	rax, QWORD PTR link$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR prev$[rsp], rax

; 243  :     link = prev;

	mov	rax, QWORD PTR prev$[rsp]
	mov	QWORD PTR link$[rsp], rax

; 244  :   }

	jmp	$LN2@bind
$LN3@bind:

; 245  : 
; 246  :   // Chain unused links.
; 247  :   link = data->links;

	mov	rax, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR link$[rsp], rax

; 248  :   if (link) {

	cmp	QWORD PTR link$[rsp], 0
	je	SHORT $LN11@bind

; 249  :     if (prev == NULL)

	cmp	QWORD PTR prev$[rsp], 0
	jne	SHORT $LN12@bind

; 250  :       prev = link;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR prev$[rsp], rax
$LN12@bind:

; 251  : 
; 252  :     prev->prev = _unusedLinks;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax], rcx

; 253  :     _unusedLinks = link;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR link$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN11@bind:

; 254  :   }
; 255  : 
; 256  :   // Set as bound (offset is zero or greater and no links).
; 257  :   data->offset = pos;

	mov	rax, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rax], rcx

; 258  :   data->links = NULL;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 259  : 
; 260  :   if (error != kErrorOk)

	cmp	DWORD PTR error$[rsp], 0
	je	SHORT $LN13@bind

; 261  :     return setError(error);

	xor	r8d, r8d
	mov	edx, DWORD PTR error$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	SHORT $LN1@bind
$LN13@bind:

; 262  : 
; 263  :   return error;

	mov	eax, DWORD PTR error$[rsp]
$LN1@bind:

; 264  : }

	add	rsp, 120				; 00000078H
	ret	0
?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z ENDP	; asmjit::Assembler::bind
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
link$ = 32
tv77 = 40
this$ = 64
?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ PROC ; asmjit::Assembler::_newLabelLink

; 172  : LabelLink* Assembler::_newLabelLink() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 173  :   LabelLink* link = _unusedLinks;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR link$[rsp], rax

; 174  : 
; 175  :   if (link) {

	cmp	QWORD PTR link$[rsp], 0
	je	SHORT $LN2@newLabelLi

; 176  :     _unusedLinks = link->prev;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR link$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+112], rcx

; 177  :   }

	jmp	SHORT $LN3@newLabelLi
$LN2@newLabelLi:

; 178  :   else {
; 179  :     link = _baseZone.allocT<LabelLink>();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv77[rsp], rax
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$allocT@ULabelLink@asmjit@@@Zone@asmjit@@QEAAPEAULabelLink@1@_K@Z ; asmjit::Zone::allocT<asmjit::LabelLink>
	mov	QWORD PTR link$[rsp], rax

; 180  :     if (link == NULL)

	cmp	QWORD PTR link$[rsp], 0
	jne	SHORT $LN4@newLabelLi

; 181  :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@newLabelLi
$LN4@newLabelLi:
$LN3@newLabelLi:

; 182  :   }
; 183  : 
; 184  :   link->prev = NULL;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR [rax], 0

; 185  :   link->offset = 0;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR [rax+8], 0

; 186  :   link->displacement = 0;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR [rax+16], 0

; 187  :   link->relocId = -1;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR [rax+24], -1

; 188  : 
; 189  :   return link;

	mov	rax, QWORD PTR link$[rsp]
$LN1@newLabelLi:

; 190  : }

	add	rsp, 56					; 00000038H
	ret	0
?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ ENDP ; asmjit::Assembler::_newLabelLink
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv93 = 32
data$ = 40
this$ = 80
dst$ = 88
?_newLabel@Assembler@asmjit@@QEAAIPEAULabel@2@@Z PROC	; asmjit::Assembler::_newLabel

; 154  : Error Assembler::_newLabel(Label* dst) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 155  :   dst->_label.op = kOperandTypeLabel;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 5

; 156  :   dst->_label.size = 0;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax+1], 0

; 157  :   dst->_label.id = OperandUtil::makeLabelId(static_cast<uint32_t>(_labelList.getLength()));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?getLength@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::LabelData>::getLength
	mov	ecx, eax
	call	?makeLabelId@OperandUtil@asmjit@@SAII@Z	; asmjit::OperandUtil::makeLabelId
	mov	rcx, QWORD PTR dst$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 158  : 
; 159  :   LabelData data;
; 160  :   data.offset = -1;

	mov	QWORD PTR data$[rsp], -1

; 161  :   data.links = NULL;

	mov	QWORD PTR data$[rsp+8], 0

; 162  : 
; 163  :   if (_labelList.append(data) != kErrorOk)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv93[rsp], rax
	lea	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR tv93[rsp]
	call	?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z ; asmjit::PodVector<asmjit::LabelData>::append
	test	eax, eax
	je	SHORT $LN2@newLabel

; 164  :     goto _NoMemory;

	jmp	SHORT $LN3@newLabel
	jmp	SHORT $_NoMemory$6
$LN2@newLabel:

; 165  :   return kErrorOk;

	xor	eax, eax
	jmp	SHORT $LN1@newLabel
$LN3@newLabel:
$_NoMemory$6:

; 166  : 
; 167  : _NoMemory:
; 168  :   dst->_label.id = kInvalidValue;

	mov	rax, QWORD PTR dst$[rsp]
	mov	DWORD PTR [rax+4], -1			; ffffffffH

; 169  :   return setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
$LN1@newLabel:

; 170  : }

	add	rsp, 72					; 00000048H
	ret	0
?_newLabel@Assembler@asmjit@@QEAAIPEAULabel@2@@Z ENDP	; asmjit::Assembler::_newLabel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
i$ = 32
tv74 = 40
tv89 = 48
data$ = 56
this$ = 96
index$ = 104
?_registerIndexedLabels@Assembler@asmjit@@QEAAI_K@Z PROC ; asmjit::Assembler::_registerIndexedLabels

; 135  : Error Assembler::_registerIndexedLabels(size_t index) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 136  :   size_t i = _labelList.getLength();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?getLength@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::LabelData>::getLength
	mov	QWORD PTR i$[rsp], rax

; 137  :   if (index < i)

	mov	rax, QWORD PTR i$[rsp]
	cmp	QWORD PTR index$[rsp], rax
	jae	SHORT $LN5@registerIn

; 138  :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@registerIn
$LN5@registerIn:

; 139  : 
; 140  :   if (_labelList._grow(index - i) != kErrorOk)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR index$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR tv74[rsp]
	call	?_grow@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAI_K@Z ; asmjit::PodVector<asmjit::LabelData>::_grow
	test	eax, eax
	je	SHORT $LN6@registerIn

; 141  :     return setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	SHORT $LN1@registerIn
$LN6@registerIn:

; 142  : 
; 143  :   LabelData data;
; 144  :   data.offset = -1;

	mov	QWORD PTR data$[rsp], -1

; 145  :   data.links = NULL;

	mov	QWORD PTR data$[rsp+8], 0
$LN4@registerIn:

; 146  : 
; 147  :   do {
; 148  :     _labelList.append(data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR tv89[rsp]
	call	?append@?$PodVector@ULabelData@asmjit@@@asmjit@@QEAAIAEBULabelData@2@@Z ; asmjit::PodVector<asmjit::LabelData>::append
	npad	1

; 149  :   } while (++i < index);

	mov	rax, QWORD PTR i$[rsp]
	inc	rax
	mov	QWORD PTR i$[rsp], rax
	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR i$[rsp], rax
	jb	SHORT $LN4@registerIn

; 150  : 
; 151  :   return kErrorOk;

	xor	eax, eax
$LN1@registerIn:

; 152  : }

	add	rsp, 88					; 00000058H
	ret	0
?_registerIndexedLabels@Assembler@asmjit@@QEAAI_K@Z ENDP ; asmjit::Assembler::_registerIndexedLabels
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z
_TEXT	SEGMENT
tv70 = 32
this$ = 64
id$ = 72
?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z PROC ; asmjit::Assembler::getLabelData, COMDAT

; 375  :   ASMJIT_INLINE LabelData* getLabelData(uint32_t id) const {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 376  :     ASMJIT_ASSERT(isLabelValid(id));
; 377  :     return const_cast<LabelData*>(&_labelList[id]);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv70[rsp], rax
	mov	eax, DWORD PTR id$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv70[rsp]
	call	??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z ; asmjit::PodVector<asmjit::LabelData>::operator[]

; 378  :   }

	add	rsp, 56					; 00000038H
	ret	0
?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ENDP ; asmjit::Assembler::getLabelData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ PROC	; asmjit::Assembler::getTrampolineSize, COMDAT

; 318  :   ASMJIT_INLINE size_t getTrampolineSize() const {

	mov	QWORD PTR [rsp+8], rcx

; 319  :     return _trampolineSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+96]

; 320  :   }

	ret	0
?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ ENDP	; asmjit::Assembler::getTrampolineSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getCodeSize@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?getCodeSize@Assembler@asmjit@@QEBA_KXZ PROC		; asmjit::Assembler::getCodeSize, COMDAT

; 304  :   ASMJIT_INLINE size_t getCodeSize() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 305  :     return getOffset() + getTrampolineSize();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	QWORD PTR tv65[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ ; asmjit::Assembler::getTrampolineSize
	mov	rcx, QWORD PTR tv65[rsp]
	add	rcx, rax
	mov	rax, rcx

; 306  :   }

	add	rsp, 56					; 00000038H
	ret	0
?getCodeSize@Assembler@asmjit@@QEBA_KXZ ENDP		; asmjit::Assembler::getCodeSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?setInt32At@Assembler@asmjit@@QEAAX_KH@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
x$ = 24
?setInt32At@Assembler@asmjit@@QEAAX_KH@Z PROC		; asmjit::Assembler::setInt32At, COMDAT

; 288  :   ASMJIT_INLINE void setInt32At(size_t pos, int32_t x) {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 289  :     ASMJIT_ASSERT(pos + 4 <= (size_t)(_end - _buffer));
; 290  :     *reinterpret_cast<int32_t*>(_buffer + pos) = x;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR pos$[rsp]
	mov	edx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax+rcx], edx

; 291  :   }

	ret	0
?setInt32At@Assembler@asmjit@@QEAAX_KH@Z ENDP		; asmjit::Assembler::setInt32At
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?setByteAt@Assembler@asmjit@@QEAAX_KE@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
x$ = 24
?setByteAt@Assembler@asmjit@@QEAAX_KE@Z PROC		; asmjit::Assembler::setByteAt, COMDAT

; 264  :   ASMJIT_INLINE void setByteAt(size_t pos, uint8_t x) {

	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 265  :     ASMJIT_ASSERT(pos + 1 <= (size_t)(_end - _buffer));
; 266  :     *reinterpret_cast<uint8_t*>(_buffer + pos) = x;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR pos$[rsp]
	movzx	edx, BYTE PTR x$[rsp]
	mov	BYTE PTR [rax+rcx], dl

; 267  :   }

	ret	0
?setByteAt@Assembler@asmjit@@QEAAX_KE@Z ENDP		; asmjit::Assembler::setByteAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getByteAt@Assembler@asmjit@@QEBAE_K@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
?getByteAt@Assembler@asmjit@@QEBAE_K@Z PROC		; asmjit::Assembler::getByteAt, COMDAT

; 228  :   ASMJIT_INLINE uint8_t getByteAt(size_t pos) const {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 229  :     ASMJIT_ASSERT(pos + 1 <= (size_t)(_end - _buffer));
; 230  :     return *reinterpret_cast<const uint8_t*>(_buffer + pos);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR pos$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]

; 231  :   }

	ret	0
?getByteAt@Assembler@asmjit@@QEBAE_K@Z ENDP		; asmjit::Assembler::getByteAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
newBuffer$ = 32
capacity$ = 40
offset$ = 48
this$ = 80
n$ = 88
?_reserve@Assembler@asmjit@@QEAAI_K@Z PROC		; asmjit::Assembler::_reserve

; 108  : Error Assembler::_reserve(size_t n) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 109  :   size_t capacity = getCapacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getCapacity@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getCapacity
	mov	QWORD PTR capacity$[rsp], rax

; 110  :   if (n <= capacity)

	mov	rax, QWORD PTR capacity$[rsp]
	cmp	QWORD PTR n$[rsp], rax
	ja	SHORT $LN2@reserve

; 111  :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@reserve
$LN2@reserve:

; 112  : 
; 113  :   uint8_t* newBuffer;
; 114  :   if (_buffer == NULL)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 0
	jne	SHORT $LN3@reserve

; 115  :     newBuffer = static_cast<uint8_t*>(ASMJIT_ALLOC(n));

	mov	rcx, QWORD PTR n$[rsp]
	call	malloc
	mov	QWORD PTR newBuffer$[rsp], rax
	jmp	SHORT $LN4@reserve
$LN3@reserve:

; 116  :   else
; 117  :     newBuffer = static_cast<uint8_t*>(ASMJIT_REALLOC(_buffer, n));

	mov	rdx, QWORD PTR n$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+72]
	call	realloc
	mov	QWORD PTR newBuffer$[rsp], rax
$LN4@reserve:

; 118  : 
; 119  :   if (newBuffer == NULL)

	cmp	QWORD PTR newBuffer$[rsp], 0
	jne	SHORT $LN5@reserve

; 120  :     return setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	SHORT $LN1@reserve
$LN5@reserve:

; 121  : 
; 122  :   size_t offset = getOffset();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	QWORD PTR offset$[rsp], rax

; 123  : 
; 124  :   _buffer = newBuffer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR newBuffer$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 125  :   _end = _buffer + n;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, QWORD PTR n$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 126  :   _cursor = newBuffer + offset;

	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR newBuffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 127  : 
; 128  :   return kErrorOk;

	xor	eax, eax
$LN1@reserve:

; 129  : }

	add	rsp, 72					; 00000048H
	ret	0
?_reserve@Assembler@asmjit@@QEAAI_K@Z ENDP		; asmjit::Assembler::_reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
capacity$ = 32
after$ = 40
oldCapacity$1 = 48
this$ = 80
n$ = 88
?_grow@Assembler@asmjit@@QEAAI_K@Z PROC			; asmjit::Assembler::_grow

; 73   : Error Assembler::_grow(size_t n) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 74   :   size_t capacity = getCapacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getCapacity@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getCapacity
	mov	QWORD PTR capacity$[rsp], rax

; 75   :   size_t after = getOffset() + n;

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	add	rax, QWORD PTR n$[rsp]
	mov	QWORD PTR after$[rsp], rax

; 76   : 
; 77   :   // Overflow.
; 78   :   if (n > IntUtil::maxUInt<uintptr_t>() - capacity)

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	sub	rax, QWORD PTR capacity$[rsp]
	cmp	QWORD PTR n$[rsp], rax
	jbe	SHORT $LN5@grow

; 79   :     return setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@grow
$LN5@grow:

; 80   : 
; 81   :   // Grow is called when allocation is needed, so it shouldn't happen, but on
; 82   :   // the other hand it is simple to catch and it's not an error.
; 83   :   if (after <= capacity)

	mov	rax, QWORD PTR capacity$[rsp]
	cmp	QWORD PTR after$[rsp], rax
	ja	SHORT $LN6@grow

; 84   :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@grow
$LN6@grow:

; 85   : 
; 86   :   if (capacity < kMemAllocOverhead)

	cmp	QWORD PTR capacity$[rsp], 32		; 00000020H
	jae	SHORT $LN7@grow

; 87   :     capacity = kMemAllocOverhead;

	mov	QWORD PTR capacity$[rsp], 32		; 00000020H
	jmp	SHORT $LN8@grow
$LN7@grow:

; 88   :   else
; 89   :     capacity += kMemAllocOverhead;

	mov	rax, QWORD PTR capacity$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR capacity$[rsp], rax
$LN8@grow:
$LN4@grow:

; 90   : 
; 91   :   do {
; 92   :     size_t oldCapacity = capacity;

	mov	rax, QWORD PTR capacity$[rsp]
	mov	QWORD PTR oldCapacity$1[rsp], rax

; 93   : 
; 94   :     if (capacity < kMemAllocGrowMax)

	cmp	QWORD PTR capacity$[rsp], 8388608	; 00800000H
	jae	SHORT $LN9@grow

; 95   :       capacity *= 2;

	mov	rax, QWORD PTR capacity$[rsp]
	shl	rax, 1
	mov	QWORD PTR capacity$[rsp], rax
	jmp	SHORT $LN10@grow
$LN9@grow:

; 96   :     else
; 97   :       capacity += kMemAllocGrowMax;

	mov	rax, QWORD PTR capacity$[rsp]
	add	rax, 8388608				; 00800000H
	mov	QWORD PTR capacity$[rsp], rax
$LN10@grow:

; 98   : 
; 99   :     // Overflow.
; 100  :     if (oldCapacity > capacity)

	mov	rax, QWORD PTR capacity$[rsp]
	cmp	QWORD PTR oldCapacity$1[rsp], rax
	jbe	SHORT $LN11@grow

; 101  :       return setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	SHORT $LN1@grow
$LN11@grow:

; 102  :   } while (capacity - kMemAllocOverhead < after);

	mov	rax, QWORD PTR capacity$[rsp]
	sub	rax, 32					; 00000020H
	cmp	rax, QWORD PTR after$[rsp]
	jb	SHORT $LN4@grow

; 103  : 
; 104  :   capacity -= kMemAllocOverhead;

	mov	rax, QWORD PTR capacity$[rsp]
	sub	rax, 32					; 00000020H
	mov	QWORD PTR capacity$[rsp], rax

; 105  :   return _reserve(capacity);

	mov	rdx, QWORD PTR capacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_reserve@Assembler@asmjit@@QEAAI_K@Z	; asmjit::Assembler::_reserve
$LN1@grow:

; 106  : }

	add	rsp, 72					; 00000048H
	ret	0
?_grow@Assembler@asmjit@@QEAAI_K@Z ENDP			; asmjit::Assembler::_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getOffset@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getOffset@Assembler@asmjit@@QEBA_KXZ PROC		; asmjit::Assembler::getOffset, COMDAT

; 203  :   ASMJIT_INLINE size_t getOffset() const {

	mov	QWORD PTR [rsp+8], rcx

; 204  :     return (size_t)(_cursor - _buffer);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	rax, QWORD PTR [rax+88]
	sub	rax, rcx

; 205  :   }

	ret	0
?getOffset@Assembler@asmjit@@QEBA_KXZ ENDP		; asmjit::Assembler::getOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?setCursor@Assembler@asmjit@@QEAAXPEAE@Z
_TEXT	SEGMENT
this$ = 8
cursor$ = 16
?setCursor@Assembler@asmjit@@QEAAXPEAE@Z PROC		; asmjit::Assembler::setCursor, COMDAT

; 197  :   ASMJIT_INLINE void setCursor(uint8_t* cursor) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 198  :     ASMJIT_ASSERT(cursor >= _buffer && cursor <= _end);
; 199  :     _cursor = cursor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 200  :   }

	ret	0
?setCursor@Assembler@asmjit@@QEAAXPEAE@Z ENDP		; asmjit::Assembler::setCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getCursor@Assembler@asmjit@@QEBAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?getCursor@Assembler@asmjit@@QEBAPEAEXZ PROC		; asmjit::Assembler::getCursor, COMDAT

; 192  :   ASMJIT_INLINE uint8_t* getCursor() const {

	mov	QWORD PTR [rsp+8], rcx

; 193  :     return _cursor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]

; 194  :   }

	ret	0
?getCursor@Assembler@asmjit@@QEBAPEAEXZ ENDP		; asmjit::Assembler::getCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ PROC	; asmjit::Assembler::getRemainingSpace, COMDAT

; 177  :   ASMJIT_INLINE size_t getRemainingSpace() const {

	mov	QWORD PTR [rsp+8], rcx

; 178  :     return (size_t)(_end - _cursor);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	rax, QWORD PTR [rax+80]
	sub	rax, rcx

; 179  :   }

	ret	0
?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ ENDP	; asmjit::Assembler::getRemainingSpace
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getCapacity@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getCapacity@Assembler@asmjit@@QEBA_KXZ PROC		; asmjit::Assembler::getCapacity, COMDAT

; 171  :   ASMJIT_INLINE size_t getCapacity() const {

	mov	QWORD PTR [rsp+8], rcx

; 172  :     return (size_t)(_end - _buffer);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	rax, QWORD PTR [rax+80]
	sub	rax, rcx

; 173  :   }

	ret	0
?getCapacity@Assembler@asmjit@@QEBA_KXZ ENDP		; asmjit::Assembler::getCapacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
tv87 = 32
tv141 = 40
tv150 = 48
this$ = 80
releaseMemory$ = 88
?reset@Assembler@asmjit@@QEAAX_N@Z PROC			; asmjit::Assembler::reset

; 44   : void Assembler::reset(bool releaseMemory) {

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 45   :   // CodeGen members.
; 46   :   _baseAddress = kNoBaseAddress;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], -1

; 47   :   _instOptions = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+48], 0

; 48   :   _error = kErrorOk;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+52], 0

; 49   : 
; 50   :   _baseZone.reset(releaseMemory);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv87[rsp], rax
	movzx	edx, BYTE PTR releaseMemory$[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	?reset@Zone@asmjit@@QEAAX_N@Z		; asmjit::Zone::reset
	npad	1

; 51   : 
; 52   :   // Assembler members.
; 53   :   if (releaseMemory && _buffer != NULL) {

	movzx	eax, BYTE PTR releaseMemory$[rsp]
	test	eax, eax
	je	SHORT $LN2@reset
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN2@reset

; 54   :     ASMJIT_FREE(_buffer);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+72]
	call	free

; 55   :     _buffer = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 56   :     _end = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0
$LN2@reset:

; 57   :   }
; 58   : 
; 59   :   _cursor = _buffer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+88], rcx

; 60   :   _trampolineSize = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+96], 0

; 61   : 
; 62   :   _comment = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+104], 0

; 63   :   _unusedLinks = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+112], 0

; 64   : 
; 65   :   _labelList.reset(releaseMemory);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv141[rsp], rax
	movzx	edx, BYTE PTR releaseMemory$[rsp]
	mov	rcx, QWORD PTR tv141[rsp]
	call	?reset@PodVectorBase@asmjit@@QEAAX_N@Z	; asmjit::PodVectorBase::reset

; 66   :   _relocList.reset(releaseMemory);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv150[rsp], rax
	movzx	edx, BYTE PTR releaseMemory$[rsp]
	mov	rcx, QWORD PTR tv150[rsp]
	call	?reset@PodVectorBase@asmjit@@QEAAX_N@Z	; asmjit::PodVectorBase::reset
	npad	1

; 67   : }

	add	rsp, 72					; 00000048H
	ret	0
?reset@Assembler@asmjit@@QEAAX_N@Z ENDP			; asmjit::Assembler::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
this$ = 48
??1Assembler@asmjit@@UEAA@XZ PROC			; asmjit::Assembler::~Assembler

; 36   : Assembler::~Assembler() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7Assembler@asmjit@@6B@
	mov	QWORD PTR [rax], rcx

; 37   :   reset(true);

	mov	dl, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?reset@Assembler@asmjit@@QEAAX_N@Z	; asmjit::Assembler::reset
	npad	1

; 38   : }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>
	npad	1
	mov	rcx, QWORD PTR this$[rsp]
	call	??1CodeGen@asmjit@@UEAA@XZ		; asmjit::CodeGen::~CodeGen
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1Assembler@asmjit@@UEAA@XZ ENDP			; asmjit::Assembler::~Assembler
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA PROC	; `asmjit::Assembler::~Assembler'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1CodeGen@asmjit@@UEAA@XZ		; asmjit::CodeGen::~CodeGen
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1Assembler@asmjit@@UEAA@XZ@4HA ENDP	; `asmjit::Assembler::~Assembler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA PROC	; `asmjit::Assembler::~Assembler'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 120				; 00000078H
	call	??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1Assembler@asmjit@@UEAA@XZ@4HA ENDP	; `asmjit::Assembler::~Assembler'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA PROC	; `asmjit::Assembler::~Assembler'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1Assembler@asmjit@@UEAA@XZ@4HA ENDP	; `asmjit::Assembler::~Assembler'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.cpp
_TEXT	SEGMENT
this$ = 48
runtime$ = 56
??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z PROC		; asmjit::Assembler::Assembler

; 34   :   _unusedLinks(NULL) {}

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 28   :   CodeGen(runtime),

	mov	rdx, QWORD PTR runtime$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0CodeGen@asmjit@@QEAA@PEAURuntime@1@@Z ; asmjit::CodeGen::CodeGen
	npad	1

; 34   :   _unusedLinks(NULL) {}

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7Assembler@asmjit@@6B@
	mov	QWORD PTR [rax], rcx

; 29   :   _buffer(NULL),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 30   :   _end(NULL),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 31   :   _cursor(NULL),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+88], 0

; 32   :   _trampolineSize(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+96], 0

; 33   :   _comment(NULL),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+104], 0

; 34   :   _unusedLinks(NULL) {}

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+112], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	??0?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::LabelData>::PodVector<asmjit::LabelData>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??0?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::RelocData>::PodVector<asmjit::RelocData>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z ENDP		; asmjit::Assembler::Assembler
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
runtime$ = 56
?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA PROC ; `asmjit::Assembler::Assembler'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1CodeGen@asmjit@@UEAA@XZ		; asmjit::CodeGen::~CodeGen
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA ENDP ; `asmjit::Assembler::Assembler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
runtime$ = 56
?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA PROC ; `asmjit::Assembler::Assembler'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 120				; 00000078H
	call	??1?$PodVector@ULabelData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::LabelData>::~PodVector<asmjit::LabelData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA ENDP ; `asmjit::Assembler::Assembler'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
runtime$ = 56
?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA PROC ; `asmjit::Assembler::Assembler'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$PodVector@URelocData@asmjit@@@asmjit@@QEAA@XZ ; asmjit::PodVector<asmjit::RelocData>::~PodVector<asmjit::RelocData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z@4HA ENDP ; `asmjit::Assembler::Assembler'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Imm@asmjit@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 64
val$ = 72
??0Imm@asmjit@@QEAA@_J@Z PROC				; asmjit::Imm::Imm, COMDAT

; 742  :   explicit Imm(int64_t val) : Operand(NoInit) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::Operand::Operand

; 743  :     _init_packed_op_sz_b0_b1_id(kOperandTypeImm, 0, 0, 0, kInvalidValue);

	mov	DWORD PTR [rsp+40], -1			; ffffffffH
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, 4
	mov	rcx, QWORD PTR this$[rsp]
	call	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id

; 744  :     _imm.value._i64[0] = val;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR val$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx

; 745  :   }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0Imm@asmjit@@QEAA@_J@Z ENDP				; asmjit::Imm::Imm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?makeLabelId@OperandUtil@asmjit@@SAII@Z
_TEXT	SEGMENT
id$ = 8
?makeLabelId@OperandUtil@asmjit@@SAII@Z PROC		; asmjit::OperandUtil::makeLabelId, COMDAT

; 491  :   static ASMJIT_INLINE uint32_t makeLabelId(uint32_t id) {

	mov	DWORD PTR [rsp+8], ecx

; 492  :     return id;

	mov	eax, DWORD PTR id$[rsp]

; 493  :   }

	ret	0
?makeLabelId@OperandUtil@asmjit@@SAII@Z ENDP		; asmjit::OperandUtil::makeLabelId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getId@Operand@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getId@Operand@asmjit@@QEBAIXZ PROC			; asmjit::Operand::getId, COMDAT

; 454  :   ASMJIT_INLINE uint32_t getId() const {

	mov	QWORD PTR [rsp+8], rcx

; 455  :     return _base.id;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]

; 456  :   }

	ret	0
?getId@Operand@asmjit@@QEBAIXZ ENDP			; asmjit::Operand::getId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z
_TEXT	SEGMENT
tv77 = 32
this$ = 64
op$ = 72
sz$ = 80
r0$ = 88
r1$ = 96
id$ = 104
?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z PROC ; asmjit::Operand::_init_packed_op_sz_b0_b1_id, COMDAT

; 334  :   ASMJIT_INLINE void _init_packed_op_sz_b0_b1_id(uint32_t op, uint32_t sz, uint32_t r0, uint32_t r1, uint32_t id) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 335  :     // This hack is not for performance, but to decrease the size of the binary
; 336  :     // generated when constructing AsmJit operands (mostly for third parties).
; 337  :     // Some compilers are not able to join four BYTE writes to a single DWORD
; 338  :     // write. Because the 'a', 'b', 'c' and 'd' variables are usually compile
; 339  :     // time constants the compiler can do a really nice job if they are joined
; 340  :     // by using bitwise operations.
; 341  :     _packed[0].setPacked_2x32(IntUtil::pack32_4x8(op, sz, r0, r1), id);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv77[rsp], rax
	mov	r9d, DWORD PTR r1$[rsp]
	mov	r8d, DWORD PTR r0$[rsp]
	mov	edx, DWORD PTR sz$[rsp]
	mov	ecx, DWORD PTR op$[rsp]
	call	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z	; asmjit::IntUtil::pack32_4x8
	mov	r8d, DWORD PTR id$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv77[rsp]
	call	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ; asmjit::UInt64::setPacked_2x32
	npad	1

; 342  :   }

	add	rsp, 56					; 00000038H
	ret	0
?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ENDP ; asmjit::Operand::_init_packed_op_sz_b0_b1_id
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::Operand::Operand, COMDAT

; 312  :   explicit ASMJIT_INLINE Operand(const _NoInit&) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::Operand::Operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z
_TEXT	SEGMENT
this$ = 48
u0$ = 56
u1$ = 64
?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z PROC	; asmjit::UInt64::setPacked_2x32, COMDAT

; 498  :   ASMJIT_INLINE UInt64& setPacked_2x32(uint32_t u0, uint32_t u1) {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 499  :     if (kArchHost64Bit) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@setPacked_

; 500  :       u64 = IntUtil::pack64_2x32(u0, u1);

	mov	edx, DWORD PTR u1$[rsp]
	mov	ecx, DWORD PTR u0$[rsp]
	call	?pack64_2x32@IntUtil@asmjit@@SA_KII@Z	; asmjit::IntUtil::pack64_2x32
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 501  :     }

	jmp	SHORT $LN3@setPacked_
$LN2@setPacked_:

; 502  :     else {
; 503  :       u32[0] = u0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR u0$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 504  :       u32[1] = u1;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR u1$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN3@setPacked_:

; 505  :     }
; 506  :     return *this;

	mov	rax, QWORD PTR this$[rsp]

; 507  :   }

	add	rsp, 40					; 00000028H
	ret	0
?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ENDP	; asmjit::UInt64::setPacked_2x32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack64_2x32@IntUtil@asmjit@@SA_KII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
?pack64_2x32@IntUtil@asmjit@@SA_KII@Z PROC		; asmjit::IntUtil::pack64_2x32, COMDAT

; 102  :   static ASMJIT_INLINE uint64_t pack64_2x32(uint32_t u0, uint32_t u1) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 103  : #if defined(ASMJIT_HOST_LE)
; 104  :     return (static_cast<uint64_t>(u1) << 32) + u0;

	mov	eax, DWORD PTR u1$[rsp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR u0$[rsp]
	add	rax, rcx

; 105  : #else
; 106  :     return (static_cast<uint64_t>(u0) << 32) + u1;
; 107  : #endif // ASMJIT_HOST
; 108  :   }

	ret	0
?pack64_2x32@IntUtil@asmjit@@SA_KII@Z ENDP		; asmjit::IntUtil::pack64_2x32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
u2$ = 24
u3$ = 32
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z PROC		; asmjit::IntUtil::pack32_4x8, COMDAT

; 93   :   static ASMJIT_INLINE uint32_t pack32_4x8(uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3) {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 94   : #if defined(ASMJIT_HOST_LE)
; 95   :     return u0 + (u1 << 8) + (u2 << 16) + (u3 << 24);

	mov	eax, DWORD PTR u1$[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR u0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR u2$[rsp]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, DWORD PTR u3$[rsp]
	shl	ecx, 24
	add	eax, ecx

; 96   : #else
; 97   :     return (u0 << 24) + (u1 << 16) + (u2 << 8) + u3;
; 98   : #endif // ASMJIT_HOST
; 99   :   }

	ret	0
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z ENDP		; asmjit::IntUtil::pack32_4x8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??1PodVectorBase@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1PodVectorBase@asmjit@@QEAA@XZ PROC			; asmjit::PodVectorBase::~PodVectorBase, COMDAT

; 65   :   ASMJIT_INLINE ~PodVectorBase() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 66   :     reset(true);

	mov	dl, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?reset@PodVectorBase@asmjit@@QEAAX_N@Z	; asmjit::PodVectorBase::reset
	npad	1

; 67   :   }

	add	rsp, 40					; 00000028H
	ret	0
??1PodVectorBase@asmjit@@QEAA@XZ ENDP			; asmjit::PodVectorBase::~PodVectorBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??0PodVectorBase@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0PodVectorBase@asmjit@@QEAA@XZ PROC			; asmjit::PodVectorBase::PodVectorBase, COMDAT

; 62   :     _d(const_cast<PodVectorData*>(&_nullData)) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B ; asmjit::PodVectorBase::_nullData
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0PodVectorBase@asmjit@@QEAA@XZ ENDP			; asmjit::PodVectorBase::PodVectorBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@PodVectorData@asmjit@@QEBAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?getData@PodVectorData@asmjit@@QEBAPEAXXZ PROC		; asmjit::PodVectorData::getData, COMDAT

; 34   :   ASMJIT_INLINE void* getData() const {

	mov	QWORD PTR [rsp+8], rcx

; 35   :     return (void*)(this + 1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16

; 36   :   }

	ret	0
?getData@PodVectorData@asmjit@@QEBAPEAXXZ ENDP		; asmjit::PodVectorData::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ PROC		; asmjit::CodeGen::getBaseAddress, COMDAT

; 181  :   ASMJIT_INLINE Ptr getBaseAddress() const {

	mov	QWORD PTR [rsp+8], rcx

; 182  :     return _baseAddress;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]

; 183  :   }

	ret	0
?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ ENDP		; asmjit::CodeGen::getBaseAddress
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ PROC		; asmjit::CodeGen::hasBaseAddress, COMDAT

; 176  :   ASMJIT_INLINE bool hasBaseAddress() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 177  :     return _baseAddress != kNoBaseAddress;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+32], -1
	je	SHORT $LN3@hasBaseAdd
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@hasBaseAdd
$LN3@hasBaseAdd:
	mov	DWORD PTR tv66[rsp], 0
$LN4@hasBaseAdd:
	movzx	eax, BYTE PTR tv66[rsp]

; 178  :   }

	add	rsp, 24
	ret	0
?hasBaseAddress@CodeGen@asmjit@@QEBA_NXZ ENDP		; asmjit::CodeGen::hasBaseAddress
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ?alloc@Zone@asmjit@@QEAAPEAX_K@Z
_TEXT	SEGMENT
cur$ = 32
ptr$ = 40
remainingBytes$ = 48
this$ = 80
size$ = 88
?alloc@Zone@asmjit@@QEAAPEAX_K@Z PROC			; asmjit::Zone::alloc, COMDAT

; 154  :   ASMJIT_INLINE void* alloc(size_t size) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 155  :     Block* cur = _block;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cur$[rsp], rax

; 156  : 
; 157  :     uint8_t* ptr = cur->pos;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 158  :     size_t remainingBytes = (size_t)(cur->end - ptr);

	mov	rax, QWORD PTR cur$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	mov	QWORD PTR remainingBytes$[rsp], rax

; 159  : 
; 160  :     if (remainingBytes < size)

	mov	rax, QWORD PTR size$[rsp]
	cmp	QWORD PTR remainingBytes$[rsp], rax
	jae	SHORT $LN2@alloc

; 161  :       return _alloc(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::_alloc
	jmp	SHORT $LN1@alloc
$LN2@alloc:

; 162  : 
; 163  :     cur->pos += size;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rcx], rax

; 164  :     ASMJIT_ASSERT(cur->pos <= cur->end);
; 165  : 
; 166  :     return (void*)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
$LN1@alloc:

; 167  :   }

	add	rsp, 72					; 00000048H
	ret	0
?alloc@Zone@asmjit@@QEAAPEAX_K@Z ENDP			; asmjit::Zone::alloc
_TEXT	ENDS
END
