; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?alloc@Zone@asmjit@@QEAAPEAX_K@Z		; asmjit::Zone::alloc
PUBLIC	?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ	; asmjit::ConstPoolNode::getData
PUBLIC	??0ConstPoolTree@asmjit@@QEAA@_K@Z		; asmjit::ConstPoolTree::ConstPoolTree
PUBLIC	??1ConstPoolTree@asmjit@@QEAA@XZ		; asmjit::ConstPoolTree::~ConstPoolTree
PUBLIC	?reset@ConstPoolTree@asmjit@@QEAAXXZ		; asmjit::ConstPoolTree::reset
PUBLIC	?setDataSize@ConstPoolTree@asmjit@@QEAAX_K@Z	; asmjit::ConstPoolTree::setDataSize
PUBLIC	?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z ; asmjit::ConstPoolTree::get
PUBLIC	?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z ; asmjit::ConstPoolTree::put
PUBLIC	?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z ; asmjit::ConstPoolTree::_newNode
PUBLIC	??_FConstPoolTree@asmjit@@QEAAXXZ		; asmjit::ConstPoolTree::`default constructor closure'
PUBLIC	??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z ; asmjit::Zone::allocT<asmjit::ConstPoolNode>
PUBLIC	??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z		; asmjit::ConstPool::ConstPool
PUBLIC	??1ConstPool@asmjit@@QEAA@XZ			; asmjit::ConstPool::~ConstPool
PUBLIC	?reset@ConstPool@asmjit@@QEAAXXZ		; asmjit::ConstPool::reset
PUBLIC	?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z	; asmjit::ConstPool::add
PUBLIC	?fill@ConstPool@asmjit@@QEAAXPEAX@Z		; asmjit::ConstPool::fill
PUBLIC	??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z ; asmjit::Zone::allocT<asmjit::ConstPoolGap>
PUBLIC	??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z	; asmjit::IntUtil::isAligned<unsigned __int64>
PUBLIC	??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z		; asmjit::IntUtil::deltaTo<unsigned __int64>
PUBLIC	??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z		; asmjit::IntUtil::iMax<unsigned __int64>
PUBLIC	??0ConstPoolFill@asmjit@@QEAA@PEAE_K@Z		; asmjit::ConstPoolFill::ConstPoolFill
PUBLIC	?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z ; asmjit::ConstPoolFill::visit
PUBLIC	??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z ; asmjit::ConstPoolTree::iterate<asmjit::ConstPoolFill>
PUBLIC	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z		; asmjit::IntUtil::alignTo<unsigned __int64>
EXTRN	??_L@YAXPEAX_K1P6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	?_alloc@Zone@asmjit@@QEAAPEAX_K@Z:PROC		; asmjit::Zone::_alloc
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@Zone@asmjit@@QEAAPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$?alloc@Zone@asmjit@@QEAAPEAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z DD imagerel $LN8
	DD	imagerel $LN8+158
	DD	imagerel $unwind$?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z
$pdata$?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z DD imagerel $LN17
	DD	imagerel $LN17+523
	DD	imagerel $unwind$?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z DD imagerel $LN4
	DD	imagerel $LN4+219
	DD	imagerel $unwind$?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_FConstPoolTree@asmjit@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??_FConstPoolTree@asmjit@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+247
	DD	imagerel $unwind$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA DD imagerel ?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1ConstPool@asmjit@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$??1ConstPool@asmjit@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?reset@ConstPool@asmjit@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+142
	DD	imagerel $unwind$?reset@ConstPool@asmjit@@QEAAXXZ
$pdata$?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z DD imagerel $LN29
	DD	imagerel $LN29+1182
	DD	imagerel $unwind$?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z
$pdata$?fill@ConstPool@asmjit@@QEAAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+148
	DD	imagerel $unwind$?fill@ConstPool@asmjit@@QEAAXPEAX@Z
$pdata$?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z DD imagerel ?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z
	DD	imagerel ?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z+157
	DD	imagerel $unwind$?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z
$pdata$?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z DD imagerel ?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z
	DD	imagerel ?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z+247
	DD	imagerel $unwind$?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z
$pdata$?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z DD imagerel ?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z
	DD	imagerel ?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z+94
	DD	imagerel $unwind$?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z DD imagerel ?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z
	DD	imagerel ?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z+406
	DD	imagerel $unwind$?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+108
	DD	imagerel $unwind$?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+277
	DD	imagerel $unwind$??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z
pdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	0fdH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z DD 022319H
	DD	04b0111H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_FConstPoolTree@asmjit@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z DD 011801H
	DD	06218H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z
	DD	01bH
	DD	01f3H
voltbl	ENDS
xdata	SEGMENT
$unwind$?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z DD 010e01H
	DD	0820eH
$unwind$?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z DD 022319H
	DD	04f0111H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z
$cppxdata$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z
	DD	imagerel $ip2state$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z
$stateUnwindMap$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA
$ip2state$??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	0bdH, 02H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1ConstPool@asmjit@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ConstPool@asmjit@@QEAA@XZ
$cppxdata$??1ConstPool@asmjit@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ConstPool@asmjit@@QEAA@XZ
	DD	imagerel $ip2state$??1ConstPool@asmjit@@QEAA@XZ
$stateUnwindMap$??1ConstPool@asmjit@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA
$ip2state$??1ConstPool@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?reset@ConstPool@asmjit@@QEAAXXZ DD 010901H
	DD	06209H
$unwind$?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z DD 021b01H
	DD	017011bH
$unwind$?fill@ConstPool@asmjit@@QEAAXPEAX@Z DD 010e01H
	DD	0820eH
$unwind$?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z DD 010901H
	DD	02209H
$unwind$?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z DD 010901H
	DD	02209H
$unwind$?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z DD 010901H
	DD	06209H
$unwind$?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@Zone@asmjit@@QEAAPEAX_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z
_TEXT	SEGMENT
base$ = 8
alignment$ = 16
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z PROC		; asmjit::IntUtil::alignTo<unsigned __int64>, COMDAT

; 401  :   static ASMJIT_INLINE T alignTo(T base, T alignment) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 402  :     return (base + (alignment - 1)) & ~(alignment - 1);

	mov	rax, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR alignment$[rsp]
	lea	rax, QWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR alignment$[rsp]
	dec	rcx
	not	rcx
	and	rax, rcx

; 403  :   }

	ret	0
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z ENDP		; asmjit::IntUtil::alignTo<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z
_TEXT	SEGMENT
node$ = 32
top$ = 40
link$ = 48
stack$ = 64
__$ArrayPad$ = 576
this$ = 608
visitor$ = 616
??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z PROC ; asmjit::ConstPoolTree::iterate<asmjit::ConstPoolFill>, COMDAT

; 114  :   ASMJIT_INLINE void iterate(Visitor& visitor) const {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 600				; 00000258H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 115  :     ConstPoolNode* node = const_cast<ConstPoolNode*>(_root);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR node$[rsp], rax

; 116  :     ConstPoolNode* link;
; 117  : 
; 118  :     ConstPoolNode* stack[kHeightLimit];
; 119  : 
; 120  :     if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN5@iterate

; 121  :       return;

	jmp	$LN1@iterate
$LN5@iterate:

; 122  : 
; 123  :     size_t top = 0;

	mov	QWORD PTR top$[rsp], 0
$LN2@iterate:

; 124  : 
; 125  :     for (;;) {
; 126  :       link = node->_link[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR link$[rsp], rax

; 127  : 
; 128  :       if (link != NULL) {

	cmp	QWORD PTR link$[rsp], 0
	je	SHORT $LN6@iterate

; 129  :         ASMJIT_ASSERT(top != kHeightLimit);
; 130  :         stack[top++] = node;

	mov	rax, QWORD PTR top$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR stack$[rsp+rax*8], rcx
	mov	rax, QWORD PTR top$[rsp]
	inc	rax
	mov	QWORD PTR top$[rsp], rax

; 131  : 
; 132  :         node = link;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR node$[rsp], rax

; 133  :         continue;

	jmp	SHORT $LN2@iterate
$LN6@iterate:
$_Visit$11:

; 134  :       }
; 135  : 
; 136  : _Visit:
; 137  :       visitor.visit(node);

	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR visitor$[rsp]
	call	?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z ; asmjit::ConstPoolFill::visit

; 138  :       link = node->_link[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR link$[rsp], rax

; 139  : 
; 140  :       if (link != NULL) {

	cmp	QWORD PTR link$[rsp], 0
	je	SHORT $LN7@iterate

; 141  :         node = link;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR node$[rsp], rax

; 142  :         continue;

	jmp	$LN2@iterate
$LN7@iterate:

; 143  :       }
; 144  : 
; 145  :       if (top == 0)

	cmp	QWORD PTR top$[rsp], 0
	jne	SHORT $LN8@iterate

; 146  :         break;

	jmp	SHORT $LN3@iterate
$LN8@iterate:

; 147  : 
; 148  :       node = stack[--top];

	mov	rax, QWORD PTR top$[rsp]
	dec	rax
	mov	QWORD PTR top$[rsp], rax
	mov	rax, QWORD PTR top$[rsp]
	mov	rax, QWORD PTR stack$[rsp+rax*8]
	mov	QWORD PTR node$[rsp], rax

; 149  :       goto _Visit;

	jmp	SHORT $_Visit$11

; 150  :     }

	jmp	$LN2@iterate
$LN3@iterate:
$LN1@iterate:

; 151  :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 600				; 00000258H
	ret	0
??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z ENDP ; asmjit::ConstPoolTree::iterate<asmjit::ConstPoolFill>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
;	COMDAT ?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z
_TEXT	SEGMENT
tv84 = 32
tv82 = 40
tv80 = 48
this$ = 80
node$ = 88
?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z PROC ; asmjit::ConstPoolFill::visit, COMDAT

; 336  :   ASMJIT_INLINE void visit(const ConstPoolNode* node) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 337  :     if (!node->_shared)

	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+16]
	shr	eax, 31
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@visit

; 338  :       ::memcpy(_dst + node->_offset, node->getData(), _dataSize);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR node$[rsp]
	call	?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ ; asmjit::ConstPoolNode::getData
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR tv80[rsp], rax
	mov	r8, QWORD PTR tv84[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	memcpy
	npad	1
$LN2@visit:

; 339  :   }

	add	rsp, 72					; 00000048H
	ret	0
?visit@ConstPoolFill@asmjit@@QEAAXPEBUConstPoolNode@2@@Z ENDP ; asmjit::ConstPoolFill::visit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
;	COMDAT ??0ConstPoolFill@asmjit@@QEAA@PEAE_K@Z
_TEXT	SEGMENT
this$ = 8
dst$ = 16
dataSize$ = 24
??0ConstPoolFill@asmjit@@QEAA@PEAE_K@Z PROC		; asmjit::ConstPoolFill::ConstPoolFill, COMDAT

; 334  :     _dataSize(dataSize) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 333  :     _dst(dst),

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax], rcx

; 334  :     _dataSize(dataSize) {}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR dataSize$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ConstPoolFill@asmjit@@QEAA@PEAE_K@Z ENDP		; asmjit::ConstPoolFill::ConstPoolFill
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
a$ = 32
b$ = 40
??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z PROC		; asmjit::IntUtil::iMax<unsigned __int64>, COMDAT

; 123  :   static ASMJIT_INLINE T iMax(const T& a, const T& b) { return a > b ? a : b; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jbe	SHORT $LN3@iMax
	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@iMax
$LN3@iMax:
	mov	rax, QWORD PTR b$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv65[rsp], rax
$LN4@iMax:
	mov	rax, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z ENDP		; asmjit::IntUtil::iMax<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z
_TEXT	SEGMENT
base$ = 48
alignment$ = 56
??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z PROC		; asmjit::IntUtil::deltaTo<unsigned __int64>, COMDAT

; 434  :   static ASMJIT_INLINE T deltaTo(T base, T alignment) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 435  :     return alignTo(base, alignment) - base;

	mov	rdx, QWORD PTR alignment$[rsp]
	mov	rcx, QWORD PTR base$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	sub	rax, QWORD PTR base$[rsp]

; 436  :   }

	add	rsp, 40					; 00000028H
	ret	0
??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z ENDP		; asmjit::IntUtil::deltaTo<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z
_TEXT	SEGMENT
tv66 = 0
base$ = 32
alignment$ = 40
??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z PROC		; asmjit::IntUtil::isAligned<unsigned __int64>, COMDAT

; 395  :   static ASMJIT_INLINE bool isAligned(T base, T alignment) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 396  :     return (base % alignment) == 0;

	xor	edx, edx
	mov	rax, QWORD PTR base$[rsp]
	div	QWORD PTR alignment$[rsp]
	mov	rax, rdx
	test	rax, rax
	jne	SHORT $LN3@isAligned
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@isAligned
$LN3@isAligned:
	mov	DWORD PTR tv66[rsp], 0
$LN4@isAligned:
	movzx	eax, BYTE PTR tv66[rsp]

; 397  :   }

	add	rsp, 24
	ret	0
??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z ENDP		; asmjit::IntUtil::isAligned<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
gapLength$1 = 32
gapIndex$2 = 40
gap$3 = 48
self$ = 80
offset$ = 88
length$ = 96
?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z PROC	; asmjit::ConstPool_addGap

; 179  : static void ConstPool_addGap(ConstPool* self, size_t offset, size_t length) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
$LN2@ConstPool_:

; 180  :   ASMJIT_ASSERT(length > 0);
; 181  : 
; 182  :   while (length > 0) {

	cmp	QWORD PTR length$[rsp], 0
	jbe	$LN3@ConstPool_

; 183  :     size_t gapIndex;
; 184  :     size_t gapLength;
; 185  : 
; 186  :     if (length >= 16 && IntUtil::isAligned<size_t>(offset, 16)) {

	cmp	QWORD PTR length$[rsp], 16
	jb	SHORT $LN4@ConstPool_
	mov	edx, 16
	mov	rcx, QWORD PTR offset$[rsp]
	call	??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z ; asmjit::IntUtil::isAligned<unsigned __int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@ConstPool_

; 187  :       gapIndex = ConstPool::kIndex16;

	mov	QWORD PTR gapIndex$2[rsp], 4

; 188  :       gapLength = 16;

	mov	QWORD PTR gapLength$1[rsp], 16

; 189  :     }

	jmp	$LN5@ConstPool_
$LN4@ConstPool_:

; 190  :     else if (length >= 8 && IntUtil::isAligned<size_t>(offset, 8)) {

	cmp	QWORD PTR length$[rsp], 8
	jb	SHORT $LN6@ConstPool_
	mov	edx, 8
	mov	rcx, QWORD PTR offset$[rsp]
	call	??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z ; asmjit::IntUtil::isAligned<unsigned __int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@ConstPool_

; 191  :       gapIndex = ConstPool::kIndex8;

	mov	QWORD PTR gapIndex$2[rsp], 3

; 192  :       gapLength = 8;

	mov	QWORD PTR gapLength$1[rsp], 8

; 193  :     }

	jmp	SHORT $LN7@ConstPool_
$LN6@ConstPool_:

; 194  :     else if (length >= 4 && IntUtil::isAligned<size_t>(offset, 4)) {

	cmp	QWORD PTR length$[rsp], 4
	jb	SHORT $LN8@ConstPool_
	mov	edx, 4
	mov	rcx, QWORD PTR offset$[rsp]
	call	??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z ; asmjit::IntUtil::isAligned<unsigned __int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@ConstPool_

; 195  :       gapIndex = ConstPool::kIndex4;

	mov	QWORD PTR gapIndex$2[rsp], 2

; 196  :       gapLength = 4;

	mov	QWORD PTR gapLength$1[rsp], 4

; 197  :     }

	jmp	SHORT $LN9@ConstPool_
$LN8@ConstPool_:

; 198  :     else if (length >= 2 && IntUtil::isAligned<size_t>(offset, 2)) {

	cmp	QWORD PTR length$[rsp], 2
	jb	SHORT $LN10@ConstPool_
	mov	edx, 2
	mov	rcx, QWORD PTR offset$[rsp]
	call	??$isAligned@_K@IntUtil@asmjit@@SA_N_K0@Z ; asmjit::IntUtil::isAligned<unsigned __int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ConstPool_

; 199  :       gapIndex = ConstPool::kIndex2;

	mov	QWORD PTR gapIndex$2[rsp], 1

; 200  :       gapLength = 2;

	mov	QWORD PTR gapLength$1[rsp], 2

; 201  :     }

	jmp	SHORT $LN11@ConstPool_
$LN10@ConstPool_:

; 202  :     else {
; 203  :       gapIndex = ConstPool::kIndex1;

	mov	QWORD PTR gapIndex$2[rsp], 0

; 204  :       gapLength = 1;

	mov	QWORD PTR gapLength$1[rsp], 1
$LN11@ConstPool_:
$LN9@ConstPool_:
$LN7@ConstPool_:
$LN5@ConstPool_:

; 205  :     }
; 206  : 
; 207  :     // We don't have to check for errors here, if this failed nothing really
; 208  :     // happened (just the gap won't be visible) and it will fail again at
; 209  :     // place where checking will cause kErrorNoHeapMemory.
; 210  :     ConstPoolGap* gap = ConstPool_allocGap(self);

	mov	rcx, QWORD PTR self$[rsp]
	call	?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z ; asmjit::ConstPool_allocGap
	mov	QWORD PTR gap$3[rsp], rax

; 211  :     if (gap == NULL)

	cmp	QWORD PTR gap$3[rsp], 0
	jne	SHORT $LN12@ConstPool_

; 212  :       return;

	jmp	SHORT $LN1@ConstPool_
$LN12@ConstPool_:

; 213  : 
; 214  :     gap->_next = self->_gaps[gapIndex];

	mov	rax, QWORD PTR gap$3[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	rdx, QWORD PTR gapIndex$2[rsp]
	mov	rcx, QWORD PTR [rcx+rdx*8+152]
	mov	QWORD PTR [rax], rcx

; 215  :     self->_gaps[gapIndex] = gap;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR gapIndex$2[rsp]
	mov	rdx, QWORD PTR gap$3[rsp]
	mov	QWORD PTR [rax+rcx*8+152], rdx

; 216  : 
; 217  :     gap->_offset = offset;

	mov	rax, QWORD PTR gap$3[rsp]
	mov	rcx, QWORD PTR offset$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 218  :     gap->_length = gapLength;

	mov	rax, QWORD PTR gap$3[rsp]
	mov	rcx, QWORD PTR gapLength$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 219  : 
; 220  :     offset += gapLength;

	mov	rax, QWORD PTR gapLength$1[rsp]
	mov	rcx, QWORD PTR offset$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR offset$[rsp], rax

; 221  :     length -= gapLength;

	mov	rax, QWORD PTR gapLength$1[rsp]
	mov	rcx, QWORD PTR length$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR length$[rsp], rax

; 222  :   }

	jmp	$LN2@ConstPool_
$LN3@ConstPool_:
$LN1@ConstPool_:

; 223  : }

	add	rsp, 72					; 00000048H
	ret	0
?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z ENDP	; asmjit::ConstPool_addGap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
self$ = 8
gap$ = 16
?ConstPool_freeGap@asmjit@@YAXPEAUConstPool@1@PEAUConstPoolGap@1@@Z PROC ; asmjit::ConstPool_freeGap

; 174  : static ASMJIT_INLINE void ConstPool_freeGap(ConstPool* self,  ConstPoolGap* gap) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 175  :   gap->_next = self->_gapPool;

	mov	rax, QWORD PTR gap$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR [rcx+200]
	mov	QWORD PTR [rax], rcx

; 176  :   self->_gapPool = gap;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR gap$[rsp]
	mov	QWORD PTR [rax+200], rcx

; 177  : }

	ret	0
?ConstPool_freeGap@asmjit@@YAXPEAUConstPool@1@PEAUConstPoolGap@1@@Z ENDP ; asmjit::ConstPool_freeGap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z PROC ; asmjit::Zone::allocT<asmjit::ConstPoolGap>, COMDAT

; 176  :   ASMJIT_INLINE T* allocT(size_t size = sizeof(T)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 177  :     return static_cast<T*>(alloc(size));

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::alloc

; 178  :   }

	add	rsp, 40					; 00000028H
	ret	0
??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z ENDP ; asmjit::Zone::allocT<asmjit::ConstPoolGap>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
gap$ = 32
tv71 = 40
self$ = 64
?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z PROC ; asmjit::ConstPool_allocGap

; 165  : static ASMJIT_INLINE ConstPoolGap* ConstPool_allocGap(ConstPool* self) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 166  :   ConstPoolGap* gap = self->_gapPool;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+200]
	mov	QWORD PTR gap$[rsp], rax

; 167  :   if (gap == NULL)

	cmp	QWORD PTR gap$[rsp], 0
	jne	SHORT $LN2@ConstPool_

; 168  :     return self->_zone->allocT<ConstPoolGap>();

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv71[rsp], rax
	mov	edx, 24
	mov	rcx, QWORD PTR tv71[rsp]
	call	??$allocT@UConstPoolGap@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolGap@1@_K@Z ; asmjit::Zone::allocT<asmjit::ConstPoolGap>
	jmp	SHORT $LN1@ConstPool_
$LN2@ConstPool_:

; 169  : 
; 170  :   self->_gapPool = gap->_next;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR gap$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+200], rcx

; 171  :   return gap;

	mov	rax, QWORD PTR gap$[rsp]
$LN1@ConstPool_:

; 172  : }

	add	rsp, 56					; 00000038H
	ret	0
?ConstPool_allocGap@asmjit@@YAPEAUConstPoolGap@1@PEAUConstPool@1@@Z ENDP ; asmjit::ConstPool_allocGap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
level$ = 0
link$ = 8
node$ = 32
?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z PROC ; asmjit::ConstPoolTree_splitNode

; 47   : static ASMJIT_INLINE ConstPoolNode* ConstPoolTree_splitNode(ConstPoolNode* node) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 48   :   ConstPoolNode* link = node->_link[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR link$[rsp], rax

; 49   :   uint32_t level = node->_level;

	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+16]
	btr	eax, 31
	mov	DWORD PTR level$[rsp], eax

; 50   : 
; 51   :   if (level != 0 && link != NULL && link->_link[1] != NULL && link->_link[1]->_level == level) {

	cmp	DWORD PTR level$[rsp], 0
	je	$LN2@ConstPoolT
	cmp	QWORD PTR link$[rsp], 0
	je	$LN2@ConstPoolT
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR link$[rsp]
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN2@ConstPoolT
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR link$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [rax+16]
	btr	eax, 31
	cmp	eax, DWORD PTR level$[rsp]
	jne	SHORT $LN2@ConstPoolT

; 52   :     node->_link[1] = link->_link[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR node$[rsp]
	mov	r8, QWORD PTR link$[rsp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 53   :     link->_link[0] = node;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR link$[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 54   : 
; 55   :     node = link;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR node$[rsp], rax

; 56   :     node->_level++;

	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+16]
	btr	eax, 31
	inc	eax
	btr	eax, 31
	mov	rcx, QWORD PTR node$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	and	ecx, -2147483648			; 80000000H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR node$[rsp]
	mov	DWORD PTR [rcx+16], eax
$LN2@ConstPoolT:

; 57   :   }
; 58   : 
; 59   :   return node;

	mov	rax, QWORD PTR node$[rsp]

; 60   : }

	add	rsp, 24
	ret	0
?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z ENDP ; asmjit::ConstPoolTree_splitNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
level$ = 0
link$ = 8
node$ = 32
?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z PROC ; asmjit::ConstPoolTree_skewNode

; 30   : static ASMJIT_INLINE ConstPoolNode* ConstPoolTree_skewNode(ConstPoolNode* node) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 31   :   ConstPoolNode* link = node->_link[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR link$[rsp], rax

; 32   :   uint32_t level = node->_level;

	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+16]
	btr	eax, 31
	mov	DWORD PTR level$[rsp], eax

; 33   : 
; 34   :   if (level != 0 && link != NULL && link->_level == level) {

	cmp	DWORD PTR level$[rsp], 0
	je	SHORT $LN2@ConstPoolT
	cmp	QWORD PTR link$[rsp], 0
	je	SHORT $LN2@ConstPoolT
	mov	rax, QWORD PTR link$[rsp]
	mov	eax, DWORD PTR [rax+16]
	btr	eax, 31
	cmp	eax, DWORD PTR level$[rsp]
	jne	SHORT $LN2@ConstPoolT

; 35   :     node->_link[0] = link->_link[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR node$[rsp]
	mov	r8, QWORD PTR link$[rsp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 36   :     link->_link[1] = node;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR link$[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 37   : 
; 38   :     node = link;

	mov	rax, QWORD PTR link$[rsp]
	mov	QWORD PTR node$[rsp], rax
$LN2@ConstPoolT:

; 39   :   }
; 40   : 
; 41   :   return node;

	mov	rax, QWORD PTR node$[rsp]

; 42   : }

	add	rsp, 24
	ret	0
?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z ENDP ; asmjit::ConstPoolTree_skewNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
i$1 = 32
tv79 = 40
filler$ = 48
this$ = 80
dst$ = 88
?fill@ConstPool@asmjit@@QEAAXPEAX@Z PROC		; asmjit::ConstPool::fill

; 345  : void ConstPool::fill(void* dst) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 346  :   // Clears possible gaps, asmjit should never emit garbage to the output.
; 347  :   ::memset(dst, 0, _size);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+208]
	xor	edx, edx
	mov	rcx, QWORD PTR dst$[rsp]
	call	memset

; 348  : 
; 349  :   ConstPoolFill filler(static_cast<uint8_t*>(dst), 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR dst$[rsp]
	lea	rcx, QWORD PTR filler$[rsp]
	call	??0ConstPoolFill@asmjit@@QEAA@PEAE_K@Z	; asmjit::ConstPoolFill::ConstPoolFill
	npad	1

; 350  :   for (size_t i = 0; i < ASMJIT_ARRAY_SIZE(_tree); i++) {

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN4@fill:
	cmp	QWORD PTR i$1[rsp], 6
	jae	SHORT $LN3@fill

; 351  :     _tree[i].iterate(filler);

	imul	rax, QWORD PTR i$1[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv79[rsp], rax
	lea	rdx, QWORD PTR filler$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??$iterate@UConstPoolFill@asmjit@@@ConstPoolTree@asmjit@@QEBAXAEAUConstPoolFill@1@@Z ; asmjit::ConstPoolTree::iterate<asmjit::ConstPoolFill>

; 352  :     filler._dataSize <<= 1;

	mov	rax, QWORD PTR filler$[rsp+8]
	shl	rax, 1
	mov	QWORD PTR filler$[rsp+8], rax

; 353  :   }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 354  : }

	add	rsp, 72					; 00000048H
	ret	0
?fill@ConstPool@asmjit@@QEAAXPEAX@Z ENDP		; asmjit::ConstPool::fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
treeIndex$ = 48
node$ = 56
offset$ = 64
gap$1 = 72
gapLength$2 = 80
i$3 = 88
pData$4 = 96
gapIndex$ = 104
deltaTo$5 = 112
pCount$ = 120
gapOffset$6 = 128
tv77 = 136
tv163 = 144
tv183 = 152
tv200 = 160
this$ = 192
data$ = 200
size$ = 208
dstOffset$ = 216
?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z PROC		; asmjit::ConstPool::add

; 225  : Error ConstPool::add(const void* data, size_t size, size_t& dstOffset) {

$LN29:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 226  :   size_t treeIndex;
; 227  : 
; 228  :   if (size == 32)

	cmp	QWORD PTR size$[rsp], 32		; 00000020H
	jne	SHORT $LN9@add

; 229  :     treeIndex = kIndex32;

	mov	QWORD PTR treeIndex$[rsp], 5
	jmp	SHORT $LN10@add
$LN9@add:

; 230  :   else if (size == 16)

	cmp	QWORD PTR size$[rsp], 16
	jne	SHORT $LN11@add

; 231  :     treeIndex = kIndex16;

	mov	QWORD PTR treeIndex$[rsp], 4
	jmp	SHORT $LN12@add
$LN11@add:

; 232  :   else if (size == 8)

	cmp	QWORD PTR size$[rsp], 8
	jne	SHORT $LN13@add

; 233  :     treeIndex = kIndex8;

	mov	QWORD PTR treeIndex$[rsp], 3
	jmp	SHORT $LN14@add
$LN13@add:

; 234  :   else if (size == 4)

	cmp	QWORD PTR size$[rsp], 4
	jne	SHORT $LN15@add

; 235  :     treeIndex = kIndex4;

	mov	QWORD PTR treeIndex$[rsp], 2
	jmp	SHORT $LN16@add
$LN15@add:

; 236  :   else if (size == 2)

	cmp	QWORD PTR size$[rsp], 2
	jne	SHORT $LN17@add

; 237  :     treeIndex = kIndex2;

	mov	QWORD PTR treeIndex$[rsp], 1
	jmp	SHORT $LN18@add
$LN17@add:

; 238  :   else if (size == 1)

	cmp	QWORD PTR size$[rsp], 1
	jne	SHORT $LN19@add

; 239  :     treeIndex = kIndex1;

	mov	QWORD PTR treeIndex$[rsp], 0
	jmp	SHORT $LN20@add
$LN19@add:

; 240  :   else
; 241  :     return kErrorInvalidArgument;

	mov	eax, 3
	jmp	$LN1@add
$LN20@add:
$LN18@add:
$LN16@add:
$LN14@add:
$LN12@add:
$LN10@add:

; 242  : 
; 243  :   ConstPoolNode* node = _tree[treeIndex].get(data);

	imul	rax, QWORD PTR treeIndex$[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv77[rsp], rax
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z ; asmjit::ConstPoolTree::get
	mov	QWORD PTR node$[rsp], rax

; 244  :   if (node != NULL) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN21@add

; 245  :     dstOffset = node->_offset;

	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR dstOffset$[rsp]
	mov	QWORD PTR [rcx], rax

; 246  :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@add
$LN21@add:

; 247  :   }
; 248  : 
; 249  :   // Before incrementing the current offset try if there is a gap that can
; 250  :   // be used for the requested data.
; 251  :   size_t offset = ~static_cast<size_t>(0);

	mov	QWORD PTR offset$[rsp], -1

; 252  :   size_t gapIndex = treeIndex;

	mov	rax, QWORD PTR treeIndex$[rsp]
	mov	QWORD PTR gapIndex$[rsp], rax
$LN2@add:

; 253  : 
; 254  :   while (gapIndex != kIndexCount - 1) {

	cmp	QWORD PTR gapIndex$[rsp], 5
	je	$LN3@add

; 255  :     ConstPoolGap* gap = _gaps[treeIndex];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR treeIndex$[rsp]
	mov	rax, QWORD PTR [rax+rcx*8+152]
	mov	QWORD PTR gap$1[rsp], rax

; 256  : 
; 257  :     // Check if there is a gap.
; 258  :     if (gap != NULL) {

	cmp	QWORD PTR gap$1[rsp], 0
	je	$LN22@add

; 259  :       size_t gapOffset = gap->_offset;

	mov	rax, QWORD PTR gap$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR gapOffset$6[rsp], rax

; 260  :       size_t gapLength = gap->_length;

	mov	rax, QWORD PTR gap$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR gapLength$2[rsp], rax

; 261  : 
; 262  :       // Destroy the gap for now.
; 263  :       _gaps[treeIndex] = gap->_next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR treeIndex$[rsp]
	mov	rdx, QWORD PTR gap$1[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	QWORD PTR [rax+rcx*8+152], rdx

; 264  :       ConstPool_freeGap(this, gap);

	mov	rdx, QWORD PTR gap$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ConstPool_freeGap@asmjit@@YAXPEAUConstPool@1@PEAUConstPoolGap@1@@Z ; asmjit::ConstPool_freeGap

; 265  : 
; 266  :       offset = gapOffset;

	mov	rax, QWORD PTR gapOffset$6[rsp]
	mov	QWORD PTR offset$[rsp], rax

; 267  :       ASMJIT_ASSERT(IntUtil::isAligned<size_t>(offset, size));
; 268  : 
; 269  :       gapLength -= size;

	mov	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR gapLength$2[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR gapLength$2[rsp], rax

; 270  :       if (gapLength > 0)

	cmp	QWORD PTR gapLength$2[rsp], 0
	jbe	SHORT $LN23@add

; 271  :         ConstPool_addGap(this, gapOffset, gapLength);

	mov	r8, QWORD PTR gapLength$2[rsp]
	mov	rdx, QWORD PTR gapOffset$6[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z ; asmjit::ConstPool_addGap
	npad	1
$LN23@add:
$LN22@add:

; 272  :     }
; 273  : 
; 274  :     gapIndex++;

	mov	rax, QWORD PTR gapIndex$[rsp]
	inc	rax
	mov	QWORD PTR gapIndex$[rsp], rax

; 275  :   }

	jmp	$LN2@add
$LN3@add:

; 276  : 
; 277  :   if (offset == ~static_cast<size_t>(0)) {

	cmp	QWORD PTR offset$[rsp], -1
	jne	$LN24@add

; 278  :     // Get how many bytes have to be skipped so the address is aligned accordingly
; 279  :     // to the 'size'.
; 280  :     size_t deltaTo = IntUtil::deltaTo<size_t>(_size, size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+208]
	call	??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::deltaTo<unsigned __int64>
	mov	QWORD PTR deltaTo$5[rsp], rax

; 281  : 
; 282  :     if (deltaTo != 0) {

	cmp	QWORD PTR deltaTo$5[rsp], 0
	je	SHORT $LN25@add

; 283  :       ConstPool_addGap(this, _size, deltaTo);

	mov	r8, QWORD PTR deltaTo$5[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+208]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ConstPool_addGap@asmjit@@YAXPEAUConstPool@1@_K1@Z ; asmjit::ConstPool_addGap

; 284  :       _size += deltaTo;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+208]
	add	rax, QWORD PTR deltaTo$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+208], rax
$LN25@add:

; 285  :     }
; 286  : 
; 287  :     offset = _size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+208]
	mov	QWORD PTR offset$[rsp], rax

; 288  :     _size += size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+208]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+208], rax
$LN24@add:

; 289  :   }
; 290  : 
; 291  :   // Add the initial node to the right index.
; 292  :   node = ConstPoolTree::_newNode(_zone, data, size, offset, false);

	mov	BYTE PTR [rsp+32], 0
	mov	r9, QWORD PTR offset$[rsp]
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z ; asmjit::ConstPoolTree::_newNode
	mov	QWORD PTR node$[rsp], rax

; 293  :   if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN26@add

; 294  :     return kErrorNoHeapMemory;

	mov	eax, 1
	jmp	$LN1@add
$LN26@add:

; 295  : 
; 296  :   _tree[treeIndex].put(node);

	imul	rax, QWORD PTR treeIndex$[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv163[rsp], rax
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR tv163[rsp]
	call	?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z ; asmjit::ConstPoolTree::put

; 297  :   _alignment = IntUtil::iMax<size_t>(_alignment, size);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 216				; 000000d8H
	lea	rdx, QWORD PTR size$[rsp]
	mov	rcx, rax
	call	??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z	; asmjit::IntUtil::iMax<unsigned __int64>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+216], rax

; 298  : 
; 299  :   dstOffset = offset;

	mov	rax, QWORD PTR dstOffset$[rsp]
	mov	rcx, QWORD PTR offset$[rsp]
	mov	QWORD PTR [rax], rcx

; 300  : 
; 301  :   // Now create a bunch of shared constants that are based on the data pattern.
; 302  :   // We stop at size 4, it probably doesn't make sense to split constants down
; 303  :   // to 1 byte.
; 304  :   size_t pCount = 1;

	mov	QWORD PTR pCount$[rsp], 1
$LN4@add:

; 305  :   while (size > 4) {

	cmp	QWORD PTR size$[rsp], 4
	jbe	$LN5@add

; 306  :     size >>= 1;

	mov	rax, QWORD PTR size$[rsp]
	shr	rax, 1
	mov	QWORD PTR size$[rsp], rax

; 307  :     pCount <<= 1;

	mov	rax, QWORD PTR pCount$[rsp]
	shl	rax, 1
	mov	QWORD PTR pCount$[rsp], rax

; 308  : 
; 309  :     ASMJIT_ASSERT(treeIndex != 0);
; 310  :     treeIndex--;

	mov	rax, QWORD PTR treeIndex$[rsp]
	dec	rax
	mov	QWORD PTR treeIndex$[rsp], rax

; 311  : 
; 312  :     const uint8_t* pData = static_cast<const uint8_t*>(data);

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR pData$4[rsp], rax

; 313  :     for (size_t i = 0; i < pCount; i++, pData += size) {

	mov	QWORD PTR i$3[rsp], 0
	jmp	SHORT $LN8@add
$LN6@add:
	mov	rax, QWORD PTR i$3[rsp]
	inc	rax
	mov	QWORD PTR i$3[rsp], rax
	mov	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR pData$4[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pData$4[rsp], rax
$LN8@add:
	mov	rax, QWORD PTR pCount$[rsp]
	cmp	QWORD PTR i$3[rsp], rax
	jae	$LN7@add

; 314  :       node = _tree[treeIndex].get(pData);

	imul	rax, QWORD PTR treeIndex$[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv183[rsp], rax
	mov	rdx, QWORD PTR pData$4[rsp]
	mov	rcx, QWORD PTR tv183[rsp]
	call	?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z ; asmjit::ConstPoolTree::get
	mov	QWORD PTR node$[rsp], rax

; 315  : 
; 316  :       if (node != NULL)

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN27@add

; 317  :         continue;

	jmp	SHORT $LN6@add
$LN27@add:

; 318  : 
; 319  :       node = ConstPoolTree::_newNode(_zone, pData, size, offset + (i * size), true);

	mov	rax, QWORD PTR i$3[rsp]
	imul	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR offset$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+32], 1
	mov	r9, rax
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, QWORD PTR pData$4[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z ; asmjit::ConstPoolTree::_newNode
	mov	QWORD PTR node$[rsp], rax

; 320  :       _tree[treeIndex].put(node);

	imul	rax, QWORD PTR treeIndex$[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv200[rsp], rax
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR tv200[rsp]
	call	?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z ; asmjit::ConstPoolTree::put
	npad	1

; 321  :     }

	jmp	$LN6@add
$LN7@add:

; 322  :   }

	jmp	$LN4@add
$LN5@add:

; 323  : 
; 324  :   return kErrorOk;

	xor	eax, eax
$LN1@add:

; 325  : }

	add	rsp, 184				; 000000b8H
	ret	0
?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z ENDP		; asmjit::ConstPool::add
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
i$1 = 32
this$ = 64
?reset@ConstPool@asmjit@@QEAAXXZ PROC			; asmjit::ConstPool::reset

; 150  : void ConstPool::reset() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 151  :   for (size_t i = 0; i < ASMJIT_ARRAY_SIZE(_tree); i++) {

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@reset
$LN2@reset:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN4@reset:
	cmp	QWORD PTR i$1[rsp], 6
	jae	SHORT $LN3@reset

; 152  :     _tree[i].reset();

	imul	rax, QWORD PTR i$1[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?reset@ConstPoolTree@asmjit@@QEAAXXZ	; asmjit::ConstPoolTree::reset

; 153  :     _gaps[i] = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	mov	QWORD PTR [rax+rcx*8+152], 0

; 154  :   }

	jmp	SHORT $LN2@reset
$LN3@reset:

; 155  : 
; 156  :   _gapPool = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+200], 0

; 157  :   _size = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+208], 0

; 158  :   _alignment = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+216], 0

; 159  : }

	add	rsp, 56					; 00000038H
	ret	0
?reset@ConstPool@asmjit@@QEAAXXZ ENDP			; asmjit::ConstPool::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
this$ = 48
??1ConstPool@asmjit@@QEAA@XZ PROC			; asmjit::ConstPool::~ConstPool

; 144  : ConstPool::~ConstPool() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	r9, OFFSET FLAT:??1ConstPoolTree@asmjit@@QEAA@XZ ; asmjit::ConstPoolTree::~ConstPoolTree
	mov	r8d, 6
	mov	edx, 24
	mov	rcx, rax
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ConstPool@asmjit@@QEAA@XZ ENDP			; asmjit::ConstPool::~ConstPool
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA PROC	; `asmjit::ConstPool::~ConstPool'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	lea	r9, OFFSET FLAT:??1ConstPoolTree@asmjit@@QEAA@XZ ; asmjit::ConstPoolTree::~ConstPoolTree
	mov	r8d, 6
	mov	edx, 24
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ConstPool@asmjit@@QEAA@XZ@4HA ENDP	; `asmjit::ConstPool::~ConstPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
i$1 = 48
dataSize$ = 56
tv84 = 64
this$ = 96
zone$ = 104
??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z PROC		; asmjit::ConstPool::ConstPool

; 129  : ConstPool::ConstPool(Zone* zone) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rcx, OFFSET FLAT:??1ConstPoolTree@asmjit@@QEAA@XZ ; asmjit::ConstPoolTree::~ConstPoolTree
	mov	QWORD PTR [rsp+32], rcx
	lea	r9, OFFSET FLAT:??_FConstPoolTree@asmjit@@QEAAXXZ
	mov	r8d, 6
	mov	edx, 24
	mov	rcx, rax
	call	??_L@YAXPEAX_K1P6AX0@Z2@Z
	npad	1

; 130  :   _zone = zone;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR zone$[rsp]
	mov	QWORD PTR [rax], rcx

; 131  : 
; 132  :   size_t dataSize = 1;

	mov	QWORD PTR dataSize$[rsp], 1

; 133  :   for (size_t i = 0; i < ASMJIT_ARRAY_SIZE(_tree); i++) {

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ConstPool
$LN2@ConstPool:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN4@ConstPool:
	cmp	QWORD PTR i$1[rsp], 6
	jae	SHORT $LN3@ConstPool

; 134  :     _tree[i].setDataSize(dataSize);

	imul	rax, QWORD PTR i$1[rsp], 24
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv84[rsp], rax
	mov	rdx, QWORD PTR dataSize$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?setDataSize@ConstPoolTree@asmjit@@QEAAX_K@Z ; asmjit::ConstPoolTree::setDataSize

; 135  :     _gaps[i] = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	mov	QWORD PTR [rax+rcx*8+152], 0

; 136  :     dataSize <<= 1;

	mov	rax, QWORD PTR dataSize$[rsp]
	shl	rax, 1
	mov	QWORD PTR dataSize$[rsp], rax

; 137  :   }

	jmp	SHORT $LN2@ConstPool
$LN3@ConstPool:

; 138  : 
; 139  :   _gapPool = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+200], 0

; 140  :   _size = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+208], 0

; 141  :   _alignment = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+216], 0

; 142  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z ENDP		; asmjit::ConstPool::ConstPool
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 48
dataSize$ = 56
tv84 = 64
this$ = 96
zone$ = 104
?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA PROC ; `asmjit::ConstPool::ConstPool'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	lea	r9, OFFSET FLAT:??1ConstPoolTree@asmjit@@QEAA@XZ ; asmjit::ConstPoolTree::~ConstPoolTree
	mov	r8d, 6
	mov	edx, 24
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ConstPool@asmjit@@QEAA@PEAUZone@1@@Z@4HA ENDP ; `asmjit::ConstPool::ConstPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z PROC ; asmjit::Zone::allocT<asmjit::ConstPoolNode>, COMDAT

; 176  :   ASMJIT_INLINE T* allocT(size_t size = sizeof(T)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 177  :     return static_cast<T*>(alloc(size));

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::alloc

; 178  :   }

	add	rsp, 40					; 00000028H
	ret	0
??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z ENDP ; asmjit::Zone::allocT<asmjit::ConstPoolNode>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_FConstPoolTree@asmjit@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_FConstPoolTree@asmjit@@QEAAXXZ PROC			; asmjit::ConstPoolTree::`default constructor closure', COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	??0ConstPoolTree@asmjit@@QEAA@_K@Z	; asmjit::ConstPoolTree::ConstPoolTree
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??_FConstPoolTree@asmjit@@QEAAXXZ ENDP			; asmjit::ConstPoolTree::`default constructor closure'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z
_TEXT	SEGMENT
node$ = 32
zone$ = 64
data$ = 72
size$ = 80
offset$ = 88
shared$ = 96
?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z PROC ; asmjit::ConstPoolTree::_newNode, COMDAT

; 157  :   static ASMJIT_INLINE ConstPoolNode* _newNode(Zone* zone, const void* data, size_t size, size_t offset, bool shared) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 158  :     ConstPoolNode* node = zone->allocT<ConstPoolNode>(sizeof(ConstPoolNode) + size);

	mov	rax, QWORD PTR size$[rsp]
	add	rax, 24
	mov	rdx, rax
	mov	rcx, QWORD PTR zone$[rsp]
	call	??$allocT@UConstPoolNode@asmjit@@@Zone@asmjit@@QEAAPEAUConstPoolNode@1@_K@Z ; asmjit::Zone::allocT<asmjit::ConstPoolNode>
	mov	QWORD PTR node$[rsp], rax

; 159  :     if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN2@newNode

; 160  :       return NULL;

	xor	eax, eax
	jmp	$LN1@newNode
$LN2@newNode:

; 161  : 
; 162  :     node->_link[0] = NULL;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 163  :     node->_link[1] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 164  :     node->_level = 1;

	mov	rax, QWORD PTR node$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, -2147483648			; 80000000H
	or	eax, 1
	mov	rcx, QWORD PTR node$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 165  :     node->_shared = shared;

	movzx	eax, BYTE PTR shared$[rsp]
	and	eax, 1
	shl	eax, 31
	mov	rcx, QWORD PTR node$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	btr	ecx, 31
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR node$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 166  :     node->_offset = static_cast<uint32_t>(offset);

	mov	rax, QWORD PTR node$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+20], ecx

; 167  : 
; 168  :     ::memcpy(node->getData(), data, size);

	mov	rcx, QWORD PTR node$[rsp]
	call	?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ ; asmjit::ConstPoolNode::getData
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, rax
	call	memcpy

; 169  :     return node;

	mov	rax, QWORD PTR node$[rsp]
$LN1@newNode:

; 170  :   }

	add	rsp, 56					; 00000038H
	ret	0
?_newNode@ConstPoolTree@asmjit@@SAPEAUConstPoolNode@2@PEAUZone@2@PEBX_K2_N@Z ENDP ; asmjit::ConstPoolTree::_newNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
top$ = 32
node$ = 40
dir$ = 48
tv90 = 52
tv146 = 56
link$1 = 64
dataSize$ = 72
tv88 = 80
tv86 = 88
stack$ = 96
__$ArrayPad$ = 608
this$ = 640
newNode$ = 648
?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z PROC ; asmjit::ConstPoolTree::put

; 76   : void ConstPoolTree::put(ConstPoolNode* newNode) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 632				; 00000278H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 77   :   size_t dataSize = _dataSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR dataSize$[rsp], rax

; 78   : 
; 79   :   _length++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 80   :   if (_root == NULL) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN7@put

; 81   :     _root = newNode;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR newNode$[rsp]
	mov	QWORD PTR [rax], rcx

; 82   :     return;

	jmp	$LN1@put
$LN7@put:

; 83   :   }
; 84   : 
; 85   :   ConstPoolNode* node = _root;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR node$[rsp], rax

; 86   :   ConstPoolNode* stack[kHeightLimit];
; 87   : 
; 88   :   unsigned int top = 0;

	mov	DWORD PTR top$[rsp], 0
$LN2@put:

; 89   :   unsigned int dir;
; 90   : 
; 91   :   // Find a spot and save the stack.
; 92   :   for (;;) {
; 93   :     stack[top++] = node;

	mov	eax, DWORD PTR top$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR stack$[rsp+rax*8], rcx
	mov	eax, DWORD PTR top$[rsp]
	inc	eax
	mov	DWORD PTR top$[rsp], eax

; 94   :     dir = ::memcmp(node->getData(), newNode->getData(), dataSize) < 0;

	mov	rcx, QWORD PTR newNode$[rsp]
	call	?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ ; asmjit::ConstPoolNode::getData
	mov	QWORD PTR tv88[rsp], rax
	mov	rcx, QWORD PTR node$[rsp]
	call	?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ ; asmjit::ConstPoolNode::getData
	mov	QWORD PTR tv86[rsp], rax
	mov	r8, QWORD PTR dataSize$[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	call	memcmp
	test	eax, eax
	jge	SHORT $LN13@put
	mov	DWORD PTR tv90[rsp], 1
	jmp	SHORT $LN14@put
$LN13@put:
	mov	DWORD PTR tv90[rsp], 0
$LN14@put:
	mov	eax, DWORD PTR tv90[rsp]
	mov	DWORD PTR dir$[rsp], eax

; 95   : 
; 96   :     ConstPoolNode* link = node->_link[dir];

	mov	eax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR link$1[rsp], rax

; 97   :     if (link == NULL)

	cmp	QWORD PTR link$1[rsp], 0
	jne	SHORT $LN8@put

; 98   :       break;

	jmp	SHORT $LN3@put
$LN8@put:

; 99   : 
; 100  :     node = link;

	mov	rax, QWORD PTR link$1[rsp]
	mov	QWORD PTR node$[rsp], rax

; 101  :   }

	jmp	$LN2@put
$LN3@put:

; 102  : 
; 103  :   // Link and rebalance.
; 104  :   node->_link[dir] = newNode;

	mov	eax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rdx, QWORD PTR newNode$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN5@put:

; 105  : 
; 106  :   while (top > 0) {

	cmp	DWORD PTR top$[rsp], 0
	jbe	$LN6@put

; 107  :     // Which child?
; 108  :     node = stack[--top];

	mov	eax, DWORD PTR top$[rsp]
	dec	eax
	mov	DWORD PTR top$[rsp], eax
	mov	eax, DWORD PTR top$[rsp]
	mov	rax, QWORD PTR stack$[rsp+rax*8]
	mov	QWORD PTR node$[rsp], rax

; 109  : 
; 110  :     if (top != 0) {

	cmp	DWORD PTR top$[rsp], 0
	je	SHORT $LN9@put

; 111  :       dir = stack[top - 1]->_link[1] == node;

	mov	eax, DWORD PTR top$[rsp]
	dec	eax
	mov	eax, eax
	mov	rax, QWORD PTR stack$[rsp+rax*8]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR node$[rsp]
	cmp	QWORD PTR [rax+rcx], rdx
	jne	SHORT $LN15@put
	mov	DWORD PTR tv146[rsp], 1
	jmp	SHORT $LN16@put
$LN15@put:
	mov	DWORD PTR tv146[rsp], 0
$LN16@put:
	mov	eax, DWORD PTR tv146[rsp]
	mov	DWORD PTR dir$[rsp], eax
$LN9@put:

; 112  :     }
; 113  : 
; 114  :     node = ConstPoolTree_skewNode(node);

	mov	rcx, QWORD PTR node$[rsp]
	call	?ConstPoolTree_skewNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z ; asmjit::ConstPoolTree_skewNode
	mov	QWORD PTR node$[rsp], rax

; 115  :     node = ConstPoolTree_splitNode(node);

	mov	rcx, QWORD PTR node$[rsp]
	call	?ConstPoolTree_splitNode@asmjit@@YAPEAUConstPoolNode@1@PEAU21@@Z ; asmjit::ConstPoolTree_splitNode
	mov	QWORD PTR node$[rsp], rax

; 116  : 
; 117  :     // Fix the parent.
; 118  :     if (top != 0)

	cmp	DWORD PTR top$[rsp], 0
	je	SHORT $LN10@put

; 119  :       stack[top - 1]->_link[dir] = node;

	mov	eax, DWORD PTR top$[rsp]
	dec	eax
	mov	eax, eax
	mov	rax, QWORD PTR stack$[rsp+rax*8]
	mov	ecx, DWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+rcx*8], rdx
	jmp	SHORT $LN11@put
$LN10@put:

; 120  :     else
; 121  :       _root = node;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], rcx
$LN11@put:

; 122  :   }

	jmp	$LN5@put
$LN6@put:
$LN1@put:

; 123  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 632				; 00000278H
	ret	0
?put@ConstPoolTree@asmjit@@QEAAXPEAUConstPoolNode@2@@Z ENDP ; asmjit::ConstPoolTree::put
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.cpp
_TEXT	SEGMENT
c$1 = 32
tv76 = 36
node$ = 40
dataSize$ = 48
tv80 = 56
this$ = 80
data$ = 88
?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z PROC ; asmjit::ConstPoolTree::get

; 62   : ConstPoolNode* ConstPoolTree::get(const void* data) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 63   :   ConstPoolNode* node = _root;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR node$[rsp], rax

; 64   :   size_t dataSize = _dataSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR dataSize$[rsp], rax
$LN2@get:

; 65   : 
; 66   :   while (node != NULL) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@get

; 67   :     int c = ::memcmp(node->getData(), data, dataSize);

	mov	rcx, QWORD PTR node$[rsp]
	call	?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ ; asmjit::ConstPoolNode::getData
	mov	r8, QWORD PTR dataSize$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, rax
	call	memcmp
	mov	DWORD PTR c$1[rsp], eax

; 68   :     if (c == 0)

	cmp	DWORD PTR c$1[rsp], 0
	jne	SHORT $LN4@get

; 69   :       return node;

	mov	rax, QWORD PTR node$[rsp]
	jmp	SHORT $LN1@get
$LN4@get:

; 70   :     node = node->_link[c < 0];

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR tv80[rsp], rax
	cmp	DWORD PTR c$1[rsp], 0
	jge	SHORT $LN6@get
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN7@get
$LN6@get:
	mov	DWORD PTR tv76[rsp], 0
$LN7@get:
	movsxd	rax, DWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR node$[rsp], rax

; 71   :   }

	jmp	SHORT $LN2@get
$LN3@get:

; 72   : 
; 73   :   return NULL;

	xor	eax, eax
$LN1@get:

; 74   : }

	add	rsp, 72					; 00000048H
	ret	0
?get@ConstPoolTree@asmjit@@QEAAPEAUConstPoolNode@2@PEBX@Z ENDP ; asmjit::ConstPoolTree::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ?setDataSize@ConstPoolTree@asmjit@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
dataSize$ = 16
?setDataSize@ConstPoolTree@asmjit@@QEAAX_K@Z PROC	; asmjit::ConstPoolTree::setDataSize, COMDAT

; 97   :   ASMJIT_INLINE void setDataSize(size_t dataSize) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 98   :     ASMJIT_ASSERT(isEmpty());
; 99   :     _dataSize = dataSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR dataSize$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 100  :   }

	ret	0
?setDataSize@ConstPoolTree@asmjit@@QEAAX_K@Z ENDP	; asmjit::ConstPoolTree::setDataSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ?reset@ConstPoolTree@asmjit@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?reset@ConstPoolTree@asmjit@@QEAAXXZ PROC		; asmjit::ConstPoolTree::reset, COMDAT

; 80   :   ASMJIT_INLINE void reset() {

	mov	QWORD PTR [rsp+8], rcx

; 81   :     _root = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 82   :     _length = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 83   :   }

	ret	0
?reset@ConstPoolTree@asmjit@@QEAAXXZ ENDP		; asmjit::ConstPoolTree::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ??1ConstPoolTree@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1ConstPoolTree@asmjit@@QEAA@XZ PROC			; asmjit::ConstPoolTree::~ConstPoolTree, COMDAT

; 74   :   ASMJIT_INLINE ~ConstPoolTree() {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1ConstPoolTree@asmjit@@QEAA@XZ ENDP			; asmjit::ConstPoolTree::~ConstPoolTree
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ??0ConstPoolTree@asmjit@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
dataSize$ = 16
??0ConstPoolTree@asmjit@@QEAA@_K@Z PROC			; asmjit::ConstPoolTree::ConstPoolTree, COMDAT

; 73   :     _dataSize(dataSize) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 71   :     _root(NULL),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 72   :     _length(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 73   :     _dataSize(dataSize) {}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR dataSize$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ConstPoolTree@asmjit@@QEAA@_K@Z ENDP			; asmjit::ConstPoolTree::ConstPoolTree
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\constpool.h
;	COMDAT ?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ PROC		; asmjit::ConstPoolNode::getData, COMDAT

; 35   :   ASMJIT_INLINE void* getData() const {

	mov	QWORD PTR [rsp+8], rcx

; 36   :     return static_cast<void*>(const_cast<ConstPoolNode*>(this) + 1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24

; 37   :   }

	ret	0
?getData@ConstPoolNode@asmjit@@QEBAPEAXXZ ENDP		; asmjit::ConstPoolNode::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ?alloc@Zone@asmjit@@QEAAPEAX_K@Z
_TEXT	SEGMENT
cur$ = 32
ptr$ = 40
remainingBytes$ = 48
this$ = 80
size$ = 88
?alloc@Zone@asmjit@@QEAAPEAX_K@Z PROC			; asmjit::Zone::alloc, COMDAT

; 154  :   ASMJIT_INLINE void* alloc(size_t size) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 155  :     Block* cur = _block;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cur$[rsp], rax

; 156  : 
; 157  :     uint8_t* ptr = cur->pos;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 158  :     size_t remainingBytes = (size_t)(cur->end - ptr);

	mov	rax, QWORD PTR cur$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	mov	QWORD PTR remainingBytes$[rsp], rax

; 159  : 
; 160  :     if (remainingBytes < size)

	mov	rax, QWORD PTR size$[rsp]
	cmp	QWORD PTR remainingBytes$[rsp], rax
	jae	SHORT $LN2@alloc

; 161  :       return _alloc(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::_alloc
	jmp	SHORT $LN1@alloc
$LN2@alloc:

; 162  : 
; 163  :     cur->pos += size;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rcx], rax

; 164  :     ASMJIT_ASSERT(cur->pos <= cur->end);
; 165  : 
; 166  :     return (void*)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
$LN1@alloc:

; 167  :   }

	add	rsp, 72					; 00000048H
	ret	0
?alloc@Zone@asmjit@@QEAAPEAX_K@Z ENDP			; asmjit::Zone::alloc
_TEXT	ENDS
END
