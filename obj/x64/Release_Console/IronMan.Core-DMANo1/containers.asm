; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B ; asmjit::PodVectorBase::_nullData
CONST	SEGMENT
?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B DQ 0000000000000000H ; asmjit::PodVectorBase::_nullData
	DQ	0000000000000000H
CONST	ENDS
PUBLIC	?reset@PodVectorBase@asmjit@@QEAAX_N@Z		; asmjit::PodVectorBase::reset
PUBLIC	?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z		; asmjit::PodVectorBase::_grow
PUBLIC	?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z	; asmjit::PodVectorBase::_reserve
PUBLIC	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ		; asmjit::IntUtil::maxUInt<unsigned __int64>
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
pdata	SEGMENT
$pdata$?reset@PodVectorBase@asmjit@@QEAAX_N@Z DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$?reset@PodVectorBase@asmjit@@QEAAX_N@Z
$pdata$?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z DD imagerel $LN14
	DD	imagerel $LN14+291
	DD	imagerel $unwind$?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z
$pdata$?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z DD imagerel $LN9
	DD	imagerel $LN9+220
	DD	imagerel $unwind$?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?reset@PodVectorBase@asmjit@@QEAAX_N@Z DD 010d01H
	DD	0620dH
$unwind$?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z DD 011301H
	DD	08213H
$unwind$?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ
_TEXT	SEGMENT
??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ PROC		; asmjit::IntUtil::maxUInt<unsigned __int64>, COMDAT

; 131  :   static ASMJIT_INLINE T maxUInt() { return ~T(0); }

	mov	rax, -1
	ret	0
??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ ENDP		; asmjit::IntUtil::maxUInt<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.cpp
_TEXT	SEGMENT
d$ = 32
nBytes$ = 40
this$ = 64
n$ = 72
sizeOfT$ = 80
?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z PROC		; asmjit::PodVectorBase::_reserve

; 85   : Error PodVectorBase::_reserve(size_t n, size_t sizeOfT) {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 86   :   PodVectorData* d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax

; 87   : 
; 88   :   if (d->capacity >= n)

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR n$[rsp]
	cmp	QWORD PTR [rax], rcx
	jb	SHORT $LN2@reserve

; 89   :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@reserve
$LN2@reserve:

; 90   : 
; 91   :   size_t nBytes = sizeof(PodVectorData) + n * sizeOfT;

	mov	rax, QWORD PTR n$[rsp]
	imul	rax, QWORD PTR sizeOfT$[rsp]
	add	rax, 16
	mov	QWORD PTR nBytes$[rsp], rax

; 92   :   if (nBytes < n)

	mov	rax, QWORD PTR n$[rsp]
	cmp	QWORD PTR nBytes$[rsp], rax
	jae	SHORT $LN3@reserve

; 93   :     return kErrorNoHeapMemory;

	mov	eax, 1
	jmp	SHORT $LN1@reserve
$LN3@reserve:

; 94   : 
; 95   :   if (d == &_nullData) {

	lea	rax, OFFSET FLAT:?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B ; asmjit::PodVectorBase::_nullData
	cmp	QWORD PTR d$[rsp], rax
	jne	SHORT $LN4@reserve

; 96   :     d = static_cast<PodVectorData*>(ASMJIT_ALLOC(nBytes));

	mov	rcx, QWORD PTR nBytes$[rsp]
	call	malloc
	mov	QWORD PTR d$[rsp], rax

; 97   :     if (d == NULL)

	cmp	QWORD PTR d$[rsp], 0
	jne	SHORT $LN6@reserve

; 98   :       return kErrorNoHeapMemory;

	mov	eax, 1
	jmp	SHORT $LN1@reserve
$LN6@reserve:

; 99   :     d->length = 0;

	mov	rax, QWORD PTR d$[rsp]
	mov	QWORD PTR [rax+8], 0

; 100  :   }

	jmp	SHORT $LN5@reserve
$LN4@reserve:

; 101  :   else {
; 102  :     d = static_cast<PodVectorData*>(ASMJIT_REALLOC(d, nBytes));

	mov	rdx, QWORD PTR nBytes$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	call	realloc
	mov	QWORD PTR d$[rsp], rax

; 103  :     if (d == NULL)

	cmp	QWORD PTR d$[rsp], 0
	jne	SHORT $LN7@reserve

; 104  :       return kErrorNoHeapMemory;

	mov	eax, 1
	jmp	SHORT $LN1@reserve
$LN7@reserve:
$LN5@reserve:

; 105  :   }
; 106  : 
; 107  :   d->capacity = n;

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR n$[rsp]
	mov	QWORD PTR [rax], rcx

; 108  :   _d = d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	mov	QWORD PTR [rax], rcx

; 109  : 
; 110  :   return kErrorOk;

	xor	eax, eax
$LN1@reserve:

; 111  : }

	add	rsp, 56					; 00000038H
	ret	0
?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z ENDP		; asmjit::PodVectorBase::_reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.cpp
_TEXT	SEGMENT
capacity$ = 32
after$ = 40
d$ = 48
threshold$ = 56
this$ = 80
n$ = 88
sizeOfT$ = 96
?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z PROC		; asmjit::PodVectorBase::_grow

; 49   : Error PodVectorBase::_grow(size_t n, size_t sizeOfT) {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 50   :   PodVectorData* d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax

; 51   : 
; 52   :   size_t threshold = kMemAllocGrowMax / sizeOfT;

	xor	edx, edx
	mov	eax, 8388608				; 00800000H
	div	QWORD PTR sizeOfT$[rsp]
	mov	QWORD PTR threshold$[rsp], rax

; 53   :   size_t capacity = d->capacity;

	mov	rax, QWORD PTR d$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR capacity$[rsp], rax

; 54   :   size_t after = d->length;

	mov	rax, QWORD PTR d$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR after$[rsp], rax

; 55   : 
; 56   :   if (IntUtil::maxUInt<size_t>() - n < after)

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	sub	rax, QWORD PTR n$[rsp]
	cmp	rax, QWORD PTR after$[rsp]
	jae	SHORT $LN4@grow

; 57   :     return kErrorNoHeapMemory;

	mov	eax, 1
	jmp	$LN1@grow
$LN4@grow:

; 58   : 
; 59   :   after += n;

	mov	rax, QWORD PTR n$[rsp]
	mov	rcx, QWORD PTR after$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR after$[rsp], rax

; 60   : 
; 61   :   if (capacity >= after)

	mov	rax, QWORD PTR after$[rsp]
	cmp	QWORD PTR capacity$[rsp], rax
	jb	SHORT $LN5@grow

; 62   :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@grow
$LN5@grow:

; 63   : 
; 64   :   // PodVector is used as a linear array for some data structures used by
; 65   :   // AsmJit code generation. The purpose of this agressive growing schema
; 66   :   // is to minimize memory reallocations, because AsmJit code generation
; 67   :   // classes live short life and will be freed or reused soon.
; 68   :   if (capacity < 32)

	cmp	QWORD PTR capacity$[rsp], 32		; 00000020H
	jae	SHORT $LN6@grow

; 69   :     capacity = 32;

	mov	QWORD PTR capacity$[rsp], 32		; 00000020H
	jmp	SHORT $LN7@grow
$LN6@grow:

; 70   :   else if (capacity < 128)

	cmp	QWORD PTR capacity$[rsp], 128		; 00000080H
	jae	SHORT $LN8@grow

; 71   :     capacity = 128;

	mov	QWORD PTR capacity$[rsp], 128		; 00000080H
	jmp	SHORT $LN9@grow
$LN8@grow:

; 72   :   else if (capacity < 512)

	cmp	QWORD PTR capacity$[rsp], 512		; 00000200H
	jae	SHORT $LN10@grow

; 73   :     capacity = 512;

	mov	QWORD PTR capacity$[rsp], 512		; 00000200H
$LN10@grow:
$LN9@grow:
$LN7@grow:
$LN2@grow:

; 74   : 
; 75   :   while (capacity < after) {

	mov	rax, QWORD PTR after$[rsp]
	cmp	QWORD PTR capacity$[rsp], rax
	jae	SHORT $LN3@grow

; 76   :     if (capacity < threshold)

	mov	rax, QWORD PTR threshold$[rsp]
	cmp	QWORD PTR capacity$[rsp], rax
	jae	SHORT $LN11@grow

; 77   :       capacity *= 2;

	mov	rax, QWORD PTR capacity$[rsp]
	shl	rax, 1
	mov	QWORD PTR capacity$[rsp], rax
	jmp	SHORT $LN12@grow
$LN11@grow:

; 78   :     else
; 79   :       capacity += threshold;

	mov	rax, QWORD PTR threshold$[rsp]
	mov	rcx, QWORD PTR capacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR capacity$[rsp], rax
$LN12@grow:

; 80   :   }

	jmp	SHORT $LN2@grow
$LN3@grow:

; 81   : 
; 82   :   return _reserve(capacity, sizeOfT);

	mov	r8, QWORD PTR sizeOfT$[rsp]
	mov	rdx, QWORD PTR capacity$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_reserve@PodVectorBase@asmjit@@IEAAI_K0@Z ; asmjit::PodVectorBase::_reserve
$LN1@grow:

; 83   : }

	add	rsp, 72					; 00000048H
	ret	0
?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z ENDP		; asmjit::PodVectorBase::_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.cpp
_TEXT	SEGMENT
d$ = 32
this$ = 64
releaseMemory$ = 72
?reset@PodVectorBase@asmjit@@QEAAX_N@Z PROC		; asmjit::PodVectorBase::reset

; 30   : void PodVectorBase::reset(bool releaseMemory) {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 31   :   PodVectorData* d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax

; 32   : 
; 33   :   if (d == &_nullData)

	lea	rax, OFFSET FLAT:?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B ; asmjit::PodVectorBase::_nullData
	cmp	QWORD PTR d$[rsp], rax
	jne	SHORT $LN2@reset

; 34   :     return;

	jmp	SHORT $LN1@reset
$LN2@reset:

; 35   : 
; 36   :   if (releaseMemory) {

	movzx	eax, BYTE PTR releaseMemory$[rsp]
	test	eax, eax
	je	SHORT $LN3@reset

; 37   :     ASMJIT_FREE(d);

	mov	rcx, QWORD PTR d$[rsp]
	call	free

; 38   :     _d = const_cast<PodVectorData*>(&_nullData);

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?_nullData@PodVectorBase@asmjit@@2UPodVectorData@2@B ; asmjit::PodVectorBase::_nullData
	mov	QWORD PTR [rax], rcx

; 39   :     return;

	jmp	SHORT $LN1@reset
$LN3@reset:

; 40   :   }
; 41   : 
; 42   :   d->length = 0;

	mov	rax, QWORD PTR d$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN1@reset:

; 43   : }

	add	rsp, 56					; 00000038H
	ret	0
?reset@PodVectorBase@asmjit@@QEAAX_N@Z ENDP		; asmjit::PodVectorBase::reset
_TEXT	ENDS
END
