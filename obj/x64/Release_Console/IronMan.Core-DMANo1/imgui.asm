; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	?EmptyString@ImGuiTextBuffer@@2PADA		; ImGuiTextBuffer::EmptyString
PUBLIC	?GImGui@@3PEAUImGuiContext@@EA			; GImGui
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
_BSS	SEGMENT
?EmptyString@ImGuiTextBuffer@@2PADA DB 01H DUP (?)	; ImGuiTextBuffer::EmptyString
	ALIGN	8

?GImGui@@3PEAUImGuiContext@@EA DQ 01H DUP (?)		; GImGui
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?GCrc32LookupTable@@3QBIB DD 00H			; GCrc32LookupTable
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
?GStyleVarInfo@@3QBUImGuiStyleVarInfo@@B DD 04H		; GStyleVarInfo
	DD	01H
	DD	00H
	DD	04H
	DD	02H
	DD	04H
	DD	04H
	DD	01H
	DD	0cH
	DD	04H
	DD	01H
	DD	010H
	DD	04H
	DD	02H
	DD	014H
	DD	04H
	DD	02H
	DD	01cH
	DD	04H
	DD	01H
	DD	024H
	DD	04H
	DD	01H
	DD	028H
	DD	04H
	DD	01H
	DD	02cH
	DD	04H
	DD	01H
	DD	030H
	DD	04H
	DD	02H
	DD	034H
	DD	04H
	DD	01H
	DD	03cH
	DD	04H
	DD	01H
	DD	040H
	DD	04H
	DD	02H
	DD	044H
	DD	04H
	DD	02H
	DD	04cH
	DD	04H
	DD	01H
	DD	05cH
	DD	04H
	DD	01H
	DD	064H
	DD	04H
	DD	01H
	DD	068H
	DD	04H
	DD	01H
	DD	06cH
	DD	04H
	DD	01H
	DD	070H
	DD	04H
	DD	01H
	DD	074H
	DD	04H
	DD	02H
	DD	07cH
	DD	04H
	DD	02H
	DD	084H
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsnprintf
PUBLIC	fabsf
PUBLIC	?hash_@@YA?B_KPEBD@Z				; hash_
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	??0ImVec2@@QEAA@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QEAA@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QEAA@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z ; ImGui::CreateContext
PUBLIC	?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z	; ImGui::DestroyContext
PUBLIC	?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ ; ImGui::GetCurrentContext
PUBLIC	?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z ; ImGui::SetCurrentContext
PUBLIC	?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K1111@Z ; ImGui::DebugCheckVersionAndDataLayout
PUBLIC	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ			; ImGui::GetIO
PUBLIC	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ		; ImGui::GetStyle
PUBLIC	?NewFrame@ImGui@@YAXXZ				; ImGui::NewFrame
PUBLIC	?EndFrame@ImGui@@YAXXZ				; ImGui::EndFrame
PUBLIC	?Render@ImGui@@YAXXZ				; ImGui::Render
PUBLIC	?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ	; ImGui::GetDrawData
PUBLIC	?ShowMetricsWindow@ImGui@@YAXPEA_N@Z		; ImGui::ShowMetricsWindow
PUBLIC	?GetVersion@ImGui@@YAPEBDXZ			; ImGui::GetVersion
PUBLIC	?Begin@ImGui@@YA_NPEBDPEA_NH@Z			; ImGui::Begin
PUBLIC	?End@ImGui@@YAXXZ				; ImGui::End
PUBLIC	?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z	; ImGui::BeginChild
PUBLIC	?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z	; ImGui::BeginChild
PUBLIC	?EndChild@ImGui@@YAXXZ				; ImGui::EndChild
PUBLIC	?IsWindowAppearing@ImGui@@YA_NXZ		; ImGui::IsWindowAppearing
PUBLIC	?IsWindowCollapsed@ImGui@@YA_NXZ		; ImGui::IsWindowCollapsed
PUBLIC	?IsWindowFocused@ImGui@@YA_NH@Z			; ImGui::IsWindowFocused
PUBLIC	?IsWindowHovered@ImGui@@YA_NH@Z			; ImGui::IsWindowHovered
PUBLIC	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ	; ImGui::GetWindowDrawList
PUBLIC	?GetWindowPos@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetWindowPos
PUBLIC	?GetWindowSize@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetWindowSize
PUBLIC	?GetWindowWidth@ImGui@@YAMXZ			; ImGui::GetWindowWidth
PUBLIC	?GetWindowHeight@ImGui@@YAMXZ			; ImGui::GetWindowHeight
PUBLIC	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetContentRegionMax
PUBLIC	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetContentRegionAvail
PUBLIC	?GetContentRegionAvailWidth@ImGui@@YAMXZ	; ImGui::GetContentRegionAvailWidth
PUBLIC	?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMin
PUBLIC	?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMax
PUBLIC	?GetWindowContentRegionWidth@ImGui@@YAMXZ	; ImGui::GetWindowContentRegionWidth
PUBLIC	?GetNextWindowPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetNextWindowPos
PUBLIC	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z	; ImGui::SetNextWindowPos
PUBLIC	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z	; ImGui::SetNextWindowSize
PUBLIC	?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z ; ImGui::SetNextWindowSizeConstraints
PUBLIC	?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z ; ImGui::SetNextWindowContentSize
PUBLIC	?SetNextWindowCollapsed@ImGui@@YAX_NH@Z		; ImGui::SetNextWindowCollapsed
PUBLIC	?SetNextWindowFocus@ImGui@@YAXXZ		; ImGui::SetNextWindowFocus
PUBLIC	?SetNextWindowBgAlpha@ImGui@@YAXM@Z		; ImGui::SetNextWindowBgAlpha
PUBLIC	?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z		; ImGui::SetWindowPos
PUBLIC	?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z	; ImGui::SetWindowSize
PUBLIC	?SetWindowCollapsed@ImGui@@YAX_NH@Z		; ImGui::SetWindowCollapsed
PUBLIC	?SetWindowFocus@ImGui@@YAXXZ			; ImGui::SetWindowFocus
PUBLIC	?SetWindowFontScale@ImGui@@YAXM@Z		; ImGui::SetWindowFontScale
PUBLIC	?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z	; ImGui::SetWindowPos
PUBLIC	?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z	; ImGui::SetWindowSize
PUBLIC	?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z		; ImGui::SetWindowCollapsed
PUBLIC	?SetWindowFocus@ImGui@@YAXPEBD@Z		; ImGui::SetWindowFocus
PUBLIC	?GetScrollX@ImGui@@YAMXZ			; ImGui::GetScrollX
PUBLIC	?GetScrollY@ImGui@@YAMXZ			; ImGui::GetScrollY
PUBLIC	?GetScrollMaxX@ImGui@@YAMXZ			; ImGui::GetScrollMaxX
PUBLIC	?GetScrollMaxY@ImGui@@YAMXZ			; ImGui::GetScrollMaxY
PUBLIC	?SetScrollX@ImGui@@YAXM@Z			; ImGui::SetScrollX
PUBLIC	?SetScrollY@ImGui@@YAXM@Z			; ImGui::SetScrollY
PUBLIC	?SetScrollHereY@ImGui@@YAXM@Z			; ImGui::SetScrollHereY
PUBLIC	?SetScrollFromPosY@ImGui@@YAXMM@Z		; ImGui::SetScrollFromPosY
PUBLIC	?PushFont@ImGui@@YAXPEAUImFont@@@Z		; ImGui::PushFont
PUBLIC	?PopFont@ImGui@@YAXXZ				; ImGui::PopFont
PUBLIC	?PushStyleColor@ImGui@@YAXHI@Z			; ImGui::PushStyleColor
PUBLIC	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z	; ImGui::PushStyleColor
PUBLIC	?PopStyleColor@ImGui@@YAXH@Z			; ImGui::PopStyleColor
PUBLIC	?PushStyleVar@ImGui@@YAXHM@Z			; ImGui::PushStyleVar
PUBLIC	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z		; ImGui::PushStyleVar
PUBLIC	?PopStyleVar@ImGui@@YAXH@Z			; ImGui::PopStyleVar
PUBLIC	?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z	; ImGui::GetStyleColorVec4
PUBLIC	?GetFont@ImGui@@YAPEAUImFont@@XZ		; ImGui::GetFont
PUBLIC	?GetFontSize@ImGui@@YAMXZ			; ImGui::GetFontSize
PUBLIC	?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetFontTexUvWhitePixel
PUBLIC	?GetColorU32@ImGui@@YAIHM@Z			; ImGui::GetColorU32
PUBLIC	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z		; ImGui::GetColorU32
PUBLIC	?GetColorU32@ImGui@@YAIQEAM@Z			; ImGui::GetColorU32
PUBLIC	?GetColorU32@ImGui@@YAII@Z			; ImGui::GetColorU32
PUBLIC	?FloatArrayGetColorU32@ImGui@@YAIQEAM@Z		; ImGui::FloatArrayGetColorU32
PUBLIC	?FloatArrayGetColorU32@ImGui@@YAIUImVec4@@@Z	; ImGui::FloatArrayGetColorU32
PUBLIC	?PushItemWidth@ImGui@@YAXM@Z			; ImGui::PushItemWidth
PUBLIC	?PopItemWidth@ImGui@@YAXXZ			; ImGui::PopItemWidth
PUBLIC	?CalcItemWidth@ImGui@@YAMXZ			; ImGui::CalcItemWidth
PUBLIC	?PushTextWrapPos@ImGui@@YAXM@Z			; ImGui::PushTextWrapPos
PUBLIC	?PopTextWrapPos@ImGui@@YAXXZ			; ImGui::PopTextWrapPos
PUBLIC	?PushAllowKeyboardFocus@ImGui@@YAX_N@Z		; ImGui::PushAllowKeyboardFocus
PUBLIC	?PopAllowKeyboardFocus@ImGui@@YAXXZ		; ImGui::PopAllowKeyboardFocus
PUBLIC	?PushButtonRepeat@ImGui@@YAX_N@Z		; ImGui::PushButtonRepeat
PUBLIC	?PopButtonRepeat@ImGui@@YAXXZ			; ImGui::PopButtonRepeat
PUBLIC	?SameLine@ImGui@@YAXMMM@Z			; ImGui::SameLine
PUBLIC	?Indent@ImGui@@YAXM@Z				; ImGui::Indent
PUBLIC	?Unindent@ImGui@@YAXM@Z				; ImGui::Unindent
PUBLIC	?BeginGroup@ImGui@@YAXXZ			; ImGui::BeginGroup
PUBLIC	?EndGroup@ImGui@@YAXXZ				; ImGui::EndGroup
PUBLIC	?GetCursorPos@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetCursorPos
PUBLIC	?GetCursorPosX@ImGui@@YAMXZ			; ImGui::GetCursorPosX
PUBLIC	?GetCursorPosY@ImGui@@YAMXZ			; ImGui::GetCursorPosY
PUBLIC	?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::SetCursorPos
PUBLIC	?SetCursorPosX@ImGui@@YAXM@Z			; ImGui::SetCursorPosX
PUBLIC	?SetCursorPosY@ImGui@@YAXM@Z			; ImGui::SetCursorPosY
PUBLIC	?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetCursorStartPos
PUBLIC	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetCursorScreenPos
PUBLIC	?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z	; ImGui::SetCursorScreenPos
PUBLIC	?GetTextLineHeight@ImGui@@YAMXZ			; ImGui::GetTextLineHeight
PUBLIC	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ	; ImGui::GetTextLineHeightWithSpacing
PUBLIC	?GetFrameHeight@ImGui@@YAMXZ			; ImGui::GetFrameHeight
PUBLIC	?GetFrameHeightWithSpacing@ImGui@@YAMXZ		; ImGui::GetFrameHeightWithSpacing
PUBLIC	?PushID@ImGui@@YAXPEBD@Z			; ImGui::PushID
PUBLIC	?PushID@ImGui@@YAXPEBD0@Z			; ImGui::PushID
PUBLIC	?PushID@ImGui@@YAXPEBX@Z			; ImGui::PushID
PUBLIC	?PushID@ImGui@@YAXH@Z				; ImGui::PushID
PUBLIC	?PopID@ImGui@@YAXXZ				; ImGui::PopID
PUBLIC	?GetID@ImGui@@YAIPEBD@Z				; ImGui::GetID
PUBLIC	?GetID@ImGui@@YAIPEBD0@Z			; ImGui::GetID
PUBLIC	?GetID@ImGui@@YAIPEBX@Z				; ImGui::GetID
PUBLIC	?BeginTooltip@ImGui@@YAXXZ			; ImGui::BeginTooltip
PUBLIC	?EndTooltip@ImGui@@YAXXZ			; ImGui::EndTooltip
PUBLIC	?SetTooltip@ImGui@@YAXPEBDZZ			; ImGui::SetTooltip
PUBLIC	?SetTooltipV@ImGui@@YAXPEBDPEAD@Z		; ImGui::SetTooltipV
PUBLIC	?OpenPopup@ImGui@@YAXPEBD@Z			; ImGui::OpenPopup
PUBLIC	?BeginPopup@ImGui@@YA_NPEBDH@Z			; ImGui::BeginPopup
PUBLIC	?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z	; ImGui::BeginPopupContextItem
PUBLIC	?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z	; ImGui::BeginPopupContextWindow
PUBLIC	?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z	; ImGui::BeginPopupContextVoid
PUBLIC	?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z	; ImGui::BeginPopupModal
PUBLIC	?EndPopup@ImGui@@YAXXZ				; ImGui::EndPopup
PUBLIC	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z	; ImGui::OpenPopupOnItemClick
PUBLIC	?IsPopupOpen@ImGui@@YA_NPEBD@Z			; ImGui::IsPopupOpen
PUBLIC	?CloseCurrentPopup@ImGui@@YAXXZ			; ImGui::CloseCurrentPopup
PUBLIC	?Columns@ImGui@@YAXHPEBD_N@Z			; ImGui::Columns
PUBLIC	?NextColumn@ImGui@@YAXXZ			; ImGui::NextColumn
PUBLIC	?GetColumnIndex@ImGui@@YAHXZ			; ImGui::GetColumnIndex
PUBLIC	?GetColumnWidth@ImGui@@YAMH@Z			; ImGui::GetColumnWidth
PUBLIC	?SetColumnWidth@ImGui@@YAXHM@Z			; ImGui::SetColumnWidth
PUBLIC	?GetColumnOffset@ImGui@@YAMH@Z			; ImGui::GetColumnOffset
PUBLIC	?SetColumnOffset@ImGui@@YAXHM@Z			; ImGui::SetColumnOffset
PUBLIC	?GetColumnsCount@ImGui@@YAHXZ			; ImGui::GetColumnsCount
PUBLIC	?BeginDragDropSource@ImGui@@YA_NH@Z		; ImGui::BeginDragDropSource
PUBLIC	?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z	; ImGui::SetDragDropPayload
PUBLIC	?EndDragDropSource@ImGui@@YAXXZ			; ImGui::EndDragDropSource
PUBLIC	?BeginDragDropTarget@ImGui@@YA_NXZ		; ImGui::BeginDragDropTarget
PUBLIC	?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z ; ImGui::AcceptDragDropPayload
PUBLIC	?EndDragDropTarget@ImGui@@YAXXZ			; ImGui::EndDragDropTarget
PUBLIC	?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ ; ImGui::GetDragDropPayload
PUBLIC	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z	; ImGui::PushClipRect
PUBLIC	?PopClipRect@ImGui@@YAXXZ			; ImGui::PopClipRect
PUBLIC	?SetItemDefaultFocus@ImGui@@YAXXZ		; ImGui::SetItemDefaultFocus
PUBLIC	?SetKeyboardFocusHere@ImGui@@YAXH@Z		; ImGui::SetKeyboardFocusHere
PUBLIC	?IsItemHovered@ImGui@@YA_NH@Z			; ImGui::IsItemHovered
PUBLIC	?IsItemActive@ImGui@@YA_NXZ			; ImGui::IsItemActive
PUBLIC	?IsItemFocused@ImGui@@YA_NXZ			; ImGui::IsItemFocused
PUBLIC	?IsItemClicked@ImGui@@YA_NH@Z			; ImGui::IsItemClicked
PUBLIC	?IsItemVisible@ImGui@@YA_NXZ			; ImGui::IsItemVisible
PUBLIC	?IsItemEdited@ImGui@@YA_NXZ			; ImGui::IsItemEdited
PUBLIC	?IsItemActivated@ImGui@@YA_NXZ			; ImGui::IsItemActivated
PUBLIC	?IsItemDeactivated@ImGui@@YA_NXZ		; ImGui::IsItemDeactivated
PUBLIC	?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ	; ImGui::IsItemDeactivatedAfterEdit
PUBLIC	?IsAnyItemHovered@ImGui@@YA_NXZ			; ImGui::IsAnyItemHovered
PUBLIC	?IsAnyItemActive@ImGui@@YA_NXZ			; ImGui::IsAnyItemActive
PUBLIC	?IsAnyItemFocused@ImGui@@YA_NXZ			; ImGui::IsAnyItemFocused
PUBLIC	?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetItemRectMin
PUBLIC	?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetItemRectMax
PUBLIC	?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetItemRectSize
PUBLIC	?SetItemAllowOverlap@ImGui@@YAXXZ		; ImGui::SetItemAllowOverlap
PUBLIC	?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z	; ImGui::IsRectVisible
PUBLIC	?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z	; ImGui::IsRectVisible
PUBLIC	?GetTime@ImGui@@YANXZ				; ImGui::GetTime
PUBLIC	?GetFrameCount@ImGui@@YAHXZ			; ImGui::GetFrameCount
PUBLIC	?GetOverlayDrawList@ImGui@@YAPEAUImDrawList@@XZ	; ImGui::GetOverlayDrawList
PUBLIC	?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ ; ImGui::GetDrawListSharedData
PUBLIC	?GetStyleColorName@ImGui@@YAPEBDH@Z		; ImGui::GetStyleColorName
PUBLIC	?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z	; ImGui::SetStateStorage
PUBLIC	?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ	; ImGui::GetStateStorage
PUBLIC	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z	; ImGui::CalcTextSize
PUBLIC	?CalcListClipping@ImGui@@YAXHMPEAH0@Z		; ImGui::CalcListClipping
PUBLIC	?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z	; ImGui::BeginChildFrame
PUBLIC	?EndChildFrame@ImGui@@YAXXZ			; ImGui::EndChildFrame
PUBLIC	?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z ; ImGui::ColorConvertU32ToFloat4
PUBLIC	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
PUBLIC	?ColorConvertFloat4ToRGB@ImGui@@YAXAEBUImVec4@@AEAM11@Z ; ImGui::ColorConvertFloat4ToRGB
PUBLIC	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z	; ImGui::ColorConvertRGBtoHSV
PUBLIC	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z	; ImGui::ColorConvertHSVtoRGB
PUBLIC	?GetKeyIndex@ImGui@@YAHH@Z			; ImGui::GetKeyIndex
PUBLIC	?IsKeyDown@ImGui@@YA_NH@Z			; ImGui::IsKeyDown
PUBLIC	?IsKeyPressed@ImGui@@YA_NH_N@Z			; ImGui::IsKeyPressed
PUBLIC	?IsKeyReleased@ImGui@@YA_NH@Z			; ImGui::IsKeyReleased
PUBLIC	?GetKeyPressedAmount@ImGui@@YAHHMM@Z		; ImGui::GetKeyPressedAmount
PUBLIC	?IsMouseDown@ImGui@@YA_NH@Z			; ImGui::IsMouseDown
PUBLIC	?IsAnyMouseDown@ImGui@@YA_NXZ			; ImGui::IsAnyMouseDown
PUBLIC	?IsMouseClicked@ImGui@@YA_NH_N@Z		; ImGui::IsMouseClicked
PUBLIC	?IsMouseDoubleClicked@ImGui@@YA_NH@Z		; ImGui::IsMouseDoubleClicked
PUBLIC	?IsMouseReleased@ImGui@@YA_NH@Z			; ImGui::IsMouseReleased
PUBLIC	?IsMouseDragging@ImGui@@YA_NHM@Z		; ImGui::IsMouseDragging
PUBLIC	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
PUBLIC	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z	; ImGui::IsMousePosValid
PUBLIC	?GetMousePos@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetMousePos
PUBLIC	?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetMousePosOnOpeningCurrentPopup
PUBLIC	?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z	; ImGui::GetMouseDragDelta
PUBLIC	?ResetMouseDragDelta@ImGui@@YAXH@Z		; ImGui::ResetMouseDragDelta
PUBLIC	?GetMouseCursor@ImGui@@YAHXZ			; ImGui::GetMouseCursor
PUBLIC	?SetMouseCursor@ImGui@@YAXH@Z			; ImGui::SetMouseCursor
PUBLIC	?CaptureKeyboardFromApp@ImGui@@YAX_N@Z		; ImGui::CaptureKeyboardFromApp
PUBLIC	?CaptureMouseFromApp@ImGui@@YAX_N@Z		; ImGui::CaptureMouseFromApp
PUBLIC	?GetClipboardText@ImGui@@YAPEBDXZ		; ImGui::GetClipboardText
PUBLIC	?SetClipboardText@ImGui@@YAXPEBD@Z		; ImGui::SetClipboardText
PUBLIC	?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z ; ImGui::SetAllocatorFunctions
PUBLIC	?MemAlloc@ImGui@@YAPEAX_K@Z			; ImGui::MemAlloc
PUBLIC	?MemFree@ImGui@@YAXPEAX@Z			; ImGui::MemFree
PUBLIC	??0ImGuiStyle@@QEAA@XZ				; ImGuiStyle::ImGuiStyle
PUBLIC	?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z		; ImGuiStyle::ScaleAllSizes
PUBLIC	?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z	; ImGuiIO::AddInputCharactersUTF8
PUBLIC	?AddInputCharacter@ImGuiIO@@QEAAXG@Z		; ImGuiIO::AddInputCharacter
PUBLIC	?ClearInputCharacters@ImGuiIO@@QEAAXXZ		; ImGuiIO::ClearInputCharacters
PUBLIC	??0?$ImVector@G@@QEAA@XZ			; ImVector<unsigned short>::ImVector<unsigned short>
PUBLIC	??1?$ImVector@G@@QEAA@XZ			; ImVector<unsigned short>::~ImVector<unsigned short>
PUBLIC	??A?$ImVector@G@@QEAAAEAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?clear@?$ImVector@G@@QEAAXXZ			; ImVector<unsigned short>::clear
PUBLIC	?_grow_capacity@?$ImVector@G@@QEBAHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	?push_back@?$ImVector@G@@QEAAXAEBG@Z		; ImVector<unsigned short>::push_back
PUBLIC	??0ImGuiIO@@QEAA@XZ				; ImGuiIO::ImGuiIO
PUBLIC	??1ImGuiIO@@QEAA@XZ				; ImGuiIO::~ImGuiIO
PUBLIC	??0ImGuiSizeCallbackData@@QEAA@XZ		; ImGuiSizeCallbackData::ImGuiSizeCallbackData
PUBLIC	?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z		; ImGuiPayload::IsDataType
PUBLIC	??0ImGuiPayload@@QEAA@XZ			; ImGuiPayload::ImGuiPayload
PUBLIC	?Clear@ImGuiPayload@@QEAAXXZ			; ImGuiPayload::Clear
PUBLIC	?Begin@ImGui@@YA_NPEBDPEA_NAEBUImVec2@@MH@Z	; ImGui::Begin
PUBLIC	??2@YAPEAX_KUImNewDummy@@PEAX@Z			; operator new
PUBLIC	??3@YAXPEAXUImNewDummy@@0@Z			; operator delete
PUBLIC	??0ImGuiTextFilter@@QEAA@PEBD@Z			; ImGuiTextFilter::ImGuiTextFilter
PUBLIC	?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z		; ImGuiTextFilter::Draw
PUBLIC	?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z	; ImGuiTextFilter::PassFilter
PUBLIC	?Build@ImGuiTextFilter@@QEAAXXZ			; ImGuiTextFilter::Build
PUBLIC	??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z	; ImGuiTextFilter::TextRange::TextRange
PUBLIC	?begin@TextRange@ImGuiTextFilter@@QEBAPEBDXZ	; ImGuiTextFilter::TextRange::begin
PUBLIC	?end@TextRange@ImGuiTextFilter@@QEBAPEBDXZ	; ImGuiTextFilter::TextRange::end
PUBLIC	?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ	; ImGuiTextFilter::TextRange::empty
PUBLIC	?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z ; ImGuiTextFilter::TextRange::split
PUBLIC	??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ ; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>
PUBLIC	??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
PUBLIC	?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ ; ImVector<ImGuiTextFilter::TextRange>::empty
PUBLIC	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAAEAUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
PUBLIC	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAAEBUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity
PUBLIC	?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ; ImVector<ImGuiTextFilter::TextRange>::resize
PUBLIC	?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ; ImVector<ImGuiTextFilter::TextRange>::reserve
PUBLIC	?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z ; ImVector<ImGuiTextFilter::TextRange>::push_back
PUBLIC	??0?$ImVector@D@@QEAA@XZ			; ImVector<char>::ImVector<char>
PUBLIC	??1?$ImVector@D@@QEAA@XZ			; ImVector<char>::~ImVector<char>
PUBLIC	??A?$ImVector@D@@QEAAAEADH@Z			; ImVector<char>::operator[]
PUBLIC	?clear@?$ImVector@D@@QEAAXXZ			; ImVector<char>::clear
PUBLIC	?_grow_capacity@?$ImVector@D@@QEBAHH@Z		; ImVector<char>::_grow_capacity
PUBLIC	?resize@?$ImVector@D@@QEAAXH@Z			; ImVector<char>::resize
PUBLIC	?reserve@?$ImVector@D@@QEAAXH@Z			; ImVector<char>::reserve
PUBLIC	?append@ImGuiTextBuffer@@QEAAXPEBD0@Z		; ImGuiTextBuffer::append
PUBLIC	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ		; ImGuiTextBuffer::appendf
PUBLIC	?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z	; ImGuiTextBuffer::appendfv
PUBLIC	??1ImGuiTextBuffer@@QEAA@XZ			; ImGuiTextBuffer::~ImGuiTextBuffer
PUBLIC	??0Pair@ImGuiStorage@@QEAA@IH@Z			; ImGuiStorage::Pair::Pair
PUBLIC	??0Pair@ImGuiStorage@@QEAA@IM@Z			; ImGuiStorage::Pair::Pair
PUBLIC	??0Pair@ImGuiStorage@@QEAA@IPEAX@Z		; ImGuiStorage::Pair::Pair
PUBLIC	??0?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ	; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>
PUBLIC	??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ	; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
PUBLIC	??A?$ImVector@UPair@ImGuiStorage@@@@QEAAAEAUPair@ImGuiStorage@@H@Z ; ImVector<ImGuiStorage::Pair>::operator[]
PUBLIC	?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ	; ImVector<ImGuiStorage::Pair>::clear
PUBLIC	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
PUBLIC	?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
PUBLIC	?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z ; ImVector<ImGuiStorage::Pair>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z ; ImVector<ImGuiStorage::Pair>::reserve
PUBLIC	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
PUBLIC	?Clear@ImGuiStorage@@QEAAXXZ			; ImGuiStorage::Clear
PUBLIC	?GetInt@ImGuiStorage@@QEBAHIH@Z			; ImGuiStorage::GetInt
PUBLIC	?SetInt@ImGuiStorage@@QEAAXIH@Z			; ImGuiStorage::SetInt
PUBLIC	?GetBool@ImGuiStorage@@QEBA_NI_N@Z		; ImGuiStorage::GetBool
PUBLIC	?SetBool@ImGuiStorage@@QEAAXI_N@Z		; ImGuiStorage::SetBool
PUBLIC	?GetFloat@ImGuiStorage@@QEBAMIM@Z		; ImGuiStorage::GetFloat
PUBLIC	?SetFloat@ImGuiStorage@@QEAAXIM@Z		; ImGuiStorage::SetFloat
PUBLIC	?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z		; ImGuiStorage::GetVoidPtr
PUBLIC	?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z		; ImGuiStorage::SetVoidPtr
PUBLIC	?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z		; ImGuiStorage::GetIntRef
PUBLIC	?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z	; ImGuiStorage::GetBoolRef
PUBLIC	?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z		; ImGuiStorage::GetFloatRef
PUBLIC	?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z	; ImGuiStorage::GetVoidPtrRef
PUBLIC	?SetAllInt@ImGuiStorage@@QEAAXH@Z		; ImGuiStorage::SetAllInt
PUBLIC	?BuildSortByKey@ImGuiStorage@@QEAAXXZ		; ImGuiStorage::BuildSortByKey
PUBLIC	??0ImGuiStorage@@QEAA@XZ			; ImGuiStorage::ImGuiStorage
PUBLIC	??1ImGuiStorage@@QEAA@XZ			; ImGuiStorage::~ImGuiStorage
PUBLIC	??0ImGuiListClipper@@QEAA@HM@Z			; ImGuiListClipper::ImGuiListClipper
PUBLIC	??1ImGuiListClipper@@QEAA@XZ			; ImGuiListClipper::~ImGuiListClipper
PUBLIC	?Step@ImGuiListClipper@@QEAA_NXZ		; ImGuiListClipper::Step
PUBLIC	?Begin@ImGuiListClipper@@QEAAXHM@Z		; ImGuiListClipper::Begin
PUBLIC	?End@ImGuiListClipper@@QEAAXXZ			; ImGuiListClipper::End
PUBLIC	??0?$ImVector@UImDrawCmd@@@@QEAA@XZ		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
PUBLIC	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
PUBLIC	?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ	; ImVector<ImDrawCmd>::empty
PUBLIC	?begin@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::begin
PUBLIC	?end@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::end
PUBLIC	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
PUBLIC	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ	; ImVector<ImDrawCmd>::pop_back
PUBLIC	??0?$ImVector@UImDrawVert@@@@QEAA@XZ		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
PUBLIC	??1?$ImVector@UImDrawVert@@@@QEAA@XZ		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
PUBLIC	?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ	; ImVector<ImDrawVert>::empty
PUBLIC	??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
PUBLIC	??0?$ImVector@UImDrawChannel@@@@QEAA@XZ		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
PUBLIC	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
PUBLIC	??0?$ImVector@UImVec4@@@@QEAA@XZ		; ImVector<ImVec4>::ImVector<ImVec4>
PUBLIC	??1?$ImVector@UImVec4@@@@QEAA@XZ		; ImVector<ImVec4>::~ImVector<ImVec4>
PUBLIC	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ	; ImVector<ImVec4>::back
PUBLIC	??0?$ImVector@PEAX@@QEAA@XZ			; ImVector<void *>::ImVector<void *>
PUBLIC	??1?$ImVector@PEAX@@QEAA@XZ			; ImVector<void *>::~ImVector<void *>
PUBLIC	??0?$ImVector@UImVec2@@@@QEAA@XZ		; ImVector<ImVec2>::ImVector<ImVec2>
PUBLIC	??1?$ImVector@UImVec2@@@@QEAA@XZ		; ImVector<ImVec2>::~ImVector<ImVec2>
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ; ImDrawList::ImDrawList
PUBLIC	??1ImDrawList@@QEAA@XZ				; ImDrawList::~ImDrawList
PUBLIC	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFillConvex@ImDrawList@@QEAAXI@Z		; ImDrawList::PathFillConvex
PUBLIC	?PathStroke@ImDrawList@@QEAAXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	??0ImDrawData@@QEAA@XZ				; ImDrawData::ImDrawData
PUBLIC	??1ImDrawData@@QEAA@XZ				; ImDrawData::~ImDrawData
PUBLIC	?Clear@ImDrawData@@QEAAXXZ			; ImDrawData::Clear
PUBLIC	??0?$ImVector@H@@QEAA@XZ			; ImVector<int>::ImVector<int>
PUBLIC	??1?$ImVector@H@@QEAA@XZ			; ImVector<int>::~ImVector<int>
PUBLIC	?empty@?$ImVector@H@@QEBA_NXZ			; ImVector<int>::empty
PUBLIC	?back@?$ImVector@H@@QEAAAEAHXZ			; ImVector<int>::back
PUBLIC	?_grow_capacity@?$ImVector@H@@QEBAHH@Z		; ImVector<int>::_grow_capacity
PUBLIC	?resize@?$ImVector@H@@QEAAXH@Z			; ImVector<int>::resize
PUBLIC	?reserve@?$ImVector@H@@QEAAXH@Z			; ImVector<int>::reserve
PUBLIC	?push_back@?$ImVector@H@@QEAAXAEBH@Z		; ImVector<int>::push_back
PUBLIC	?pop_back@?$ImVector@H@@QEAAXXZ			; ImVector<int>::pop_back
PUBLIC	??0?$ImVector@PEAUImFont@@@@QEAA@XZ		; ImVector<ImFont *>::ImVector<ImFont *>
PUBLIC	??1?$ImVector@PEAUImFont@@@@QEAA@XZ		; ImVector<ImFont *>::~ImVector<ImFont *>
PUBLIC	?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ	; ImVector<ImFont *>::empty
PUBLIC	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
PUBLIC	?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ		; ImVector<ImFont *>::clear
PUBLIC	?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ ; ImVector<ImFont *>::back
PUBLIC	?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z ; ImVector<ImFont *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z	; ImVector<ImFont *>::reserve
PUBLIC	?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ; ImVector<ImFont *>::push_back
PUBLIC	?pop_back@?$ImVector@PEAUImFont@@@@QEAAXXZ	; ImVector<ImFont *>::pop_back
PUBLIC	??_GImFontAtlas@@QEAAPEAXI@Z			; ImFontAtlas::`scalar deleting destructor'
PUBLIC	??0?$ImVector@M@@QEAA@XZ			; ImVector<float>::ImVector<float>
PUBLIC	??1?$ImVector@M@@QEAA@XZ			; ImVector<float>::~ImVector<float>
PUBLIC	?empty@?$ImVector@M@@QEBA_NXZ			; ImVector<float>::empty
PUBLIC	?back@?$ImVector@M@@QEAAAEAMXZ			; ImVector<float>::back
PUBLIC	?_grow_capacity@?$ImVector@M@@QEBAHH@Z		; ImVector<float>::_grow_capacity
PUBLIC	?resize@?$ImVector@M@@QEAAXH@Z			; ImVector<float>::resize
PUBLIC	?reserve@?$ImVector@M@@QEAAXH@Z			; ImVector<float>::reserve
PUBLIC	?push_back@?$ImVector@M@@QEAAXAEBM@Z		; ImVector<float>::push_back
PUBLIC	?pop_back@?$ImVector@M@@QEAAXXZ			; ImVector<float>::pop_back
PUBLIC	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z		; ImTextStrToUtf8
PUBLIC	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z		; ImTextCharFromUtf8
PUBLIC	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z	; ImTextStrFromUtf8
PUBLIC	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z		; ImTextCountCharsFromUtf8
PUBLIC	?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z	; ImTextCountUtf8BytesFromChar
PUBLIC	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z	; ImTextCountUtf8BytesFromStr
PUBLIC	?ImHashData@@YAIPEBX_KI@Z			; ImHashData
PUBLIC	?ImHashStr@@YAIPEBD_KI@Z			; ImHashStr
PUBLIC	?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z	; ImFileLoadToMemory
PUBLIC	?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z		; ImFileOpen
PUBLIC	?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z	; ImLineClosestPoint
PUBLIC	?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z	; ImTriangleContainsPoint
PUBLIC	?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z ; ImTriangleClosestPoint
PUBLIC	?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z ; ImTriangleBarycentricCoords
PUBLIC	?ImGetDirQuadrantFromDelta@@YAHMM@Z		; ImGetDirQuadrantFromDelta
PUBLIC	?ImStricmp@@YAHPEBD0@Z				; ImStricmp
PUBLIC	?ImStrnicmp@@YAHPEBD0_K@Z			; ImStrnicmp
PUBLIC	?ImStrncpy@@YAXPEADPEBD_K@Z			; ImStrncpy
PUBLIC	?ImStrdup@@YAPEADPEBD@Z				; ImStrdup
PUBLIC	?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z		; ImStrdupcpy
PUBLIC	?ImStrchrRange@@YAPEBDPEBD0D@Z			; ImStrchrRange
PUBLIC	?ImStrlenW@@YAHPEBG@Z				; ImStrlenW
PUBLIC	?ImStreolRange@@YAPEBDPEBD0@Z			; ImStreolRange
PUBLIC	?ImStrbolW@@YAPEBGPEBG0@Z			; ImStrbolW
PUBLIC	?ImStristr@@YAPEBDPEBD000@Z			; ImStristr
PUBLIC	?ImStrTrimBlanks@@YAXPEAD@Z			; ImStrTrimBlanks
PUBLIC	?ImFormatString@@YAHPEAD_KPEBDZZ		; ImFormatString
PUBLIC	?ImFormatStringV@@YAHPEAD_KPEBD0@Z		; ImFormatStringV
PUBLIC	??0ImVec1@@QEAA@XZ				; ImVec1::ImVec1
PUBLIC	??0ImVec1@@QEAA@M@Z				; ImVec1::ImVec1
PUBLIC	??0ImRect@@QEAA@XZ				; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec4@@@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@MMMM@Z				; ImRect::ImRect
PUBLIC	?GetSize@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetSize
PUBLIC	?GetWidth@ImRect@@QEBAMXZ			; ImRect::GetWidth
PUBLIC	?GetHeight@ImRect@@QEBAMXZ			; ImRect::GetHeight
PUBLIC	?GetTR@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetTR
PUBLIC	?GetBL@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetBL
PUBLIC	?GetBR@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetBR
PUBLIC	?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z		; ImRect::Contains
PUBLIC	?Contains@ImRect@@QEBA_NAEBU1@@Z		; ImRect::Contains
PUBLIC	?Overlaps@ImRect@@QEBA_NAEBU1@@Z		; ImRect::Overlaps
PUBLIC	?Add@ImRect@@QEAAXAEBUImVec2@@@Z		; ImRect::Add
PUBLIC	?Add@ImRect@@QEAAXAEBU1@@Z			; ImRect::Add
PUBLIC	?Expand@ImRect@@QEAAXM@Z			; ImRect::Expand
PUBLIC	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z		; ImRect::Expand
PUBLIC	?Translate@ImRect@@QEAAXAEBUImVec2@@@Z		; ImRect::Translate
PUBLIC	?TranslateX@ImRect@@QEAAXM@Z			; ImRect::TranslateX
PUBLIC	?TranslateY@ImRect@@QEAAXM@Z			; ImRect::TranslateY
PUBLIC	?ClipWith@ImRect@@QEAAXAEBU1@@Z			; ImRect::ClipWith
PUBLIC	?ClipWithFull@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWithFull
PUBLIC	?Floor@ImRect@@QEAAXXZ				; ImRect::Floor
PUBLIC	?IsInverted@ImRect@@QEBA_NXZ			; ImRect::IsInverted
PUBLIC	??0ImGuiColorMod@@QEAA@XZ			; ImGuiColorMod::ImGuiColorMod
PUBLIC	??0ImGuiStyleMod@@QEAA@HM@Z			; ImGuiStyleMod::ImGuiStyleMod
PUBLIC	??0ImGuiStyleMod@@QEAA@HUImVec2@@@Z		; ImGuiStyleMod::ImGuiStyleMod
PUBLIC	??0ImGuiInputTextState@@QEAA@XZ			; ImGuiInputTextState::ImGuiInputTextState
PUBLIC	??1ImGuiInputTextState@@QEAA@XZ			; ImGuiInputTextState::~ImGuiInputTextState
PUBLIC	??0ImGuiPopupRef@@QEAA@XZ			; ImGuiPopupRef::ImGuiPopupRef
PUBLIC	??0ImGuiColumnData@@QEAA@XZ			; ImGuiColumnData::ImGuiColumnData
PUBLIC	??0?$ImVector@UImGuiColumnData@@@@QEAA@XZ	; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
PUBLIC	??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ	; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
PUBLIC	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
PUBLIC	??A?$ImVector@UImGuiColumnData@@@@QEBAAEBUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ	; ImVector<ImGuiColumnData>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z	; ImVector<ImGuiColumnData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ; ImVector<ImGuiColumnData>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z ; ImVector<ImGuiColumnData>::push_back
PUBLIC	??0ImGuiColumnsSet@@QEAA@XZ			; ImGuiColumnsSet::ImGuiColumnsSet
PUBLIC	?Clear@ImGuiColumnsSet@@QEAAXXZ			; ImGuiColumnsSet::Clear
PUBLIC	??1ImGuiColumnsSet@@QEAA@XZ			; ImGuiColumnsSet::~ImGuiColumnsSet
PUBLIC	??_GImGuiColumnsSet@@QEAAPEAXI@Z		; ImGuiColumnsSet::`scalar deleting destructor'
PUBLIC	??0?$ImVector@PEAUImDrawList@@@@QEAA@XZ		; ImVector<ImDrawList *>::ImVector<ImDrawList *>
PUBLIC	??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ		; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
PUBLIC	?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ	; ImVector<ImDrawList *>::empty
PUBLIC	??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z ; ImVector<ImDrawList *>::operator[]
PUBLIC	?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ	; ImVector<ImDrawList *>::clear
PUBLIC	?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z ; ImVector<ImDrawList *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z	; ImVector<ImDrawList *>::resize
PUBLIC	?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z	; ImVector<ImDrawList *>::reserve
PUBLIC	?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z ; ImVector<ImDrawList *>::push_back
PUBLIC	?Clear@ImDrawDataBuilder@@QEAAXXZ		; ImDrawDataBuilder::Clear
PUBLIC	?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ	; ImDrawDataBuilder::ClearFreeMemory
PUBLIC	?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ ; ImDrawDataBuilder::FlattenIntoSingleLayer
PUBLIC	??0ImDrawDataBuilder@@QEAA@XZ			; ImDrawDataBuilder::ImDrawDataBuilder
PUBLIC	??1ImDrawDataBuilder@@QEAA@XZ			; ImDrawDataBuilder::~ImDrawDataBuilder
PUBLIC	??0ImGuiNavMoveResult@@QEAA@XZ			; ImGuiNavMoveResult::ImGuiNavMoveResult
PUBLIC	?Clear@ImGuiNavMoveResult@@QEAAXXZ		; ImGuiNavMoveResult::Clear
PUBLIC	??0ImGuiNextWindowData@@QEAA@XZ			; ImGuiNextWindowData::ImGuiNextWindowData
PUBLIC	?Clear@ImGuiNextWindowData@@QEAAXXZ		; ImGuiNextWindowData::Clear
PUBLIC	??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ	; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
PUBLIC	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ	; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
PUBLIC	?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ	; ImVector<ImGuiWindow *>::empty
PUBLIC	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
PUBLIC	?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ	; ImVector<ImGuiWindow *>::clear
PUBLIC	?begin@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::begin
PUBLIC	?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::back
PUBLIC	?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z ; ImVector<ImGuiWindow *>::swap
PUBLIC	?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z ; ImVector<ImGuiWindow *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z	; ImVector<ImGuiWindow *>::resize
PUBLIC	?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z	; ImVector<ImGuiWindow *>::reserve
PUBLIC	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
PUBLIC	?pop_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ	; ImVector<ImGuiWindow *>::pop_back
PUBLIC	?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_front
PUBLIC	?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z ; ImVector<ImGuiWindow *>::insert
PUBLIC	??0?$ImVector@UImGuiColorMod@@@@QEAA@XZ		; ImVector<ImGuiColorMod>::ImVector<ImGuiColorMod>
PUBLIC	??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ		; ImVector<ImGuiColorMod>::~ImVector<ImGuiColorMod>
PUBLIC	?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ	; ImVector<ImGuiColorMod>::clear
PUBLIC	?back@?$ImVector@UImGuiColorMod@@@@QEAAAEAUImGuiColorMod@@XZ ; ImVector<ImGuiColorMod>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z ; ImVector<ImGuiColorMod>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z	; ImVector<ImGuiColorMod>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiColorMod@@@@QEAAXXZ	; ImVector<ImGuiColorMod>::pop_back
PUBLIC	??0?$ImVector@UImGuiStyleMod@@@@QEAA@XZ		; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>
PUBLIC	??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ		; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
PUBLIC	?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ	; ImVector<ImGuiStyleMod>::clear
PUBLIC	?back@?$ImVector@UImGuiStyleMod@@@@QEAAAEAUImGuiStyleMod@@XZ ; ImVector<ImGuiStyleMod>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z ; ImVector<ImGuiStyleMod>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z	; ImVector<ImGuiStyleMod>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ	; ImVector<ImGuiStyleMod>::pop_back
PUBLIC	??0?$ImVector@UImGuiPopupRef@@@@QEAA@XZ		; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>
PUBLIC	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ		; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
PUBLIC	?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ	; ImVector<ImGuiPopupRef>::empty
PUBLIC	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ	; ImVector<ImGuiPopupRef>::clear
PUBLIC	?back@?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@XZ ; ImVector<ImGuiPopupRef>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z ; ImVector<ImGuiPopupRef>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z	; ImVector<ImGuiPopupRef>::resize
PUBLIC	?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z	; ImVector<ImGuiPopupRef>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z ; ImVector<ImGuiPopupRef>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ	; ImVector<ImGuiPopupRef>::pop_back
PUBLIC	??0?$ImVector@E@@QEAA@XZ			; ImVector<unsigned char>::ImVector<unsigned char>
PUBLIC	??1?$ImVector@E@@QEAA@XZ			; ImVector<unsigned char>::~ImVector<unsigned char>
PUBLIC	?clear@?$ImVector@E@@QEAAXXZ			; ImVector<unsigned char>::clear
PUBLIC	?_grow_capacity@?$ImVector@E@@QEBAHH@Z		; ImVector<unsigned char>::_grow_capacity
PUBLIC	?resize@?$ImVector@E@@QEAAXH@Z			; ImVector<unsigned char>::resize
PUBLIC	?reserve@?$ImVector@E@@QEAAXH@Z			; ImVector<unsigned char>::reserve
PUBLIC	??0?$ImVector@UImGuiTabBar@@@@QEAA@XZ		; ImVector<ImGuiTabBar>::ImVector<ImGuiTabBar>
PUBLIC	??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ		; ImVector<ImGuiTabBar>::~ImVector<ImGuiTabBar>
PUBLIC	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ	; ImVector<ImGuiTabBar>::clear
PUBLIC	??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ		; ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>
PUBLIC	??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ		; ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>
PUBLIC	?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z ; ImPool<ImGuiTabBar>::GetByIndex
PUBLIC	?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ		; ImPool<ImGuiTabBar>::Clear
PUBLIC	??0?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ	; ImVector<ImGuiTabBarSortItem>::ImVector<ImGuiTabBarSortItem>
PUBLIC	??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ	; ImVector<ImGuiTabBarSortItem>::~ImVector<ImGuiTabBarSortItem>
PUBLIC	??0?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ	; ImVector<ImGuiTabBar *>::ImVector<ImGuiTabBar *>
PUBLIC	??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ	; ImVector<ImGuiTabBar *>::~ImVector<ImGuiTabBar *>
PUBLIC	??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z	; ImGuiContext::ImGuiContext
PUBLIC	??1ImGuiContext@@QEAA@XZ			; ImGuiContext::~ImGuiContext
PUBLIC	??_GImGuiContext@@QEAAPEAXI@Z			; ImGuiContext::`scalar deleting destructor'
PUBLIC	??0?$ImVector@UImGuiGroupData@@@@QEAA@XZ	; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
PUBLIC	??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ	; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
PUBLIC	?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z ; ImVector<ImGuiGroupData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z	; ImVector<ImGuiGroupData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z	; ImVector<ImGuiGroupData>::reserve
PUBLIC	?pop_back@?$ImVector@UImGuiGroupData@@@@QEAAXXZ	; ImVector<ImGuiGroupData>::pop_back
PUBLIC	??0ImGuiWindowTempData@@QEAA@XZ			; ImGuiWindowTempData::ImGuiWindowTempData
PUBLIC	??1ImGuiWindowTempData@@QEAA@XZ			; ImGuiWindowTempData::~ImGuiWindowTempData
PUBLIC	??0?$ImVector@I@@QEAA@XZ			; ImVector<unsigned int>::ImVector<unsigned int>
PUBLIC	??1?$ImVector@I@@QEAA@XZ			; ImVector<unsigned int>::~ImVector<unsigned int>
PUBLIC	?back@?$ImVector@I@@QEAAAEAIXZ			; ImVector<unsigned int>::back
PUBLIC	?_grow_capacity@?$ImVector@I@@QEBAHH@Z		; ImVector<unsigned int>::_grow_capacity
PUBLIC	?resize@?$ImVector@I@@QEAAXH@Z			; ImVector<unsigned int>::resize
PUBLIC	?reserve@?$ImVector@I@@QEAAXH@Z			; ImVector<unsigned int>::reserve
PUBLIC	?push_back@?$ImVector@I@@QEAAXAEBI@Z		; ImVector<unsigned int>::push_back
PUBLIC	?pop_back@?$ImVector@I@@QEAAXXZ			; ImVector<unsigned int>::pop_back
PUBLIC	??0?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ	; ImVector<ImGuiColumnsSet>::ImVector<ImGuiColumnsSet>
PUBLIC	??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ	; ImVector<ImGuiColumnsSet>::~ImVector<ImGuiColumnsSet>
PUBLIC	??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z ; ImVector<ImGuiColumnsSet>::operator[]
PUBLIC	?back@?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@XZ ; ImVector<ImGuiColumnsSet>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z ; ImVector<ImGuiColumnsSet>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z ; ImVector<ImGuiColumnsSet>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z ; ImVector<ImGuiColumnsSet>::push_back
PUBLIC	??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z	; ImGuiWindow::ImGuiWindow
PUBLIC	??1ImGuiWindow@@QEAA@XZ				; ImGuiWindow::~ImGuiWindow
PUBLIC	?GetID@ImGuiWindow@@QEAAIPEBD0@Z		; ImGuiWindow::GetID
PUBLIC	?GetID@ImGuiWindow@@QEAAIPEBX@Z			; ImGuiWindow::GetID
PUBLIC	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetIDNoKeepAlive
PUBLIC	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z	; ImGuiWindow::GetIDNoKeepAlive
PUBLIC	?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z ; ImGuiWindow::GetIDFromRectangle
PUBLIC	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ		; ImGuiWindow::Rect
PUBLIC	?CalcFontSize@ImGuiWindow@@QEBAMXZ		; ImGuiWindow::CalcFontSize
PUBLIC	?TitleBarHeight@ImGuiWindow@@QEBAMXZ		; ImGuiWindow::TitleBarHeight
PUBLIC	?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::TitleBarRect
PUBLIC	?MenuBarHeight@ImGuiWindow@@QEBAMXZ		; ImGuiWindow::MenuBarHeight
PUBLIC	?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::MenuBarRect
PUBLIC	??_GImGuiWindow@@QEAAPEAXI@Z			; ImGuiWindow::`scalar deleting destructor'
PUBLIC	??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
PUBLIC	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
PUBLIC	??1ImGuiTabBar@@QEAA@XZ				; ImGuiTabBar::~ImGuiTabBar
PUBLIC	??_GImGuiTabBar@@QEAAPEAXI@Z			; ImGuiTabBar::`scalar deleting destructor'
PUBLIC	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
PUBLIC	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ	; ImGui::GetCurrentWindow
PUBLIC	?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z	; ImGui::FindWindowByID
PUBLIC	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
PUBLIC	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z	; ImGui::FocusWindow
PUBLIC	?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusPreviousWindowIgnoringOne
PUBLIC	?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::BringWindowToFocusFront
PUBLIC	?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::BringWindowToDisplayFront
PUBLIC	?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::BringWindowToDisplayBack
PUBLIC	?UpdateWindowParentAndRootLinks@ImGui@@YAXPEAUImGuiWindow@@H0@Z ; ImGui::UpdateWindowParentAndRootLinks
PUBLIC	?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::CalcWindowExpectedSize
PUBLIC	?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z ; ImGui::IsWindowChildOf
PUBLIC	?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z ; ImGui::IsWindowNavFocusable
PUBLIC	?SetWindowScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollX
PUBLIC	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
PUBLIC	?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxX
PUBLIC	?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxY
PUBLIC	?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z ; ImGui::GetWindowAllowedExtentRect
PUBLIC	?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowPos
PUBLIC	?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowSize
PUBLIC	?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z ; ImGui::SetWindowCollapsed
PUBLIC	?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z	; ImGui::SetCurrentFont
PUBLIC	?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ		; ImGui::GetDefaultFont
PUBLIC	?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z	; ImGui::Initialize
PUBLIC	?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z	; ImGui::Shutdown
PUBLIC	?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ ; ImGui::UpdateHoveredWindowAndCaptureFlags
PUBLIC	?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::StartMouseMovingWindow
PUBLIC	?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ	; ImGui::UpdateMouseMovingWindowNewFrame
PUBLIC	?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ	; ImGui::UpdateMouseMovingWindowEndFrame
PUBLIC	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z	; ImGui::SetActiveID
PUBLIC	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z	; ImGui::SetFocusID
PUBLIC	?ClearActiveID@ImGui@@YAXXZ			; ImGui::ClearActiveID
PUBLIC	?GetHoveredID@ImGui@@YAIXZ			; ImGui::GetHoveredID
PUBLIC	?SetHoveredID@ImGui@@YAXI@Z			; ImGui::SetHoveredID
PUBLIC	?KeepAliveID@ImGui@@YAXI@Z			; ImGui::KeepAliveID
PUBLIC	?MarkItemEdited@ImGui@@YAXI@Z			; ImGui::MarkItemEdited
PUBLIC	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z		; ImGui::ItemSize
PUBLIC	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z		; ImGui::ItemSize
PUBLIC	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z	; ImGui::ItemAdd
PUBLIC	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z	; ImGui::ItemHoverable
PUBLIC	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z	; ImGui::IsClippedEx
PUBLIC	?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
PUBLIC	?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister
PUBLIC	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z	; ImGui::CalcItemSize
PUBLIC	?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z	; ImGui::CalcWrapWidthForPos
PUBLIC	?PushMultiItemsWidths@ImGui@@YAXHM@Z		; ImGui::PushMultiItemsWidths
PUBLIC	?PushItemFlag@ImGui@@YAXH_N@Z			; ImGui::PushItemFlag
PUBLIC	?PopItemFlag@ImGui@@YAXXZ			; ImGui::PopItemFlag
PUBLIC	?OpenPopupEx@ImGui@@YAXI@Z			; ImGui::OpenPopupEx
PUBLIC	?ClosePopupToLevel@ImGui@@YAXH_N@Z		; ImGui::ClosePopupToLevel
PUBLIC	?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::ClosePopupsOverWindow
PUBLIC	?IsPopupOpen@ImGui@@YA_NI@Z			; ImGui::IsPopupOpen
PUBLIC	?BeginPopupEx@ImGui@@YA_NIH@Z			; ImGui::BeginPopupEx
PUBLIC	?BeginTooltipEx@ImGui@@YAXH_N@Z			; ImGui::BeginTooltipEx
PUBLIC	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
PUBLIC	?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::FindBestWindowPosForPopup
PUBLIC	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
PUBLIC	?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z	; ImGui::NavInitWindow
PUBLIC	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ	; ImGui::NavMoveRequestButNoResultYet
PUBLIC	?NavMoveRequestCancel@ImGui@@YAXXZ		; ImGui::NavMoveRequestCancel
PUBLIC	?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z ; ImGui::NavMoveRequestForward
PUBLIC	?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::NavMoveRequestTryWrapping
PUBLIC	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
PUBLIC	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
PUBLIC	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
PUBLIC	?ActivateItem@ImGui@@YAXI@Z			; ImGui::ActivateItem
PUBLIC	?SetNavID@ImGui@@YAXIH@Z			; ImGui::SetNavID
PUBLIC	?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z	; ImGui::SetNavIDWithRectRel
PUBLIC	?IsKeyPressedMap@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressedMap
PUBLIC	?IsNavInputDown@ImGui@@YA_NH@Z			; ImGui::IsNavInputDown
PUBLIC	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
PUBLIC	?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressedAnyOfTwo
PUBLIC	?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::BeginDragDropTargetCustom
PUBLIC	?ClearDragDrop@ImGui@@YAXXZ			; ImGui::ClearDragDrop
PUBLIC	?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ	; ImGui::IsDragDropPayloadBeingAccepted
PUBLIC	?BeginColumns@ImGui@@YAXPEBDHH@Z		; ImGui::BeginColumns
PUBLIC	?EndColumns@ImGui@@YAXXZ			; ImGui::EndColumns
PUBLIC	?PushColumnClipRect@ImGui@@YAXH@Z		; ImGui::PushColumnClipRect
PUBLIC	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z	; ImGui::RenderText
PUBLIC	?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z	; ImGui::RenderTextWrapped
PUBLIC	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
PUBLIC	?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z ; ImGui::RenderTextClippedEx
PUBLIC	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z		; ImGui::RenderFrame
PUBLIC	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z	; ImGui::RenderFrameBorder
PUBLIC	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z		; ImGui::RenderArrow
PUBLIC	?RenderBullet@ImGui@@YAXUImVec2@@@Z		; ImGui::RenderBullet
PUBLIC	?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z	; ImGui::RenderCheckMark
PUBLIC	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z	; ImGui::RenderNavHighlight
PUBLIC	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z	; ImGui::FindRenderedTextEnd
PUBLIC	??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z ; IM_DELETE<ImGuiContext>
PUBLIC	??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z ; IM_DELETE<ImFontAtlas>
PUBLIC	??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z ; IM_DELETE<ImGuiWindow>
PUBLIC	?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z ; ImGuiStyleVarInfo::GetVarPtr
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_07JLDOGPMM@?$CD?$CD?$CL?9oly@		; `string'
PUBLIC	??_C@_05EJCOBEBF@?$CDMOVE@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_07MCAEODGB@Default@			; `string'
PUBLIC	??_C@_03KHICJKCI@?4?4?4@			; `string'
PUBLIC	??_C@_0N@CCJDMNMD@?$CFlld?9?$CFs?$CL?$CF08X@	; `string'
PUBLIC	??_C@_09ONMJNNOG@?$CFlld?9?$CF08X@		; `string'
PUBLIC	??_C@_07HDHBJEOI@?$CDRESIZE@			; `string'
PUBLIC	??_C@_09BJOGEADB@?$CDCOLLAPSE@			; `string'
PUBLIC	??_C@_06KIIKKNMI@?$CDCLOSE@			; `string'
PUBLIC	??_C@_04OJAHODMC@Text@				; `string'
PUBLIC	??_C@_0N@LNHHFNPK@TextDisabled@			; `string'
PUBLIC	??_C@_08DMKFNKPN@WindowBg@			; `string'
PUBLIC	??_C@_07BLEJOHFO@ChildBg@			; `string'
PUBLIC	??_C@_07LKIIIJHA@PopupBg@			; `string'
PUBLIC	??_C@_06CMOGDIBK@Border@			; `string'
PUBLIC	??_C@_0N@DECGFAEC@BorderShadow@			; `string'
PUBLIC	??_C@_07PJIIOGAC@FrameBg@			; `string'
PUBLIC	??_C@_0P@KIOOHHAC@FrameBgHovered@		; `string'
PUBLIC	??_C@_0O@BGDCDDEA@FrameBgActive@		; `string'
PUBLIC	??_C@_07MMLEKCPI@TitleBg@			; `string'
PUBLIC	??_C@_0O@JHBFJHNE@TitleBgActive@		; `string'
PUBLIC	??_C@_0BB@EGCOMBJG@TitleBgCollapsed@		; `string'
PUBLIC	??_C@_09GEKCKLDE@MenuBarBg@			; `string'
PUBLIC	??_C@_0M@MFDHPFJF@ScrollbarBg@			; `string'
PUBLIC	??_C@_0O@HABIDNBE@ScrollbarGrab@		; `string'
PUBLIC	??_C@_0BF@JFEOOMLL@ScrollbarGrabHovered@	; `string'
PUBLIC	??_C@_0BE@GODMFNCF@ScrollbarGrabActive@		; `string'
PUBLIC	??_C@_09DMKAANGE@CheckMark@			; `string'
PUBLIC	??_C@_0L@LAMBADIC@SliderGrab@			; `string'
PUBLIC	??_C@_0BB@HBOBMOMP@SliderGrabActive@		; `string'
PUBLIC	??_C@_06LKBCGDFD@Button@			; `string'
PUBLIC	??_C@_0O@HBCGNIAI@ButtonHovered@		; `string'
PUBLIC	??_C@_0N@IMHOFKJ@ButtonActive@			; `string'
PUBLIC	??_C@_06OENKJGA@Header@				; `string'
PUBLIC	??_C@_0O@HAINNLMC@HeaderHovered@		; `string'
PUBLIC	??_C@_0N@HILFCJOI@HeaderActive@			; `string'
PUBLIC	??_C@_09IBFEOKHN@Separator@			; `string'
PUBLIC	??_C@_0BB@CHICANJA@SeparatorHovered@		; `string'
PUBLIC	??_C@_0BA@BPNGFOJM@SeparatorActive@		; `string'
PUBLIC	??_C@_0L@NGBDNFNJ@ResizeGrip@			; `string'
PUBLIC	??_C@_0BC@NNEDPMNH@ResizeGripHovered@		; `string'
PUBLIC	??_C@_0BB@NBBKHKIC@ResizeGripActive@		; `string'
PUBLIC	??_C@_03IEAKBACE@Tab@				; `string'
PUBLIC	??_C@_0L@JFDLBKBD@TabHovered@			; `string'
PUBLIC	??_C@_09BLMKPFCF@TabActive@			; `string'
PUBLIC	??_C@_0N@KLEENDFP@TabUnfocused@			; `string'
PUBLIC	??_C@_0BD@JMEALEPP@TabUnfocusedActive@		; `string'
PUBLIC	??_C@_09HDJFFJLL@PlotLines@			; `string'
PUBLIC	??_C@_0BB@OMALNJLN@PlotLinesHovered@		; `string'
PUBLIC	??_C@_0O@EEKOCENA@PlotHistogram@		; `string'
PUBLIC	??_C@_0BF@GJALJGDC@PlotHistogramHovered@	; `string'
PUBLIC	??_C@_0P@IBBLAEBJ@TextSelectedBg@		; `string'
PUBLIC	??_C@_0P@GDDMCLOI@DragDropTarget@		; `string'
PUBLIC	??_C@_0N@ENCIHEPH@NavHighlight@			; `string'
PUBLIC	??_C@_0BG@MCGDEFOI@NavWindowingHighlight@	; `string'
PUBLIC	??_C@_0BC@JHKONDGH@NavWindowingDimBg@		; `string'
PUBLIC	??_C@_0BB@JOEAHKNC@ModalWindowDimBg@		; `string'
PUBLIC	??_C@_0BB@PMCDEDKJ@?$CD?$CD?$CL?9Tooip?$CL?9_?$CF02d@ ; `string'
PUBLIC	??_C@_0BD@IMJHKMJC@?$CD?$CD?$CL?9M?4e?4n?4u_?$CL?9?$CF02d@ ; `string'
PUBLIC	??_C@_0BF@DKJDPJG@?$CD?$CD?$CL?9P?4o?4p?4u?4p_?$CL?9?$CF08x@ ; `string'
PUBLIC	??_C@_0P@DCJGJLLM@window_context@		; `string'
PUBLIC	??_C@_0N@OOFNFKBH@void_context@			; `string'
PUBLIC	??_C@_07HIFEPIJN@columns@			; `string'
PUBLIC	??_C@_0O@KMAIKFAM@?$CDSourceExtern@		; `string'
PUBLIC	??_C@_0CH@BMBAOAAJ@?$CFs?3?5?8?$CFlld?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5@ ; `string'
PUBLIC	??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING@	; `string'
PUBLIC	??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp@ ; `string'
PUBLIC	??_C@_07KNEBDGNE@indexed@			; `string'
PUBLIC	??_C@_0M@NGJKDAN@non?9indexed@			; `string'
PUBLIC	??_C@_0EB@BKFKDBKJ@Draw?5?$CF4d?5?$CFs?5vtx?0?5tex?50x?$CFp?0?5clip@ ; `string'
PUBLIC	??_C@_03DAKNAIGI@idx@				; `string'
PUBLIC	??_C@_03NDEAONJP@?5?5?5@			; `string'
PUBLIC	??_C@_0DG@MPIFBGBG@?$CFs?5?$CF04d?3?5pos?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5uv?5@ ; `string'
PUBLIC	??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ@		; `string'
PUBLIC	??_C@_06BKKJGDHO@Window@			; `string'
PUBLIC	??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp@ ; `string'
PUBLIC	??_C@_08IJNCDCKF@DrawList@			; `string'
PUBLIC	??_C@_0DO@PMCJMPLH@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5Size?3?5?$CI?$CF?41f?0?$CF@ ; `string'
PUBLIC	??_C@_0BB@GGEIPOID@AlwaysAutoResize@		; `string'
PUBLIC	??_C@_0M@COLEABDL@NoNavInputs@			; `string'
PUBLIC	??_C@_0O@LAPEOEIJ@NoMouseInputs@		; `string'
PUBLIC	??_C@_0BB@EBNDPMCP@NoSavedSettings?5@		; `string'
PUBLIC	??_C@_0L@OPMMHACC@ChildMenu?5@			; `string'
PUBLIC	??_C@_06IFIMNOLK@Modal?5@			; `string'
PUBLIC	??_C@_06NMKCIICK@Popup?5@			; `string'
PUBLIC	??_C@_08LGECAIGF@Tooltip?5@			; `string'
PUBLIC	??_C@_06MMFPNIIL@Child?5@			; `string'
PUBLIC	??_C@_0CF@HFFEAFCN@Flags?3?50x?$CF08X?5?$CI?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs@ ; `string'
PUBLIC	??_C@_0BO@JAHLHNNL@Scroll?3?5?$CI?$CF?42f?1?$CF?42f?0?$CF?42f?1?$CF?42f?$CJ@ ; `string'
PUBLIC	??_C@_0DO@LPCMGHLI@Active?3?5?$CFd?1?$CFd?0?5WriteAccessed?3?5?$CF@ ; `string'
PUBLIC	??_C@_0DM@DJJIBEFM@Appearing?3?5?$CFd?0?5Hidden?3?5?$CFd?5?$CIReg?5@ ; `string'
PUBLIC	??_C@_0DC@CFCLKJDH@NavLastIds?3?50x?$CF08X?00x?$CF08X?0?5NavL@ ; `string'
PUBLIC	??_C@_0BM@NPFIBFIA@NavLastChildNavWindow?3?5?$CFlld@ ; `string'
PUBLIC	??_C@_0CG@HFMDFCIJ@NavRectRel?$FL0?$FN?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$CI?$CF?41f@ ; `string'
PUBLIC	??_C@_0BG@KHCECGOM@NavRectRel?$FL0?$FN?3?5?$DMNone?$DO@ ; `string'
PUBLIC	??_C@_0L@EHLMOHOL@RootWindow@			; `string'
PUBLIC	??_C@_0N@BPPHAMMO@ParentWindow@			; `string'
PUBLIC	??_C@_0N@BGDHDNPO@ChildWindows@			; `string'
PUBLIC	??_C@_0BC@FIDDFLAI@Columns?5sets?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_07IBCCJKML@Columns@			; `string'
PUBLIC	??_C@_0CN@LMOAIACO@Columns?5Id?3?50x?$CF08X?0?5Count?3?5?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0CF@PKFCLBKA@Width?3?5?$CF?41f?5?$CIMinX?3?5?$CF?41f?0?5MaxX?3?5@ ; `string'
PUBLIC	??_C@_0CJ@CPAFBJNN@Column?5?$CF02d?3?5OffsetNorm?5?$CF?43f?5?$CI?$DN@ ; `string'
PUBLIC	??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes@	; `string'
PUBLIC	??_C@_0M@MDILNFHC@?5?$CKInactive?$CK@		; `string'
PUBLIC	??_C@_0BD@HNMBCOGC@TabBar?5?$CI?$CFd?5tabs?$CJ?$CFs@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_0BC@NHDMGCPM@?$CF02d?$CFc?5Tab?50x?$CF08X@ ; `string'
PUBLIC	??_C@_0O@JMODJGLN@ImGui?5Metrics@		; `string'
PUBLIC	??_C@_0O@NCHBJMJF@Dear?5ImGui?5?$CFs@		; `string'
PUBLIC	??_C@_0CN@EIPBEGMP@Application?5average?5?$CF?43f?5ms?1fra@ ; `string'
PUBLIC	??_C@_0CH@HHKODNBE@?$CFd?5vertices?0?5?$CFd?5indices?5?$CI?$CFd?5tri@ ; `string'
PUBLIC	??_C@_0BP@OPGGNCEP@?$CFd?5active?5windows?5?$CI?$CFd?5visible?$CJ@ ; `string'
PUBLIC	??_C@_0P@EGHDCIHB@?$CFd?5allocations@		; `string'
PUBLIC	??_C@_0DF@PLCAEOIM@Show?5clipping?5rectangles?5when?5h@ ; `string'
PUBLIC	??_C@_0BO@BAAKGIGK@Ctrl?5shows?5window?5begin?5order@ ; `string'
PUBLIC	??_C@_07LDLFNPGN@Windows@			; `string'
PUBLIC	??_C@_0BG@JOELHCIA@Active?5DrawLists?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0M@CMLJJLKO@Popups?5?$CI?$CFd?$CJ@	; `string'
PUBLIC	??_C@_06ENDEIGLN@Popups@			; `string'
PUBLIC	??_C@_0L@CMJPHOMG@?5ChildMenu@			; `string'
PUBLIC	??_C@_0N@FFCBFAEB@?5ChildWindow@		; `string'
PUBLIC	??_C@_0CC@KHIGFAF@PopupID?3?5?$CF08x?0?5Window?3?5?8?$CFlld?8?$CFs@ ; `string'
PUBLIC	??_C@_0O@JLIGAOM@Tab?5Bars?5?$CI?$CFd?$CJ@	; `string'
PUBLIC	??_C@_07NBICDJOO@TabBars@			; `string'
PUBLIC	??_C@_0P@DKNCHHLP@Internal?5state@		; `string'
PUBLIC	??_C@_04OHJIHAFH@None@				; `string'
PUBLIC	??_C@_05PEEFLODH@Mouse@				; `string'
PUBLIC	??_C@_03JFAAHAIK@Nav@				; `string'
PUBLIC	??_C@_0M@BGJILJC@NavKeyboard@			; `string'
PUBLIC	??_C@_0L@GFEAGONP@NavGamepad@			; `string'
PUBLIC	??_C@_0BG@CLFHKGNJ@HoveredWindow?3?5?8?$CFlld?8@ ; `string'
PUBLIC	??_C@_0BK@PENLHICC@HoveredRootWindow?3?5?8?$CFlld?8@ ; `string'
PUBLIC	??_C@_0DG@FAAGHPBL@HoveredId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5@ ; `string'
PUBLIC	??_C@_0EB@PEJDHKLE@ActiveId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5s@ ; `string'
PUBLIC	??_C@_0BH@CKLACKBD@ActiveIdWindow?3?5?8?$CFlld?8@ ; `string'
PUBLIC	??_C@_0BF@CFCDIHDM@MovingWindow?3?5?8?$CFlld?8@	; `string'
PUBLIC	??_C@_0BC@NLCAEKMP@NavWindow?3?5?8?$CFlld?8@	; `string'
PUBLIC	??_C@_0BM@KFFINKHC@NavId?3?50x?$CF08X?0?5NavLayer?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BD@HIKDFBG@NavInputSource?3?5?$CFs@	; `string'
PUBLIC	??_C@_0BO@PADIALFI@NavActive?3?5?$CFd?0?5NavVisible?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CK@FMBJOEO@NavActivateId?3?50x?$CF08X?0?5NavInput@ ; `string'
PUBLIC	??_C@_0DC@PBLGJJAI@NavDisableHighlight?3?5?$CFd?0?5NavDis@ ; `string'
PUBLIC	??_C@_0BL@MDEMGJOE@NavWindowingTarget?3?5?8?$CFlld?8@ ; `string'
PUBLIC	??_C@_0DJ@OPOHHHAC@DragDrop?3?5?$CFd?0?5SourceId?5?$DN?50x?$CF08X@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	__real@00000000
PUBLIC	__real@1e3ce508
PUBLIC	__real@3727c5ac
PUBLIC	__real@38d1b717
PUBLIC	__real@3b808081
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c888889
PUBLIC	__real@3d23d70a
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e2aaaab
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f266666
PUBLIC	__real@3f2b851f
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f490fdb
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f5db22d
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3fa00000
PUBLIC	__real@3faccccd
PUBLIC	__real@3fc90fdb
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40600000
PUBLIC	__real@40800000
PUBLIC	__real@4096cbe4
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41980000
PUBLIC	__real@41a80000
PUBLIC	__real@41c00000
PUBLIC	__real@42000000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@437f0000
PUBLIC	__real@43c80000
PUBLIC	__real@44160000
PUBLIC	__real@44480000
PUBLIC	__real@447a0000
PUBLIC	__real@461c3c00
PUBLIC	__real@7f7fffff
PUBLIC	__real@beaaaaab
PUBLIC	__real@bf400000
PUBLIC	__real@bf5db22d
PUBLIC	__real@bf800000
PUBLIC	__real@c7efffffe0000000
PUBLIC	__real@c87a0000
PUBLIC	__real@ff7fffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YAXPEAX_K1P6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_Init_thread_header:PROC
EXTRN	_Init_thread_abort:PROC
EXTRN	_Init_thread_footer:PROC
EXTRN	_wfopen:PROC
EXTRN	fclose:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	memchr:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	strncpy:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	fabs:PROC
EXTRN	fmodf:PROC
EXTRN	qsort:PROC
EXTRN	toupper:PROC
EXTRN	__imp_GlobalAlloc:PROC
EXTRN	__imp_GlobalUnlock:PROC
EXTRN	__imp_GlobalLock:PROC
EXTRN	__imp_GlobalFree:PROC
EXTRN	__imp_OpenClipboard:PROC
EXTRN	__imp_CloseClipboard:PROC
EXTRN	__imp_SetClipboardData:PROC
EXTRN	__imp_GetClipboardData:PROC
EXTRN	__imp_EmptyClipboard:PROC
EXTRN	ImmGetContext:PROC
EXTRN	ImmReleaseContext:PROC
EXTRN	ImmSetCompositionWindow:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z:PROC ; ImGui::StyleColorsDark
EXTRN	?Separator@ImGui@@YAXXZ:PROC			; ImGui::Separator
EXTRN	?Text@ImGui@@YAXPEBDZZ:PROC			; ImGui::Text
EXTRN	?TextV@ImGui@@YAXPEBDPEAD@Z:PROC		; ImGui::TextV
EXTRN	?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ:PROC	; ImGui::TextColored
EXTRN	?BulletText@ImGui@@YAXPEBDZZ:PROC		; ImGui::BulletText
EXTRN	?SmallButton@ImGui@@YA_NPEBD@Z:PROC		; ImGui::SmallButton
EXTRN	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z:PROC		; ImGui::Checkbox
EXTRN	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z:PROC ; ImGui::InputText
EXTRN	?TreeNode@ImGui@@YA_NPEBD@Z:PROC		; ImGui::TreeNode
EXTRN	?TreeNode@ImGui@@YA_NPEBD0ZZ:PROC		; ImGui::TreeNode
EXTRN	?TreeNode@ImGui@@YA_NPEBXPEBDZZ:PROC		; ImGui::TreeNode
EXTRN	?TreePop@ImGui@@YAXXZ:PROC			; ImGui::TreePop
EXTRN	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z:PROC ; ImGui::Selectable
EXTRN	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z:PROC ; ImDrawList::PushClipRect
EXTRN	?PushClipRectFullScreen@ImDrawList@@QEAAXXZ:PROC ; ImDrawList::PushClipRectFullScreen
EXTRN	?PopClipRect@ImDrawList@@QEAAXXZ:PROC		; ImDrawList::PopClipRect
EXTRN	?PushTextureID@ImDrawList@@QEAAXPEAX@Z:PROC	; ImDrawList::PushTextureID
EXTRN	?PopTextureID@ImDrawList@@QEAAXXZ:PROC		; ImDrawList::PopTextureID
EXTRN	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z:PROC ; ImDrawList::AddLine
EXTRN	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z:PROC ; ImDrawList::AddRect
EXTRN	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z:PROC ; ImDrawList::AddRectFilled
EXTRN	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z:PROC ; ImDrawList::AddTriangleFilled
EXTRN	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z:PROC ; ImDrawList::AddCircleFilled
EXTRN	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z:PROC ; ImDrawList::AddText
EXTRN	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z:PROC ; ImDrawList::AddPolyline
EXTRN	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z:PROC ; ImDrawList::AddConvexPolyFilled
EXTRN	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z:PROC ; ImDrawList::PathArcTo
EXTRN	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z:PROC ; ImDrawList::PathArcToFast
EXTRN	?ChannelsSplit@ImDrawList@@QEAAXH@Z:PROC	; ImDrawList::ChannelsSplit
EXTRN	?ChannelsMerge@ImDrawList@@QEAAXXZ:PROC		; ImDrawList::ChannelsMerge
EXTRN	?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z:PROC	; ImDrawList::ChannelsSetCurrent
EXTRN	?Clear@ImDrawList@@QEAAXXZ:PROC			; ImDrawList::Clear
EXTRN	?ClearFreeMemory@ImDrawList@@QEAAXXZ:PROC	; ImDrawList::ClearFreeMemory
EXTRN	??0ImFontAtlas@@QEAA@XZ:PROC			; ImFontAtlas::ImFontAtlas
EXTRN	??1ImFontAtlas@@QEAA@XZ:PROC			; ImFontAtlas::~ImFontAtlas
EXTRN	??0ImFont@@QEAA@XZ:PROC				; ImFont::ImFont
EXTRN	??1ImFont@@QEAA@XZ:PROC				; ImFont::~ImFont
EXTRN	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z:PROC ; ImFont::CalcTextSizeA
EXTRN	??0ImGuiMenuColumns@@QEAA@XZ:PROC		; ImGuiMenuColumns::ImGuiMenuColumns
EXTRN	?Update@ImGuiMenuColumns@@QEAAXHM_N@Z:PROC	; ImGuiMenuColumns::Update
EXTRN	??0ImDrawListSharedData@@QEAA@XZ:PROC		; ImDrawListSharedData::ImDrawListSharedData
EXTRN	?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z:PROC ; ImGui::TabBarQueueChangeTabOrder
EXTRN	?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z:PROC ; ImGui::RenderMouseCursor
EXTRN	?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z:PROC	; ImGui::CloseButton
EXTRN	?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z:PROC	; ImGui::CollapseButton
EXTRN	?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z:PROC	; ImGui::Scrollbar
EXTRN	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z:PROC ; ImGui::ButtonBehavior
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_Init_thread_epoch:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
	ALIGN	8

?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?GImAllocatorUserData@@3PEAXEA DQ 01H DUP (?)		; GImAllocatorUserData
?resize_grip_def@@3QBUImGuiResizeGripDef@@B DB 060H DUP (?) ; resize_grip_def
_BSS	ENDS
;	COMDAT ?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B
_BSS	SEGMENT
?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B DB 070H DUP (?) ; `ImGui::RenderOuterBorders'::`7'::resize_border_def
_BSS	ENDS
;	COMDAT ?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA DD 01H DUP (?) ; `ImGui::RenderOuterBorders'::`7'::$TSS0
_BSS	ENDS
;	COMDAT ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A
_BSS	SEGMENT
?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A DB 010H DUP (?) ; `GetClipboardTextFn_DefaultImpl'::`2'::buf_local
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA DD 01H DUP (?) ; `GetClipboardTextFn_DefaultImpl'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?show_window_begin_order@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA
_BSS	SEGMENT
?show_window_begin_order@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowMetricsWindow'::`2'::show_window_begin_order
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$_vsnprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fabsf DD	imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fabsf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hash_@@YA?B_KPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$?hash_@@YA?B_KPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z DD imagerel $LN7
	DD	imagerel $LN7+162
	DD	imagerel $unwind$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA+35
	DD	imagerel $unwind$?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z
$pdata$?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K1111@Z DD imagerel $LN11
	DD	imagerel $LN11+163
	DD	imagerel $unwind$?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K1111@Z
$pdata$?NewFrame@ImGui@@YAXXZ DD imagerel $LN44
	DD	imagerel $LN44+2622
	DD	imagerel $unwind$?NewFrame@ImGui@@YAXXZ
$pdata$?EndFrame@ImGui@@YAXXZ DD imagerel $LN24
	DD	imagerel $LN24+974
	DD	imagerel $unwind$?EndFrame@ImGui@@YAXXZ
$pdata$?Render@ImGui@@YAXXZ DD imagerel $LN19
	DD	imagerel $LN19+854
	DD	imagerel $unwind$?Render@ImGui@@YAXXZ
$pdata$?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ DD imagerel $LN5
	DD	imagerel $LN5+66
	DD	imagerel $unwind$?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ
$pdata$?ShowMetricsWindow@ImGui@@YAXPEA_N@Z DD imagerel $LN41
	DD	imagerel $LN41+2466
	DD	imagerel $unwind$?ShowMetricsWindow@ImGui@@YAXPEA_N@Z
$pdata$?Begin@ImGui@@YA_NPEBDPEA_NH@Z DD imagerel $LN251
	DD	imagerel $LN251+16053
	DD	imagerel $unwind$?Begin@ImGui@@YA_NPEBDPEA_NH@Z
$pdata$?End@ImGui@@YAXXZ DD imagerel $LN8
	DD	imagerel $LN8+239
	DD	imagerel $unwind$?End@ImGui@@YAXXZ
$pdata$?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z
$pdata$?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z
$pdata$?EndChild@ImGui@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+596
	DD	imagerel $unwind$?EndChild@ImGui@@YAXXZ
$pdata$?IsWindowAppearing@ImGui@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?IsWindowAppearing@ImGui@@YA_NXZ
$pdata$?IsWindowCollapsed@ImGui@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?IsWindowCollapsed@ImGui@@YA_NXZ
$pdata$?IsWindowFocused@ImGui@@YA_NH@Z DD imagerel $LN20
	DD	imagerel $LN20+386
	DD	imagerel $unwind$?IsWindowFocused@ImGui@@YA_NH@Z
$pdata$?IsWindowHovered@ImGui@@YA_NH@Z DD imagerel $LN20
	DD	imagerel $LN20+384
	DD	imagerel $unwind$?IsWindowHovered@ImGui@@YA_NH@Z
$pdata$?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ
$pdata$?GetWindowPos@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?GetWindowPos@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetWindowSize@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?GetWindowSize@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetWindowWidth@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?GetWindowWidth@ImGui@@YAMXZ
$pdata$?GetWindowHeight@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?GetWindowHeight@ImGui@@YAMXZ
$pdata$?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetContentRegionAvailWidth@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$?GetContentRegionAvailWidth@ImGui@@YAMXZ
$pdata$?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetWindowContentRegionWidth@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?GetWindowContentRegionWidth@ImGui@@YAMXZ
$pdata$?GetNextWindowPos@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?GetNextWindowPos@ImGui@@YA?AUImVec2@@XZ
$pdata$?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z
$pdata$?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z
$pdata$?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+136
	DD	imagerel $unwind$?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z
$pdata$?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z
$pdata$?SetNextWindowCollapsed@ImGui@@YAX_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$?SetNextWindowCollapsed@ImGui@@YAX_NH@Z
$pdata$?SetNextWindowFocus@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?SetNextWindowFocus@ImGui@@YAXXZ
$pdata$?SetNextWindowBgAlpha@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?SetNextWindowBgAlpha@ImGui@@YAXM@Z
$pdata$?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z
$pdata$?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z
$pdata$?SetWindowCollapsed@ImGui@@YAX_NH@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?SetWindowCollapsed@ImGui@@YAX_NH@Z
$pdata$?SetWindowFocus@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?SetWindowFocus@ImGui@@YAXXZ
$pdata$?SetWindowFontScale@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?SetWindowFontScale@ImGui@@YAXM@Z
$pdata$?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z
$pdata$?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z
$pdata$?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z
$pdata$?SetWindowFocus@ImGui@@YAXPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+66
	DD	imagerel $unwind$?SetWindowFocus@ImGui@@YAXPEBD@Z
$pdata$?GetScrollMaxX@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?GetScrollMaxX@ImGui@@YAMXZ
$pdata$?GetScrollMaxY@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?GetScrollMaxY@ImGui@@YAMXZ
$pdata$?SetScrollX@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?SetScrollX@ImGui@@YAXM@Z
$pdata$?SetScrollY@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$?SetScrollY@ImGui@@YAXM@Z
$pdata$?SetScrollHereY@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+158
	DD	imagerel $unwind$?SetScrollHereY@ImGui@@YAXM@Z
$pdata$?SetScrollFromPosY@ImGui@@YAXMM@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?SetScrollFromPosY@ImGui@@YAXMM@Z
$pdata$?PushFont@ImGui@@YAXPEAUImFont@@@Z DD imagerel $LN4
	DD	imagerel $LN4+133
	DD	imagerel $unwind$?PushFont@ImGui@@YAXPEAUImFont@@@Z
$pdata$?PopFont@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$?PopFont@ImGui@@YAXXZ
$pdata$?PushStyleColor@ImGui@@YAXHI@Z DD imagerel $LN3
	DD	imagerel $LN3+178
	DD	imagerel $unwind$?PushStyleColor@ImGui@@YAXHI@Z
$pdata$?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z DD imagerel $LN3
	DD	imagerel $LN3+154
	DD	imagerel $unwind$?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z
$pdata$?PopStyleColor@ImGui@@YAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$?PopStyleColor@ImGui@@YAXH@Z
$pdata$?PushStyleVar@ImGui@@YAXHM@Z DD imagerel $LN4
	DD	imagerel $LN4+163
	DD	imagerel $unwind$?PushStyleVar@ImGui@@YAXHM@Z
$pdata$?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z DD imagerel $LN4
	DD	imagerel $LN4+162
	DD	imagerel $unwind$?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z
$pdata$?PopStyleVar@ImGui@@YAXH@Z DD imagerel $LN8
	DD	imagerel $LN8+304
	DD	imagerel $unwind$?PopStyleVar@ImGui@@YAXH@Z
$pdata$?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z
$pdata$?GetColorU32@ImGui@@YAIHM@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?GetColorU32@ImGui@@YAIHM@Z
$pdata$?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z
$pdata$?GetColorU32@ImGui@@YAIQEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+157
	DD	imagerel $unwind$?GetColorU32@ImGui@@YAIQEAM@Z
$pdata$?GetColorU32@ImGui@@YAII@Z DD imagerel $LN4
	DD	imagerel $LN4+109
	DD	imagerel $unwind$?GetColorU32@ImGui@@YAII@Z
$pdata$?PushItemWidth@ImGui@@YAXM@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?PushItemWidth@ImGui@@YAXM@Z
$pdata$?PopItemWidth@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+133
	DD	imagerel $unwind$?PopItemWidth@ImGui@@YAXXZ
$pdata$?CalcItemWidth@ImGui@@YAMXZ DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$?CalcItemWidth@ImGui@@YAMXZ
$pdata$?PushTextWrapPos@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?PushTextWrapPos@ImGui@@YAXM@Z
$pdata$?PopTextWrapPos@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$?PopTextWrapPos@ImGui@@YAXXZ
$pdata$?PushAllowKeyboardFocus@ImGui@@YAX_N@Z DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$?PushAllowKeyboardFocus@ImGui@@YAX_N@Z
$pdata$?PopAllowKeyboardFocus@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$?PopAllowKeyboardFocus@ImGui@@YAXXZ
$pdata$?PushButtonRepeat@ImGui@@YAX_N@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?PushButtonRepeat@ImGui@@YAX_N@Z
$pdata$?PopButtonRepeat@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$?PopButtonRepeat@ImGui@@YAXXZ
$pdata$?SameLine@ImGui@@YAXMMM@Z DD imagerel $LN9
	DD	imagerel $LN9+351
	DD	imagerel $unwind$?SameLine@ImGui@@YAXMMM@Z
$pdata$?Indent@ImGui@@YAXM@Z DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$?Indent@ImGui@@YAXM@Z
$pdata$?Unindent@ImGui@@YAXM@Z DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$?Unindent@ImGui@@YAXM@Z
$pdata$?BeginGroup@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+450
	DD	imagerel $unwind$?BeginGroup@ImGui@@YAXXZ
$pdata$?EndGroup@ImGui@@YAXXZ DD imagerel $LN7
	DD	imagerel $LN7+586
	DD	imagerel $unwind$?EndGroup@ImGui@@YAXXZ
$pdata$?GetCursorPos@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?GetCursorPos@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetCursorPosX@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?GetCursorPosX@ImGui@@YAMXZ
$pdata$?GetCursorPosY@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?GetCursorPosY@ImGui@@YAMXZ
$pdata$?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+145
	DD	imagerel $unwind$?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z
$pdata$?SetCursorPosX@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$?SetCursorPosX@ImGui@@YAXM@Z
$pdata$?SetCursorPosY@ImGui@@YAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$?SetCursorPosY@ImGui@@YAXM@Z
$pdata$?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ
$pdata$?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z
$pdata$?GetTextLineHeight@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?GetTextLineHeight@ImGui@@YAMXZ
$pdata$?GetTextLineHeightWithSpacing@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?GetTextLineHeightWithSpacing@ImGui@@YAMXZ
$pdata$?GetFrameHeight@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?GetFrameHeight@ImGui@@YAMXZ
$pdata$?GetFrameHeightWithSpacing@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?GetFrameHeightWithSpacing@ImGui@@YAMXZ
$pdata$?PushID@ImGui@@YAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?PushID@ImGui@@YAXPEBD@Z
$pdata$?PushID@ImGui@@YAXPEBD0@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?PushID@ImGui@@YAXPEBD0@Z
$pdata$?PushID@ImGui@@YAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?PushID@ImGui@@YAXPEBX@Z
$pdata$?PushID@ImGui@@YAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$?PushID@ImGui@@YAXH@Z
$pdata$?PopID@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?PopID@ImGui@@YAXXZ
$pdata$?GetID@ImGui@@YAIPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?GetID@ImGui@@YAIPEBD@Z
$pdata$?GetID@ImGui@@YAIPEBD0@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?GetID@ImGui@@YAIPEBD0@Z
$pdata$?GetID@ImGui@@YAIPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?GetID@ImGui@@YAIPEBX@Z
$pdata$?BeginTooltip@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+215
	DD	imagerel $unwind$?BeginTooltip@ImGui@@YAXXZ
$pdata$?EndTooltip@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$?EndTooltip@ImGui@@YAXXZ
$pdata$?SetTooltip@ImGui@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?SetTooltip@ImGui@@YAXPEBDZZ
$pdata$?SetTooltipV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$?SetTooltipV@ImGui@@YAXPEBDPEAD@Z
$pdata$?OpenPopup@ImGui@@YAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?OpenPopup@ImGui@@YAXPEBD@Z
$pdata$?BeginPopup@ImGui@@YA_NPEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+134
	DD	imagerel $unwind$?BeginPopup@ImGui@@YA_NPEBDH@Z
$pdata$?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z DD imagerel $LN6
	DD	imagerel $LN6+149
	DD	imagerel $unwind$?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z
$pdata$?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z DD imagerel $LN7
	DD	imagerel $LN7+162
	DD	imagerel $unwind$?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z
$pdata$?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z DD imagerel $LN5
	DD	imagerel $LN5+136
	DD	imagerel $unwind$?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z
$pdata$?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z DD imagerel $LN8
	DD	imagerel $LN8+336
	DD	imagerel $unwind$?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z
$pdata$?EndPopup@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?EndPopup@ImGui@@YAXXZ
$pdata$?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z DD imagerel $LN6
	DD	imagerel $LN6+140
	DD	imagerel $unwind$?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z
$pdata$?IsPopupOpen@ImGui@@YA_NPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+157
	DD	imagerel $unwind$?IsPopupOpen@ImGui@@YA_NPEBD@Z
$pdata$?CloseCurrentPopup@ImGui@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+371
	DD	imagerel $unwind$?CloseCurrentPopup@ImGui@@YAXXZ
$pdata$?Columns@ImGui@@YAXHPEBD_N@Z DD imagerel $LN8
	DD	imagerel $LN8+175
	DD	imagerel $unwind$?Columns@ImGui@@YAXHPEBD_N@Z
$pdata$?NextColumn@ImGui@@YAXXZ DD imagerel $LN7
	DD	imagerel $LN7+497
	DD	imagerel $unwind$?NextColumn@ImGui@@YAXXZ
$pdata$?GetColumnIndex@ImGui@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$?GetColumnIndex@ImGui@@YAHXZ
$pdata$?GetColumnWidth@ImGui@@YAMH@Z DD imagerel $LN4
	DD	imagerel $LN4+150
	DD	imagerel $unwind$?GetColumnWidth@ImGui@@YAMH@Z
$pdata$?SetColumnWidth@ImGui@@YAXHM@Z DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$?SetColumnWidth@ImGui@@YAXHM@Z
$pdata$?GetColumnOffset@ImGui@@YAMH@Z DD imagerel $LN4
	DD	imagerel $LN4+140
	DD	imagerel $unwind$?GetColumnOffset@ImGui@@YAMH@Z
$pdata$?SetColumnOffset@ImGui@@YAXHM@Z DD imagerel $LN10
	DD	imagerel $LN10+424
	DD	imagerel $unwind$?SetColumnOffset@ImGui@@YAXHM@Z
$pdata$?GetColumnsCount@ImGui@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$?GetColumnsCount@ImGui@@YAHXZ
$pdata$?BeginDragDropSource@ImGui@@YA_NH@Z DD imagerel $LN23
	DD	imagerel $LN23+859
	DD	imagerel $unwind$?BeginDragDropSource@ImGui@@YA_NH@Z
$pdata$?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z DD imagerel $LN12
	DD	imagerel $LN12+431
	DD	imagerel $unwind$?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z
$pdata$?EndDragDropSource@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+77
	DD	imagerel $unwind$?EndDragDropSource@ImGui@@YAXXZ
$pdata$?BeginDragDropTarget@ImGui@@YA_NXZ DD imagerel $LN11
	DD	imagerel $LN11+333
	DD	imagerel $unwind$?BeginDragDropTarget@ImGui@@YA_NXZ
$pdata$?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z DD imagerel $LN15
	DD	imagerel $LN15+969
	DD	imagerel $unwind$?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z
$pdata$?EndDragDropTarget@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?EndDragDropTarget@ImGui@@YAXXZ
$pdata$?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ DD imagerel $LN5
	DD	imagerel $LN5+66
	DD	imagerel $unwind$?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ
$pdata$?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z DD imagerel $LN3
	DD	imagerel $LN3+152
	DD	imagerel $unwind$?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z
$pdata$?PopClipRect@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?PopClipRect@ImGui@@YAXXZ
$pdata$?SetItemDefaultFocus@ImGui@@YAXXZ DD imagerel $LN7
	DD	imagerel $LN7+390
	DD	imagerel $unwind$?SetItemDefaultFocus@ImGui@@YAXXZ
$pdata$?SetKeyboardFocusHere@ImGui@@YAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?SetKeyboardFocusHere@ImGui@@YAXH@Z
$pdata$?IsItemHovered@ImGui@@YA_NH@Z DD imagerel $LN11
	DD	imagerel $LN11+343
	DD	imagerel $unwind$?IsItemHovered@ImGui@@YA_NH@Z
$pdata$?IsItemActive@ImGui@@YA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+100
	DD	imagerel $unwind$?IsItemActive@ImGui@@YA_NXZ
$pdata$?IsItemFocused@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$?IsItemFocused@ImGui@@YA_NXZ
$pdata$?IsItemClicked@ImGui@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+68
	DD	imagerel $unwind$?IsItemClicked@ImGui@@YA_NH@Z
$pdata$?IsItemVisible@ImGui@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?IsItemVisible@ImGui@@YA_NXZ
$pdata$?IsItemEdited@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$?IsItemEdited@ImGui@@YA_NXZ
$pdata$?IsItemActivated@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$?IsItemActivated@ImGui@@YA_NXZ
$pdata$?IsItemDeactivated@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$?IsItemDeactivated@ImGui@@YA_NXZ
$pdata$?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ DD imagerel $LN7
	DD	imagerel $LN7+102
	DD	imagerel $unwind$?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ
$pdata$?IsAnyItemHovered@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?IsAnyItemHovered@ImGui@@YA_NXZ
$pdata$?IsAnyItemActive@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?IsAnyItemActive@ImGui@@YA_NXZ
$pdata$?IsAnyItemFocused@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?IsAnyItemFocused@ImGui@@YA_NXZ
$pdata$?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ
$pdata$?SetItemAllowOverlap@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?SetItemAllowOverlap@ImGui@@YAXXZ
$pdata$?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z
$pdata$?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z
$pdata$?GetStyleColorName@ImGui@@YAPEBDH@Z DD imagerel $LN54
	DD	imagerel $LN54+788
	DD	imagerel $unwind$?GetStyleColorName@ImGui@@YAPEBDH@Z
$pdata$?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z
$pdata$?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ
$pdata$?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z DD imagerel $LN6
	DD	imagerel $LN6+305
	DD	imagerel $unwind$?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z
$pdata$?CalcListClipping@ImGui@@YAXHMPEAH0@Z DD imagerel $LN7
	DD	imagerel $LN7+399
	DD	imagerel $unwind$?CalcListClipping@ImGui@@YAXHMPEAH0@Z
$pdata$?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+206
	DD	imagerel $unwind$?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z
$pdata$?EndChildFrame@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$?EndChildFrame@ImGui@@YAXXZ
$pdata$?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z DD imagerel $LN3
	DD	imagerel $LN3+168
	DD	imagerel $unwind$?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z
$pdata$?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z DD imagerel $LN3
	DD	imagerel $LN3+206
	DD	imagerel $unwind$?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z
$pdata$?ColorConvertFloat4ToRGB@ImGui@@YAXAEBUImVec4@@AEAM11@Z DD imagerel $LN3
	DD	imagerel $LN3+178
	DD	imagerel $unwind$?ColorConvertFloat4ToRGB@ImGui@@YAXAEBUImVec4@@AEAM11@Z
$pdata$?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z
$pdata$?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z DD imagerel $LN14
	DD	imagerel $LN14+664
	DD	imagerel $unwind$?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z
$pdata$?IsKeyPressed@ImGui@@YA_NH_N@Z DD imagerel $LN8
	DD	imagerel $LN8+184
	DD	imagerel $unwind$?IsKeyPressed@ImGui@@YA_NH_N@Z
$pdata$?IsKeyReleased@ImGui@@YA_NH@Z DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$?IsKeyReleased@ImGui@@YA_NH@Z
$pdata$?GetKeyPressedAmount@ImGui@@YAHHMM@Z DD imagerel $LN4
	DD	imagerel $LN4+115
	DD	imagerel $unwind$?GetKeyPressedAmount@ImGui@@YAHHMM@Z
$pdata$?IsMouseDown@ImGui@@YA_NH@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?IsMouseDown@ImGui@@YA_NH@Z
$pdata$?IsAnyMouseDown@ImGui@@YA_NXZ DD imagerel $LN7
	DD	imagerel $LN7+73
	DD	imagerel $unwind$?IsAnyMouseDown@ImGui@@YA_NXZ
$pdata$?IsMouseClicked@ImGui@@YA_NH_N@Z DD imagerel $LN10
	DD	imagerel $LN10+299
	DD	imagerel $unwind$?IsMouseClicked@ImGui@@YA_NH_N@Z
$pdata$?IsMouseDoubleClicked@ImGui@@YA_NH@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?IsMouseDoubleClicked@ImGui@@YA_NH@Z
$pdata$?IsMouseReleased@ImGui@@YA_NH@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?IsMouseReleased@ImGui@@YA_NH@Z
$pdata$?IsMouseDragging@ImGui@@YA_NHM@Z DD imagerel $LN7
	DD	imagerel $LN7+142
	DD	imagerel $unwind$?IsMouseDragging@ImGui@@YA_NHM@Z
$pdata$?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z DD imagerel $LN5
	DD	imagerel $LN5+233
	DD	imagerel $unwind$?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z
$pdata$?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z DD imagerel $LN7
	DD	imagerel $LN7+139
	DD	imagerel $unwind$?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z
$pdata$?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ DD imagerel $LN4
	DD	imagerel $LN4+125
	DD	imagerel $unwind$?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ
$pdata$?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z DD imagerel $LN6
	DD	imagerel $LN6+197
	DD	imagerel $unwind$?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z
$pdata$?ResetMouseDragDelta@ImGui@@YAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?ResetMouseDragDelta@ImGui@@YAXH@Z
$pdata$?CaptureKeyboardFromApp@ImGui@@YAX_N@Z DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$?CaptureKeyboardFromApp@ImGui@@YAX_N@Z
$pdata$?CaptureMouseFromApp@ImGui@@YAX_N@Z DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$?CaptureMouseFromApp@ImGui@@YAX_N@Z
$pdata$?GetClipboardText@ImGui@@YAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$?GetClipboardText@ImGui@@YAPEBDXZ
$pdata$?SetClipboardText@ImGui@@YAXPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$?SetClipboardText@ImGui@@YAXPEBD@Z
$pdata$?MemAlloc@ImGui@@YAPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$?MemAlloc@ImGui@@YAPEAX_K@Z
$pdata$?MemFree@ImGui@@YAXPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$?MemFree@ImGui@@YAXPEAX@Z
$pdata$??0ImGuiStyle@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+1147
	DD	imagerel $unwind$??0ImGuiStyle@@QEAA@XZ
$pdata$?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+1030
	DD	imagerel $unwind$?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z
$pdata$?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+136
	DD	imagerel $unwind$?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z
$pdata$?AddInputCharacter@ImGuiIO@@QEAAXG@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?AddInputCharacter@ImGuiIO@@QEAAXG@Z
$pdata$?ClearInputCharacters@ImGuiIO@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?ClearInputCharacters@ImGuiIO@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@G@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@G@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@G@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@G@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@G@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?reserve@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@G@@QEAAXAEBG@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@G@@QEAAXAEBG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0ImGuiIO@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+1170
	DD	imagerel $unwind$??0ImGuiIO@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiIO@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$??1ImGuiIO@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiSizeCallbackData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0ImGuiSizeCallbackData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiPayload@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??0ImGuiPayload@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImGuiPayload@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?Clear@ImGuiPayload@@QEAAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Begin@ImGui@@YA_NPEBDPEA_NAEBUImVec2@@MH@Z DD imagerel $LN7
	DD	imagerel $LN7+134
	DD	imagerel $unwind$?Begin@ImGui@@YA_NPEBDPEA_NAEBUImVec2@@MH@Z
$pdata$??0ImGuiTextFilter@@QEAA@PEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+122
	DD	imagerel $unwind$??0ImGuiTextFilter@@QEAA@PEBD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z DD imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z
$pdata$?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z DD imagerel $LN14
	DD	imagerel $LN14+362
	DD	imagerel $unwind$?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z
$pdata$?Build@ImGuiTextFilter@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+455
	DD	imagerel $unwind$?Build@ImGuiTextFilter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+53
	DD	imagerel $unwind$?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z DD imagerel $LN7
	DD	imagerel $LN7+199
	DD	imagerel $unwind$?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@D@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@D@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@D@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@D@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@D@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@D@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@D@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?reserve@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?append@ImGuiTextBuffer@@QEAAXPEBD0@Z DD imagerel $LN10
	DD	imagerel $LN10+379
	DD	imagerel $unwind$?append@ImGuiTextBuffer@@QEAAXPEBD0@Z
$pdata$?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ
$pdata$?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z DD imagerel $LN9
	DD	imagerel $LN9+328
	DD	imagerel $unwind$?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiTextBuffer@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1ImGuiTextBuffer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z DD imagerel $LN5
	DD	imagerel $LN5+261
	DD	imagerel $unwind$?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImGuiStorage@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?Clear@ImGuiStorage@@QEAAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?GetInt@ImGuiStorage@@QEBAHIH@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$?GetInt@ImGuiStorage@@QEBAHIH@Z
$pdata$?SetInt@ImGuiStorage@@QEAAXIH@Z DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$?SetInt@ImGuiStorage@@QEAAXIH@Z
$pdata$?GetBool@ImGuiStorage@@QEBA_NI_N@Z DD imagerel $LN7
	DD	imagerel $LN7+96
	DD	imagerel $unwind$?GetBool@ImGuiStorage@@QEBA_NI_N@Z
$pdata$?SetBool@ImGuiStorage@@QEAAXI_N@Z DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$?SetBool@ImGuiStorage@@QEAAXI_N@Z
$pdata$?GetFloat@ImGuiStorage@@QEBAMIM@Z DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$?GetFloat@ImGuiStorage@@QEBAMIM@Z
$pdata$?SetFloat@ImGuiStorage@@QEAAXIM@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?SetFloat@ImGuiStorage@@QEAAXIM@Z
$pdata$?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z
$pdata$?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+142
	DD	imagerel $unwind$?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z
$pdata$?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z
$pdata$?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z
$pdata$?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z
$pdata$?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z
$pdata$?SetAllInt@ImGuiStorage@@QEAAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+84
	DD	imagerel $unwind$?SetAllInt@ImGuiStorage@@QEAAXH@Z
$pdata$?BuildSortByKey@ImGuiStorage@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?BuildSortByKey@ImGuiStorage@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiStorage@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??0ImGuiStorage@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiStorage@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1ImGuiStorage@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiListClipper@@QEAA@HM@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0ImGuiListClipper@@QEAA@HM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?Step@ImGuiListClipper@@QEAA_NXZ DD imagerel $LN10
	DD	imagerel $LN10+323
	DD	imagerel $unwind$?Step@ImGuiListClipper@@QEAA_NXZ
$pdata$?Begin@ImGuiListClipper@@QEAAXHM@Z DD imagerel $LN5
	DD	imagerel $LN5+241
	DD	imagerel $unwind$?Begin@ImGuiListClipper@@QEAAXHM@Z
$pdata$?End@ImGuiListClipper@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$?End@ImGuiListClipper@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImDrawVert@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImVec4@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImVec4@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAX@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAX@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImVec2@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImVec2@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DD imagerel $LN10
	DD	imagerel $LN10+188
	DD	imagerel $unwind$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImDrawList@@QEAA@XZ DD imagerel $LN10
	DD	imagerel $LN10+151
	DD	imagerel $unwind$??1ImDrawList@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA DD imagerel ?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathFillConvex@ImDrawList@@QEAAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathStroke@ImDrawList@@QEAAXI_NM@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$?PathStroke@ImDrawList@@QEAAXI_NM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0ImDrawData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImDrawData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1ImDrawData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImDrawData@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?Clear@ImDrawData@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@H@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@H@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@H@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@H@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@H@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@H@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@H@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@H@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@H@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@H@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@H@@QEAAXAEBH@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@H@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAUImFont@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFontAtlas@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImFontAtlas@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@M@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@M@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@M@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@M@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@M@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@M@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@M@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@M@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@M@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@M@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@M@@QEAAXAEBM@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@M@@QEAAXAEBM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ImTextStrToUtf8@@YAHPEADHPEBG1@Z DD imagerel $LN8
	DD	imagerel $LN8+272
	DD	imagerel $unwind$?ImTextStrToUtf8@@YAHPEADHPEBG1@Z
$pdata$?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z DD imagerel $LN25
	DD	imagerel $LN25+1245
	DD	imagerel $unwind$?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z
$pdata$?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z DD imagerel $LN9
	DD	imagerel $LN9+244
	DD	imagerel $unwind$?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z
$pdata$?ImTextCountCharsFromUtf8@@YAHPEBD0@Z DD imagerel $LN8
	DD	imagerel $LN8+132
	DD	imagerel $unwind$?ImTextCountCharsFromUtf8@@YAHPEBD0@Z
$pdata$?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z
$pdata$?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z DD imagerel $LN8
	DD	imagerel $LN8+142
	DD	imagerel $unwind$?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z
$pdata$?ImHashData@@YAIPEBX_KI@Z DD imagerel $LN5
	DD	imagerel $LN5+152
	DD	imagerel $unwind$?ImHashData@@YAIPEBX_KI@Z
$pdata$?ImHashStr@@YAIPEBD_KI@Z DD imagerel $LN11
	DD	imagerel $LN11+409
	DD	imagerel $unwind$?ImHashStr@@YAIPEBD_KI@Z
$pdata$?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z DD imagerel $LN11
	DD	imagerel $LN11+359
	DD	imagerel $unwind$?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z
$pdata$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+246
	DD	imagerel $unwind$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA DD imagerel ?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA
	DD	imagerel ?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ImCharIsBlankA@@YA_ND@Z DD imagerel ?ImCharIsBlankA@@YA_ND@Z
	DD	imagerel ?ImCharIsBlankA@@YA_ND@Z+53
	DD	imagerel $unwind$?ImCharIsBlankA@@YA_ND@Z
$pdata$?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z DD imagerel $LN5
	DD	imagerel $LN5+273
	DD	imagerel $unwind$?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z
$pdata$?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z DD imagerel $LN11
	DD	imagerel $LN11+446
	DD	imagerel $unwind$?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z
$pdata$?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z DD imagerel $LN5
	DD	imagerel $LN5+362
	DD	imagerel $unwind$?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z
$pdata$?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z DD imagerel $LN3
	DD	imagerel $LN3+250
	DD	imagerel $unwind$?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z
$pdata$?ImGetDirQuadrantFromDelta@@YAHMM@Z DD imagerel $LN8
	DD	imagerel $LN8+136
	DD	imagerel $unwind$?ImGetDirQuadrantFromDelta@@YAHMM@Z
$pdata$?ImStricmp@@YAHPEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$?ImStricmp@@YAHPEBD0@Z
$pdata$?ImStrnicmp@@YAHPEBD0_K@Z DD imagerel $LN5
	DD	imagerel $LN5+148
	DD	imagerel $unwind$?ImStrnicmp@@YAHPEBD0_K@Z
$pdata$?ImStrncpy@@YAXPEADPEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$?ImStrncpy@@YAXPEADPEBD_K@Z
$pdata$?ImStrdup@@YAPEADPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?ImStrdup@@YAPEADPEBD@Z
$pdata$?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+171
	DD	imagerel $unwind$?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z
$pdata$?ImStrchrRange@@YAPEBDPEBD0D@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?ImStrchrRange@@YAPEBDPEBD0D@Z
$pdata$?ImStrlenW@@YAHPEBG@Z DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$?ImStrlenW@@YAHPEBG@Z
$pdata$?ImStreolRange@@YAPEBDPEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$?ImStreolRange@@YAPEBDPEBD0@Z
$pdata$?ImStristr@@YAPEBDPEBD000@Z DD imagerel $LN14
	DD	imagerel $LN14+307
	DD	imagerel $unwind$?ImStristr@@YAPEBDPEBD000@Z
$pdata$?ImStrTrimBlanks@@YAXPEAD@Z DD imagerel $LN12
	DD	imagerel $LN12+267
	DD	imagerel $unwind$?ImStrTrimBlanks@@YAXPEAD@Z
$pdata$?ImFormatString@@YAHPEAD_KPEBDZZ DD imagerel $LN6
	DD	imagerel $LN6+136
	DD	imagerel $unwind$?ImFormatString@@YAHPEAD_KPEBDZZ
$pdata$?ImFormatStringV@@YAHPEAD_KPEBD0@Z DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$?ImFormatStringV@@YAHPEAD_KPEBD0@Z
$pdata$??D@YA?AUImVec2@@AEBU0@M@Z DD imagerel ??D@YA?AUImVec2@@AEBU0@M@Z
	DD	imagerel ??D@YA?AUImVec2@@AEBU0@M@Z+74
	DD	imagerel $unwind$??D@YA?AUImVec2@@AEBU0@M@Z
$pdata$??K@YA?AUImVec2@@AEBU0@M@Z DD imagerel ??K@YA?AUImVec2@@AEBU0@M@Z
	DD	imagerel ??K@YA?AUImVec2@@AEBU0@M@Z+74
	DD	imagerel $unwind$??K@YA?AUImVec2@@AEBU0@M@Z
$pdata$??H@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??H@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??H@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??H@YA?AUImVec2@@AEBU0@0@Z
$pdata$??G@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??G@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??G@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??G@YA?AUImVec2@@AEBU0@0@Z
$pdata$??D@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??D@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??D@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??D@YA?AUImVec2@@AEBU0@0@Z
$pdata$??K@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??K@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??K@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??K@YA?AUImVec2@@AEBU0@0@Z
$pdata$?ImFabs@@YAMM@Z DD imagerel ?ImFabs@@YAMM@Z
	DD	imagerel ?ImFabs@@YAMM@Z+26
	DD	imagerel $unwind$?ImFabs@@YAMM@Z
$pdata$?ImFmod@@YAMMM@Z DD imagerel ?ImFmod@@YAMMM@Z
	DD	imagerel ?ImFmod@@YAMMM@Z+38
	DD	imagerel $unwind$?ImFmod@@YAMMM@Z
$pdata$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z+157
	DD	imagerel $unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z
$pdata$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z+157
	DD	imagerel $unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z
$pdata$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
	DD	imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z+247
	DD	imagerel $unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
$pdata$?ImLerp@@YA?AUImVec2@@AEBU1@00@Z DD imagerel ?ImLerp@@YA?AUImVec2@@AEBU1@00@Z
	DD	imagerel ?ImLerp@@YA?AUImVec2@@AEBU1@00@Z+137
	DD	imagerel $unwind$?ImLerp@@YA?AUImVec2@@AEBU1@00@Z
$pdata$?ImSaturate@@YAMM@Z DD imagerel ?ImSaturate@@YAMM@Z
	DD	imagerel ?ImSaturate@@YAMM@Z+94
	DD	imagerel $unwind$?ImSaturate@@YAMM@Z
$pdata$?ImFloor@@YA?AUImVec2@@AEBU1@@Z DD imagerel ?ImFloor@@YA?AUImVec2@@AEBU1@@Z
	DD	imagerel ?ImFloor@@YA?AUImVec2@@AEBU1@@Z+64
	DD	imagerel $unwind$?ImFloor@@YA?AUImVec2@@AEBU1@@Z
$pdata$??$ImMin@M@@YAMMM@Z DD imagerel ??$ImMin@M@@YAMMM@Z
	DD	imagerel ??$ImMin@M@@YAMMM@Z+63
	DD	imagerel $unwind$??$ImMin@M@@YAMMM@Z
$pdata$??$ImMax@M@@YAMMM@Z DD imagerel ??$ImMax@M@@YAMMM@Z
	DD	imagerel ??$ImMax@M@@YAMMM@Z+63
	DD	imagerel $unwind$??$ImMax@M@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??0ImRect@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@AEBUImVec4@@@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??0ImRect@@QEAA@AEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$??0ImRect@@QEAA@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSize@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?GetSize@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTR@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?GetTR@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBL@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?GetBL@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Contains@ImRect@@QEBA_NAEBU1@@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?Contains@ImRect@@QEBA_NAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Overlaps@ImRect@@QEBA_NAEBU1@@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?Overlaps@ImRect@@QEBA_NAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClipWith@ImRect@@QEAAXAEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?ClipWith@ImRect@@QEAAXAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClipWithFull@ImRect@@QEAAXAEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?ClipWithFull@ImRect@@QEAAXAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsInverted@ImRect@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$?IsInverted@ImRect@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiColorMod@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0ImGuiColorMod@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiInputTextState@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+92
	DD	imagerel $unwind$??0ImGuiInputTextState@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiInputTextState@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+68
	DD	imagerel $unwind$??1ImGuiInputTextState@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiPopupRef@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0ImGuiPopupRef@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiColumnData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0ImGuiColumnData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiColumnsSet@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??0ImGuiColumnsSet@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImGuiColumnsSet@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+175
	DD	imagerel $unwind$?Clear@ImGuiColumnsSet@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiColumnsSet@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1ImGuiColumnsSet@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImGuiColumnsSet@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImGuiColumnsSet@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImDrawDataBuilder@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+81
	DD	imagerel $unwind$?Clear@ImDrawDataBuilder@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+351
	DD	imagerel $unwind$?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawDataBuilder@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??0ImDrawDataBuilder@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA+42
	DD	imagerel $unwind$?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImDrawDataBuilder@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$??1ImDrawDataBuilder@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA+42
	DD	imagerel $unwind$?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiNavMoveResult@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??0ImGuiNavMoveResult@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImGuiNavMoveResult@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+137
	DD	imagerel $unwind$?Clear@ImGuiNavMoveResult@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiNextWindowData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+410
	DD	imagerel $unwind$??0ImGuiNextWindowData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z DD imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z DD imagerel $LN5
	DD	imagerel $LN5+269
	DD	imagerel $unwind$?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@E@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@E@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@E@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@E@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@E@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@E@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@E@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@E@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@E@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?reserve@?$ImVector@E@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+176
	DD	imagerel $unwind$?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z DD imagerel $LN31
	DD	imagerel $LN31+3169
	DD	imagerel $unwind$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA+35
	DD	imagerel $unwind$?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiContext@@QEAA@XZ DD imagerel $LN24
	DD	imagerel $LN24+432
	DD	imagerel $unwind$??1ImGuiContext@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA DD imagerel ?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA
	DD	imagerel ?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImGuiContext@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImGuiContext@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiWindowTempData@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+1107
	DD	imagerel $unwind$??0ImGuiWindowTempData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA+34
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA+34
	DD	imagerel $unwind$?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA+34
	DD	imagerel $unwind$?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA+34
	DD	imagerel $unwind$?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA+34
	DD	imagerel $unwind$?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiWindowTempData@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+114
	DD	imagerel $unwind$??1ImGuiWindowTempData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD imagerel ?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@I@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@I@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@I@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@I@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@I@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@I@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@I@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@I@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@I@@QEAAXAEBI@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@I@@QEAAXAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z DD imagerel $LN8
	DD	imagerel $LN8+2146
	DD	imagerel $unwind$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD imagerel ?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA+34
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
$pdata$?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD imagerel ?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DD	imagerel ?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA+34
	DD	imagerel $unwind$?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
$pdata$?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD imagerel ?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DD	imagerel ?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA+34
	DD	imagerel $unwind$?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
$pdata$?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD imagerel ?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DD	imagerel ?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA+34
	DD	imagerel $unwind$?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
$pdata$?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD imagerel ?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DD	imagerel ?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA+34
	DD	imagerel $unwind$?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1ImGuiWindow@@QEAA@XZ DD imagerel $LN11
	DD	imagerel $LN11+201
	DD	imagerel $unwind$??1ImGuiWindow@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA
$pdata$?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA
$pdata$?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA
$pdata$?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA DD imagerel ?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DD	imagerel ?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetID@ImGuiWindow@@QEAAIPEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+134
	DD	imagerel $unwind$?GetID@ImGuiWindow@@QEAAIPEBD0@Z
$pdata$?GetID@ImGuiWindow@@QEAAIPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?GetID@ImGuiWindow@@QEAAIPEBX@Z
$pdata$?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z
$pdata$?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z
$pdata$?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z DD imagerel $LN3
	DD	imagerel $LN3+220
	DD	imagerel $unwind$?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TitleBarHeight@ImGuiWindow@@QEBAMXZ DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$?TitleBarHeight@ImGuiWindow@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MenuBarHeight@ImGuiWindow@@QEBAMXZ DD imagerel $LN5
	DD	imagerel $LN5+111
	DD	imagerel $unwind$?MenuBarHeight@ImGuiWindow@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ DD imagerel $LN3
	DD	imagerel $LN3+168
	DD	imagerel $unwind$?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImGuiWindow@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImGuiWindow@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiTabBar@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1ImGuiTabBar@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImGuiTabBar@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImGuiTabBar@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z
$pdata$?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z
$pdata$?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN12
	DD	imagerel $LN12+361
	DD	imagerel $unwind$?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN8
	DD	imagerel $LN8+202
	DD	imagerel $unwind$?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN8
	DD	imagerel $LN8+334
	DD	imagerel $unwind$?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN9
	DD	imagerel $LN9+366
	DD	imagerel $unwind$?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN8
	DD	imagerel $LN8+302
	DD	imagerel $unwind$?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z
$pdata$?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z
$pdata$?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z
$pdata$?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z
$pdata$?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z DD imagerel $LN7
	DD	imagerel $LN7+232
	DD	imagerel $unwind$?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z
$pdata$?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+260
	DD	imagerel $unwind$?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z
$pdata$?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z
$pdata$?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z DD imagerel $LN5
	DD	imagerel $LN5+264
	DD	imagerel $unwind$?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z
$pdata$?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z DD imagerel $LN8
	DD	imagerel $LN8+622
	DD	imagerel $unwind$?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z
$pdata$?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ DD imagerel $LN38
	DD	imagerel $LN38+996
	DD	imagerel $unwind$?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ
$pdata$?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN6
	DD	imagerel $LN6+198
	DD	imagerel $unwind$?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+371
	DD	imagerel $unwind$?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ
$pdata$?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ DD imagerel $LN21
	DD	imagerel $LN21+568
	DD	imagerel $unwind$?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ
$pdata$?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z DD imagerel $LN10
	DD	imagerel $LN10+369
	DD	imagerel $unwind$?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z
$pdata$?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z DD imagerel $LN7
	DD	imagerel $LN7+384
	DD	imagerel $unwind$?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z
$pdata$?ClearActiveID@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?ClearActiveID@ImGui@@YAXXZ
$pdata$?GetHoveredID@ImGui@@YAIXZ DD imagerel $LN5
	DD	imagerel $LN5+68
	DD	imagerel $unwind$?GetHoveredID@ImGui@@YAIXZ
$pdata$?SetHoveredID@ImGui@@YAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$?SetHoveredID@ImGui@@YAXI@Z
$pdata$?KeepAliveID@ImGui@@YAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$?KeepAliveID@ImGui@@YAXI@Z
$pdata$?MarkItemEdited@ImGui@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?MarkItemEdited@ImGui@@YAXI@Z
$pdata$?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z DD imagerel $LN5
	DD	imagerel $LN5+512
	DD	imagerel $unwind$?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z
$pdata$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z
$pdata$?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z DD imagerel $LN13
	DD	imagerel $LN13+453
	DD	imagerel $unwind$?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z
$pdata$?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z DD imagerel $LN10
	DD	imagerel $LN10+286
	DD	imagerel $unwind$?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z
$pdata$?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z DD imagerel $LN7
	DD	imagerel $LN7+122
	DD	imagerel $unwind$?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z
$pdata$?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z DD imagerel $LN13
	DD	imagerel $LN13+404
	DD	imagerel $unwind$?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z
$pdata$?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z DD imagerel $LN11
	DD	imagerel $LN11+370
	DD	imagerel $unwind$?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z
$pdata$?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z DD imagerel $LN7
	DD	imagerel $LN7+179
	DD	imagerel $unwind$?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z
$pdata$?PushMultiItemsWidths@ImGui@@YAXHM@Z DD imagerel $LN7
	DD	imagerel $LN7+355
	DD	imagerel $unwind$?PushMultiItemsWidths@ImGui@@YAXHM@Z
$pdata$?PushItemFlag@ImGui@@YAXH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$?PushItemFlag@ImGui@@YAXH_N@Z
$pdata$?PopItemFlag@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$?PopItemFlag@ImGui@@YAXXZ
$pdata$?OpenPopupEx@ImGui@@YAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+562
	DD	imagerel $unwind$?OpenPopupEx@ImGui@@YAXI@Z
$pdata$?ClosePopupToLevel@ImGui@@YAXH_N@Z DD imagerel $LN7
	DD	imagerel $LN7+208
	DD	imagerel $unwind$?ClosePopupToLevel@ImGui@@YAXH_N@Z
$pdata$?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN16
	DD	imagerel $LN16+380
	DD	imagerel $unwind$?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?IsPopupOpen@ImGui@@YA_NI@Z DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$?IsPopupOpen@ImGui@@YA_NI@Z
$pdata$?BeginPopupEx@ImGui@@YA_NIH@Z DD imagerel $LN7
	DD	imagerel $LN7+221
	DD	imagerel $unwind$?BeginPopupEx@ImGui@@YA_NIH@Z
$pdata$?BeginTooltipEx@ImGui@@YAXH_N@Z DD imagerel $LN6
	DD	imagerel $LN6+260
	DD	imagerel $unwind$?BeginTooltipEx@ImGui@@YAXH_N@Z
$pdata$?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ DD imagerel $LN8
	DD	imagerel $LN8+119
	DD	imagerel $unwind$?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ
$pdata$?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD imagerel $LN11
	DD	imagerel $LN11+1407
	DD	imagerel $unwind$?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z
$pdata$?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z DD imagerel $LN43
	DD	imagerel $LN43+1727
	DD	imagerel $unwind$?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z
$pdata$?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z DD imagerel $LN8
	DD	imagerel $LN8+266
	DD	imagerel $unwind$?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z
$pdata$?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+85
	DD	imagerel $unwind$?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ
$pdata$?NavMoveRequestCancel@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?NavMoveRequestCancel@ImGui@@YAXXZ
$pdata$?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z
$pdata$?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z DD imagerel $LN13
	DD	imagerel $LN13+748
	DD	imagerel $unwind$?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z
$pdata$?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z DD imagerel $LN14
	DD	imagerel $LN14+559
	DD	imagerel $unwind$?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z
$pdata$?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z DD imagerel $LN10
	DD	imagerel $LN10+700
	DD	imagerel $unwind$?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z
$pdata$?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z DD imagerel $LN8
	DD	imagerel $LN8+160
	DD	imagerel $unwind$?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z
$pdata$?ActivateItem@ImGui@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?ActivateItem@ImGui@@YAXI@Z
$pdata$?SetNavID@ImGui@@YAXIH@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?SetNavID@ImGui@@YAXIH@Z
$pdata$?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsKeyPressedMap@ImGui@@YA_NH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$?IsKeyPressedMap@ImGui@@YA_NH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNavInputDown@ImGui@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?IsNavInputDown@ImGui@@YA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z DD imagerel $LN5
	DD	imagerel $LN5+99
	DD	imagerel $unwind$?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z DD imagerel $LN9
	DD	imagerel $LN9+249
	DD	imagerel $unwind$?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z
$pdata$?ClearDragDrop@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+180
	DD	imagerel $unwind$?ClearDragDrop@ImGui@@YAXXZ
$pdata$?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ
$pdata$?BeginColumns@ImGui@@YAXPEBDHH@Z DD imagerel $LN20
	DD	imagerel $LN20+1273
	DD	imagerel $unwind$?BeginColumns@ImGui@@YAXPEBDHH@Z
$pdata$?EndColumns@ImGui@@YAXXZ DD imagerel $LN22
	DD	imagerel $LN22+1270
	DD	imagerel $unwind$?EndColumns@ImGui@@YAXXZ
$pdata$?PushColumnClipRect@ImGui@@YAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+152
	DD	imagerel $unwind$?PushColumnClipRect@ImGui@@YAXH@Z
$pdata$?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z DD imagerel $LN7
	DD	imagerel $LN7+1130
	DD	imagerel $unwind$?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z
$pdata$?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z DD imagerel $LN5
	DD	imagerel $LN5+1120
	DD	imagerel $unwind$?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z
$pdata$?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z DD imagerel $LN4
	DD	imagerel $LN4+201
	DD	imagerel $unwind$?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z
$pdata$?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z DD imagerel $LN18
	DD	imagerel $LN18+898
	DD	imagerel $unwind$?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z
$pdata$?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z DD imagerel $LN4
	DD	imagerel $LN4+520
	DD	imagerel $unwind$?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z
$pdata$?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z DD imagerel $LN4
	DD	imagerel $LN4+420
	DD	imagerel $unwind$?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z
$pdata$?RenderArrow@ImGui@@YAXUImVec2@@HM@Z DD imagerel $LN13
	DD	imagerel $LN13+830
	DD	imagerel $unwind$?RenderArrow@ImGui@@YAXUImVec2@@HM@Z
$pdata$?RenderBullet@ImGui@@YAXUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+141
	DD	imagerel $unwind$?RenderBullet@ImGui@@YAXUImVec2@@@Z
$pdata$?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z DD imagerel $LN3
	DD	imagerel $LN3+571
	DD	imagerel $unwind$?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z
$pdata$?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z DD imagerel $LN12
	DD	imagerel $LN12+806
	DD	imagerel $unwind$?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z
$pdata$?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z DD imagerel $LN7
	DD	imagerel $LN7+128
	DD	imagerel $unwind$?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z
$pdata$?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z DD imagerel ?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z
	DD	imagerel ?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z+105
	DD	imagerel $unwind$?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z
$pdata$?FindHoveredWindow@@YAXXZ DD imagerel ?FindHoveredWindow@@YAXXZ
	DD	imagerel ?FindHoveredWindow@@YAXXZ+614
	DD	imagerel $unwind$?FindHoveredWindow@@YAXXZ
$pdata$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z DD imagerel ?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z
	DD	imagerel ?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z+675
	DD	imagerel $unwind$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA DD imagerel ?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA
	DD	imagerel ?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA+35
	DD	imagerel $unwind$?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z DD imagerel ?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z
	DD	imagerel ?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z+361
	DD	imagerel $unwind$?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z
$pdata$?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z DD imagerel ?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z
	DD	imagerel ?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z+608
	DD	imagerel $unwind$?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z
$pdata$?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z DD imagerel ?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z
	DD	imagerel ?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z+152
	DD	imagerel $unwind$?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z
$pdata$?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z DD imagerel ?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z
	DD	imagerel ?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z+230
	DD	imagerel $unwind$?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z
$pdata$?GetViewportRect@@YA?AUImRect@@XZ DD imagerel ?GetViewportRect@@YA?AUImRect@@XZ
	DD	imagerel ?GetViewportRect@@YA?AUImRect@@XZ+73
	DD	imagerel $unwind$?GetViewportRect@@YA?AUImRect@@XZ
$pdata$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z DD imagerel ?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z
	DD	imagerel ?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z+283
	DD	imagerel $unwind$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA DD imagerel ?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z DD imagerel ?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z
	DD	imagerel ?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z+203
	DD	imagerel $unwind$?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z
$pdata$?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z DD imagerel ?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z
	DD	imagerel ?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z+150
	DD	imagerel $unwind$?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z
$pdata$?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z DD imagerel ?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z
	DD	imagerel ?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z+770
	DD	imagerel $unwind$?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z
$pdata$?NavUpdate@ImGui@@YAXXZ DD imagerel ?NavUpdate@ImGui@@YAXXZ
	DD	imagerel ?NavUpdate@ImGui@@YAXXZ+5812
	DD	imagerel $unwind$?NavUpdate@ImGui@@YAXXZ
$pdata$?NavUpdateWindowing@ImGui@@YAXXZ DD imagerel ?NavUpdateWindowing@ImGui@@YAXXZ
	DD	imagerel ?NavUpdateWindowing@ImGui@@YAXXZ+2360
	DD	imagerel $unwind$?NavUpdateWindowing@ImGui@@YAXXZ
$pdata$?NavUpdateMoveResult@ImGui@@YAXXZ DD imagerel ?NavUpdateMoveResult@ImGui@@YAXXZ
	DD	imagerel ?NavUpdateMoveResult@ImGui@@YAXXZ+904
	DD	imagerel $unwind$?NavUpdateMoveResult@ImGui@@YAXXZ
$pdata$?NavUpdatePageUpPageDown@ImGui@@YAMH@Z DD imagerel ?NavUpdatePageUpPageDown@ImGui@@YAMH@Z
	DD	imagerel ?NavUpdatePageUpPageDown@ImGui@@YAMH@Z+850
	DD	imagerel $unwind$?NavUpdatePageUpPageDown@ImGui@@YAMH@Z
$pdata$?NavUpdateAnyRequestFlag@ImGui@@YAXXZ DD imagerel ?NavUpdateAnyRequestFlag@ImGui@@YAXXZ
	DD	imagerel ?NavUpdateAnyRequestFlag@ImGui@@YAXXZ+102
	DD	imagerel $unwind$?NavUpdateAnyRequestFlag@ImGui@@YAXXZ
$pdata$?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z DD imagerel ?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z
	DD	imagerel ?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z+1171
	DD	imagerel $unwind$?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z
$pdata$?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ DD imagerel ?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ
	DD	imagerel ?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ+510
	DD	imagerel $unwind$?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ
$pdata$?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel ?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z
	DD	imagerel ?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z+113
	DD	imagerel $unwind$?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z
$pdata$?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z DD imagerel ?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z
	DD	imagerel ?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z+60
	DD	imagerel $unwind$?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z
$pdata$?UpdateMouseInputs@ImGui@@YAXXZ DD imagerel ?UpdateMouseInputs@ImGui@@YAXXZ
	DD	imagerel ?UpdateMouseInputs@ImGui@@YAXXZ+1634
	DD	imagerel $unwind$?UpdateMouseInputs@ImGui@@YAXXZ
$pdata$?UpdateMouseWheel@ImGui@@YAXXZ DD imagerel ?UpdateMouseWheel@ImGui@@YAXXZ
	DD	imagerel ?UpdateMouseWheel@ImGui@@YAXXZ+991
	DD	imagerel $unwind$?UpdateMouseWheel@ImGui@@YAXXZ
$pdata$?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z DD imagerel ?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z
	DD	imagerel ?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z+2728
	DD	imagerel $unwind$?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z
$pdata$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z DD imagerel ?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z
	DD	imagerel ?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z+1838
	DD	imagerel $unwind$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA DD imagerel ?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
	DD	imagerel ?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?MallocWrapper@@YAPEAX_KPEAX@Z DD imagerel ?MallocWrapper@@YAPEAX_KPEAX@Z
	DD	imagerel ?MallocWrapper@@YAPEAX_KPEAX@Z+29
	DD	imagerel $unwind$?MallocWrapper@@YAPEAX_KPEAX@Z
$pdata$?FreeWrapper@@YAXPEAX0@Z DD imagerel ?FreeWrapper@@YAXPEAX0@Z
	DD	imagerel ?FreeWrapper@@YAXPEAX0@Z+30
	DD	imagerel $unwind$?FreeWrapper@@YAXPEAX0@Z
$pdata$??$ImSwap@M@@YAXAEAM0@Z DD imagerel ??$ImSwap@M@@YAXAEAM0@Z
	DD	imagerel ??$ImSwap@M@@YAXAEAM0@Z+65
	DD	imagerel $unwind$??$ImSwap@M@@YAXAEAM0@Z
$pdata$?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z DD imagerel ?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z
	DD	imagerel ?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z+200
	DD	imagerel $unwind$?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z
$pdata$?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z DD imagerel ?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z
	DD	imagerel ?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z+153
	DD	imagerel $unwind$?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z
$pdata$?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z DD imagerel ?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z
	DD	imagerel ?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z+161
	DD	imagerel $unwind$?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z DD imagerel ?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z
	DD	imagerel ?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z+63
	DD	imagerel $unwind$?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z
$pdata$??$ImClamp@M@@YAMMMM@Z DD imagerel ??$ImClamp@M@@YAMMMM@Z
	DD	imagerel ??$ImClamp@M@@YAMMMM@Z+108
	DD	imagerel $unwind$??$ImClamp@M@@YAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ChildWindowComparer@@YAHPEBX0@Z DD imagerel ?ChildWindowComparer@@YAHPEBX0@Z
	DD	imagerel ?ChildWindowComparer@@YAHPEBX0@Z+160
	DD	imagerel $unwind$?ChildWindowComparer@@YAHPEBX0@Z
$pdata$?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z DD imagerel ?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z
	DD	imagerel ?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z+188
	DD	imagerel $unwind$?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z
$pdata$?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z DD imagerel ?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z
	DD	imagerel ?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z+117
	DD	imagerel $unwind$?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z
$pdata$?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z DD imagerel ?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z
	DD	imagerel ?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z+304
	DD	imagerel $unwind$?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z
$pdata$??$ImClamp@H@@YAHHHH@Z DD imagerel ??$ImClamp@H@@YAHHHH@Z
	DD	imagerel ??$ImClamp@H@@YAHHHH@Z+79
	DD	imagerel $unwind$??$ImClamp@H@@YAHHHH@Z
$pdata$?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z DD imagerel ?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z
	DD	imagerel ?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z+236
	DD	imagerel $unwind$?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z
$pdata$?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z DD imagerel ?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z
	DD	imagerel ?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z+628
	DD	imagerel $unwind$?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z
$pdata$?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD imagerel ?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z
	DD	imagerel ?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z+388
	DD	imagerel $unwind$?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z
$pdata$?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z DD imagerel ?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z
	DD	imagerel ?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z+573
	DD	imagerel $unwind$?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z
$pdata$?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z DD imagerel ?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z
	DD	imagerel ?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z+302
	DD	imagerel $unwind$?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eresize_grip_def@@YAXXZ DD imagerel ??__Eresize_grip_def@@YAXXZ
	DD	imagerel ??__Eresize_grip_def@@YAXXZ+293
	DD	imagerel $unwind$??__Eresize_grip_def@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z DD imagerel ?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z
	DD	imagerel ?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z+571
	DD	imagerel $unwind$?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z
$pdata$?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z DD imagerel ?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z
	DD	imagerel ?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z+215
	DD	imagerel $unwind$?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z
$pdata$?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z DD imagerel ?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z
	DD	imagerel ?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z+1617
	DD	imagerel $unwind$?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z
$pdata$?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z DD imagerel ?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z
	DD	imagerel ?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z+216
	DD	imagerel $unwind$?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z
$pdata$?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z DD imagerel ?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z
	DD	imagerel ?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z+654
	DD	imagerel $unwind$?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z
$pdata$?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z DD imagerel ?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z
	DD	imagerel ?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z+115
	DD	imagerel $unwind$?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z
$pdata$?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z DD imagerel ?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z
	DD	imagerel ?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z+181
	DD	imagerel $unwind$?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z
$pdata$?NavUpdateWindowingHighlightWindow@@YAXH@Z DD imagerel ?NavUpdateWindowingHighlightWindow@@YAXH@Z
	DD	imagerel ?NavUpdateWindowingHighlightWindow@@YAXH@Z+236
	DD	imagerel $unwind$?NavUpdateWindowingHighlightWindow@@YAXH@Z
$pdata$?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z DD imagerel ?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z
	DD	imagerel ?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z+226
	DD	imagerel $unwind$?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z
$pdata$?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z DD imagerel ?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z
	DD	imagerel ?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z+242
	DD	imagerel $unwind$?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z
$pdata$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z DD imagerel ?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z
	DD	imagerel ?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z+264
	DD	imagerel $unwind$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA DD imagerel ?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA
	DD	imagerel ?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ DD imagerel ??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ
	DD	imagerel ??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ+22
	DD	imagerel $unwind$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z DD imagerel ?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z
	DD	imagerel ?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z+2347
	DD	imagerel $unwind$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA DD imagerel ?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z DD imagerel ?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z
	DD	imagerel ?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z+129
	DD	imagerel $unwind$?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z
$pdata$?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z DD imagerel ?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z
	DD	imagerel ?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z+2302
	DD	imagerel $unwind$?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z
$pdata$?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z DD imagerel ?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z
	DD	imagerel ?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z+524
	DD	imagerel $unwind$?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@c87a0000
CONST	SEGMENT
__real@c87a0000 DD 0c87a0000r			; -256000
CONST	ENDS
;	COMDAT __real@c7efffffe0000000
CONST	SEGMENT
__real@c7efffffe0000000 DQ 0c7efffffe0000000r	; -3.40282e+38
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf5db22d
CONST	SEGMENT
__real@bf5db22d DD 0bf5db22dr			; -0.866
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@beaaaaab
CONST	SEGMENT
__real@beaaaaab DD 0beaaaaabr			; -0.333333
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41a80000
CONST	SEGMENT
__real@41a80000 DD 041a80000r			; 21
CONST	ENDS
;	COMDAT __real@41980000
CONST	SEGMENT
__real@41980000 DD 041980000r			; 19
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4096cbe4
CONST	SEGMENT
__real@4096cbe4 DD 04096cbe4r			; 4.71239
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40600000
CONST	SEGMENT
__real@40600000 DD 040600000r			; 3.5
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3faccccd
CONST	SEGMENT
__real@3faccccd DD 03faccccdr			; 1.35
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f5db22d
CONST	SEGMENT
__real@3f5db22d DD 03f5db22dr			; 0.866
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fdb
CONST	SEGMENT
__real@3f490fdb DD 03f490fdbr			; 0.785398
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f2b851f
CONST	SEGMENT
__real@3f2b851f DD 03f2b851fr			; 0.67
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e2aaaab
CONST	SEGMENT
__real@3e2aaaab DD 03e2aaaabr			; 0.166667
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3c888889
CONST	SEGMENT
__real@3c888889 DD 03c888889r			; 0.0166667
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@1e3ce508
CONST	SEGMENT
__real@1e3ce508 DD 01e3ce508r			; 1e-20
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OPOHHHAC@DragDrop?3?5?$CFd?0?5SourceId?5?$DN?50x?$CF08X@
CONST	SEGMENT
??_C@_0DJ@OPOHHHAC@DragDrop?3?5?$CFd?0?5SourceId?5?$DN?50x?$CF08X@ DB 'Dr'
	DB	'agDrop: %d, SourceId = 0x%08X, Payload "%s" (%d bytes)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MDEMGJOE@NavWindowingTarget?3?5?8?$CFlld?8@
CONST	SEGMENT
??_C@_0BL@MDEMGJOE@NavWindowingTarget?3?5?8?$CFlld?8@ DB 'NavWindowingTar'
	DB	'get: ''%lld''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PBLGJJAI@NavDisableHighlight?3?5?$CFd?0?5NavDis@
CONST	SEGMENT
??_C@_0DC@PBLGJJAI@NavDisableHighlight?3?5?$CFd?0?5NavDis@ DB 'NavDisable'
	DB	'Highlight: %d, NavDisableMouseHover: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FMBJOEO@NavActivateId?3?50x?$CF08X?0?5NavInput@
CONST	SEGMENT
??_C@_0CK@FMBJOEO@NavActivateId?3?50x?$CF08X?0?5NavInput@ DB 'NavActivate'
	DB	'Id: 0x%08X, NavInputId: 0x%08X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PADIALFI@NavActive?3?5?$CFd?0?5NavVisible?3?5?$CFd@
CONST	SEGMENT
??_C@_0BO@PADIALFI@NavActive?3?5?$CFd?0?5NavVisible?3?5?$CFd@ DB 'NavActi'
	DB	've: %d, NavVisible: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HIKDFBG@NavInputSource?3?5?$CFs@
CONST	SEGMENT
??_C@_0BD@HIKDFBG@NavInputSource?3?5?$CFs@ DB 'NavInputSource: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KFFINKHC@NavId?3?50x?$CF08X?0?5NavLayer?3?5?$CFd@
CONST	SEGMENT
??_C@_0BM@KFFINKHC@NavId?3?50x?$CF08X?0?5NavLayer?3?5?$CFd@ DB 'NavId: 0x'
	DB	'%08X, NavLayer: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLCAEKMP@NavWindow?3?5?8?$CFlld?8@
CONST	SEGMENT
??_C@_0BC@NLCAEKMP@NavWindow?3?5?8?$CFlld?8@ DB 'NavWindow: ''%lld''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CFCDIHDM@MovingWindow?3?5?8?$CFlld?8@
CONST	SEGMENT
??_C@_0BF@CFCDIHDM@MovingWindow?3?5?8?$CFlld?8@ DB 'MovingWindow: ''%lld'''
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CKLACKBD@ActiveIdWindow?3?5?8?$CFlld?8@
CONST	SEGMENT
??_C@_0BH@CKLACKBD@ActiveIdWindow?3?5?8?$CFlld?8@ DB 'ActiveIdWindow: ''%'
	DB	'lld''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PEJDHKLE@ActiveId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5s@
CONST	SEGMENT
??_C@_0EB@PEJDHKLE@ActiveId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5s@ DB 'A'
	DB	'ctiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: '
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FAAGHPBL@HoveredId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5@
CONST	SEGMENT
??_C@_0DG@FAAGHPBL@HoveredId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5@ DB 'H'
	DB	'overedId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PENLHICC@HoveredRootWindow?3?5?8?$CFlld?8@
CONST	SEGMENT
??_C@_0BK@PENLHICC@HoveredRootWindow?3?5?8?$CFlld?8@ DB 'HoveredRootWindo'
	DB	'w: ''%lld''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CLFHKGNJ@HoveredWindow?3?5?8?$CFlld?8@
CONST	SEGMENT
??_C@_0BG@CLFHKGNJ@HoveredWindow?3?5?8?$CFlld?8@ DB 'HoveredWindow: ''%ll'
	DB	'd''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GFEAGONP@NavGamepad@
CONST	SEGMENT
??_C@_0L@GFEAGONP@NavGamepad@ DB 'NavGamepad', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BGJILJC@NavKeyboard@
CONST	SEGMENT
??_C@_0M@BGJILJC@NavKeyboard@ DB 'NavKeyboard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFAAHAIK@Nav@
CONST	SEGMENT
??_C@_03JFAAHAIK@Nav@ DB 'Nav', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEEFLODH@Mouse@
CONST	SEGMENT
??_C@_05PEEFLODH@Mouse@ DB 'Mouse', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None@
CONST	SEGMENT
??_C@_04OHJIHAFH@None@ DB 'None', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKNCHHLP@Internal?5state@
CONST	SEGMENT
??_C@_0P@DKNCHHLP@Internal?5state@ DB 'Internal state', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBICDJOO@TabBars@
CONST	SEGMENT
??_C@_07NBICDJOO@TabBars@ DB 'TabBars', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JLIGAOM@Tab?5Bars?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0O@JLIGAOM@Tab?5Bars?5?$CI?$CFd?$CJ@ DB 'Tab Bars (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KHIGFAF@PopupID?3?5?$CF08x?0?5Window?3?5?8?$CFlld?8?$CFs@
CONST	SEGMENT
??_C@_0CC@KHIGFAF@PopupID?3?5?$CF08x?0?5Window?3?5?8?$CFlld?8?$CFs@ DB 'P'
	DB	'opupID: %08x, Window: ''%lld''%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFCBFAEB@?5ChildWindow@
CONST	SEGMENT
??_C@_0N@FFCBFAEB@?5ChildWindow@ DB ' ChildWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMJPHOMG@?5ChildMenu@
CONST	SEGMENT
??_C@_0L@CMJPHOMG@?5ChildMenu@ DB ' ChildMenu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENDEIGLN@Popups@
CONST	SEGMENT
??_C@_06ENDEIGLN@Popups@ DB 'Popups', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMLJJLKO@Popups?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0M@CMLJJLKO@Popups?5?$CI?$CFd?$CJ@ DB 'Popups (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JOELHCIA@Active?5DrawLists?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BG@JOELHCIA@Active?5DrawLists?5?$CI?$CFd?$CJ@ DB 'Active DrawLists'
	DB	' (%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDLFNPGN@Windows@
CONST	SEGMENT
??_C@_07LDLFNPGN@Windows@ DB 'Windows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BAAKGIGK@Ctrl?5shows?5window?5begin?5order@
CONST	SEGMENT
??_C@_0BO@BAAKGIGK@Ctrl?5shows?5window?5begin?5order@ DB 'Ctrl shows wind'
	DB	'ow begin order', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PLCAEOIM@Show?5clipping?5rectangles?5when?5h@
CONST	SEGMENT
??_C@_0DF@PLCAEOIM@Show?5clipping?5rectangles?5when?5h@ DB 'Show clipping'
	DB	' rectangles when hovering draw commands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EGHDCIHB@?$CFd?5allocations@
CONST	SEGMENT
??_C@_0P@EGHDCIHB@?$CFd?5allocations@ DB '%d allocations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OPGGNCEP@?$CFd?5active?5windows?5?$CI?$CFd?5visible?$CJ@
CONST	SEGMENT
??_C@_0BP@OPGGNCEP@?$CFd?5active?5windows?5?$CI?$CFd?5visible?$CJ@ DB '%d'
	DB	' active windows (%d visible)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HHKODNBE@?$CFd?5vertices?0?5?$CFd?5indices?5?$CI?$CFd?5tri@
CONST	SEGMENT
??_C@_0CH@HHKODNBE@?$CFd?5vertices?0?5?$CFd?5indices?5?$CI?$CFd?5tri@ DB '%'
	DB	'd vertices, %d indices (%d triangles)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EIPBEGMP@Application?5average?5?$CF?43f?5ms?1fra@
CONST	SEGMENT
??_C@_0CN@EIPBEGMP@Application?5average?5?$CF?43f?5ms?1fra@ DB 'Applicati'
	DB	'on average %.3f ms/frame (%.1f FPS)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NCHBJMJF@Dear?5ImGui?5?$CFs@
CONST	SEGMENT
??_C@_0O@NCHBJMJF@Dear?5ImGui?5?$CFs@ DB 'Dear ImGui %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMODJGLN@ImGui?5Metrics@
CONST	SEGMENT
??_C@_0O@JMODJGLN@ImGui?5Metrics@ DB 'ImGui Metrics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHDMGCPM@?$CF02d?$CFc?5Tab?50x?$CF08X@
CONST	SEGMENT
??_C@_0BC@NHDMGCPM@?$CF02d?$CFc?5Tab?50x?$CF08X@ DB '%02d%c Tab 0x%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HNMBCOGC@TabBar?5?$CI?$CFd?5tabs?$CJ?$CFs@
CONST	SEGMENT
??_C@_0BD@HNMBCOGC@TabBar?5?$CI?$CFd?5tabs?$CJ?$CFs@ DB 'TabBar (%d tabs)'
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDILNFHC@?5?$CKInactive?$CK@
CONST	SEGMENT
??_C@_0M@MDILNFHC@?5?$CKInactive?$CK@ DB ' *Inactive*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes@
CONST	SEGMENT
??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes@ DB 'Storage: %d bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CPAFBJNN@Column?5?$CF02d?3?5OffsetNorm?5?$CF?43f?5?$CI?$DN@
CONST	SEGMENT
??_C@_0CJ@CPAFBJNN@Column?5?$CF02d?3?5OffsetNorm?5?$CF?43f?5?$CI?$DN@ DB 'C'
	DB	'olumn %02d: OffsetNorm %.3f (= %.1f px)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PKFCLBKA@Width?3?5?$CF?41f?5?$CIMinX?3?5?$CF?41f?0?5MaxX?3?5@
CONST	SEGMENT
??_C@_0CF@PKFCLBKA@Width?3?5?$CF?41f?5?$CIMinX?3?5?$CF?41f?0?5MaxX?3?5@ DB 'W'
	DB	'idth: %.1f (MinX: %.1f, MaxX: %.1f)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LMOAIACO@Columns?5Id?3?50x?$CF08X?0?5Count?3?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0CN@LMOAIACO@Columns?5Id?3?50x?$CF08X?0?5Count?3?5?$CFd?0?5@ DB 'Co'
	DB	'lumns Id: 0x%08X, Count: %d, Flags: 0x%04X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBCCJKML@Columns@
CONST	SEGMENT
??_C@_07IBCCJKML@Columns@ DB 'Columns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FIDDFLAI@Columns?5sets?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BC@FIDDFLAI@Columns?5sets?5?$CI?$CFd?$CJ@ DB 'Columns sets (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGDHDNPO@ChildWindows@
CONST	SEGMENT
??_C@_0N@BGDHDNPO@ChildWindows@ DB 'ChildWindows', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BPPHAMMO@ParentWindow@
CONST	SEGMENT
??_C@_0N@BPPHAMMO@ParentWindow@ DB 'ParentWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EHLMOHOL@RootWindow@
CONST	SEGMENT
??_C@_0L@EHLMOHOL@RootWindow@ DB 'RootWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KHCECGOM@NavRectRel?$FL0?$FN?3?5?$DMNone?$DO@
CONST	SEGMENT
??_C@_0BG@KHCECGOM@NavRectRel?$FL0?$FN?3?5?$DMNone?$DO@ DB 'NavRectRel[0]'
	DB	': <None>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HFMDFCIJ@NavRectRel?$FL0?$FN?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$CI?$CF?41f@
CONST	SEGMENT
??_C@_0CG@HFMDFCIJ@NavRectRel?$FL0?$FN?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$CI?$CF?41f@ DB 'N'
	DB	'avRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NPFIBFIA@NavLastChildNavWindow?3?5?$CFlld@
CONST	SEGMENT
??_C@_0BM@NPFIBFIA@NavLastChildNavWindow?3?5?$CFlld@ DB 'NavLastChildNavW'
	DB	'indow: %lld', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CFCLKJDH@NavLastIds?3?50x?$CF08X?00x?$CF08X?0?5NavL@
CONST	SEGMENT
??_C@_0DC@CFCLKJDH@NavLastIds?3?50x?$CF08X?00x?$CF08X?0?5NavL@ DB 'NavLas'
	DB	'tIds: 0x%08X,0x%08X, NavLayerActiveMask: %X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DJJIBEFM@Appearing?3?5?$CFd?0?5Hidden?3?5?$CFd?5?$CIReg?5@
CONST	SEGMENT
??_C@_0DM@DJJIBEFM@Appearing?3?5?$CFd?0?5Hidden?3?5?$CFd?5?$CIReg?5@ DB 'A'
	DB	'ppearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LPCMGHLI@Active?3?5?$CFd?1?$CFd?0?5WriteAccessed?3?5?$CF@
CONST	SEGMENT
??_C@_0DO@LPCMGHLI@Active?3?5?$CFd?1?$CFd?0?5WriteAccessed?3?5?$CF@ DB 'A'
	DB	'ctive: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JAHLHNNL@Scroll?3?5?$CI?$CF?42f?1?$CF?42f?0?$CF?42f?1?$CF?42f?$CJ@
CONST	SEGMENT
??_C@_0BO@JAHLHNNL@Scroll?3?5?$CI?$CF?42f?1?$CF?42f?0?$CF?42f?1?$CF?42f?$CJ@ DB 'S'
	DB	'croll: (%.2f/%.2f,%.2f/%.2f)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HFFEAFCN@Flags?3?50x?$CF08X?5?$CI?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs@
CONST	SEGMENT
??_C@_0CF@HFFEAFCN@Flags?3?50x?$CF08X?5?$CI?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs@ DB 'F'
	DB	'lags: 0x%08X (%s%s%s%s%s%s%s%s%s..)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MMFPNIIL@Child?5@
CONST	SEGMENT
??_C@_06MMFPNIIL@Child?5@ DB 'Child ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGECAIGF@Tooltip?5@
CONST	SEGMENT
??_C@_08LGECAIGF@Tooltip?5@ DB 'Tooltip ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMKCIICK@Popup?5@
CONST	SEGMENT
??_C@_06NMKCIICK@Popup?5@ DB 'Popup ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFIMNOLK@Modal?5@
CONST	SEGMENT
??_C@_06IFIMNOLK@Modal?5@ DB 'Modal ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPMMHACC@ChildMenu?5@
CONST	SEGMENT
??_C@_0L@OPMMHACC@ChildMenu?5@ DB 'ChildMenu ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EBNDPMCP@NoSavedSettings?5@
CONST	SEGMENT
??_C@_0BB@EBNDPMCP@NoSavedSettings?5@ DB 'NoSavedSettings ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LAPEOEIJ@NoMouseInputs@
CONST	SEGMENT
??_C@_0O@LAPEOEIJ@NoMouseInputs@ DB 'NoMouseInputs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COLEABDL@NoNavInputs@
CONST	SEGMENT
??_C@_0M@COLEABDL@NoNavInputs@ DB 'NoNavInputs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEIPOID@AlwaysAutoResize@
CONST	SEGMENT
??_C@_0BB@GGEIPOID@AlwaysAutoResize@ DB 'AlwaysAutoResize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PMCJMPLH@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5Size?3?5?$CI?$CF?41f?0?$CF@
CONST	SEGMENT
??_C@_0DO@PMCJMPLH@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5Size?3?5?$CI?$CF?41f?0?$CF@ DB 'P'
	DB	'os: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJNCDCKF@DrawList@
CONST	SEGMENT
??_C@_08IJNCDCKF@DrawList@ DB 'DrawList', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp@
CONST	SEGMENT
??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp@ DB '%s ''%s'''
	DB	', %d @ 0x%p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06BKKJGDHO@Window@
CONST	SEGMENT
??_C@_06BKKJGDHO@Window@ DB 'Window', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ@ DB '%s (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MPIFBGBG@?$CFs?5?$CF04d?3?5pos?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5uv?5@
CONST	SEGMENT
??_C@_0DG@MPIFBGBG@?$CFs?5?$CF04d?3?5pos?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5uv?5@ DB '%'
	DB	's %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDEAONJP@?5?5?5@
CONST	SEGMENT
??_C@_03NDEAONJP@?5?5?5@ DB '   ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAKNAIGI@idx@
CONST	SEGMENT
??_C@_03DAKNAIGI@idx@ DB 'idx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BKFKDBKJ@Draw?5?$CF4d?5?$CFs?5vtx?0?5tex?50x?$CFp?0?5clip@
CONST	SEGMENT
??_C@_0EB@BKFKDBKJ@Draw?5?$CF4d?5?$CFs?5vtx?0?5tex?50x?$CFp?0?5clip@ DB 'D'
	DB	'raw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0'
	DB	'f)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NGJKDAN@non?9indexed@
CONST	SEGMENT
??_C@_0M@NGJKDAN@non?9indexed@ DB 'non-indexed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNEBDGNE@indexed@
CONST	SEGMENT
??_C@_07KNEBDGNE@indexed@ DB 'indexed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp@
CONST	SEGMENT
??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp@ DB 'Callback %p, '
	DB	'user_data %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING@
CONST	SEGMENT
??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING@ DB 'CURRENTLY APPENDING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BMBAOAAJ@?$CFs?3?5?8?$CFlld?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5@
CONST	SEGMENT
??_C@_0CH@BMBAOAAJ@?$CFs?3?5?8?$CFlld?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5@ DB '%'
	DB	's: ''%lld'' %d vtx, %d indices, %d cmds', 00H ; `string'
CONST	ENDS
;	COMDAT ?show_draw_cmd_clip_rects@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA
_DATA	SEGMENT
?show_draw_cmd_clip_rects@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA DB 01H ; `ImGui::ShowMetricsWindow'::`2'::show_draw_cmd_clip_rects
_DATA	ENDS
;	COMDAT ??_C@_0O@KMAIKFAM@?$CDSourceExtern@
CONST	SEGMENT
??_C@_0O@KMAIKFAM@?$CDSourceExtern@ DB '#SourceExtern', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HIFEPIJN@columns@
CONST	SEGMENT
??_C@_07HIFEPIJN@columns@ DB 'columns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOFNFKBH@void_context@
CONST	SEGMENT
??_C@_0N@OOFNFKBH@void_context@ DB 'void_context', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DCJGJLLM@window_context@
CONST	SEGMENT
??_C@_0P@DCJGJLLM@window_context@ DB 'window_context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DKJDPJG@?$CD?$CD?$CL?9P?4o?4p?4u?4p_?$CL?9?$CF08x@
CONST	SEGMENT
??_C@_0BF@DKJDPJG@?$CD?$CD?$CL?9P?4o?4p?4u?4p_?$CL?9?$CF08x@ DB '##+-P.o.'
	DB	'p.u.p_+-%08x', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IMJHKMJC@?$CD?$CD?$CL?9M?4e?4n?4u_?$CL?9?$CF02d@
CONST	SEGMENT
??_C@_0BD@IMJHKMJC@?$CD?$CD?$CL?9M?4e?4n?4u_?$CL?9?$CF02d@ DB '##+-M.e.n.'
	DB	'u_+-%02d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PMCDEDKJ@?$CD?$CD?$CL?9Tooip?$CL?9_?$CF02d@
CONST	SEGMENT
??_C@_0BB@PMCDEDKJ@?$CD?$CD?$CL?9Tooip?$CL?9_?$CF02d@ DB '##+-Tooip+-_%02'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JOEAHKNC@ModalWindowDimBg@
CONST	SEGMENT
??_C@_0BB@JOEAHKNC@ModalWindowDimBg@ DB 'ModalWindowDimBg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHKONDGH@NavWindowingDimBg@
CONST	SEGMENT
??_C@_0BC@JHKONDGH@NavWindowingDimBg@ DB 'NavWindowingDimBg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCGDEFOI@NavWindowingHighlight@
CONST	SEGMENT
??_C@_0BG@MCGDEFOI@NavWindowingHighlight@ DB 'NavWindowingHighlight', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENCIHEPH@NavHighlight@
CONST	SEGMENT
??_C@_0N@ENCIHEPH@NavHighlight@ DB 'NavHighlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDDMCLOI@DragDropTarget@
CONST	SEGMENT
??_C@_0P@GDDMCLOI@DragDropTarget@ DB 'DragDropTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IBBLAEBJ@TextSelectedBg@
CONST	SEGMENT
??_C@_0P@IBBLAEBJ@TextSelectedBg@ DB 'TextSelectedBg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJALJGDC@PlotHistogramHovered@
CONST	SEGMENT
??_C@_0BF@GJALJGDC@PlotHistogramHovered@ DB 'PlotHistogramHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EEKOCENA@PlotHistogram@
CONST	SEGMENT
??_C@_0O@EEKOCENA@PlotHistogram@ DB 'PlotHistogram', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OMALNJLN@PlotLinesHovered@
CONST	SEGMENT
??_C@_0BB@OMALNJLN@PlotLinesHovered@ DB 'PlotLinesHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDJFFJLL@PlotLines@
CONST	SEGMENT
??_C@_09HDJFFJLL@PlotLines@ DB 'PlotLines', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMEALEPP@TabUnfocusedActive@
CONST	SEGMENT
??_C@_0BD@JMEALEPP@TabUnfocusedActive@ DB 'TabUnfocusedActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLEENDFP@TabUnfocused@
CONST	SEGMENT
??_C@_0N@KLEENDFP@TabUnfocused@ DB 'TabUnfocused', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLMKPFCF@TabActive@
CONST	SEGMENT
??_C@_09BLMKPFCF@TabActive@ DB 'TabActive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFDLBKBD@TabHovered@
CONST	SEGMENT
??_C@_0L@JFDLBKBD@TabHovered@ DB 'TabHovered', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEAKBACE@Tab@
CONST	SEGMENT
??_C@_03IEAKBACE@Tab@ DB 'Tab', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NBBKHKIC@ResizeGripActive@
CONST	SEGMENT
??_C@_0BB@NBBKHKIC@ResizeGripActive@ DB 'ResizeGripActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NNEDPMNH@ResizeGripHovered@
CONST	SEGMENT
??_C@_0BC@NNEDPMNH@ResizeGripHovered@ DB 'ResizeGripHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NGBDNFNJ@ResizeGrip@
CONST	SEGMENT
??_C@_0L@NGBDNFNJ@ResizeGrip@ DB 'ResizeGrip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BPNGFOJM@SeparatorActive@
CONST	SEGMENT
??_C@_0BA@BPNGFOJM@SeparatorActive@ DB 'SeparatorActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHICANJA@SeparatorHovered@
CONST	SEGMENT
??_C@_0BB@CHICANJA@SeparatorHovered@ DB 'SeparatorHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBFEOKHN@Separator@
CONST	SEGMENT
??_C@_09IBFEOKHN@Separator@ DB 'Separator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HILFCJOI@HeaderActive@
CONST	SEGMENT
??_C@_0N@HILFCJOI@HeaderActive@ DB 'HeaderActive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HAINNLMC@HeaderHovered@
CONST	SEGMENT
??_C@_0O@HAINNLMC@HeaderHovered@ DB 'HeaderHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OENKJGA@Header@
CONST	SEGMENT
??_C@_06OENKJGA@Header@ DB 'Header', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IMHOFKJ@ButtonActive@
CONST	SEGMENT
??_C@_0N@IMHOFKJ@ButtonActive@ DB 'ButtonActive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HBCGNIAI@ButtonHovered@
CONST	SEGMENT
??_C@_0O@HBCGNIAI@ButtonHovered@ DB 'ButtonHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LKBCGDFD@Button@
CONST	SEGMENT
??_C@_06LKBCGDFD@Button@ DB 'Button', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HBOBMOMP@SliderGrabActive@
CONST	SEGMENT
??_C@_0BB@HBOBMOMP@SliderGrabActive@ DB 'SliderGrabActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LAMBADIC@SliderGrab@
CONST	SEGMENT
??_C@_0L@LAMBADIC@SliderGrab@ DB 'SliderGrab', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMKAANGE@CheckMark@
CONST	SEGMENT
??_C@_09DMKAANGE@CheckMark@ DB 'CheckMark', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GODMFNCF@ScrollbarGrabActive@
CONST	SEGMENT
??_C@_0BE@GODMFNCF@ScrollbarGrabActive@ DB 'ScrollbarGrabActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFEOOMLL@ScrollbarGrabHovered@
CONST	SEGMENT
??_C@_0BF@JFEOOMLL@ScrollbarGrabHovered@ DB 'ScrollbarGrabHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HABIDNBE@ScrollbarGrab@
CONST	SEGMENT
??_C@_0O@HABIDNBE@ScrollbarGrab@ DB 'ScrollbarGrab', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MFDHPFJF@ScrollbarBg@
CONST	SEGMENT
??_C@_0M@MFDHPFJF@ScrollbarBg@ DB 'ScrollbarBg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GEKCKLDE@MenuBarBg@
CONST	SEGMENT
??_C@_09GEKCKLDE@MenuBarBg@ DB 'MenuBarBg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EGCOMBJG@TitleBgCollapsed@
CONST	SEGMENT
??_C@_0BB@EGCOMBJG@TitleBgCollapsed@ DB 'TitleBgCollapsed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JHBFJHNE@TitleBgActive@
CONST	SEGMENT
??_C@_0O@JHBFJHNE@TitleBgActive@ DB 'TitleBgActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMLEKCPI@TitleBg@
CONST	SEGMENT
??_C@_07MMLEKCPI@TitleBg@ DB 'TitleBg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BGDCDDEA@FrameBgActive@
CONST	SEGMENT
??_C@_0O@BGDCDDEA@FrameBgActive@ DB 'FrameBgActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KIOOHHAC@FrameBgHovered@
CONST	SEGMENT
??_C@_0P@KIOOHHAC@FrameBgHovered@ DB 'FrameBgHovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJIIOGAC@FrameBg@
CONST	SEGMENT
??_C@_07PJIIOGAC@FrameBg@ DB 'FrameBg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DECGFAEC@BorderShadow@
CONST	SEGMENT
??_C@_0N@DECGFAEC@BorderShadow@ DB 'BorderShadow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMOGDIBK@Border@
CONST	SEGMENT
??_C@_06CMOGDIBK@Border@ DB 'Border', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKIIIJHA@PopupBg@
CONST	SEGMENT
??_C@_07LKIIIJHA@PopupBg@ DB 'PopupBg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BLEJOHFO@ChildBg@
CONST	SEGMENT
??_C@_07BLEJOHFO@ChildBg@ DB 'ChildBg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMKFNKPN@WindowBg@
CONST	SEGMENT
??_C@_08DMKFNKPN@WindowBg@ DB 'WindowBg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LNHHFNPK@TextDisabled@
CONST	SEGMENT
??_C@_0N@LNHHFNPK@TextDisabled@ DB 'TextDisabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OJAHODMC@Text@
CONST	SEGMENT
??_C@_04OJAHODMC@Text@ DB 'Text', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KIIKKNMI@?$CDCLOSE@
CONST	SEGMENT
??_C@_06KIIKKNMI@?$CDCLOSE@ DB '#CLOSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BJOGEADB@?$CDCOLLAPSE@
CONST	SEGMENT
??_C@_09BJOGEADB@?$CDCOLLAPSE@ DB '#COLLAPSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDHBJEOI@?$CDRESIZE@
CONST	SEGMENT
??_C@_07HDHBJEOI@?$CDRESIZE@ DB '#RESIZE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONMJNNOG@?$CFlld?9?$CF08X@
CONST	SEGMENT
??_C@_09ONMJNNOG@?$CFlld?9?$CF08X@ DB '%lld-%08X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCJDMNMD@?$CFlld?9?$CFs?$CL?$CF08X@
CONST	SEGMENT
??_C@_0N@CCJDMNMD@?$CFlld?9?$CFs?$CL?$CF08X@ DB '%lld-%s+%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHICJKCI@?4?4?4@
CONST	SEGMENT
??_C@_03KHICJKCI@?4?4?4@ DB '...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MCAEODGB@Default@
CONST	SEGMENT
??_C@_07MCAEODGB@Default@ DB 'Default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJCOBEBF@?$CDMOVE@
CONST	SEGMENT
??_C@_05EJCOBEBF@?$CDMOVE@ DB '#MOVE', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?GImAllocatorAllocFunc@@3P6APEAX_KPEAX@ZEA DQ FLAT:?MallocWrapper@@YAPEAX_KPEAX@Z ; GImAllocatorAllocFunc
?GImAllocatorFreeFunc@@3P6AXPEAX0@ZEA DQ FLAT:?FreeWrapper@@YAXPEAX0@Z ; GImAllocatorFreeFunc
_DATA	ENDS
;	COMDAT ??_C@_07JLDOGPMM@?$CD?$CD?$CL?9oly@
CONST	SEGMENT
??_C@_07JLDOGPMM@?$CD?$CD?$CL?9oly@ DB '##+-oly', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eresize_grip_def@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z DD 011101H
	DD	06211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z DD 010c01H
	DD	0620cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNavInputDown@ImGui@@YA_NH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsKeyPressedMap@ImGui@@YA_NH_N@Z DD 010c01H
	DD	0620cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImGuiTabBar@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiTabBar@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiTabBar@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiTabBar@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiTabBar@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiTabBar@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiTabBar@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiTabBar@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImGuiWindow@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MenuBarHeight@ImGuiWindow@@QEBAMXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TitleBarHeight@ImGuiWindow@@QEBAMXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@I@@QEAAXAEBI@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@I@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@I@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@I@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@I@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@I@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@I@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@I@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@I@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiWindowTempData@@QEAA@XZ DB 0cH
	DB	00H
	DB	00H
	DB	012H
	DB	08H
	DB	'('
	DB	06H
	DB	'('
	DB	04H
	DB	'('
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiWindowTempData@@QEAA@XZ DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiWindowTempData@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiWindowTempData@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiWindowTempData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiWindowTempData@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiWindowTempData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiWindowTempData@@QEAA@XZ DB 0eH
	DB	00H
	DB	00H
	DB	0f9H, 02H
	DB	02H
	DB	'Z'
	DB	04H
	DB	'.'
	DB	06H
	DB	'.'
	DB	08H
	DB	'.'
	DB	0aH
	DB	'Q', 0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiWindowTempData@@QEAA@XZ DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImGuiWindowTempData@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiWindowTempData@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiWindowTempData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiWindowTempData@@QEAA@XZ DD 030b11H
	DD	07007c20bH
	DD	06006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiWindowTempData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImGuiContext@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiContext@@QEAA@XZ DB ','
	DB	00H
	DB	00H
	DB	012H
	DB	'('
	DB	'('
	DB	'&'
	DB	'('
	DB	'$'
	DB	'('
	DB	'"'
	DB	'('
	DB	' '
	DB	'('
	DB	01eH
	DB	'('
	DB	01cH
	DB	'('
	DB	01aH
	DB	'('
	DB	018H
	DB	'('
	DB	016H
	DB	'('
	DB	014H
	DB	'('
	DB	012H
	DB	'('
	DB	010H
	DB	'('
	DB	0eH
	DB	'('
	DB	0cH
	DB	'('
	DB	0aH
	DB	'('
	DB	08H
	DB	'('
	DB	06H
	DB	'('
	DB	04H
	DB	'('
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiContext@@QEAA@XZ DB 02aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiContext@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiContext@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiContext@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiContext@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiContext@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z DB '2'
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	086H
	DB	04H
	DB	'.'
	DB	06H
	DB	'.'
	DB	08H
	DB	'.'
	DB	0aH
	DB	'.'
	DB	0cH
	DB	'.'
	DB	0eH
	DB	086H
	DB	010H
	DB	'.'
	DB	012H
	DB	'.'
	DB	014H
	DB	'.'
	DB	016H
	DB	091H, 02H
	DB	018H
	DB	'.'
	DB	01aH
	DB	'.'
	DB	01cH
	DB	086H
	DB	01eH
	DB	'.'
	DB	' '
	DB	'.'
	DB	'"'
	DB	'.'
	DB	'$'
	DB	'.'
	DB	'&'
	DB	'.'
	DB	'('
	DB	'Z'
	DB	'*'
	DB	'E', 04H
	DB	','
	DB	'X'
	DB	'*'
	DB	0ddH, 01fH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z DB 02cH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z
	DD	imagerel $ip2state$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z DD 041311H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	012H
	DB	04H
	DB	016H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ
	DD	imagerel $ip2state$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'$'
	DB	04H
	DB	018H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ
	DD	imagerel $ip2state$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@E@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@E@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@E@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@E@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@E@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@E@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@E@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@E@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@E@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiNextWindowData@@QEAA@XZ DD 030b01H
	DD	07007a20bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImGuiNavMoveResult@@QEAAXXZ DD 030b01H
	DD	07007620bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiNavMoveResult@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImDrawDataBuilder@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImDrawDataBuilder@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImDrawDataBuilder@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImDrawDataBuilder@@QEAA@XZ
	DD	imagerel $ip2state$??1ImDrawDataBuilder@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImDrawDataBuilder@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImDrawDataBuilder@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImDrawDataBuilder@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImDrawDataBuilder@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImDrawDataBuilder@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImDrawDataBuilder@@QEAA@XZ
	DD	imagerel $ip2state$??0ImDrawDataBuilder@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawDataBuilder@@QEAA@XZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImDrawDataBuilder@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImDrawDataBuilder@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImGuiColumnsSet@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiColumnsSet@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiColumnsSet@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiColumnsSet@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiColumnsSet@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiColumnsSet@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiColumnsSet@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiColumnsSet@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImGuiColumnsSet@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiColumnsSet@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiColumnsSet@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImGuiColumnsSet@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiColumnsSet@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiColumnsSet@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiColumnsSet@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiColumnsSet@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiColumnData@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiPopupRef@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiInputTextState@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	012H
	DB	04H
	DB	'$'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiInputTextState@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiInputTextState@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiInputTextState@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiInputTextState@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiInputTextState@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiInputTextState@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiInputTextState@@QEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'&'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiInputTextState@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImGuiInputTextState@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiInputTextState@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiInputTextState@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiInputTextState@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiInputTextState@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiColorMod@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsInverted@ImRect@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClipWithFull@ImRect@@QEAAXAEBU1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClipWith@ImRect@@QEAAXAEBU1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Overlaps@ImRect@@QEBA_NAEBU1@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Contains@ImRect@@QEBA_NAEBU1@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBL@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTR@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSize@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@MMMM@Z DD 011b01H
	DD	0621bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@AEBUImVec4@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@M@@QEAAXAEBM@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@M@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@M@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@M@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@M@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@M@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@M@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@M@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@M@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@M@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFontAtlas@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAUImFont@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAUImFont@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@H@@QEAAXAEBH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@H@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@H@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@H@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@H@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@H@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@H@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@H@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImDrawData@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImDrawData@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImDrawData@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1ImDrawData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImDrawData@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImDrawData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawData@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathStroke@ImDrawList@@QEAAXI_NM@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImDrawList@@QEAA@XZ DB 012H
	DB	00H
	DB	00H
	DB	012H
	DB	0eH
	DB	016H
	DB	0cH
	DB	'('
	DB	0aH
	DB	'('
	DB	08H
	DB	'$'
	DB	06H
	DB	'$'
	DB	04H
	DB	'$'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImDrawList@@QEAA@XZ DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImDrawList@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImDrawList@@QEAA@XZ
	DD	imagerel $ip2state$??1ImDrawList@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImDrawList@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImDrawList@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DB 012H
	DB	00H
	DB	00H
	DB	'8'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'$'
	DB	08H
	DB	'$'
	DB	0aH
	DB	'('
	DB	0cH
	DB	'('
	DB	0eH
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
	DD	imagerel $ip2state$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImVec2@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImVec2@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImVec2@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImVec2@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImVec2@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAX@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAX@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAX@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAX@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAX@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImVec4@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImVec4@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImVec4@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImVec4@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImVec4@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawVert@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawVert@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiListClipper@@QEAA@HM@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiStorage@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiStorage@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiStorage@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiStorage@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiStorage@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiStorage@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiStorage@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiStorage@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiStorage@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImGuiStorage@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiStorage@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiStorage@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiStorage@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiStorage@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImGuiStorage@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiTextBuffer@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiTextBuffer@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiTextBuffer@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiTextBuffer@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiTextBuffer@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiTextBuffer@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiTextBuffer@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@D@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@D@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@D@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@D@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@D@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@D@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@D@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@D@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@D@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImGuiPayload@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiPayload@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiSizeCallbackData@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiIO@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiIO@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiIO@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiIO@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiIO@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiIO@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiIO@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@G@@QEAAXAEBG@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@G@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@G@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@G@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@G@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@G@@QEAA@XZ
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z
	DD	016H
	DD	01f4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z
	DD	020H
	DD	0913H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z
	DD	024H
	DD	02eaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z
	DD	016H
	DD	084H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z
	DD	025H
	DD	06a7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?BeginTooltipEx@ImGui@@YAXH_N@Z
	DD	016H
	DD	0f2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?BeginPopupEx@ImGui@@YA_NIH@Z
	DD	016H
	DD	0cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z
	DD	018H
	DD	0caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Begin@ImGui@@YA_NPEBDPEA_NH@Z
	DD	022H
	DD	03e9bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ShowMetricsWindow@ImGui@@YAXPEA_N@Z
	DD	016H
	DD	098aH
voltbl	ENDS
xdata	SEGMENT
$unwind$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z
$cppxdata$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z
	DD	imagerel $ip2state$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z
$stateUnwindMap$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA
$ip2state$?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	'b'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z DD 010901H
	DD	04209H
$unwind$?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K1111@Z DD 011801H
	DD	06218H
$unwind$?NewFrame@ImGui@@YAXXZ DD 040a01H
	DD	017010aH
	DD	060027003H
$unwind$?EndFrame@ImGui@@YAXXZ DD 020701H
	DD	0110107H
$unwind$?Render@ImGui@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ DD 010401H
	DD	02204H
$unwind$?ShowMetricsWindow@ImGui@@YAXPEA_N@Z DD 021e19H
	DD	02d010cH
	DD	imagerel __GSHandlerCheck
	DD	0158H
$unwind$?Begin@ImGui@@YA_NPEBDPEA_NH@Z DD 042a19H
	DD	010b0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0840H
$unwind$?End@ImGui@@YAXXZ DD 010401H
	DD	08204H
$unwind$?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z DD 011801H
	DD	08218H
$unwind$?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z DD 011701H
	DD	06217H
$unwind$?EndChild@ImGui@@YAXXZ DD 020701H
	DD	0170107H
$unwind$?IsWindowAppearing@ImGui@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?IsWindowCollapsed@ImGui@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?IsWindowFocused@ImGui@@YA_NH@Z DD 010801H
	DD	08208H
$unwind$?IsWindowHovered@ImGui@@YA_NH@Z DD 010801H
	DD	06208H
$unwind$?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ DD 010401H
	DD	06204H
$unwind$?GetWindowPos@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	02209H
$unwind$?GetWindowSize@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetWindowWidth@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?GetWindowHeight@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	0a209H
$unwind$?GetContentRegionAvailWidth@ImGui@@YAMXZ DD 010401H
	DD	06204H
$unwind$?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetWindowContentRegionWidth@ImGui@@YAMXZ DD 010401H
	DD	06204H
$unwind$?GetNextWindowPos@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	02209H
$unwind$?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z DD 011201H
	DD	02212H
$unwind$?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z DD 010d01H
	DD	0220dH
$unwind$?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z DD 010901H
	DD	02209H
$unwind$?SetNextWindowCollapsed@ImGui@@YAX_NH@Z DD 010c01H
	DD	0220cH
$unwind$?SetNextWindowFocus@ImGui@@YAXXZ DD 010401H
	DD	02204H
$unwind$?SetNextWindowBgAlpha@ImGui@@YAXM@Z DD 010a01H
	DD	0220aH
$unwind$?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z DD 010d01H
	DD	0620dH
$unwind$?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z DD 010d01H
	DD	0420dH
$unwind$?SetWindowCollapsed@ImGui@@YAX_NH@Z DD 010c01H
	DD	0420cH
$unwind$?SetWindowFocus@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?SetWindowFontScale@ImGui@@YAXM@Z DD 010a01H
	DD	0820aH
$unwind$?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z DD 011301H
	DD	06213H
$unwind$?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z DD 011301H
	DD	06213H
$unwind$?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z DD 011201H
	DD	06212H
$unwind$?SetWindowFocus@ImGui@@YAXPEBD@Z DD 010901H
	DD	06209H
$unwind$?GetScrollMaxX@ImGui@@YAMXZ DD 010401H
	DD	04204H
$unwind$?GetScrollMaxY@ImGui@@YAMXZ DD 010401H
	DD	04204H
$unwind$?SetScrollX@ImGui@@YAXM@Z DD 010a01H
	DD	0620aH
$unwind$?SetScrollY@ImGui@@YAXM@Z DD 010a01H
	DD	0620aH
$unwind$?SetScrollHereY@ImGui@@YAXM@Z DD 010a01H
	DD	0620aH
$unwind$?SetScrollFromPosY@ImGui@@YAXMM@Z DD 011001H
	DD	06210H
$unwind$?PushFont@ImGui@@YAXPEAUImFont@@@Z DD 010901H
	DD	08209H
$unwind$?PopFont@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?PushStyleColor@ImGui@@YAXHI@Z DD 030e01H
	DD	0700ac20eH
	DD	06009H
$unwind$?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z DD 030f01H
	DD	0700ba20fH
	DD	0600aH
$unwind$?PopStyleColor@ImGui@@YAXH@Z DD 030a01H
	DD	07006620aH
	DD	06005H
$unwind$?PushStyleVar@ImGui@@YAXHM@Z DD 010e01H
	DD	0a20eH
$unwind$?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z DD 010d01H
	DD	0a20dH
$unwind$?PopStyleVar@ImGui@@YAXH@Z DD 010801H
	DD	08208H
$unwind$?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z DD 010801H
	DD	02208H
$unwind$?GetColorU32@ImGui@@YAIHM@Z DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z DD 030b01H
	DD	07007820bH
	DD	06006H
$unwind$?GetColorU32@ImGui@@YAIQEAM@Z DD 010901H
	DD	0a209H
$unwind$?GetColorU32@ImGui@@YAII@Z DD 010801H
	DD	02208H
$unwind$?PushItemWidth@ImGui@@YAXM@Z DD 010a01H
	DD	0820aH
$unwind$?PopItemWidth@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?CalcItemWidth@ImGui@@YAMXZ DD 010401H
	DD	08204H
$unwind$?PushTextWrapPos@ImGui@@YAXM@Z DD 010a01H
	DD	0620aH
$unwind$?PopTextWrapPos@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?PushAllowKeyboardFocus@ImGui@@YAX_N@Z DD 010801H
	DD	06208H
$unwind$?PopAllowKeyboardFocus@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?PushButtonRepeat@ImGui@@YAX_N@Z DD 010801H
	DD	04208H
$unwind$?PopButtonRepeat@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?SameLine@ImGui@@YAXMMM@Z DD 011601H
	DD	06216H
$unwind$?Indent@ImGui@@YAXM@Z DD 010a01H
	DD	0820aH
$unwind$?Unindent@ImGui@@YAXM@Z DD 010a01H
	DD	0820aH
$unwind$?BeginGroup@ImGui@@YAXXZ DD 010401H
	DD	0a204H
$unwind$?EndGroup@ImGui@@YAXXZ DD 030701H
	DD	07003c207H
	DD	06002H
$unwind$?GetCursorPos@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	08209H
$unwind$?GetCursorPosX@ImGui@@YAMXZ DD 010401H
	DD	06204H
$unwind$?GetCursorPosY@ImGui@@YAMXZ DD 010401H
	DD	06204H
$unwind$?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z DD 010901H
	DD	08209H
$unwind$?SetCursorPosX@ImGui@@YAXM@Z DD 010a01H
	DD	0620aH
$unwind$?SetCursorPosY@ImGui@@YAXM@Z DD 010a01H
	DD	0620aH
$unwind$?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z DD 010901H
	DD	06209H
$unwind$?GetTextLineHeight@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?GetTextLineHeightWithSpacing@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?GetFrameHeight@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?GetFrameHeightWithSpacing@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?PushID@ImGui@@YAXPEBD@Z DD 010901H
	DD	08209H
$unwind$?PushID@ImGui@@YAXPEBD0@Z DD 010e01H
	DD	0820eH
$unwind$?PushID@ImGui@@YAXPEBX@Z DD 010901H
	DD	08209H
$unwind$?PushID@ImGui@@YAXH@Z DD 010801H
	DD	08208H
$unwind$?PopID@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?GetID@ImGui@@YAIPEBD@Z DD 010901H
	DD	06209H
$unwind$?GetID@ImGui@@YAIPEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?GetID@ImGui@@YAIPEBX@Z DD 010901H
	DD	06209H
$unwind$?BeginTooltip@ImGui@@YAXXZ DD 010401H
	DD	08204H
$unwind$?EndTooltip@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?SetTooltip@ImGui@@YAXPEBDZZ DD 011801H
	DD	06218H
$unwind$?SetTooltipV@ImGui@@YAXPEBDPEAD@Z DD 010e01H
	DD	0620eH
$unwind$?OpenPopup@ImGui@@YAXPEBD@Z DD 010901H
	DD	06209H
$unwind$?BeginPopup@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z DD 011201H
	DD	06212H
$unwind$?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z DD 011301H
	DD	0c213H
$unwind$?EndPopup@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?IsPopupOpen@ImGui@@YA_NPEBD@Z DD 010901H
	DD	08209H
$unwind$?CloseCurrentPopup@ImGui@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?Columns@ImGui@@YAXHPEBD_N@Z DD 011201H
	DD	06212H
$unwind$?NextColumn@ImGui@@YAXXZ DD 010401H
	DD	0c204H
$unwind$?GetColumnIndex@ImGui@@YAHXZ DD 010401H
	DD	06204H
$unwind$?GetColumnWidth@ImGui@@YAMH@Z DD 010801H
	DD	0a208H
$unwind$?SetColumnWidth@ImGui@@YAXHM@Z DD 010e01H
	DD	0620eH
$unwind$?GetColumnOffset@ImGui@@YAMH@Z DD 010801H
	DD	08208H
$unwind$?SetColumnOffset@ImGui@@YAXHM@Z DD 010e01H
	DD	0c20eH
$unwind$?GetColumnsCount@ImGui@@YAHXZ DD 010401H
	DD	06204H
$unwind$?BeginDragDropSource@ImGui@@YA_NH@Z DD 010801H
	DD	0c208H
$unwind$?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z DD 011801H
	DD	0a218H
$unwind$?EndDragDropSource@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?BeginDragDropTarget@ImGui@@YA_NXZ DD 030701H
	DD	07003a207H
	DD	06002H
$unwind$?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z DD 041201H
	DD	01d0112H
	DD	0600a700bH
$unwind$?EndDragDropTarget@ImGui@@YAXXZ DD 010401H
	DD	02204H
$unwind$?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ DD 010401H
	DD	02204H
$unwind$?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z DD 031501H
	DD	070118215H
	DD	06010H
$unwind$?PopClipRect@ImGui@@YAXXZ DD 030701H
	DD	070038207H
	DD	06002H
$unwind$?SetItemDefaultFocus@ImGui@@YAXXZ DD 030701H
	DD	07003c207H
	DD	06002H
$unwind$?SetKeyboardFocusHere@ImGui@@YAXH@Z DD 010801H
	DD	06208H
$unwind$?IsItemHovered@ImGui@@YA_NH@Z DD 010801H
	DD	06208H
$unwind$?IsItemActive@ImGui@@YA_NXZ DD 010401H
	DD	04204H
$unwind$?IsItemFocused@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?IsItemClicked@ImGui@@YA_NH@Z DD 010801H
	DD	06208H
$unwind$?IsItemVisible@ImGui@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?IsItemEdited@ImGui@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?IsItemActivated@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?IsItemDeactivated@ImGui@@YA_NXZ DD 010401H
	DD	04204H
$unwind$?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?IsAnyItemHovered@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?IsAnyItemActive@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?IsAnyItemFocused@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?SetItemAllowOverlap@ImGui@@YAXXZ DD 010401H
	DD	02204H
$unwind$?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z DD 010901H
	DD	0a209H
$unwind$?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z DD 010e01H
	DD	0820eH
$unwind$?GetStyleColorName@ImGui@@YAPEBDH@Z DD 010801H
	DD	02208H
$unwind$?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z DD 010901H
	DD	02209H
$unwind$?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ DD 010401H
	DD	02204H
$unwind$?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z DD 011801H
	DD	0e218H
$unwind$?CalcListClipping@ImGui@@YAXHMPEAH0@Z DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z DD 011201H
	DD	08212H
$unwind$?EndChildFrame@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z DD 010d01H
	DD	0820dH
$unwind$?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z DD 010901H
	DD	06209H
$unwind$?ColorConvertFloat4ToRGB@ImGui@@YAXAEBUImVec4@@AEAM11@Z DD 011801H
	DD	04218H
$unwind$?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z DD 011b01H
	DD	0621bH
$unwind$?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z DD 011b01H
	DD	0821bH
$unwind$?IsKeyPressed@ImGui@@YA_NH_N@Z DD 010c01H
	DD	0620cH
$unwind$?IsKeyReleased@ImGui@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?GetKeyPressedAmount@ImGui@@YAHHMM@Z DD 011401H
	DD	06214H
$unwind$?IsMouseDown@ImGui@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?IsAnyMouseDown@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?IsMouseClicked@ImGui@@YA_NH_N@Z DD 010c01H
	DD	0820cH
$unwind$?IsMouseDoubleClicked@ImGui@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?IsMouseReleased@ImGui@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?IsMouseDragging@ImGui@@YA_NHM@Z DD 010e01H
	DD	0220eH
$unwind$?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z DD 011301H
	DD	0e213H
$unwind$?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z DD 010901H
	DD	04209H
$unwind$?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ DD 010901H
	DD	06209H
$unwind$?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z DD 011301H
	DD	06213H
$unwind$?ResetMouseDragDelta@ImGui@@YAXH@Z DD 010801H
	DD	02208H
$unwind$?CaptureKeyboardFromApp@ImGui@@YAX_N@Z DD 010801H
	DD	02208H
$unwind$?CaptureMouseFromApp@ImGui@@YAX_N@Z DD 010801H
	DD	02208H
$unwind$?GetClipboardText@ImGui@@YAPEBDXZ DD 010401H
	DD	06204H
$unwind$?SetClipboardText@ImGui@@YAXPEBD@Z DD 010901H
	DD	06209H
$unwind$?MemAlloc@ImGui@@YAPEAX_K@Z DD 010901H
	DD	06209H
$unwind$?MemFree@ImGui@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$??0ImGuiStyle@@QEAA@XZ DD 020c01H
	DD	011010cH
$unwind$?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z DD 021201H
	DD	0150112H
$unwind$?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z DD 010e01H
	DD	0620eH
$unwind$?AddInputCharacter@ImGuiIO@@QEAAXG@Z DD 010e01H
	DD	0620eH
$unwind$?ClearInputCharacters@ImGuiIO@@QEAAXXZ DD 010901H
	DD	06209H
$unwind$??0ImGuiIO@@QEAA@XZ DD 010911H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiIO@@QEAA@XZ
$cppxdata$??0ImGuiIO@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiIO@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiIO@@QEAA@XZ
$stateUnwindMap$??0ImGuiIO@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA
$ip2state$??0ImGuiIO@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	011H, 03H
	DB	02H
	DB	011H, 0fH
	DB	00H
$unwind$?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?Begin@ImGui@@YA_NPEBDPEA_NAEBUImVec2@@MH@Z DD 011901H
	DD	04219H
$unwind$??0ImGuiTextFilter@@QEAA@PEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiTextFilter@@QEAA@PEBD@Z
$cppxdata$??0ImGuiTextFilter@@QEAA@PEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiTextFilter@@QEAA@PEBD@Z
	DD	imagerel $ip2state$??0ImGuiTextFilter@@QEAA@PEBD@Z
$stateUnwindMap$??0ImGuiTextFilter@@QEAA@PEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA
$ip2state$??0ImGuiTextFilter@@QEAA@PEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'D'
	DB	02H
	DB	09cH
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z DD 011401H
	DD	08214H
$unwind$?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z DD 011301H
	DD	0c213H
$unwind$?Build@ImGuiTextFilter@@QEAAXXZ DD 010901H
	DD	0c209H
$unwind$?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z DD 011201H
	DD	0a212H
$unwind$?append@ImGuiTextBuffer@@QEAAXPEBD0@Z DD 011301H
	DD	0e213H
$unwind$?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ DD 011801H
	DD	06218H
$unwind$?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z DD 011301H
	DD	0c213H
$unwind$?GetInt@ImGuiStorage@@QEBAHIH@Z DD 011201H
	DD	06212H
$unwind$?SetInt@ImGuiStorage@@QEAAXIH@Z DD 011201H
	DD	08212H
$unwind$?GetBool@ImGuiStorage@@QEBA_NI_N@Z DD 011201H
	DD	06212H
$unwind$?SetBool@ImGuiStorage@@QEAAXI_N@Z DD 011201H
	DD	06212H
$unwind$?GetFloat@ImGuiStorage@@QEBAMIM@Z DD 011301H
	DD	06213H
$unwind$?SetFloat@ImGuiStorage@@QEAAXIM@Z DD 011301H
	DD	08213H
$unwind$?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z DD 010d01H
	DD	0620dH
$unwind$?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z DD 011201H
	DD	08212H
$unwind$?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z DD 011201H
	DD	08212H
$unwind$?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z DD 011201H
	DD	06212H
$unwind$?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z DD 011301H
	DD	08213H
$unwind$?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z DD 011201H
	DD	08212H
$unwind$?SetAllInt@ImGuiStorage@@QEAAXH@Z DD 010d01H
	DD	0620dH
$unwind$?BuildSortByKey@ImGuiStorage@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?Step@ImGuiListClipper@@QEAA_NXZ DD 010901H
	DD	06209H
$unwind$?Begin@ImGuiListClipper@@QEAAXHM@Z DD 011301H
	DD	04213H
$unwind$?End@ImGuiListClipper@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?ImTextStrToUtf8@@YAHPEADHPEBG1@Z DD 011701H
	DD	08217H
$unwind$?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z DD 011301H
	DD	08213H
$unwind$?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z DD 011701H
	DD	08217H
$unwind$?ImTextCountCharsFromUtf8@@YAHPEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z DD 010e01H
	DD	0620eH
$unwind$?ImHashData@@YAIPEBX_KI@Z DD 011301H
	DD	04213H
$unwind$?ImHashStr@@YAIPEBD_KI@Z DD 011301H
	DD	04213H
$unwind$?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z DD 011801H
	DD	08218H
$unwind$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z DD 010e11H
	DD	0c20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z
$cppxdata$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z DB 08H
	DD	imagerel $stateUnwindMap$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z
	DD	imagerel $ip2state$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z
$stateUnwindMap$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA
$ip2state$?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z DB 06H
	DB	00H
	DB	00H
	DB	'z'
	DB	02H
	DB	095H, 02H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ImCharIsBlankA@@YA_ND@Z DD 010801H
	DD	02208H
$unwind$?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z DD 011801H
	DD	0a218H
$unwind$?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z DD 011801H
	DD	04218H
$unwind$?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z DD 011801H
	DD	0c218H
$unwind$?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z DD 011801H
	DD	08218H
$unwind$?ImGetDirQuadrantFromDelta@@YAHMM@Z DD 011001H
	DD	06210H
$unwind$?ImStricmp@@YAHPEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?ImStrnicmp@@YAHPEBD0_K@Z DD 011301H
	DD	06213H
$unwind$?ImStrncpy@@YAXPEADPEBD_K@Z DD 011301H
	DD	04213H
$unwind$?ImStrdup@@YAPEADPEBD@Z DD 010901H
	DD	06209H
$unwind$?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z DD 011301H
	DD	08213H
$unwind$?ImStrchrRange@@YAPEBDPEBD0D@Z DD 011301H
	DD	06213H
$unwind$?ImStrlenW@@YAHPEBG@Z DD 010901H
	DD	02209H
$unwind$?ImStreolRange@@YAPEBDPEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?ImStristr@@YAPEBDPEBD000@Z DD 011801H
	DD	08218H
$unwind$?ImStrTrimBlanks@@YAXPEAD@Z DD 010901H
	DD	06209H
$unwind$?ImFormatString@@YAHPEAD_KPEBDZZ DD 011801H
	DD	06218H
$unwind$?ImFormatStringV@@YAHPEAD_KPEBD0@Z DD 011801H
	DD	06218H
$unwind$??D@YA?AUImVec2@@AEBU0@M@Z DD 011401H
	DD	04214H
$unwind$??K@YA?AUImVec2@@AEBU0@M@Z DD 011401H
	DD	04214H
$unwind$??H@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$??G@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$??D@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$??K@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$?ImFabs@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImFmod@@YAMMM@Z DD 011001H
	DD	04210H
$unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	06213H
$unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	06213H
$unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD 011801H
	DD	06218H
$unwind$?ImLerp@@YA?AUImVec2@@AEBU1@00@Z DD 011801H
	DD	04218H
$unwind$?ImSaturate@@YAMM@Z DD 010a01H
	DD	0220aH
$unwind$?ImFloor@@YA?AUImVec2@@AEBU1@@Z DD 010e01H
	DD	0420eH
$unwind$??$ImMin@M@@YAMMM@Z DD 011001H
	DD	02210H
$unwind$??$ImMax@M@@YAMMM@Z DD 011001H
	DD	02210H
$unwind$?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ DD 010901H
	DD	0c209H
$unwind$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z DD 041811H
	DD	0130118H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z
$cppxdata$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z
	DD	imagerel $ip2state$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z
$stateUnwindMap$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA
$ip2state$??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z DB 0eH
	DB	00H
	DB	00H
	DB	'%', 05H
	DB	02H
	DB	086H
	DB	04H
	DB	'.'
	DB	06H
	DB	0b2H
	DB	08H
	DB	'^'
	DB	0aH
	DB	095H, 018H
	DB	00H
$unwind$?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1ImGuiWindow@@QEAA@XZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiWindow@@QEAA@XZ
$cppxdata$??1ImGuiWindow@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiWindow@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiWindow@@QEAA@XZ
$stateUnwindMap$??1ImGuiWindow@@QEAA@XZ DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA
$ip2state$??1ImGuiWindow@@QEAA@XZ DB 0eH
	DB	00H
	DB	00H
	DB	012H
	DB	0aH
	DB	0aeH
	DB	08H
	DB	'('
	DB	06H
	DB	'('
	DB	04H
	DB	'('
	DB	02H
	DB	'('
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetID@ImGuiWindow@@QEAAIPEBD0@Z DD 011301H
	DD	08213H
$unwind$?GetID@ImGuiWindow@@QEAAIPEBX@Z DD 010e01H
	DD	0620eH
$unwind$?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z DD 011301H
	DD	06213H
$unwind$?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z DD 010e01H
	DD	0620eH
$unwind$?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z DD 011d19H
	DD	0820eH
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z DD 010801H
	DD	06208H
$unwind$?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z DD 010901H
	DD	06209H
$unwind$?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	06209H
$unwind$?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	0a209H
$unwind$?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	0e209H
$unwind$?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	0e209H
$unwind$?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	0e209H
$unwind$?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD 010e01H
	DD	0620eH
$unwind$?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z DD 010901H
	DD	02209H
$unwind$?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z DD 010901H
	DD	04209H
$unwind$?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z DD 010901H
	DD	04209H
$unwind$?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z DD 011301H
	DD	0a213H
$unwind$?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z DD 011301H
	DD	04213H
$unwind$?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z DD 010901H
	DD	08209H
$unwind$?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z DD 010901H
	DD	02209H
$unwind$?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z DD 010901H
	DD	08209H
$unwind$?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ DD 010401H
	DD	0c204H
$unwind$?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	08209H
$unwind$?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ DD 010401H
	DD	08204H
$unwind$?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ DD 020701H
	DD	0110107H
$unwind$?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z DD 010d01H
	DD	0220dH
$unwind$?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z DD 030f01H
	DD	0700bc20fH
	DD	0600aH
$unwind$?ClearActiveID@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?GetHoveredID@ImGui@@YAIXZ DD 010401H
	DD	02204H
$unwind$?SetHoveredID@ImGui@@YAXI@Z DD 010801H
	DD	02208H
$unwind$?KeepAliveID@ImGui@@YAXI@Z DD 010801H
	DD	02208H
$unwind$?MarkItemEdited@ImGui@@YAXI@Z DD 010801H
	DD	02208H
$unwind$?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z DD 010f01H
	DD	0820fH
$unwind$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z DD 010f01H
	DD	0620fH
$unwind$?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z DD 031401H
	DD	07010a214H
	DD	0600fH
$unwind$?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z DD 010d01H
	DD	0620dH
$unwind$?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z DD 011201H
	DD	06212H
$unwind$?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z DD 011201H
	DD	08212H
$unwind$?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z DD 011a01H
	DD	0c21aH
$unwind$?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z DD 010f01H
	DD	0620fH
$unwind$?PushMultiItemsWidths@ImGui@@YAXHM@Z DD 010e01H
	DD	0a20eH
$unwind$?PushItemFlag@ImGui@@YAXH_N@Z DD 010c01H
	DD	0620cH
$unwind$?PopItemFlag@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?OpenPopupEx@ImGui@@YAXI@Z DD 040d01H
	DD	01d010dH
	DD	060057006H
$unwind$?ClosePopupToLevel@ImGui@@YAXH_N@Z DD 010c01H
	DD	0a20cH
$unwind$?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	0c209H
$unwind$?IsPopupOpen@ImGui@@YA_NI@Z DD 010801H
	DD	08208H
$unwind$?BeginPopupEx@ImGui@@YA_NIH@Z DD 011b19H
	DD	0a20cH
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$?BeginTooltipEx@ImGui@@YAXH_N@Z DD 011b19H
	DD	0c20cH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ DD 010401H
	DD	04204H
$unwind$?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD 041301H
	DD	0250113H
	DD	0600b700cH
$unwind$?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z DD 022d19H
	DD	021011bH
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z DD 030f01H
	DD	0700b820fH
	DD	0600aH
$unwind$?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?NavMoveRequestCancel@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z DD 031801H
	DD	070146218H
	DD	06013H
$unwind$?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z DD 030f01H
	DD	0700b820fH
	DD	0600aH
$unwind$?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z DD 010c01H
	DD	0820cH
$unwind$?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z DD 011801H
	DD	0e218H
$unwind$?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z DD 011c01H
	DD	0221cH
$unwind$?ActivateItem@ImGui@@YAXI@Z DD 010801H
	DD	02208H
$unwind$?SetNavID@ImGui@@YAXIH@Z DD 010c01H
	DD	0220cH
$unwind$?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z DD 031301H
	DD	0700f6213H
	DD	0600eH
$unwind$?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z DD 030f01H
	DD	0700b620fH
	DD	0600aH
$unwind$?ClearDragDrop@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ DD 010401H
	DD	02204H
$unwind$?BeginColumns@ImGui@@YAXPEBDHH@Z DD 041701H
	DD	01f0117H
	DD	0600f7010H
$unwind$?EndColumns@ImGui@@YAXXZ DD 020701H
	DD	0210107H
$unwind$?PushColumnClipRect@ImGui@@YAXH@Z DD 010801H
	DD	0a208H
$unwind$?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z DD 021b01H
	DD	027011bH
$unwind$?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z DD 021c01H
	DD	027011cH
$unwind$?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z DD 011801H
	DD	0c218H
$unwind$?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z DD 021b01H
	DD	01b011bH
$unwind$?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z DD 021b01H
	DD	017011bH
$unwind$?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z DD 021701H
	DD	0150117H
$unwind$?RenderArrow@ImGui@@YAXUImVec2@@HM@Z DD 021601H
	DD	0230116H
$unwind$?RenderBullet@ImGui@@YAXUImVec2@@@Z DD 010901H
	DD	0a209H
$unwind$?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z DD 021601H
	DD	0150116H
$unwind$?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z DD 041701H
	DD	01d0117H
	DD	0600f7010H
$unwind$?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z DD 010e01H
	DD	0220eH
$unwind$?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	06209H
$unwind$?FindHoveredWindow@@YAXXZ DD 040a01H
	DD	015010aH
	DD	060027003H
$unwind$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z DD 021611H
	DD	0150116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z
$cppxdata$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z DB 08H
	DD	imagerel $stateUnwindMap$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z
	DD	imagerel $ip2state$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z
$stateUnwindMap$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA
$ip2state$?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z DB 06H
	DB	00H
	DB	00H
	DB	0aeH
	DB	02H
	DB	'r'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA DD 020601H
	DD	050023206H
$unwind$?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z DD 010d01H
	DD	0620dH
$unwind$?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z DD 011301H
	DD	0c213H
$unwind$?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z DD 010e01H
	DD	0620eH
$unwind$?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z DD 010e01H
	DD	0820eH
$unwind$?GetViewportRect@@YA?AUImRect@@XZ DD 010901H
	DD	08209H
$unwind$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z
$cppxdata$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z DB 08H
	DD	imagerel $stateUnwindMap$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z
	DD	imagerel $ip2state$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z
$stateUnwindMap$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
$ip2state$?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z DB 06H
	DB	00H
	DB	00H
	DB	086H
	DB	02H
	DB	'2'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA DD 020601H
	DD	050023206H
$unwind$?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z DD 010e01H
	DD	0a20eH
$unwind$?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z DD 011b19H
	DD	0c20cH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z DD 022c19H
	DD	031011aH
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$?NavUpdate@ImGui@@YAXXZ DD 040a01H
	DD	03b010aH
	DD	060027003H
$unwind$?NavUpdateWindowing@ImGui@@YAXXZ DD 020701H
	DD	01f0107H
$unwind$?NavUpdateMoveResult@ImGui@@YAXXZ DD 020701H
	DD	0190107H
$unwind$?NavUpdatePageUpPageDown@ImGui@@YAMH@Z DD 010801H
	DD	0c208H
$unwind$?NavUpdateAnyRequestFlag@ImGui@@YAXXZ DD 010401H
	DD	02204H
$unwind$?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z DD 041801H
	DD	0170118H
	DD	060107011H
$unwind$?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ DD 020c01H
	DD	011010cH
$unwind$?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	02209H
$unwind$?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z DD 010901H
	DD	02209H
$unwind$?UpdateMouseInputs@ImGui@@YAXXZ DD 020701H
	DD	0190107H
$unwind$?UpdateMouseWheel@ImGui@@YAXXZ DD 020701H
	DD	0130107H
$unwind$?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z DD 021b01H
	DD	039011bH
$unwind$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z DD 020c11H
	DD	033010cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z
$cppxdata$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z
	DD	imagerel $ip2state$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z
$stateUnwindMap$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
$ip2state$?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z DB 06H
	DB	00H
	DB	00H
	DB	0c9H, 05H
	DB	02H
	DB	'=', 05H
	DB	00H
$unwind$?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?MallocWrapper@@YAPEAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?FreeWrapper@@YAXPEAX0@Z DD 010e01H
	DD	0420eH
$unwind$??$ImSwap@M@@YAXAEAM0@Z DD 010e01H
	DD	0220eH
$unwind$?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z DD 010d01H
	DD	0620dH
$unwind$?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z DD 011001H
	DD	06210H
$unwind$?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z DD 010d01H
	DD	0220dH
$unwind$?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z DD 010901H
	DD	02209H
$unwind$??$ImClamp@M@@YAMMMM@Z DD 011601H
	DD	02216H
$unwind$?ChildWindowComparer@@YAHPEBX0@Z DD 010e01H
	DD	0420eH
$unwind$?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z DD 010e01H
	DD	0820eH
$unwind$?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z DD 010901H
	DD	06209H
$unwind$?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z DD 010e01H
	DD	0820eH
$unwind$??$ImClamp@H@@YAHHHH@Z DD 011101H
	DD	02211H
$unwind$?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z DD 011201H
	DD	02212H
$unwind$?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z DD 041801H
	DD	0110118H
	DD	060107011H
$unwind$?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD 010e01H
	DD	0620eH
$unwind$?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z DD 021601H
	DD	0110116H
$unwind$?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z DD 011801H
	DD	0a218H
$unwind$?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z DD 011901H
	DD	0c219H
$unwind$?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z DD 011201H
	DD	04212H
$unwind$?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z DD 021101H
	DD	0150111H
$unwind$?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z DD 010801H
	DD	06208H
$unwind$?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z DD 010e01H
	DD	0e20eH
$unwind$?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z DD 010901H
	DD	08209H
$unwind$?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z DD 011101H
	DD	08211H
$unwind$?NavUpdateWindowingHighlightWindow@@YAXH@Z DD 010801H
	DD	08208H
$unwind$?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z DD 010d01H
	DD	0820dH
$unwind$?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z DD 011201H
	DD	0c212H
$unwind$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z DD 021011H
	DD	0150110H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z
$cppxdata$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z DB 08H
	DD	imagerel $stateUnwindMap$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z
	DD	imagerel $ip2state$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z
$stateUnwindMap$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA
$ip2state$?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z DB 06H
	DB	00H
	DB	00H
	DB	0d9H, 02H
	DB	02H
	DB	' '
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA DD 020601H
	DD	050023206H
$unwind$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z DD 022819H
	DD	0610116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z
	DD	02f2H
$cppxdata$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z
	DD	imagerel $ip2state$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z
$stateUnwindMap$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA
$ip2state$?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	01dH, 017H
	DB	02H
	DB	0cdH, 0cH
	DB	00H
$unwind$?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA DD 020601H
	DD	050023206H
$unwind$?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z DD 021101H
	DD	0270111H
$unwind$?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z DD 021e19H
	DD	033010cH
	DD	imagerel __GSHandlerCheck
	DD	0180H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hash_@@YA?B_KPEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fabsf DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?resize_grip_def$initializer$@@3P6AXXZEA DQ FLAT:??__Eresize_grip_def@@YAXXZ ; resize_grip_def$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv152 = 48
tab_n$1 = 52
tab$2 = 56
tv158 = 64
tv70 = 72
p$ = 80
buf_end$ = 88
tv93 = 96
buf$ = 112
__$ArrayPad$ = 384
tab_bar$ = 416
?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z PROC ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeTabBar

; 8544 : 		{

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 408				; 00000198H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 8545 : 			// Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
; 8546 : 			char buf[256];
; 8547 : 			char* p = buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 8548 : 			const char* buf_end = buf + IM_ARRAYSIZE(buf);

	lea	rax, QWORD PTR buf$[rsp+256]
	mov	QWORD PTR buf_end$[rsp], rax

; 8549 : 			ImFormatString(p, buf_end - p, ("TabBar (%d tabs)%s"), tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2) ? (" *Inactive*") : "");

	call	?GetFrameCount@ImGui@@YAHXZ		; ImGui::GetFrameCount
	sub	eax, 2
	mov	rcx, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rcx+12], eax
	jge	SHORT $LN9@NodeTabBar
	lea	rax, OFFSET FLAT:??_C@_0M@MDILNFHC@?5?$CKInactive?$CK@
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN10@NodeTabBar
$LN9@NodeTabBar:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv70[rsp], rax
$LN10@NodeTabBar:
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buf_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv70[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	r9d, DWORD PTR [rcx+16]
	lea	r8, OFFSET FLAT:??_C@_0BD@HNMBCOGC@TabBar?5?$CI?$CFd?5tabs?$CJ?$CFs@
	mov	rdx, rax
	mov	rcx, QWORD PTR p$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1

; 8550 : 			if (ImGui::TreeNode(tab_bar, "%s", buf))

	lea	r8, QWORD PTR buf$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TreeNode@ImGui@@YA_NPEBXPEBDZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	$LN5@NodeTabBar

; 8551 : 			{
; 8552 : 				for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	DWORD PTR tab_n$1[rsp], 0
	jmp	SHORT $LN4@NodeTabBar
$LN2@NodeTabBar:
	mov	eax, DWORD PTR tab_n$1[rsp]
	inc	eax
	mov	DWORD PTR tab_n$1[rsp], eax
$LN4@NodeTabBar:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_n$1[rsp], eax
	jge	$LN3@NodeTabBar

; 8553 : 				{
; 8554 : 					const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv93[rsp], rax
	mov	edx, DWORD PTR tab_n$1[rsp]
	mov	rcx, QWORD PTR tv93[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$2[rsp], rax

; 8555 : 					ImGui::PushID(tab);

	mov	rcx, QWORD PTR tab$2[rsp]
	call	?PushID@ImGui@@YAXPEBX@Z		; ImGui::PushID
	npad	1

; 8556 : 					if (ImGui::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } ImGui::SameLine(0, 2);

	lea	rcx, OFFSET FLAT:??_C@_01MNNFJEPP@?$DM@
	call	?SmallButton@ImGui@@YA_NPEBD@Z		; ImGui::SmallButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@NodeTabBar
	mov	r8d, -1
	mov	rdx, QWORD PTR tab$2[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
	npad	1
$LN6@NodeTabBar:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@40000000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1

; 8557 : 					if (ImGui::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } ImGui::SameLine();

	lea	rcx, OFFSET FLAT:??_C@_01PPODPGHN@?$DO@
	call	?SmallButton@ImGui@@YA_NPEBD@Z		; ImGui::SmallButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@NodeTabBar
	mov	r8d, 1
	mov	rdx, QWORD PTR tab$2[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
	npad	1
$LN7@NodeTabBar:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 8558 : 					ImGui::Text(("%02d%c Tab 0x%08X"), tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);

	mov	rax, QWORD PTR tab$2[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv158[rsp], eax
	mov	rax, QWORD PTR tab$2[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN11@NodeTabBar
	mov	BYTE PTR tv152[rsp], 42			; 0000002aH
	jmp	SHORT $LN12@NodeTabBar
$LN11@NodeTabBar:
	mov	BYTE PTR tv152[rsp], 32			; 00000020H
$LN12@NodeTabBar:
	movsx	eax, BYTE PTR tv152[rsp]
	mov	r9d, DWORD PTR tv158[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR tab_n$1[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BC@NHDMGCPM@?$CF02d?$CFc?5Tab?50x?$CF08X@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8559 : 					ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 8560 : 				}

	jmp	$LN2@NodeTabBar
$LN3@NodeTabBar:

; 8561 : 				ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN5@NodeTabBar:

; 8562 : 			}
; 8563 : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 408				; 00000198H
	ret	0
?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z ENDP ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeTabBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
flags$ = 96
column_n$1 = 100
columns$2 = 104
n$3 = 112
tv72 = 116
tv213 = 120
tv147 = 128
tv151 = 136
tv155 = 144
tv160 = 152
tv164 = 160
tv168 = 168
tv172 = 176
tv176 = 184
tv255 = 192
tv80 = 200
tv202 = 208
tv204 = 216
tv200 = 224
tv198 = 232
tv291 = 240
tv333 = 248
tv356 = 256
tv369 = 264
tv380 = 272
tv389 = 280
tv387 = 288
window$ = 320
label$ = 328
?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z PROC ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindow

; 8502 : 		{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H

; 8503 : 			if (!ImGui::TreeNode(window, ("%s '%s', %d @ 0x%p"), label, window->Name, window->Active || window->WasActive, window))

	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	jne	SHORT $LN17@NodeWindow
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	jne	SHORT $LN17@NodeWindow
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN18@NodeWindow
$LN17@NodeWindow:
	mov	DWORD PTR tv72[rsp], 1
$LN18@NodeWindow:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv72[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	r9, QWORD PTR [rax+16]
	mov	r8, QWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp@
	mov	rcx, QWORD PTR window$[rsp]
	call	?TreeNode@ImGui@@YA_NPEBXPEBDZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@NodeWindow

; 8504 : 				return;

	jmp	$LN1@NodeWindow
$LN8@NodeWindow:

; 8505 : 			ImGuiWindowFlags flags = window->Flags;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR flags$[rsp], eax

; 8506 : 			NodeDrawList(window, window->DrawList, ("DrawList"));

	lea	r8, OFFSET FLAT:??_C@_08IJNCDCKF@DrawList@
	mov	rax, QWORD PTR window$[rsp]
	mov	rdx, QWORD PTR [rax+696]
	mov	rcx, QWORD PTR window$[rsp]
	call	?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeDrawList

; 8507 : 			ImGui::BulletText(("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)"), window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);

	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+12]
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm1, DWORD PTR [rax+8]
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm3, DWORD PTR [rax]
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm4, DWORD PTR [rax+52]
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm5, DWORD PTR [rax+48]
	movsd	QWORD PTR [rsp+48], xmm0
	movsd	QWORD PTR [rsp+40], xmm1
	movsd	QWORD PTR [rsp+32], xmm2
	movq	r9, xmm3
	movaps	xmm2, xmm4
	movq	r8, xmm2
	movaps	xmm1, xmm5
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0DO@PMCJMPLH@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5Size?3?5?$CI?$CF?41f?0?$CF@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8508 : 			ImGui::BulletText(("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)"), flags,

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN19@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_0BB@GGEIPOID@AlwaysAutoResize@
	mov	QWORD PTR tv147[rsp], rax
	jmp	SHORT $LN20@NodeWindow
$LN19@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv147[rsp], rax
$LN20@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN21@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_0M@COLEABDL@NoNavInputs@
	mov	QWORD PTR tv151[rsp], rax
	jmp	SHORT $LN22@NodeWindow
$LN21@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv151[rsp], rax
$LN22@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN23@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_0O@LAPEOEIJ@NoMouseInputs@
	mov	QWORD PTR tv155[rsp], rax
	jmp	SHORT $LN24@NodeWindow
$LN23@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv155[rsp], rax
$LN24@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN25@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_0L@OPMMHACC@ChildMenu?5@
	mov	QWORD PTR tv160[rsp], rax
	jmp	SHORT $LN26@NodeWindow
$LN25@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv160[rsp], rax
$LN26@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN27@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_06IFIMNOLK@Modal?5@
	mov	QWORD PTR tv164[rsp], rax
	jmp	SHORT $LN28@NodeWindow
$LN27@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv164[rsp], rax
$LN28@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN29@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_06NMKCIICK@Popup?5@
	mov	QWORD PTR tv168[rsp], rax
	jmp	SHORT $LN30@NodeWindow
$LN29@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv168[rsp], rax
$LN30@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN31@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_08LGECAIGF@Tooltip?5@
	mov	QWORD PTR tv172[rsp], rax
	jmp	SHORT $LN32@NodeWindow
$LN31@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv172[rsp], rax
$LN32@NodeWindow:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN33@NodeWindow
	lea	rax, OFFSET FLAT:??_C@_06MMFPNIIL@Child?5@
	mov	QWORD PTR tv176[rsp], rax
	jmp	SHORT $LN34@NodeWindow
$LN33@NodeWindow:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv176[rsp], rax
$LN34@NodeWindow:
	mov	rax, QWORD PTR tv147[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR tv151[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR tv155[rsp]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BB@EBNDPMCP@NoSavedSettings?5@
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR tv160[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR tv164[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv168[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv172[rsp]
	mov	r8, QWORD PTR tv176[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0CF@HFFEAFCN@Flags?3?50x?$CF08X?5?$CI?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8509 : 				(flags & ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_Tooltip) ? ("Tooltip ") : "", (flags & ImGuiWindowFlags_Popup) ? ("Popup ") : "",
; 8510 : 				(flags & ImGuiWindowFlags_Modal) ? "Modal " : "", (flags & ImGuiWindowFlags_ChildMenu) ? ("ChildMenu ") : "", ("NoSavedSettings "),
; 8511 : 				(flags & ImGuiWindowFlags_NoMouseInputs) ? "NoMouseInputs" : "", (flags & ImGuiWindowFlags_NoNavInputs) ? ("NoNavInputs") : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? ("AlwaysAutoResize") : "");
; 8512 : 			ImGui::BulletText(("Scroll: (%.2f/%.2f,%.2f/%.2f)"), window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));

	mov	rcx, QWORD PTR window$[rsp]
	call	?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxY
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv202[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+96]
	movsd	QWORD PTR tv204[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxX
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv200[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+92]
	movsd	QWORD PTR tv198[rsp], xmm0
	movsd	xmm0, QWORD PTR tv202[rsp]
	movsd	QWORD PTR [rsp+32], xmm0
	movsd	xmm3, QWORD PTR tv204[rsp]
	movq	r9, xmm3
	movsd	xmm2, QWORD PTR tv200[rsp]
	movq	r8, xmm2
	movsd	xmm1, QWORD PTR tv198[rsp]
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0BO@JAHLHNNL@Scroll?3?5?$CI?$CF?42f?1?$CF?42f?0?$CF?42f?1?$CF?42f?$CJ@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8513 : 			ImGui::BulletText(("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d"), window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	jne	SHORT $LN35@NodeWindow
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	jne	SHORT $LN35@NodeWindow
	mov	DWORD PTR tv213[rsp], -1
	jmp	SHORT $LN36@NodeWindow
$LN35@NodeWindow:
	mov	rax, QWORD PTR window$[rsp]
	movsx	eax, WORD PTR [rax+150]
	mov	DWORD PTR tv213[rsp], eax
$LN36@NodeWindow:
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	mov	rcx, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR [rcx+132]
	mov	rdx, QWORD PTR window$[rsp]
	movzx	edx, BYTE PTR [rdx+102]
	mov	r8d, DWORD PTR tv213[rsp]
	mov	DWORD PTR [rsp+32], r8d
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0DO@LPCMGHLI@Active?3?5?$CFd?1?$CFd?0?5WriteAccessed?3?5?$CF@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8514 : 			ImGui::BulletText(("Appearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d"), window->Appearing, window->Hidden, window->HiddenFramesRegular, window->HiddenFramesForResize, window->SkipItems);

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	mov	rcx, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR [rcx+140]
	mov	rdx, QWORD PTR window$[rsp]
	movzx	edx, BYTE PTR [rdx+133]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+168]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	r9d, DWORD PTR [rax+188]
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0DM@DJJIBEFM@Appearing?3?5?$CFd?0?5Hidden?3?5?$CFd?5?$CIReg?5@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8515 : 			ImGui::BulletText(("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X"), window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);

	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR window$[rsp]
	mov	r9d, DWORD PTR [rdx+420]
	mov	rdx, QWORD PTR window$[rsp]
	mov	r8d, DWORD PTR [rdx+rax+904]
	mov	rax, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR [rax+rcx+904]
	lea	rcx, OFFSET FLAT:??_C@_0DC@CFCLKJDH@NavLastIds?3?50x?$CF08X?00x?$CF08X?0?5NavL@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8516 : 			ImGui::BulletText(("NavLastChildNavWindow: %lld"), window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : 0);

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+896], 0
	je	SHORT $LN37@NodeWindow
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+896]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv255[rsp], rax
	jmp	SHORT $LN38@NodeWindow
$LN37@NodeWindow:
	mov	QWORD PTR tv255[rsp], 0
$LN38@NodeWindow:
	mov	rdx, QWORD PTR tv255[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BM@NPFIBFIA@NavLastChildNavWindow?3?5?$CFlld@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1

; 8517 : 			if (!window->NavRectRel[0].IsInverted())

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	lea	rax, QWORD PTR [rcx+rax+912]
	mov	rcx, rax
	call	?IsInverted@ImRect@@QEBA_NXZ		; ImRect::IsInverted
	movzx	eax, al
	test	eax, eax
	jne	$LN9@NodeWindow

; 8518 : 				ImGui::BulletText(("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)"), window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	cvtss2sd xmm0, DWORD PTR [rcx+rax+924]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	cvtss2sd xmm1, DWORD PTR [rcx+rax+920]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	cvtss2sd xmm2, DWORD PTR [rcx+rax+916]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	cvtss2sd xmm3, DWORD PTR [rcx+rax+912]
	movsd	QWORD PTR tv291[rsp], xmm3
	movsd	QWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movq	r9, xmm3
	movq	r8, xmm2
	movsd	xmm0, QWORD PTR tv291[rsp]
	movaps	xmm1, xmm0
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0CG@HFMDFCIJ@NavRectRel?$FL0?$FN?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$CI?$CF?41f@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1
	jmp	SHORT $LN10@NodeWindow
$LN9@NodeWindow:

; 8519 : 			else
; 8520 : 				ImGui::BulletText(("NavRectRel[0]: <None>"));

	lea	rcx, OFFSET FLAT:??_C@_0BG@KHCECGOM@NavRectRel?$FL0?$FN?3?5?$DMNone?$DO@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1
$LN10@NodeWindow:

; 8521 : 			if (window->RootWindow != window) NodeWindow(window->RootWindow, ("RootWindow"));

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+688], rcx
	je	SHORT $LN11@NodeWindow
	lea	rdx, OFFSET FLAT:??_C@_0L@EHLMOHOL@RootWindow@
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+688]
	call	?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindow
	npad	1
$LN11@NodeWindow:

; 8522 : 			if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, ("ParentWindow"));

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+880], 0
	je	SHORT $LN12@NodeWindow
	lea	rdx, OFFSET FLAT:??_C@_0N@BPPHAMMO@ParentWindow@
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+880]
	call	?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindow
	npad	1
$LN12@NodeWindow:

; 8523 : 			if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, ("ChildWindows"));

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+432], 0
	jle	SHORT $LN13@NodeWindow
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 432				; 000001b0H
	lea	rdx, OFFSET FLAT:??_C@_0N@BGDHDNPO@ChildWindows@
	mov	rcx, rax
	call	?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindows
	npad	1
$LN13@NodeWindow:

; 8524 : 			if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode(("Columns"), ("Columns sets (%d)"), window->ColumnsStorage.Size))

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+664], 0
	jle	$LN14@NodeWindow
	mov	rax, QWORD PTR window$[rsp]
	mov	r8d, DWORD PTR [rax+664]
	lea	rdx, OFFSET FLAT:??_C@_0BC@FIDDFLAI@Columns?5sets?5?$CI?$CFd?$CJ@
	lea	rcx, OFFSET FLAT:??_C@_07IBCCJKML@Columns@
	call	?TreeNode@ImGui@@YA_NPEBD0ZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	$LN14@NodeWindow

; 8525 : 			{
; 8526 : 				for (int n = 0; n < window->ColumnsStorage.Size; n++)

	mov	DWORD PTR n$3[rsp], 0
	jmp	SHORT $LN4@NodeWindow
$LN2@NodeWindow:
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN4@NodeWindow:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+664]
	cmp	DWORD PTR n$3[rsp], eax
	jge	$LN3@NodeWindow

; 8527 : 				{
; 8528 : 					const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 664				; 00000298H
	mov	QWORD PTR tv333[rsp], rax
	mov	edx, DWORD PTR n$3[rsp]
	mov	rcx, QWORD PTR tv333[rsp]
	call	??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z ; ImVector<ImGuiColumnsSet>::operator[]
	mov	QWORD PTR columns$2[rsp], rax

; 8529 : 					if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, ("Columns Id: 0x%08X, Count: %d, Flags: 0x%04X"), columns->ID, columns->Count, columns->Flags))

	mov	rax, QWORD PTR columns$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR columns$2[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR columns$2[rsp]
	mov	r9d, DWORD PTR [rcx+36]
	mov	rcx, QWORD PTR columns$2[rsp]
	mov	r8d, DWORD PTR [rcx+28]
	lea	rdx, OFFSET FLAT:??_C@_0CN@LMOAIACO@Columns?5Id?3?50x?$CF08X?0?5Count?3?5?$CFd?0?5@
	mov	ecx, eax
	call	?TreeNode@ImGui@@YA_NPEBXPEBDZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	$LN15@NodeWindow

; 8530 : 					{
; 8531 : 						ImGui::BulletText(("Width: %.1f (MinX: %.1f, MaxX: %.1f)"), columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);

	mov	rax, QWORD PTR columns$2[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+8]
	mov	rax, QWORD PTR columns$2[rsp]
	cvtss2sd xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR columns$2[rsp]
	mov	rcx, QWORD PTR columns$2[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	subss	xmm2, DWORD PTR [rcx+4]
	cvtss2sd xmm2, xmm2
	movsd	QWORD PTR tv356[rsp], xmm2
	movaps	xmm3, xmm0
	movq	r9, xmm3
	movaps	xmm2, xmm1
	movq	r8, xmm2
	movsd	xmm0, QWORD PTR tv356[rsp]
	movaps	xmm1, xmm0
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0CF@PKFCLBKA@Width?3?5?$CF?41f?5?$CIMinX?3?5?$CF?41f?0?5MaxX?3?5@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1

; 8532 : 						for (int column_n = 0; column_n < columns->Columns.Size; column_n++)

	mov	DWORD PTR column_n$1[rsp], 0
	jmp	SHORT $LN7@NodeWindow
$LN5@NodeWindow:
	mov	eax, DWORD PTR column_n$1[rsp]
	inc	eax
	mov	DWORD PTR column_n$1[rsp], eax
$LN7@NodeWindow:
	mov	rax, QWORD PTR columns$2[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR column_n$1[rsp], eax
	jge	$LN6@NodeWindow

; 8533 : 							ImGui::BulletText(("Column %02d: OffsetNorm %.3f (= %.1f px)"), column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));

	mov	rax, QWORD PTR columns$2[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv369[rsp], rax
	mov	edx, DWORD PTR column_n$1[rsp]
	mov	rcx, QWORD PTR tv369[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEBAAEBUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm1, DWORD PTR [rax]
	mov	rcx, QWORD PTR columns$2[rsp]
	call	?OffsetNormToPixels@@YAMPEBUImGuiColumnsSet@@M@Z ; OffsetNormToPixels
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv389[rsp], xmm0
	mov	rax, QWORD PTR columns$2[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv380[rsp], rax
	mov	edx, DWORD PTR column_n$1[rsp]
	mov	rcx, QWORD PTR tv380[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEBAAEBUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	cvtss2sd xmm0, DWORD PTR [rax]
	movsd	QWORD PTR tv387[rsp], xmm0
	movsd	xmm3, QWORD PTR tv389[rsp]
	movq	r9, xmm3
	movsd	xmm2, QWORD PTR tv387[rsp]
	movq	r8, xmm2
	mov	edx, DWORD PTR column_n$1[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0CJ@CPAFBJNN@Column?5?$CF02d?3?5OffsetNorm?5?$CF?43f?5?$CI?$DN@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1
	jmp	$LN5@NodeWindow
$LN6@NodeWindow:

; 8534 : 						ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN15@NodeWindow:

; 8535 : 					}
; 8536 : 				}

	jmp	$LN2@NodeWindow
$LN3@NodeWindow:

; 8537 : 				ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN14@NodeWindow:

; 8538 : 			}
; 8539 : 			ImGui::BulletText(("Storage: %d bytes"), window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));

	mov	rax, QWORD PTR window$[rsp]
	imul	eax, DWORD PTR [rax+288], 16
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText

; 8540 : 			ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN1@NodeWindow:

; 8541 : 		}

	add	rsp, 312				; 00000138H
	ret	0
?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z ENDP ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
windows$ = 64
label$ = 72
?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z PROC ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindows

; 8493 : 		{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 8494 : 			if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))

	mov	rax, QWORD PTR windows$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8, QWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ@
	mov	rcx, QWORD PTR label$[rsp]
	call	?TreeNode@ImGui@@YA_NPEBD0ZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@NodeWindow

; 8495 : 				return;

	jmp	SHORT $LN1@NodeWindow
$LN5@NodeWindow:

; 8496 : 			for (int i = 0; i < windows.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@NodeWindow
$LN2@NodeWindow:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@NodeWindow:
	mov	rax, QWORD PTR windows$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@NodeWindow

; 8497 : 				Funcs::NodeWindow(windows[i], "Window");

	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR windows$[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	lea	rdx, OFFSET FLAT:??_C@_06BKKJGDHO@Window@
	mov	rcx, QWORD PTR [rax]
	call	?NodeWindow@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindow
	npad	1
	jmp	SHORT $LN2@NodeWindow
$LN3@NodeWindow:

; 8498 : 			ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN1@NodeWindow:

; 8499 : 		}

	add	rsp, 56					; 00000038H
	ret	0
?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z ENDP ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindows
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
node_open$ = 80
pcmd$1 = 88
pcmd_node_open$2 = 96
i$3 = 100
elem_offset$ = 104
idx_i$4 = 108
n$5 = 112
overlay_draw_list$ = 120
prim$6 = 128
v$7 = 136
tv255 = 144
tv307 = 148
idx_buffer$8 = 152
buf_p$9 = 160
tv85 = 168
tv87 = 172
tv83 = 176
tv221 = 180
vtx_i$10 = 184
tv349 = 188
tv347 = 192
backup_flags$11 = 196
tv77 = 200
tv184 = 208
tv207 = 216
tv340 = 224
vtxs_rect$12 = 232
tv231 = 248
tv229 = 256
tv227 = 264
tv225 = 272
tv223 = 280
tv219 = 288
tv258 = 296
tv313 = 304
buf_end$13 = 312
tv351 = 320
tv355 = 328
tv357 = 336
tv353 = 344
clip_rect$14 = 352
clipper$15 = 368
$T16 = 392
$T17 = 400
$T18 = 408
triangles_pos$19 = 424
buf$20 = 448
__$ArrayPad$ = 752
window$ = 784
draw_list$ = 792
label$ = 800
?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z PROC ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeDrawList

; 8422 : 		{

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 776				; 00000308H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 8423 : 			bool node_open = ImGui::TreeNode(draw_list, ("%s: '%lld' %d vtx, %d indices, %d cmds"), label, draw_list->_OwnerName ? draw_list->_OwnerName : 0, draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv85[rsp], eax
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR tv87[rsp], eax
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv83[rsp], eax
	mov	rax, QWORD PTR draw_list$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN26@NodeDrawLi
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN27@NodeDrawLi
$LN26@NodeDrawLi:
	mov	QWORD PTR tv77[rsp], 0
$LN27@NodeDrawLi:
	mov	eax, DWORD PTR tv85[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR tv87[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR tv83[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv77[rsp]
	mov	r8, QWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0CH@BMBAOAAJ@?$CFs?3?5?8?$CFlld?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5@
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?TreeNode@ImGui@@YA_NPEBXPEBDZZ		; ImGui::TreeNode
	mov	BYTE PTR node_open$[rsp], al

; 8424 : 			if (draw_list == ImGui::GetWindowDrawList())

	call	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	cmp	QWORD PTR draw_list$[rsp], rax
	jne	SHORT $LN16@NodeDrawLi

; 8425 : 			{
; 8426 : 				ImGui::SameLine();

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1

; 8427 : 				ImGui::TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), ("CURRENTLY APPENDING")); // Can't display stats for active draw list! (we don't have the data double-buffered)

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ecccccd
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	lea	rdx, OFFSET FLAT:??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING@
	mov	rcx, rax
	call	?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ ; ImGui::TextColored
	npad	1

; 8428 : 				if (node_open) ImGui::TreePop();

	movzx	eax, BYTE PTR node_open$[rsp]
	test	eax, eax
	je	SHORT $LN17@NodeDrawLi
	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN17@NodeDrawLi:

; 8429 : 				return;

	jmp	$LN1@NodeDrawLi
$LN16@NodeDrawLi:

; 8430 : 			}
; 8431 : 
; 8432 : 			ImDrawList* overlay_draw_list = GetOverlayDrawList(window); // Render additional visuals into the top-most draw list

	mov	rcx, QWORD PTR window$[rsp]
	call	?GetOverlayDrawList@@YAPEAUImDrawList@@PEAUImGuiWindow@@@Z ; GetOverlayDrawList
	mov	QWORD PTR overlay_draw_list$[rsp], rax

; 8433 : 			if (window && IsItemHovered())

	cmp	QWORD PTR window$[rsp], 0
	je	SHORT $LN18@NodeDrawLi
	xor	ecx, ecx
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@NodeDrawLi

; 8434 : 				overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T16[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, -16711681				; ff00ffffH
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR overlay_draw_list$[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN18@NodeDrawLi:

; 8435 : 			if (!node_open)

	movzx	eax, BYTE PTR node_open$[rsp]
	test	eax, eax
	jne	SHORT $LN19@NodeDrawLi

; 8436 : 				return;

	jmp	$LN1@NodeDrawLi
$LN19@NodeDrawLi:

; 8437 : 
; 8438 : 			int elem_offset = 0;

	mov	DWORD PTR elem_offset$[rsp], 0

; 8439 : 			for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)

	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?begin@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::begin
	mov	QWORD PTR pcmd$1[rsp], rax
	jmp	SHORT $LN4@NodeDrawLi
$LN2@NodeDrawLi:
	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR elem_offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR elem_offset$[rsp], eax
	mov	rax, QWORD PTR pcmd$1[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR pcmd$1[rsp], rax
$LN4@NodeDrawLi:
	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?end@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::end
	cmp	QWORD PTR pcmd$1[rsp], rax
	jae	$LN3@NodeDrawLi

; 8440 : 			{
; 8441 : 				if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)

	mov	rax, QWORD PTR pcmd$1[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN20@NodeDrawLi
	mov	rax, QWORD PTR pcmd$1[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN20@NodeDrawLi

; 8442 : 					continue;

	jmp	SHORT $LN2@NodeDrawLi
$LN20@NodeDrawLi:

; 8443 : 				if (pcmd->UserCallback)

	mov	rax, QWORD PTR pcmd$1[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN21@NodeDrawLi

; 8444 : 				{
; 8445 : 					ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);

	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	r8, QWORD PTR [rax+40]
	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	rdx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1

; 8446 : 					continue;

	jmp	$LN2@NodeDrawLi
$LN21@NodeDrawLi:

; 8447 : 				}
; 8448 : 				ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;

	mov	rax, QWORD PTR draw_list$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jle	SHORT $LN28@NodeDrawLi
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv184[rsp], rax
	jmp	SHORT $LN29@NodeDrawLi
$LN28@NodeDrawLi:
	mov	QWORD PTR tv184[rsp], 0
$LN29@NodeDrawLi:
	mov	rax, QWORD PTR tv184[rsp]
	mov	QWORD PTR idx_buffer$8[rsp], rax

; 8449 : 				bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), ("Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)"), pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);

	mov	rax, QWORD PTR pcmd$1[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+24]
	movsd	QWORD PTR tv231[rsp], xmm0
	mov	rax, QWORD PTR pcmd$1[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+20]
	movsd	QWORD PTR tv229[rsp], xmm0
	mov	rax, QWORD PTR pcmd$1[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+16]
	movsd	QWORD PTR tv227[rsp], xmm0
	mov	rax, QWORD PTR pcmd$1[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+12]
	movsd	QWORD PTR tv225[rsp], xmm0
	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv223[rsp], rax
	mov	rax, QWORD PTR draw_list$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jle	SHORT $LN30@NodeDrawLi
	lea	rax, OFFSET FLAT:??_C@_07KNEBDGNE@indexed@
	mov	QWORD PTR tv207[rsp], rax
	jmp	SHORT $LN31@NodeDrawLi
$LN30@NodeDrawLi:
	lea	rax, OFFSET FLAT:??_C@_0M@NGJKDAN@non?9indexed@
	mov	QWORD PTR tv207[rsp], rax
$LN31@NodeDrawLi:
	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv221[rsp], eax
	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?begin@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::begin
	mov	rcx, QWORD PTR pcmd$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 48					; 00000030H
	idiv	rcx
	mov	QWORD PTR tv219[rsp], rax
	movsd	xmm0, QWORD PTR tv231[rsp]
	movsd	QWORD PTR [rsp+64], xmm0
	movsd	xmm0, QWORD PTR tv229[rsp]
	movsd	QWORD PTR [rsp+56], xmm0
	movsd	xmm0, QWORD PTR tv227[rsp]
	movsd	QWORD PTR [rsp+48], xmm0
	movsd	xmm0, QWORD PTR tv225[rsp]
	movsd	QWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR tv223[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv207[rsp]
	mov	r8d, DWORD PTR tv221[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0EB@BKFKDBKJ@Draw?5?$CF4d?5?$CFs?5vtx?0?5tex?50x?$CFp?0?5clip@
	mov	rcx, QWORD PTR tv219[rsp]
	call	?TreeNode@ImGui@@YA_NPEBXPEBDZZ		; ImGui::TreeNode
	mov	BYTE PTR pcmd_node_open$2[rsp], al

; 8450 : 				if (show_draw_cmd_clip_rects && ImGui::IsItemHovered())

	movzx	eax, BYTE PTR ?show_draw_cmd_clip_rects@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA
	test	eax, eax
	je	$LN22@NodeDrawLi
	xor	ecx, ecx
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	$LN22@NodeDrawLi

; 8451 : 				{
; 8452 : 					ImRect clip_rect = pcmd->ClipRect;

	mov	rax, QWORD PTR pcmd$1[rsp]
	add	rax, 12
	mov	rdx, rax
	lea	rcx, QWORD PTR clip_rect$14[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect

; 8453 : 					ImRect vtxs_rect;

	lea	rcx, QWORD PTR vtxs_rect$12[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	npad	1

; 8454 : 					for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)

	mov	eax, DWORD PTR elem_offset$[rsp]
	mov	DWORD PTR i$3[rsp], eax
	jmp	SHORT $LN7@NodeDrawLi
$LN5@NodeDrawLi:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN7@NodeDrawLi:
	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR elem_offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR i$3[rsp], eax
	jge	SHORT $LN6@NodeDrawLi

; 8455 : 						vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	QWORD PTR tv258[rsp], rax
	cmp	QWORD PTR idx_buffer$8[rsp], 0
	je	SHORT $LN32@NodeDrawLi
	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR idx_buffer$8[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR tv255[rsp], eax
	jmp	SHORT $LN33@NodeDrawLi
$LN32@NodeDrawLi:
	mov	eax, DWORD PTR i$3[rsp]
	mov	DWORD PTR tv255[rsp], eax
$LN33@NodeDrawLi:
	mov	edx, DWORD PTR tv255[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
	mov	rdx, rax
	lea	rcx, QWORD PTR vtxs_rect$12[rsp]
	call	?Add@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Add
	npad	1
	jmp	$LN5@NodeDrawLi
$LN6@NodeDrawLi:

; 8456 : 					clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255, 255, 0, 255));

	lea	rcx, QWORD PTR clip_rect$14[rsp]
	call	?Floor@ImRect@@QEAAXXZ			; ImRect::Floor
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, -16711681				; ff00ffffH
	lea	r8, QWORD PTR clip_rect$14[rsp+8]
	lea	rdx, QWORD PTR clip_rect$14[rsp]
	mov	rcx, QWORD PTR overlay_draw_list$[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 8457 : 					vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255, 0, 255, 255));

	lea	rcx, QWORD PTR vtxs_rect$12[rsp]
	call	?Floor@ImRect@@QEAAXXZ			; ImRect::Floor
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, -65281				; ffff00ffH
	lea	r8, QWORD PTR vtxs_rect$12[rsp+8]
	lea	rdx, QWORD PTR vtxs_rect$12[rsp]
	mov	rcx, QWORD PTR overlay_draw_list$[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN22@NodeDrawLi:

; 8458 : 				}
; 8459 : 				if (!pcmd_node_open)

	movzx	eax, BYTE PTR pcmd_node_open$2[rsp]
	test	eax, eax
	jne	SHORT $LN23@NodeDrawLi

; 8460 : 					continue;

	jmp	$LN2@NodeDrawLi
$LN23@NodeDrawLi:

; 8461 : 
; 8462 : 				// Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
; 8463 : 				ImGuiListClipper clipper(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.

	xor	edx, edx
	mov	rax, QWORD PTR pcmd$1[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, 3
	div	ecx
	movss	xmm2, DWORD PTR __real@bf800000
	mov	edx, eax
	lea	rcx, QWORD PTR clipper$15[rsp]
	call	??0ImGuiListClipper@@QEAA@HM@Z		; ImGuiListClipper::ImGuiListClipper
	npad	1
$LN8@NodeDrawLi:

; 8464 : 				while (clipper.Step())

	lea	rcx, QWORD PTR clipper$15[rsp]
	call	?Step@ImGuiListClipper@@QEAA_NXZ	; ImGuiListClipper::Step
	movzx	eax, al
	test	eax, eax
	je	$LN9@NodeDrawLi

; 8465 : 					for (int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)

	mov	eax, DWORD PTR clipper$15[rsp+16]
	mov	DWORD PTR prim$6[rsp], eax
	imul	eax, DWORD PTR clipper$15[rsp+16], 3
	mov	ecx, DWORD PTR elem_offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR idx_i$4[rsp], eax
	jmp	SHORT $LN12@NodeDrawLi
$LN10@NodeDrawLi:
	mov	eax, DWORD PTR prim$6[rsp]
	inc	eax
	mov	DWORD PTR prim$6[rsp], eax
$LN12@NodeDrawLi:
	mov	eax, DWORD PTR clipper$15[rsp+20]
	cmp	DWORD PTR prim$6[rsp], eax
	jge	$LN11@NodeDrawLi

; 8466 : 					{
; 8467 : 						char buf[300];
; 8468 : 						char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE(buf);

	lea	rax, QWORD PTR buf$20[rsp]
	mov	QWORD PTR buf_p$9[rsp], rax
	lea	rax, QWORD PTR buf$20[rsp+300]
	mov	QWORD PTR buf_end$13[rsp], rax

; 8469 : 						ImVec2 triangles_pos[3];

	lea	r9, OFFSET FLAT:??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
	mov	r8d, 3
	mov	edx, 8
	lea	rcx, QWORD PTR triangles_pos$19[rsp]
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z
	npad	1

; 8470 : 						for (int n = 0; n < 3; n++, idx_i++)

	mov	DWORD PTR n$5[rsp], 0
	jmp	SHORT $LN15@NodeDrawLi
$LN13@NodeDrawLi:
	mov	eax, DWORD PTR n$5[rsp]
	inc	eax
	mov	DWORD PTR n$5[rsp], eax
	mov	eax, DWORD PTR idx_i$4[rsp]
	inc	eax
	mov	DWORD PTR idx_i$4[rsp], eax
$LN15@NodeDrawLi:
	cmp	DWORD PTR n$5[rsp], 3
	jge	$LN14@NodeDrawLi

; 8471 : 						{
; 8472 : 							int vtx_i = idx_buffer ? idx_buffer[idx_i] : idx_i;

	cmp	QWORD PTR idx_buffer$8[rsp], 0
	je	SHORT $LN34@NodeDrawLi
	movsxd	rax, DWORD PTR idx_i$4[rsp]
	mov	rcx, QWORD PTR idx_buffer$8[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR tv307[rsp], eax
	jmp	SHORT $LN35@NodeDrawLi
$LN34@NodeDrawLi:
	mov	eax, DWORD PTR idx_i$4[rsp]
	mov	DWORD PTR tv307[rsp], eax
$LN35@NodeDrawLi:
	mov	eax, DWORD PTR tv307[rsp]
	mov	DWORD PTR vtx_i$10[rsp], eax

; 8473 : 							ImDrawVert& v = draw_list->VtxBuffer[vtx_i];

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	QWORD PTR tv313[rsp], rax
	mov	edx, DWORD PTR vtx_i$10[rsp]
	mov	rcx, QWORD PTR tv313[rsp]
	call	??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
	mov	QWORD PTR v$7[rsp], rax

; 8474 : 							triangles_pos[n] = v.pos;

	mov	rax, QWORD PTR v$7[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR n$5[rsp]
	mov	QWORD PTR triangles_pos$19[rsp+rcx*8], rax

; 8475 : 							buf_p += ImFormatString(buf_p, buf_end - buf_p, ("%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n"),

	mov	rax, QWORD PTR v$7[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv349[rsp], eax
	mov	rax, QWORD PTR v$7[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+12]
	movsd	QWORD PTR tv351[rsp], xmm0
	mov	rax, QWORD PTR v$7[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+8]
	movsd	QWORD PTR tv353[rsp], xmm0
	mov	rax, QWORD PTR v$7[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+4]
	movsd	QWORD PTR tv355[rsp], xmm0
	mov	rax, QWORD PTR v$7[rsp]
	cvtss2sd xmm0, DWORD PTR [rax]
	movsd	QWORD PTR tv357[rsp], xmm0
	mov	eax, DWORD PTR idx_i$4[rsp]
	mov	DWORD PTR tv347[rsp], eax
	cmp	DWORD PTR n$5[rsp], 0
	jne	SHORT $LN36@NodeDrawLi
	lea	rax, OFFSET FLAT:??_C@_03DAKNAIGI@idx@
	mov	QWORD PTR tv340[rsp], rax
	jmp	SHORT $LN37@NodeDrawLi
$LN36@NodeDrawLi:
	lea	rax, OFFSET FLAT:??_C@_03NDEAONJP@?5?5?5@
	mov	QWORD PTR tv340[rsp], rax
$LN37@NodeDrawLi:
	mov	rax, QWORD PTR buf_p$9[rsp]
	mov	rcx, QWORD PTR buf_end$13[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR tv349[rsp]
	mov	DWORD PTR [rsp+72], ecx
	movsd	xmm0, QWORD PTR tv351[rsp]
	movsd	QWORD PTR [rsp+64], xmm0
	movsd	xmm0, QWORD PTR tv353[rsp]
	movsd	QWORD PTR [rsp+56], xmm0
	movsd	xmm0, QWORD PTR tv355[rsp]
	movsd	QWORD PTR [rsp+48], xmm0
	movsd	xmm0, QWORD PTR tv357[rsp]
	movsd	QWORD PTR [rsp+40], xmm0
	mov	ecx, DWORD PTR tv347[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, QWORD PTR tv340[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DG@MPIFBGBG@?$CFs?5?$CF04d?3?5pos?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5uv?5@
	mov	rdx, rax
	mov	rcx, QWORD PTR buf_p$9[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	cdqe
	mov	rcx, QWORD PTR buf_p$9[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR buf_p$9[rsp], rax

; 8476 : 								(n == 0) ? "idx" : "   ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
; 8477 : 						}

	jmp	$LN13@NodeDrawLi
$LN14@NodeDrawLi:

; 8478 : 						ImGui::Selectable(buf, false);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, rax
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR buf$20[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	npad	1

; 8479 : 						if (ImGui::IsItemHovered())

	xor	ecx, ecx
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@NodeDrawLi

; 8480 : 						{
; 8481 : 							ImDrawListFlags backup_flags = overlay_draw_list->Flags;

	mov	rax, QWORD PTR overlay_draw_list$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR backup_flags$11[rsp], eax

; 8482 : 							overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.

	mov	rax, QWORD PTR overlay_draw_list$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, -2
	mov	rcx, QWORD PTR overlay_draw_list$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 8483 : 							overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255, 255, 0, 255), true, 1.0f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, -16711681				; ff00ffffH
	mov	r8d, 3
	lea	rdx, QWORD PTR triangles_pos$19[rsp]
	mov	rcx, QWORD PTR overlay_draw_list$[rsp]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline

; 8484 : 							overlay_draw_list->Flags = backup_flags;

	mov	rax, QWORD PTR overlay_draw_list$[rsp]
	mov	ecx, DWORD PTR backup_flags$11[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN24@NodeDrawLi:

; 8485 : 						}
; 8486 : 					}

	jmp	$LN10@NodeDrawLi
$LN11@NodeDrawLi:
	jmp	$LN8@NodeDrawLi
$LN9@NodeDrawLi:

; 8487 : 				ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1

; 8488 : 			}

	lea	rcx, QWORD PTR clipper$15[rsp]
	call	??1ImGuiListClipper@@QEAA@XZ		; ImGuiListClipper::~ImGuiListClipper
	npad	1
	jmp	$LN2@NodeDrawLi
$LN3@NodeDrawLi:

; 8489 : 			ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN1@NodeDrawLi:

; 8490 : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 776				; 00000308H
	ret	0
?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z ENDP ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
node_open$ = 80
pcmd$1 = 88
pcmd_node_open$2 = 96
i$3 = 100
elem_offset$ = 104
idx_i$4 = 108
n$5 = 112
overlay_draw_list$ = 120
prim$6 = 128
v$7 = 136
tv255 = 144
tv307 = 148
idx_buffer$8 = 152
buf_p$9 = 160
tv85 = 168
tv87 = 172
tv83 = 176
tv221 = 180
vtx_i$10 = 184
tv349 = 188
tv347 = 192
backup_flags$11 = 196
tv77 = 200
tv184 = 208
tv207 = 216
tv340 = 224
vtxs_rect$12 = 232
tv231 = 248
tv229 = 256
tv227 = 264
tv225 = 272
tv223 = 280
tv219 = 288
tv258 = 296
tv313 = 304
buf_end$13 = 312
tv351 = 320
tv355 = 328
tv357 = 336
tv353 = 344
clip_rect$14 = 352
clipper$15 = 368
$T16 = 392
$T17 = 400
$T18 = 408
triangles_pos$19 = 424
buf$20 = 448
__$ArrayPad$ = 752
window$ = 784
draw_list$ = 792
label$ = 800
?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA PROC ; ``ImGui::ShowMetricsWindow'::`2'::Funcs::NodeDrawList'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR clipper$15[rbp]
	call	??1ImGuiListClipper@@QEAA@XZ		; ImGuiListClipper::~ImGuiListClipper
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z@4HA ENDP ; ``ImGui::ShowMetricsWindow'::`2'::Funcs::NodeDrawList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ
text$yd	SEGMENT
??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ PROC ; `GetClipboardTextFn_DefaultImpl'::`2'::`dynamic atexit destructor for 'buf_local'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ ENDP ; `GetClipboardTextFn_DefaultImpl'::`2'::`dynamic atexit destructor for 'buf_local''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
n$1 = 32
columns$ = 40
tv73 = 48
tv81 = 56
tv129 = 64
tv128 = 72
tv90 = 80
$T2 = 88
window$ = 176
id$ = 184
?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z PROC ; FindOrAddColumnsSet

; 7430 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 7431 : 	for (int n = 0; n < window->ColumnsStorage.Size; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@FindOrAddC
$LN2@FindOrAddC:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@FindOrAddC:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+664]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@FindOrAddC

; 7432 : 		if (window->ColumnsStorage[n].ID == id)

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 664				; 00000298H
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z ; ImVector<ImGuiColumnsSet>::operator[]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+28], ecx
	jne	SHORT $LN5@FindOrAddC

; 7433 : 			return &window->ColumnsStorage[n];

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 664				; 00000298H
	mov	QWORD PTR tv81[rsp], rax
	mov	edx, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z ; ImVector<ImGuiColumnsSet>::operator[]
	jmp	SHORT $LN1@FindOrAddC
$LN5@FindOrAddC:
	jmp	SHORT $LN2@FindOrAddC
$LN3@FindOrAddC:

; 7434 : 
; 7435 : 	window->ColumnsStorage.push_back(ImGuiColumnsSet());

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 664				; 00000298H
	mov	QWORD PTR tv90[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImGuiColumnsSet@@QEAA@XZ		; ImGuiColumnsSet::ImGuiColumnsSet
	mov	QWORD PTR tv129[rsp], rax
	mov	rax, QWORD PTR tv129[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z ; ImVector<ImGuiColumnsSet>::push_back
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1ImGuiColumnsSet@@QEAA@XZ
	npad	1

; 7436 : 	ImGuiColumnsSet* columns = &window->ColumnsStorage.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 664				; 00000298H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@XZ ; ImVector<ImGuiColumnsSet>::back
	mov	QWORD PTR columns$[rsp], rax

; 7437 : 	columns->ID = id;

	mov	rax, QWORD PTR columns$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 7438 : 	return columns;

	mov	rax, QWORD PTR columns$[rsp]
$LN1@FindOrAddC:

; 7439 : }

	add	rsp, 168				; 000000a8H
	ret	0
?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z ENDP ; FindOrAddColumnsSet
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
n$1 = 32
columns$ = 40
tv73 = 48
tv81 = 56
tv129 = 64
tv128 = 72
tv90 = 80
$T2 = 88
window$ = 176
id$ = 184
?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA PROC ; `FindOrAddColumnsSet'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1ImGuiColumnsSet@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z@4HA ENDP ; `FindOrAddColumnsSet'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
offset_norm$ = 32
tv81 = 40
tv74 = 48
tv78 = 56
tv129 = 64
tv90 = 72
tv94 = 80
columns$ = 112
column_index$ = 120
before_resize$ = 128
?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z PROC	; GetColumnWidthEx

; 7363 : {

	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 7364 : 	if (column_index < 0)

	cmp	DWORD PTR column_index$[rsp], 0
	jge	SHORT $LN2@GetColumnW

; 7365 : 		column_index = columns->Current;

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR column_index$[rsp], eax
$LN2@GetColumnW:

; 7366 : 
; 7367 : 	float offset_norm;
; 7368 : 	if (before_resize)

	movzx	eax, BYTE PTR before_resize$[rsp]
	test	eax, eax
	je	SHORT $LN3@GetColumnW

; 7369 : 		offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv81[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	mov	QWORD PTR tv78[rsp], rax
	mov	ecx, DWORD PTR column_index$[rsp]
	inc	ecx
	mov	edx, ecx
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR [rax+24]
	mov	rax, QWORD PTR tv78[rsp]
	subss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR offset_norm$[rsp], xmm0
	jmp	SHORT $LN4@GetColumnW
$LN3@GetColumnW:

; 7370 : 	else
; 7371 : 		offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv129[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv129[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	mov	QWORD PTR tv94[rsp], rax
	mov	ecx, DWORD PTR column_index$[rsp]
	inc	ecx
	mov	edx, ecx
	mov	rcx, QWORD PTR tv90[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR tv94[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR offset_norm$[rsp], xmm0
$LN4@GetColumnW:

; 7372 : 	return OffsetNormToPixels(columns, offset_norm);

	movss	xmm1, DWORD PTR offset_norm$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	call	?OffsetNormToPixels@@YAMPEBUImGuiColumnsSet@@M@Z ; OffsetNormToPixels

; 7373 : }

	add	rsp, 104				; 00000068H
	ret	0
?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z ENDP	; GetColumnWidthEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
x$ = 32
tv70 = 36
g$ = 40
window$ = 48
columns$ = 80
column_index$ = 88
?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z PROC ; GetDraggedColumnOffset

; 7331 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 7332 : 	// Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
; 7333 : 	// window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
; 7334 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7335 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 7336 : 	IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
; 7337 : 	IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));
; 7338 : 
; 7339 : 	float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	subss	xmm0, DWORD PTR [rcx+6812]
	movss	DWORD PTR tv70[rsp], xmm0
	call	?GetColumnsRectHalfWidth@@YAMXZ		; GetColumnsRectHalfWidth
	movss	xmm1, DWORD PTR tv70[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR x$[rsp], xmm0

; 7340 : 	x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

	mov	eax, DWORD PTR column_index$[rsp]
	dec	eax
	mov	ecx, eax
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5568]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR x$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR x$[rsp], xmm0

; 7341 : 	if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN2@GetDragged

; 7342 : 		x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	mov	eax, DWORD PTR column_index$[rsp]
	inc	eax
	mov	ecx, eax
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	mov	rax, QWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR [rax+5568]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR x$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR x$[rsp], xmm0
$LN2@GetDragged:

; 7343 : 
; 7344 : 	return x;

	movss	xmm0, DWORD PTR x$[rsp]

; 7345 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z ENDP ; GetDraggedColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetColumnsRectHalfWidth@@YAMXZ PROC			; GetColumnsRectHalfWidth

; 7328 : static inline float GetColumnsRectHalfWidth() { return 4.0f; }

	movss	xmm0, DWORD PTR __real@40800000
	ret	0
?GetColumnsRectHalfWidth@@YAMXZ ENDP			; GetColumnsRectHalfWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
columns$ = 8
offset$ = 16
?PixelsToOffsetNorm@@YAMPEBUImGuiColumnsSet@@M@Z PROC	; PixelsToOffsetNorm

; 7324 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 7325 : 	return offset / (columns->MaxX - columns->MinX);

	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx+4]
	movss	xmm1, DWORD PTR offset$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 7326 : }

	ret	0
?PixelsToOffsetNorm@@YAMPEBUImGuiColumnsSet@@M@Z ENDP	; PixelsToOffsetNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
columns$ = 8
offset_norm$ = 16
?OffsetNormToPixels@@YAMPEBUImGuiColumnsSet@@M@Z PROC	; OffsetNormToPixels

; 7319 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 7320 : 	return offset_norm * (columns->MaxX - columns->MinX);

	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx+4]
	movss	xmm1, DWORD PTR offset_norm$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1

; 7321 : }

	ret	0
?OffsetNormToPixels@@YAMPEBUImGuiColumnsSet@@M@Z ENDP	; OffsetNormToPixels
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i_current$ = 32
tv84 = 36
tv87 = 40
g$ = 48
window_target$ = 56
focus_change_dir$ = 80
?NavUpdateWindowingHighlightWindow@@YAXH@Z PROC		; NavUpdateWindowingHighlightWindow

; 7078 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 7079 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7080 : 	IM_ASSERT(g.NavWindowingTarget);
; 7081 : 	if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN2@NavUpdateW

; 7082 : 		return;

	jmp	$LN1@NavUpdateW
$LN2@NavUpdateW:

; 7083 : 
; 7084 : 	const int i_current = FindWindowFocusIndex(g.NavWindowingTarget);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7104]
	call	?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z ; FindWindowFocusIndex
	mov	DWORD PTR i_current$[rsp], eax

; 7085 : 	ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);

	mov	eax, DWORD PTR focus_change_dir$[rsp]
	mov	ecx, DWORD PTR i_current$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	r8d, DWORD PTR focus_change_dir$[rsp]
	mov	edx, -2147483647			; ffffffff80000001H
	mov	ecx, eax
	call	?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z ; FindWindowNavFocusable
	mov	QWORD PTR window_target$[rsp], rax

; 7086 : 	if (!window_target)

	cmp	QWORD PTR window_target$[rsp], 0
	jne	SHORT $LN3@NavUpdateW

; 7087 : 		window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);

	mov	eax, DWORD PTR i_current$[rsp]
	mov	DWORD PTR tv87[rsp], eax
	cmp	DWORD PTR focus_change_dir$[rsp], 0
	jge	SHORT $LN6@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	dec	eax
	mov	DWORD PTR tv84[rsp], eax
	jmp	SHORT $LN7@NavUpdateW
$LN6@NavUpdateW:
	mov	DWORD PTR tv84[rsp], 0
$LN7@NavUpdateW:
	mov	r8d, DWORD PTR focus_change_dir$[rsp]
	mov	edx, DWORD PTR tv87[rsp]
	mov	ecx, DWORD PTR tv84[rsp]
	call	?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z ; FindWindowNavFocusable
	mov	QWORD PTR window_target$[rsp], rax
$LN3@NavUpdateW:

; 7088 : 	if (window_target) // Don't reset windowing target if there's a single window in the list

	cmp	QWORD PTR window_target$[rsp], 0
	je	SHORT $LN4@NavUpdateW

; 7089 : 		g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window_target$[rsp]
	mov	QWORD PTR [rax+7112], rcx
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window_target$[rsp]
	mov	QWORD PTR [rax+7104], rcx
$LN4@NavUpdateW:

; 7090 : 	g.NavWindowingToggleLayer = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7128], 0
$LN1@NavUpdateW:

; 7091 : }

	add	rsp, 72					; 00000048H
	ret	0
?NavUpdateWindowingHighlightWindow@@YAXH@Z ENDP		; NavUpdateWindowingHighlightWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
tv76 = 48
tv85 = 56
i_start$ = 80
i_stop$ = 88
dir$ = 96
?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z PROC	; FindWindowNavFocusable

; 7069 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 7070 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7071 : 	for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)

	mov	eax, DWORD PTR i_start$[rsp]
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@FindWindow
$LN2@FindWindow:
	mov	eax, DWORD PTR dir$[rsp]
	mov	ecx, DWORD PTR i$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$1[rsp], eax
$LN4@FindWindow:
	cmp	DWORD PTR i$1[rsp], 0
	jl	SHORT $LN3@FindWindow
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@FindWindow
	mov	eax, DWORD PTR i_stop$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	je	SHORT $LN3@FindWindow

; 7072 : 		if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv76[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR [rax]
	call	?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z ; ImGui::IsWindowNavFocusable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@FindWindow

; 7073 : 			return g.WindowsFocusOrder[i];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv85[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv85[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@FindWindow
$LN5@FindWindow:
	jmp	$LN2@FindWindow
$LN3@FindWindow:

; 7074 : 	return NULL;

	xor	eax, eax
$LN1@FindWindow:

; 7075 : }

	add	rsp, 72					; 00000048H
	ret	0
?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z ENDP	; FindWindowNavFocusable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
tv74 = 48
window$ = 80
?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z PROC	; FindWindowFocusIndex

; 7060 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 7061 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7062 : 	for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@FindWindow
$LN2@FindWindow:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FindWindow:
	cmp	DWORD PTR i$1[rsp], 0
	jl	SHORT $LN3@FindWindow

; 7063 : 		if (g.WindowsFocusOrder[i] == window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN5@FindWindow

; 7064 : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN1@FindWindow
$LN5@FindWindow:
	jmp	SHORT $LN2@FindWindow
$LN3@FindWindow:

; 7065 : 	return -1;

	mov	eax, -1
$LN1@FindWindow:

; 7066 : }

	add	rsp, 72					; 00000048H
	ret	0
?FindWindowFocusIndex@@YAHPEAUImGuiWindow@@@Z ENDP	; FindWindowFocusIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv91 = 40
tv89 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
window_rect$ = 88
window$ = 128
item_rect$ = 136
?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z PROC ; NavScrollToBringItemIntoView

; 6660 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 6661 : 	ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 592				; 00000250H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv91[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 584				; 00000248H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T4[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv89[rsp], rax
	mov	r8, QWORD PTR tv91[rsp]
	mov	rdx, QWORD PTR tv89[rsp]
	lea	rcx, QWORD PTR window_rect$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 6662 : 	//GetOverlayDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
; 6663 : 	if (window_rect.Contains(item_rect))

	mov	rdx, QWORD PTR item_rect$[rsp]
	lea	rcx, QWORD PTR window_rect$[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@NavScrollT

; 6664 : 		return;

	jmp	$LN1@NavScrollT
$LN2@NavScrollT:

; 6665 : 
; 6666 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6667 : 	if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	test	eax, eax
	je	SHORT $LN3@NavScrollT
	mov	rax, QWORD PTR item_rect$[rsp]
	movss	xmm0, DWORD PTR window_rect$[rsp]
	comiss	xmm0, DWORD PTR [rax]
	jbe	SHORT $LN3@NavScrollT

; 6668 : 	{
; 6669 : 		window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;

	mov	rax, QWORD PTR item_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+92]
	mov	rax, QWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR [rax+5540]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+104], xmm0

; 6670 : 		window->ScrollTargetCenterRatio.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+116], xmm0

; 6671 : 	}

	jmp	SHORT $LN4@NavScrollT
$LN3@NavScrollT:

; 6672 : 	else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	test	eax, eax
	je	SHORT $LN5@NavScrollT
	mov	rax, QWORD PTR item_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR window_rect$[rsp+8]
	jb	SHORT $LN5@NavScrollT

; 6673 : 	{
; 6674 : 		window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;

	mov	rax, QWORD PTR item_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+92]
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5540]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+104], xmm0

; 6675 : 		window->ScrollTargetCenterRatio.x = 1.0f;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+116], xmm0
$LN5@NavScrollT:
$LN4@NavScrollT:

; 6676 : 	}
; 6677 : 	if (item_rect.Min.y < window_rect.Min.y)

	mov	rax, QWORD PTR item_rect$[rsp]
	movss	xmm0, DWORD PTR window_rect$[rsp+4]
	comiss	xmm0, DWORD PTR [rax+4]
	jbe	SHORT $LN6@NavScrollT

; 6678 : 	{
; 6679 : 		window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;

	mov	rax, QWORD PTR item_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+52]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+96]
	mov	rax, QWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR [rax+5544]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+108], xmm0

; 6680 : 		window->ScrollTargetCenterRatio.y = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+120], xmm0

; 6681 : 	}

	jmp	SHORT $LN7@NavScrollT
$LN6@NavScrollT:

; 6682 : 	else if (item_rect.Max.y >= window_rect.Max.y)

	mov	rax, QWORD PTR item_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR window_rect$[rsp+12]
	jb	SHORT $LN8@NavScrollT

; 6683 : 	{
; 6684 : 		window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;

	mov	rax, QWORD PTR item_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+52]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+96]
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5544]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+108], xmm0

; 6685 : 		window->ScrollTargetCenterRatio.y = 1.0f;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+120], xmm0
$LN8@NavScrollT:
$LN7@NavScrollT:
$LN1@NavScrollT:

; 6686 : 	}
; 6687 : }

	add	rsp, 120				; 00000078H
	ret	0
?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ENDP ; NavScrollToBringItemIntoView
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv84 = 40
layer$ = 64
?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z PROC		; NavRestoreLayer

; 6556 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 6557 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6558 : 	g.NavLayer = layer;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR layer$[rsp]
	mov	DWORD PTR [rax+7132], ecx

; 6559 : 	if (layer == 0)

	cmp	DWORD PTR layer$[rsp], 0
	jne	SHORT $LN2@NavRestore

; 6560 : 		g.NavWindow = ImGui::NavRestoreLastChildNavWindow(g.NavWindow);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7024]
	call	?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z ; ImGui::NavRestoreLastChildNavWindow
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+7024], rax
$LN2@NavRestore:

; 6561 : 	if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)

	cmp	DWORD PTR layer$[rsp], 0
	jne	SHORT $LN3@NavRestore
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	ecx, 4
	imul	rcx, rcx, 0
	cmp	DWORD PTR [rax+rcx+904], 0
	je	SHORT $LN3@NavRestore

; 6562 : 		ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	ecx, 16
	imul	rcx, rcx, 0
	lea	rax, QWORD PTR [rax+rcx+912]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	QWORD PTR tv84[rsp], rdx
	mov	r8, rax
	mov	edx, DWORD PTR layer$[rsp]
	mov	rax, QWORD PTR tv84[rsp]
	mov	ecx, DWORD PTR [rcx+rax+904]
	call	?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z ; ImGui::SetNavIDWithRectRel
	npad	1
	jmp	SHORT $LN4@NavRestore
$LN3@NavRestore:

; 6563 : 	else
; 6564 : 		ImGui::NavInitWindow(g.NavWindow, true);

	mov	dl, 1
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7024]
	call	?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z ; ImGui::NavInitWindow
	npad	1
$LN4@NavRestore:

; 6565 : }

	add	rsp, 56					; 00000038H
	ret	0
?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z ENDP		; NavRestoreLayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
new_best$ = 32
dbx$ = 36
g$ = 40
dby$ = 48
dist_center$ = 52
curr$ = 56
dcy$ = 64
dcx$ = 68
dist_box$ = 72
dax$ = 76
day$ = 80
dist_axial$ = 84
quadrant$ = 88
window$ = 96
tv187 = 104
tv235 = 108
tv253 = 112
tv182 = 116
tv180 = 120
tv178 = 124
tv176 = 128
tv189 = 132
tv216 = 136
tv82 = 144
result$ = 176
cand$ = 184
?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z PROC ; NavScoreItem

; 6279 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 6280 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6281 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6282 : 	if (g.NavLayer != window->DC.NavLayerCurrent)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+400]
	cmp	DWORD PTR [rax+7132], ecx
	je	SHORT $LN2@NavScoreIt

; 6283 : 		return false;

	xor	al, al
	jmp	$LN1@NavScoreIt
$LN2@NavScoreIt:

; 6284 : 
; 6285 : 	const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7072				; 00001ba0H
	mov	QWORD PTR curr$[rsp], rax

; 6286 : 	g.NavScoringCount++;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7088]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+7088], eax

; 6287 : 
; 6288 : 	// When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
; 6289 : 	if (window->ParentWindow == g.NavWindow)

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	cmp	QWORD PTR [rax+880], rcx
	jne	SHORT $LN3@NavScoreIt

; 6290 : 	{
; 6291 : 		IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
; 6292 : 		if (!window->ClipRect.Contains(cand))

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR cand$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@NavScoreIt

; 6293 : 			return false;

	xor	al, al
	jmp	$LN1@NavScoreIt
$LN4@NavScoreIt:

; 6294 : 		cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	rdx, rax
	mov	rcx, QWORD PTR cand$[rsp]
	call	?ClipWithFull@ImRect@@QEAAXAEBU1@@Z	; ImRect::ClipWithFull
	npad	1
$LN3@NavScoreIt:

; 6295 : 	}
; 6296 : 
; 6297 : 	// We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
; 6298 : 	// For example, this ensure that items in one column are not reached when moving vertically from items in another column.
; 6299 : 	NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	r8, rax
	mov	rdx, QWORD PTR cand$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7284]
	call	?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z ; NavClampRectToVisibleAreaForMoveDir

; 6300 : 
; 6301 : 	// Compute distance between boxes
; 6302 : 	// FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
; 6303 : 	float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);

	mov	rax, QWORD PTR curr$[rsp]
	movss	xmm3, DWORD PTR [rax+8]
	mov	rax, QWORD PTR curr$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mov	rax, QWORD PTR cand$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rax, QWORD PTR cand$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?NavScoreItemDistInterval@@YAMMMMM@Z	; NavScoreItemDistInterval
	movss	DWORD PTR dbx$[rsp], xmm0

; 6304 : 	float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items

	movss	xmm2, DWORD PTR __real@3f4ccccd
	mov	rax, QWORD PTR curr$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR curr$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv182[rsp], xmm0
	movss	xmm2, DWORD PTR __real@3e4ccccd
	mov	rax, QWORD PTR curr$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR curr$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv180[rsp], xmm0
	movss	xmm2, DWORD PTR __real@3f4ccccd
	mov	rax, QWORD PTR cand$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR cand$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv178[rsp], xmm0
	movss	xmm2, DWORD PTR __real@3e4ccccd
	mov	rax, QWORD PTR cand$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR cand$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv176[rsp], xmm0
	movss	xmm3, DWORD PTR tv182[rsp]
	movss	xmm2, DWORD PTR tv180[rsp]
	movss	xmm1, DWORD PTR tv178[rsp]
	movss	xmm0, DWORD PTR tv176[rsp]
	call	?NavScoreItemDistInterval@@YAMMMMM@Z	; NavScoreItemDistInterval
	movss	DWORD PTR dby$[rsp], xmm0

; 6305 : 	if (dby != 0.0f && dbx != 0.0f)

	movss	xmm0, DWORD PTR dby$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN36@NavScoreIt
	je	SHORT $LN5@NavScoreIt
$LN36@NavScoreIt:
	movss	xmm0, DWORD PTR dbx$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN35@NavScoreIt
	je	SHORT $LN5@NavScoreIt
$LN35@NavScoreIt:

; 6306 : 		dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);

	movss	xmm0, DWORD PTR dbx$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN27@NavScoreIt
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv187[rsp], xmm0
	jmp	SHORT $LN28@NavScoreIt
$LN27@NavScoreIt:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv187[rsp], xmm0
$LN28@NavScoreIt:
	movss	xmm0, DWORD PTR dbx$[rsp]
	divss	xmm0, DWORD PTR __real@447a0000
	addss	xmm0, DWORD PTR tv187[rsp]
	movss	DWORD PTR dbx$[rsp], xmm0
$LN5@NavScoreIt:

; 6307 : 	float dist_box = ImFabs(dbx) + ImFabs(dby);

	movss	xmm0, DWORD PTR dbx$[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	DWORD PTR tv189[rsp], xmm0
	movss	xmm0, DWORD PTR dby$[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	xmm1, DWORD PTR tv189[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist_box$[rsp], xmm0

; 6308 : 
; 6309 : 	// Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
; 6310 : 	float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);

	mov	rax, QWORD PTR cand$[rsp]
	mov	rcx, QWORD PTR cand$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx+8]
	subss	xmm0, xmm1
	movss	DWORD PTR dcx$[rsp], xmm0

; 6311 : 	float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);

	mov	rax, QWORD PTR cand$[rsp]
	mov	rcx, QWORD PTR cand$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+12]
	subss	xmm0, xmm1
	movss	DWORD PTR dcy$[rsp], xmm0

; 6312 : 	float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

	movss	xmm0, DWORD PTR dcx$[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	DWORD PTR tv216[rsp], xmm0
	movss	xmm0, DWORD PTR dcy$[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	xmm1, DWORD PTR tv216[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist_center$[rsp], xmm0

; 6313 : 
; 6314 : 	// Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
; 6315 : 	ImGuiDir quadrant;
; 6316 : 	float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR dax$[rsp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR day$[rsp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR dist_axial$[rsp], xmm0

; 6317 : 	if (dbx != 0.0f || dby != 0.0f)

	movss	xmm0, DWORD PTR dbx$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN8@NavScoreIt
	jne	SHORT $LN8@NavScoreIt
	movss	xmm0, DWORD PTR dby$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN34@NavScoreIt
	je	SHORT $LN6@NavScoreIt
$LN34@NavScoreIt:
$LN8@NavScoreIt:

; 6318 : 	{
; 6319 : 		// For non-overlapping boxes, use distance between boxes
; 6320 : 		dax = dbx;

	movss	xmm0, DWORD PTR dbx$[rsp]
	movss	DWORD PTR dax$[rsp], xmm0

; 6321 : 		day = dby;

	movss	xmm0, DWORD PTR dby$[rsp]
	movss	DWORD PTR day$[rsp], xmm0

; 6322 : 		dist_axial = dist_box;

	movss	xmm0, DWORD PTR dist_box$[rsp]
	movss	DWORD PTR dist_axial$[rsp], xmm0

; 6323 : 		quadrant = ImGetDirQuadrantFromDelta(dbx, dby);

	movss	xmm1, DWORD PTR dby$[rsp]
	movss	xmm0, DWORD PTR dbx$[rsp]
	call	?ImGetDirQuadrantFromDelta@@YAHMM@Z	; ImGetDirQuadrantFromDelta
	mov	DWORD PTR quadrant$[rsp], eax

; 6324 : 	}

	jmp	$LN7@NavScoreIt
$LN6@NavScoreIt:

; 6325 : 	else if (dcx != 0.0f || dcy != 0.0f)

	movss	xmm0, DWORD PTR dcx$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN11@NavScoreIt
	jne	SHORT $LN11@NavScoreIt
	movss	xmm0, DWORD PTR dcy$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN33@NavScoreIt
	je	SHORT $LN9@NavScoreIt
$LN33@NavScoreIt:
$LN11@NavScoreIt:

; 6326 : 	{
; 6327 : 		// For overlapping boxes with different centers, use distance between centers
; 6328 : 		dax = dcx;

	movss	xmm0, DWORD PTR dcx$[rsp]
	movss	DWORD PTR dax$[rsp], xmm0

; 6329 : 		day = dcy;

	movss	xmm0, DWORD PTR dcy$[rsp]
	movss	DWORD PTR day$[rsp], xmm0

; 6330 : 		dist_axial = dist_center;

	movss	xmm0, DWORD PTR dist_center$[rsp]
	movss	DWORD PTR dist_axial$[rsp], xmm0

; 6331 : 		quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);

	movss	xmm1, DWORD PTR dcy$[rsp]
	movss	xmm0, DWORD PTR dcx$[rsp]
	call	?ImGetDirQuadrantFromDelta@@YAHMM@Z	; ImGetDirQuadrantFromDelta
	mov	DWORD PTR quadrant$[rsp], eax

; 6332 : 	}

	jmp	SHORT $LN10@NavScoreIt
$LN9@NavScoreIt:

; 6333 : 	else
; 6334 : 	{
; 6335 : 		// Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
; 6336 : 		quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	cmp	DWORD PTR [rax+412], ecx
	jae	SHORT $LN29@NavScoreIt
	mov	DWORD PTR tv235[rsp], 0
	jmp	SHORT $LN30@NavScoreIt
$LN29@NavScoreIt:
	mov	DWORD PTR tv235[rsp], 1
$LN30@NavScoreIt:
	mov	eax, DWORD PTR tv235[rsp]
	mov	DWORD PTR quadrant$[rsp], eax
$LN10@NavScoreIt:
$LN7@NavScoreIt:

; 6337 : 	}
; 6338 : 
; 6339 : #if IMGUI_DEBUG_NAV_SCORING
; 6340 : 	char buf[128];
; 6341 : 	if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
; 6342 : 	{
; 6343 : 		ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
; 6344 : 		ImDrawList* draw_list = ImGui::GetOverlayDrawList(window);
; 6345 : 		draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
; 6346 : 		draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
; 6347 : 		draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + ImGui::CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 150));
; 6348 : 		draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
; 6349 : 	}
; 6350 : 	else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
; 6351 : 	{
; 6352 : 		if (ImGui::IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
; 6353 : 		if (quadrant == g.NavMoveDir)
; 6354 : 		{
; 6355 : 			ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
; 6356 : 			ImDrawList* draw_list = ImGui::GetOverlayDrawList(window);
; 6357 : 			draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
; 6358 : 			draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
; 6359 : 		}
; 6360 : 	}
; 6361 : #endif
; 6362 : 
; 6363 : 	// Is it in the quadrant we're interesting in moving to?
; 6364 : 	bool new_best = false;

	mov	BYTE PTR new_best$[rsp], 0

; 6365 : 	if (quadrant == g.NavMoveDir)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7276]
	cmp	DWORD PTR quadrant$[rsp], eax
	jne	$LN12@NavScoreIt

; 6366 : 	{
; 6367 : 		// Does it beat the current best candidate?
; 6368 : 		if (dist_box < result->DistBox)

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR dist_box$[rsp]
	jbe	SHORT $LN13@NavScoreIt

; 6369 : 		{
; 6370 : 			result->DistBox = dist_box;

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR dist_box$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 6371 : 			result->DistCenter = dist_center;

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR dist_center$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 6372 : 			return true;

	mov	al, 1
	jmp	$LN1@NavScoreIt
$LN13@NavScoreIt:

; 6373 : 		}
; 6374 : 		if (dist_box == result->DistBox)

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR dist_box$[rsp]
	ucomiss	xmm0, DWORD PTR [rax+4]
	jp	$LN14@NavScoreIt
	jne	$LN14@NavScoreIt

; 6375 : 		{
; 6376 : 			// Try using distance between center points to break ties
; 6377 : 			if (dist_center < result->DistCenter)

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	comiss	xmm0, DWORD PTR dist_center$[rsp]
	jbe	SHORT $LN15@NavScoreIt

; 6378 : 			{
; 6379 : 				result->DistCenter = dist_center;

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR dist_center$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 6380 : 				new_best = true;

	mov	BYTE PTR new_best$[rsp], 1

; 6381 : 			}

	jmp	SHORT $LN16@NavScoreIt
$LN15@NavScoreIt:

; 6382 : 			else if (dist_center == result->DistCenter)

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR dist_center$[rsp]
	ucomiss	xmm0, DWORD PTR [rax+16]
	jp	SHORT $LN17@NavScoreIt
	jne	SHORT $LN17@NavScoreIt

; 6383 : 			{
; 6384 : 				// Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
; 6385 : 				// (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
; 6386 : 				// this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
; 6387 : 				if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 2
	je	SHORT $LN31@NavScoreIt
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 3
	je	SHORT $LN31@NavScoreIt
	movss	xmm0, DWORD PTR dbx$[rsp]
	movss	DWORD PTR tv253[rsp], xmm0
	jmp	SHORT $LN32@NavScoreIt
$LN31@NavScoreIt:
	movss	xmm0, DWORD PTR dby$[rsp]
	movss	DWORD PTR tv253[rsp], xmm0
$LN32@NavScoreIt:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR tv253[rsp]
	jbe	SHORT $LN18@NavScoreIt

; 6388 : 					new_best = true;

	mov	BYTE PTR new_best$[rsp], 1
$LN18@NavScoreIt:
$LN17@NavScoreIt:
$LN16@NavScoreIt:
$LN14@NavScoreIt:
$LN12@NavScoreIt:

; 6389 : 			}
; 6390 : 		}
; 6391 : 	}
; 6392 : 
; 6393 : 	// Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
; 6394 : 	// are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
; 6395 : 	// This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
; 6396 : 	// 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
; 6397 : 	// Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
; 6398 : 	if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	$LN19@NavScoreIt
	jne	$LN19@NavScoreIt
	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	comiss	xmm0, DWORD PTR dist_axial$[rsp]
	jbe	$LN19@NavScoreIt

; 6399 : 		if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 1
	jne	$LN20@NavScoreIt
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	jne	$LN20@NavScoreIt

; 6400 : 			if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	jne	SHORT $LN23@NavScoreIt
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR dax$[rsp]
	ja	SHORT $LN22@NavScoreIt
$LN23@NavScoreIt:
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 1
	jne	SHORT $LN24@NavScoreIt
	movss	xmm0, DWORD PTR dax$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN22@NavScoreIt
$LN24@NavScoreIt:
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 2
	jne	SHORT $LN25@NavScoreIt
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR day$[rsp]
	ja	SHORT $LN22@NavScoreIt
$LN25@NavScoreIt:
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 3
	jne	SHORT $LN21@NavScoreIt
	movss	xmm0, DWORD PTR day$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN21@NavScoreIt
$LN22@NavScoreIt:

; 6401 : 			{
; 6402 : 				result->DistAxial = dist_axial;

	mov	rax, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR dist_axial$[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 6403 : 				new_best = true;

	mov	BYTE PTR new_best$[rsp], 1
$LN21@NavScoreIt:
$LN20@NavScoreIt:
$LN19@NavScoreIt:

; 6404 : 			}
; 6405 : 
; 6406 : 	return new_best;

	movzx	eax, BYTE PTR new_best$[rsp]
$LN1@NavScoreIt:

; 6407 : }

	add	rsp, 168				; 000000a8H
	ret	0
?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z ENDP ; NavScoreItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
move_dir$ = 48
r$ = 56
clip_rect$ = 64
?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z PROC ; NavClampRectToVisibleAreaForMoveDir

; 6264 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 6265 : 	if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)

	cmp	DWORD PTR move_dir$[rsp], 0
	je	SHORT $LN4@NavClampRe
	cmp	DWORD PTR move_dir$[rsp], 1
	jne	SHORT $LN2@NavClampRe
$LN4@NavClampRe:

; 6266 : 	{
; 6267 : 		r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	mov	rax, QWORD PTR r$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 6268 : 		r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	mov	rax, QWORD PTR r$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 6269 : 	}

	jmp	SHORT $LN3@NavClampRe
$LN2@NavClampRe:

; 6270 : 	else
; 6271 : 	{
; 6272 : 		r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	mov	rax, QWORD PTR r$[rsp]
	movss	DWORD PTR [rax], xmm0

; 6273 : 		r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	mov	rax, QWORD PTR r$[rsp]
	movss	DWORD PTR [rax+8], xmm0
$LN3@NavClampRe:

; 6274 : 	}
; 6275 : }

	add	rsp, 40					; 00000028H
	ret	0
?NavClampRectToVisibleAreaForMoveDir@@YAXHAEAUImRect@@AEBU1@@Z ENDP ; NavClampRectToVisibleAreaForMoveDir
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
a0$ = 8
a1$ = 16
b0$ = 24
b1$ = 32
?NavScoreItemDistInterval@@YAMMMMM@Z PROC		; NavScoreItemDistInterval

; 6255 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0

; 6256 : 	if (a1 < b0)

	movss	xmm0, DWORD PTR b0$[rsp]
	comiss	xmm0, DWORD PTR a1$[rsp]
	jbe	SHORT $LN2@NavScoreIt

; 6257 : 		return a1 - b0;

	movss	xmm0, DWORD PTR a1$[rsp]
	subss	xmm0, DWORD PTR b0$[rsp]
	jmp	SHORT $LN1@NavScoreIt
$LN2@NavScoreIt:

; 6258 : 	if (b1 < a0)

	movss	xmm0, DWORD PTR a0$[rsp]
	comiss	xmm0, DWORD PTR b1$[rsp]
	jbe	SHORT $LN3@NavScoreIt

; 6259 : 		return a0 - b1;

	movss	xmm0, DWORD PTR a0$[rsp]
	subss	xmm0, DWORD PTR b1$[rsp]
	jmp	SHORT $LN1@NavScoreIt
$LN3@NavScoreIt:

; 6260 : 	return 0.0f;

	xorps	xmm0, xmm0
$LN1@NavScoreIt:

; 6261 : }

	ret	0
?NavScoreItemDistInterval@@YAMMMMM@Z ENDP		; NavScoreItemDistInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
idx$ = 8
?GetStyleVarInfo@@YAPEBUImGuiStyleVarInfo@@H@Z PROC	; GetStyleVarInfo

; 4937 : {

	mov	DWORD PTR [rsp+8], ecx

; 4938 : 	IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
; 4939 : 	IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
; 4940 : 	return &GStyleVarInfo[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:?GStyleVarInfo@@3QBUImGuiStyleVarInfo@@B
	add	rcx, rax
	mov	rax, rcx

; 4941 : }

	ret	0
?GetStyleVarInfo@@YAPEBUImGuiStyleVarInfo@@H@Z ENDP	; GetStyleVarInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
;	COMDAT ?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z
_TEXT	SEGMENT
this$ = 8
style$ = 16
?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z PROC ; ImGuiStyleVarInfo::GetVarPtr, COMDAT

; 4906 : 	void* GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR style$[rsp]
	add	rcx, rax
	mov	rax, rcx
	ret	0
?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z ENDP ; ImGuiStyleVarInfo::GetVarPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR b$[rsp]
	subss	xmm0, DWORD PTR a$[rsp]
	mulss	xmm0, DWORD PTR t$[rsp]
	movss	xmm1, DWORD PTR a$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	ret	0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv82 = 48
tv92 = 52
tv134 = 56
tv144 = 60
$T1 = 64
rect$ = 72
__$ReturnUdt$ = 112
window$ = 120
border_n$ = 128
perp_padding$ = 136
thickness$ = 144
?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z PROC ; GetResizeBorderRect

; 3795 : {

	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3796 : 	ImRect rect = window->Rect();

	lea	rdx, QWORD PTR rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect
	npad	1

; 3797 : 	if (thickness == 0.0f) rect.Max -= ImVec2(1, 1);

	movss	xmm0, DWORD PTR thickness$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@GetResizeB
	jne	SHORT $LN2@GetResizeB
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR rect$[rsp+8]
	call	??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator-=
	npad	1
$LN2@GetResizeB:

; 3798 : 	if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness, rect.Max.x - perp_padding, rect.Min.y + thickness);      // Top

	cmp	DWORD PTR border_n$[rsp], 0
	jne	SHORT $LN3@GetResizeB
	movss	xmm0, DWORD PTR rect$[rsp+4]
	addss	xmm0, DWORD PTR thickness$[rsp]
	movss	xmm1, DWORD PTR rect$[rsp+8]
	subss	xmm1, DWORD PTR perp_padding$[rsp]
	movss	xmm2, DWORD PTR rect$[rsp+4]
	subss	xmm2, DWORD PTR thickness$[rsp]
	movss	xmm3, DWORD PTR rect$[rsp]
	addss	xmm3, DWORD PTR perp_padding$[rsp]
	movss	DWORD PTR tv82[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv82[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetResizeB
$LN3@GetResizeB:

; 3799 : 	if (border_n == 1) return ImRect(rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x + thickness, rect.Max.y - perp_padding);   // Right

	cmp	DWORD PTR border_n$[rsp], 1
	jne	SHORT $LN4@GetResizeB
	movss	xmm0, DWORD PTR rect$[rsp+12]
	subss	xmm0, DWORD PTR perp_padding$[rsp]
	movss	xmm1, DWORD PTR rect$[rsp+8]
	addss	xmm1, DWORD PTR thickness$[rsp]
	movss	xmm2, DWORD PTR rect$[rsp+4]
	addss	xmm2, DWORD PTR perp_padding$[rsp]
	movss	xmm3, DWORD PTR rect$[rsp+8]
	subss	xmm3, DWORD PTR thickness$[rsp]
	movss	DWORD PTR tv92[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv92[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetResizeB
$LN4@GetResizeB:

; 3800 : 	if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y + thickness);      // Bottom

	cmp	DWORD PTR border_n$[rsp], 2
	jne	SHORT $LN5@GetResizeB
	movss	xmm0, DWORD PTR rect$[rsp+12]
	addss	xmm0, DWORD PTR thickness$[rsp]
	movss	xmm1, DWORD PTR rect$[rsp+8]
	subss	xmm1, DWORD PTR perp_padding$[rsp]
	movss	xmm2, DWORD PTR rect$[rsp+12]
	subss	xmm2, DWORD PTR thickness$[rsp]
	movss	xmm3, DWORD PTR rect$[rsp]
	addss	xmm3, DWORD PTR perp_padding$[rsp]
	movss	DWORD PTR tv134[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv134[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetResizeB
$LN5@GetResizeB:

; 3801 : 	if (border_n == 3) return ImRect(rect.Min.x - thickness, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding);   // Left

	cmp	DWORD PTR border_n$[rsp], 3
	jne	SHORT $LN6@GetResizeB
	movss	xmm0, DWORD PTR rect$[rsp+12]
	subss	xmm0, DWORD PTR perp_padding$[rsp]
	movss	xmm1, DWORD PTR rect$[rsp]
	addss	xmm1, DWORD PTR thickness$[rsp]
	movss	xmm2, DWORD PTR rect$[rsp+4]
	addss	xmm2, DWORD PTR perp_padding$[rsp]
	movss	xmm3, DWORD PTR rect$[rsp]
	subss	xmm3, DWORD PTR thickness$[rsp]
	movss	DWORD PTR tv144[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv144[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetResizeB
$LN6@GetResizeB:

; 3802 : 	IM_ASSERT(0);
; 3803 : 	return ImRect();

	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetResizeB:

; 3804 : }

	add	rsp, 104				; 00000068H
	ret	0
?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z ENDP ; GetResizeBorderRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
;	COMDAT ??__Eresize_grip_def@@YAXXZ
text$di	SEGMENT
??__Eresize_grip_def@@YAXXZ PROC			; `dynamic initializer for 'resize_grip_def'', COMDAT

; 3792 : };

	sub	rsp, 40					; 00000028H

; 3788 : 	{ ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+8
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+16, 0
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+20, 3

; 3789 : 	{ ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+24
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+32
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+40, 3
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+44, 6

; 3790 : 	{ ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+48
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+56
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+64, 6
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+68, 9

; 3791 : 	{ ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+72
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B+80
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+88, 9
	mov	DWORD PTR ?resize_grip_def@@3QBUImGuiResizeGripDef@@B+92, 12
	add	rsp, 40					; 00000028H
	ret	0
??__Eresize_grip_def@@YAXXZ ENDP			; `dynamic initializer for 'resize_grip_def''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
size_expected$ = 32
size_constrained$ = 40
pos_min$ = 48
pos_max$ = 56
$T1 = 64
window$ = 96
corner_target$ = 104
corner_norm$ = 112
out_pos$ = 120
out_size$ = 128
?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z PROC ; CalcResizePosSizeFromAnyCorner

; 3766 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 3767 : 	ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	r9, QWORD PTR corner_norm$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR corner_target$[rsp]
	lea	rcx, QWORD PTR pos_min$[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	npad	1

; 3768 : 	ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r9, QWORD PTR corner_norm$[rsp]
	mov	r8, QWORD PTR corner_target$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR pos_max$[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	npad	1

; 3769 : 	ImVec2 size_expected = pos_max - pos_min;

	lea	r8, QWORD PTR pos_min$[rsp]
	lea	rdx, QWORD PTR pos_max$[rsp]
	lea	rcx, QWORD PTR size_expected$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 3770 : 	ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);

	mov	r8, QWORD PTR size_expected$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR size_constrained$[rsp]
	call	?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ; CalcSizeAfterConstraint

; 3771 : 	*out_pos = pos_min;

	mov	rax, QWORD PTR out_pos$[rsp]
	mov	rcx, QWORD PTR pos_min$[rsp]
	mov	QWORD PTR [rax], rcx

; 3772 : 	if (corner_norm.x == 0.0f)

	mov	rax, QWORD PTR corner_norm$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@CalcResize
	jne	SHORT $LN2@CalcResize

; 3773 : 		out_pos->x -= (size_constrained.x - size_expected.x);

	movss	xmm0, DWORD PTR size_constrained$[rsp]
	subss	xmm0, DWORD PTR size_expected$[rsp]
	mov	rax, QWORD PTR out_pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR out_pos$[rsp]
	movss	DWORD PTR [rax], xmm0
$LN2@CalcResize:

; 3774 : 	if (corner_norm.y == 0.0f)

	mov	rax, QWORD PTR corner_norm$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@CalcResize
	jne	SHORT $LN3@CalcResize

; 3775 : 		out_pos->y -= (size_constrained.y - size_expected.y);

	movss	xmm0, DWORD PTR size_constrained$[rsp+4]
	subss	xmm0, DWORD PTR size_expected$[rsp+4]
	mov	rax, QWORD PTR out_pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR out_pos$[rsp]
	movss	DWORD PTR [rax+4], xmm0
$LN3@CalcResize:

; 3776 : 	*out_size = size_constrained;

	mov	rax, QWORD PTR out_size$[rsp]
	mov	rcx, QWORD PTR size_constrained$[rsp]
	mov	QWORD PTR [rax], rcx

; 3777 : }

	add	rsp, 88					; 00000058H
	ret	0
?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z ENDP ; CalcResizePosSizeFromAnyCorner
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
flags$ = 8
?GetWindowBgColorIdxFromFlags@@YAHH@Z PROC		; GetWindowBgColorIdxFromFlags

; 3757 : {

	mov	DWORD PTR [rsp+8], ecx

; 3758 : 	if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	je	SHORT $LN2@GetWindowB

; 3759 : 		return ImGuiCol_PopupBg;

	mov	eax, 4
	jmp	SHORT $LN1@GetWindowB
$LN2@GetWindowB:

; 3760 : 	if (flags & ImGuiWindowFlags_ChildWindow)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN3@GetWindowB

; 3761 : 		return ImGuiCol_ChildBg;

	mov	eax, 3
	jmp	SHORT $LN1@GetWindowB
$LN3@GetWindowB:

; 3762 : 	return ImGuiCol_WindowBg;

	mov	eax, 2
$LN1@GetWindowB:

; 3763 : }

	ret	0
?GetWindowBgColorIdxFromFlags@@YAHH@Z ENDP		; GetWindowBgColorIdxFromFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv72 = 32
tv76 = 33
is_popup$1 = 34
is_menu$2 = 35
size_auto_fit$3 = 40
size_min$4 = 48
style$ = 56
g$ = 64
size_auto_fit_after_constraint$5 = 72
$T6 = 80
$T7 = 88
$T8 = 96
$T9 = 104
$T10 = 112
__$ReturnUdt$ = 144
window$ = 152
size_contents$ = 160
?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z PROC ; CalcSizeAutoFit

; 3682 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 3683 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3684 : 	ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 3685 : 	if (window->Flags & ImGuiWindowFlags_Tooltip)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN2@CalcSizeAu

; 3686 : 	{
; 3687 : 		// Tooltip always resize
; 3688 : 		return size_contents;

	mov	rax, QWORD PTR size_contents$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@CalcSizeAu

; 3689 : 	}

	jmp	$LN3@CalcSizeAu
$LN2@CalcSizeAu:

; 3690 : 	else
; 3691 : 	{
; 3692 : 		// Maximum window size is determined by the display size
; 3693 : 		const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN9@CalcSizeAu
	mov	BYTE PTR tv72[rsp], 1
	jmp	SHORT $LN10@CalcSizeAu
$LN9@CalcSizeAu:
	mov	BYTE PTR tv72[rsp], 0
$LN10@CalcSizeAu:
	movzx	eax, BYTE PTR tv72[rsp]
	mov	BYTE PTR is_popup$1[rsp], al

; 3694 : 		const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN11@CalcSizeAu
	mov	BYTE PTR tv76[rsp], 1
	jmp	SHORT $LN12@CalcSizeAu
$LN11@CalcSizeAu:
	mov	BYTE PTR tv76[rsp], 0
$LN12@CalcSizeAu:
	movzx	eax, BYTE PTR tv76[rsp]
	mov	BYTE PTR is_menu$2[rsp], al

; 3695 : 		ImVec2 size_min = style.WindowMinSize;

	mov	rax, QWORD PTR style$[rsp]
	mov	rax, QWORD PTR [rax+20]
	mov	QWORD PTR size_min$4[rsp], rax

; 3696 : 		if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)

	movzx	eax, BYTE PTR is_popup$1[rsp]
	test	eax, eax
	jne	SHORT $LN5@CalcSizeAu
	movzx	eax, BYTE PTR is_menu$2[rsp]
	test	eax, eax
	je	SHORT $LN4@CalcSizeAu
$LN5@CalcSizeAu:

; 3697 : 			size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));

	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR size_min$4[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR size_min$4[rsp], rax
$LN4@CalcSizeAu:

; 3698 : 		ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 148				; 00000094H
	movss	xmm2, DWORD PTR __real@40000000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 20
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T9[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	r8, rax
	lea	rdx, QWORD PTR size_min$4[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	r9, QWORD PTR [rax]
	lea	r8, QWORD PTR size_min$4[rsp]
	mov	rdx, QWORD PTR size_contents$[rsp]
	lea	rcx, QWORD PTR size_auto_fit$3[rsp]
	call	?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z	; ImClamp
	npad	1

; 3699 : 
; 3700 : 		// When the window cannot fit all contents (either because of constraints, either because screen is too small),
; 3701 : 		// we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
; 3702 : 		ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);

	mov	r8, QWORD PTR size_auto_fit$3[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR size_auto_fit_after_constraint$5[rsp]
	call	?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ; CalcSizeAfterConstraint
	npad	1

; 3703 : 		if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))

	mov	rax, QWORD PTR size_contents$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR size_auto_fit_after_constraint$5[rsp]
	jbe	SHORT $LN6@CalcSizeAu
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN6@CalcSizeAu
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $LN6@CalcSizeAu

; 3704 : 			size_auto_fit.y += style.ScrollbarSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR size_auto_fit$3[rsp+4]
	addss	xmm0, DWORD PTR [rax+100]
	movss	DWORD PTR size_auto_fit$3[rsp+4], xmm0
$LN6@CalcSizeAu:

; 3705 : 		if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))

	mov	rax, QWORD PTR size_contents$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR size_auto_fit_after_constraint$5[rsp+4]
	jbe	SHORT $LN7@CalcSizeAu
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN7@CalcSizeAu

; 3706 : 			size_auto_fit.x += style.ScrollbarSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR size_auto_fit$3[rsp]
	addss	xmm0, DWORD PTR [rax+100]
	movss	DWORD PTR size_auto_fit$3[rsp], xmm0
$LN7@CalcSizeAu:

; 3707 : 		return size_auto_fit;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR size_auto_fit$3[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN3@CalcSizeAu:
$LN1@CalcSizeAu:

; 3708 : 	}
; 3709 : }

	add	rsp, 136				; 00000088H
	ret	0
?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z ENDP ; CalcSizeAutoFit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv129 = 32
tv146 = 36
sz$ = 40
__$ReturnUdt$ = 64
window$ = 72
?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z PROC ; CalcSizeContents

; 3668 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3669 : 	if (window->Collapsed)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	je	SHORT $LN2@CalcSizeCo

; 3670 : 		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	SHORT $LN3@CalcSizeCo
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jg	SHORT $LN3@CalcSizeCo

; 3671 : 			return window->SizeContents;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@CalcSizeCo
$LN3@CalcSizeCo:
$LN2@CalcSizeCo:

; 3672 : 	if (window->Hidden && window->HiddenFramesForResize == 0 && window->HiddenFramesRegular > 0)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	je	SHORT $LN4@CalcSizeCo
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jne	SHORT $LN4@CalcSizeCo
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+188], 0
	jle	SHORT $LN4@CalcSizeCo

; 3673 : 		return window->SizeContents;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@CalcSizeCo
$LN4@CalcSizeCo:

; 3674 : 
; 3675 : 	ImVec2 sz;

	lea	rcx, QWORD PTR sz$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 3676 : 	sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN11@CalcSizeCo
	je	SHORT $LN6@CalcSizeCo
$LN11@CalcSizeCo:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	movss	DWORD PTR tv129[rsp], xmm0
	jmp	SHORT $LN7@CalcSizeCo
$LN6@CalcSizeCo:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	subss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+92]
	movss	DWORD PTR tv129[rsp], xmm0
$LN7@CalcSizeCo:
	cvttss2si eax, DWORD PTR tv129[rsp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR sz$[rsp], xmm0

; 3677 : 	sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN10@CalcSizeCo
	je	SHORT $LN8@CalcSizeCo
$LN10@CalcSizeCo:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv146[rsp], xmm0
	jmp	SHORT $LN9@CalcSizeCo
$LN8@CalcSizeCo:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	subss	xmm0, DWORD PTR [rcx+52]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+96]
	movss	DWORD PTR tv146[rsp], xmm0
$LN9@CalcSizeCo:
	cvttss2si eax, DWORD PTR tv146[rsp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR sz$[rsp+4], xmm0

; 3678 : 	return sz + window->WindowPadding;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 80					; 00000050H
	mov	r8, rax
	lea	rdx, QWORD PTR sz$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@CalcSizeCo:

; 3679 : }

	add	rsp, 56					; 00000038H
	ret	0
?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ENDP ; CalcSizeContents
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv78 = 40
tv87 = 44
cr$1 = 48
tv147 = 64
tv150 = 68
tv134 = 72
data$2 = 80
$T3 = 112
__$ReturnUdt$ = 160
window$ = 168
new_size$ = 176
?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z PROC ; CalcSizeAfterConstraint

; 3638 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 136				; 00000088H

; 3639 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3640 : 	if (g.NextWindowData.SizeConstraintCond != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6920], 0
	je	$LN2@CalcSizeAf

; 3641 : 	{
; 3642 : 		// Using -1,-1 on either X/Y axis to preserve the current size.
; 3643 : 		ImRect cr = g.NextWindowData.SizeConstraintRect;

	lea	rax, QWORD PTR cr$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+7008]
	mov	ecx, 16
	rep movsb

; 3644 : 		new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;

	movss	xmm0, DWORD PTR cr$1[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@CalcSizeAf
	movss	xmm0, DWORD PTR cr$1[rsp+8]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@CalcSizeAf
	movss	xmm2, DWORD PTR cr$1[rsp+8]
	movss	xmm1, DWORD PTR cr$1[rsp]
	movss	xmm0, DWORD PTR new_size$[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN7@CalcSizeAf
$LN6@CalcSizeAf:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	movss	DWORD PTR tv78[rsp], xmm0
$LN7@CalcSizeAf:
	movss	xmm0, DWORD PTR tv78[rsp]
	movss	DWORD PTR new_size$[rsp], xmm0

; 3645 : 		new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;

	movss	xmm0, DWORD PTR cr$1[rsp+4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@CalcSizeAf
	movss	xmm0, DWORD PTR cr$1[rsp+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@CalcSizeAf
	movss	xmm2, DWORD PTR cr$1[rsp+12]
	movss	xmm1, DWORD PTR cr$1[rsp+4]
	movss	xmm0, DWORD PTR new_size$[rsp+4]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv87[rsp], xmm0
	jmp	SHORT $LN9@CalcSizeAf
$LN8@CalcSizeAf:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	movss	DWORD PTR tv87[rsp], xmm0
$LN9@CalcSizeAf:
	movss	xmm0, DWORD PTR tv87[rsp]
	movss	DWORD PTR new_size$[rsp+4], xmm0

; 3646 : 		if (g.NextWindowData.SizeCallback)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6976], 0
	je	SHORT $LN3@CalcSizeAf

; 3647 : 		{
; 3648 : 			ImGuiSizeCallbackData data;

	lea	rcx, QWORD PTR data$2[rsp]
	call	??0ImGuiSizeCallbackData@@QEAA@XZ

; 3649 : 			data.UserData = g.NextWindowData.SizeCallbackUserData;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6984]
	mov	QWORD PTR data$2[rsp+8], rax

; 3650 : 			data.Pos = window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR data$2[rsp+16], rax

; 3651 : 			data.CurrentSize = window->SizeFull;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR data$2[rsp], rax

; 3652 : 			data.DesiredSize = new_size;

	mov	rax, QWORD PTR new_size$[rsp]
	mov	QWORD PTR data$2[rsp+24], rax

; 3653 : 			g.NextWindowData.SizeCallback(&data);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6976]
	mov	QWORD PTR tv134[rsp], rax
	lea	rcx, QWORD PTR data$2[rsp]
	call	QWORD PTR tv134[rsp]

; 3654 : 			new_size = data.DesiredSize;

	mov	rax, QWORD PTR data$2[rsp+24]
	mov	QWORD PTR new_size$[rsp], rax
$LN3@CalcSizeAf:
$LN2@CalcSizeAf:

; 3655 : 		}
; 3656 : 	}
; 3657 : 
; 3658 : 	// Minimum size
; 3659 : 	if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777280				; 01000040H
	test	eax, eax
	jne	$LN4@CalcSizeAf

; 3660 : 	{
; 3661 : 		new_size = ImMax(new_size, g.Style.WindowMinSize);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5492				; 00001574H
	mov	r8, rax
	lea	rdx, QWORD PTR new_size$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR new_size$[rsp], rax

; 3662 : 		new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows

	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	DWORD PTR tv147[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv147[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv150[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5484]
	subss	xmm1, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR tv150[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR new_size$[rsp+4]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR new_size$[rsp+4], xmm0
$LN4@CalcSizeAf:

; 3663 : 	}
; 3664 : 	return new_size;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR new_size$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3665 : }

	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rsi
	ret	0
?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ENDP ; CalcSizeAfterConstraint
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv72 = 0
tv81 = 4
tv90 = 8
window$ = 32
flags$ = 40
enabled$ = 48
?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z PROC ; SetWindowConditionAllowFlags

; 3570 : {

	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 3571 : 	window->SetWindowPosAllowFlags = enabled ? (window->SetWindowPosAllowFlags | flags) : (window->SetWindowPosAllowFlags & ~flags);

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN3@SetWindowC
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	eax, DWORD PTR [rax+172]
	or	eax, ecx
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN4@SetWindowC
$LN3@SetWindowC:
	mov	eax, DWORD PTR flags$[rsp]
	not	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+172]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv72[rsp], eax
$LN4@SetWindowC:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv72[rsp]
	mov	DWORD PTR [rax+172], ecx

; 3572 : 	window->SetWindowSizeAllowFlags = enabled ? (window->SetWindowSizeAllowFlags | flags) : (window->SetWindowSizeAllowFlags & ~flags);

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN5@SetWindowC
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	eax, DWORD PTR [rax+144]
	or	eax, ecx
	mov	DWORD PTR tv81[rsp], eax
	jmp	SHORT $LN6@SetWindowC
$LN5@SetWindowC:
	mov	eax, DWORD PTR flags$[rsp]
	not	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+144]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv81[rsp], eax
$LN6@SetWindowC:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv81[rsp]
	mov	DWORD PTR [rax+144], ecx

; 3573 : 	window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN7@SetWindowC
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	eax, DWORD PTR [rax+176]
	or	eax, ecx
	mov	DWORD PTR tv90[rsp], eax
	jmp	SHORT $LN8@SetWindowC
$LN7@SetWindowC:
	mov	eax, DWORD PTR flags$[rsp]
	not	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+176]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv90[rsp], eax
$LN8@SetWindowC:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv90[rsp]
	mov	DWORD PTR [rax+176], ecx

; 3574 : }

	add	rsp, 24
	ret	0
?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z ENDP ; SetWindowConditionAllowFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@H@@YAHHHH@Z PROC				; ImClamp<int>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR mn$[rsp]
	cmp	DWORD PTR v$[rsp], eax
	jge	SHORT $LN5@ImClamp
	mov	eax, DWORD PTR mn$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	eax, DWORD PTR mx$[rsp]
	cmp	DWORD PTR v$[rsp], eax
	jle	SHORT $LN3@ImClamp
	mov	eax, DWORD PTR mx$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR tv66[rsp], eax
$LN4@ImClamp:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR tv67[rsp], eax
$LN6@ImClamp:
	mov	eax, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@H@@YAHHHH@Z ENDP				; ImClamp<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
n$1 = 32
tv70 = 40
io$ = 48
$T2 = 56
draw_lists$ = 80
draw_data$ = 88
?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z PROC ; SetupDrawData

; 2838 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2839 : 	ImGuiIO& io = ImGui::GetIO();

	call	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ		; ImGui::GetIO
	mov	QWORD PTR io$[rsp], rax

; 2840 : 	draw_data->Valid = true;

	mov	rax, QWORD PTR draw_data$[rsp]
	mov	BYTE PTR [rax], 1

; 2841 : 	draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;

	mov	rax, QWORD PTR draw_lists$[rsp]
	cmp	DWORD PTR [rax], 0
	jle	SHORT $LN6@SetupDrawD
	mov	rax, QWORD PTR draw_lists$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN7@SetupDrawD
$LN6@SetupDrawD:
	mov	QWORD PTR tv70[rsp], 0
$LN7@SetupDrawD:
	mov	rax, QWORD PTR draw_data$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2842 : 	draw_data->CmdListsCount = draw_lists->Size;

	mov	rax, QWORD PTR draw_data$[rsp]
	mov	rcx, QWORD PTR draw_lists$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+4], ecx

; 2843 : 	draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;

	mov	rax, QWORD PTR draw_data$[rsp]
	mov	DWORD PTR [rax+24], 0
	mov	rax, QWORD PTR draw_data$[rsp]
	mov	DWORD PTR [rax+28], 0

; 2844 : 	draw_data->DisplayPos = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 2845 : 	draw_data->DisplaySize = io.DisplaySize;

	mov	rax, QWORD PTR io$[rsp]
	mov	rax, QWORD PTR [rax+4]
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 2846 : 	draw_data->FramebufferScale = io.DisplayFramebufferScale;

	mov	rax, QWORD PTR io$[rsp]
	mov	rax, QWORD PTR [rax+172]
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2847 : 	for (int n = 0; n < draw_lists->Size; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@SetupDrawD
$LN2@SetupDrawD:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@SetupDrawD:
	mov	rax, QWORD PTR draw_lists$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@SetupDrawD

; 2848 : 	{
; 2849 : 		draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR draw_lists$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	add	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 2850 : 		draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR draw_lists$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	add	ecx, DWORD PTR [rax+40]
	mov	eax, ecx
	mov	rcx, QWORD PTR draw_data$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 2851 : 	}

	jmp	SHORT $LN2@SetupDrawD
$LN3@SetupDrawD:

; 2852 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z ENDP ; SetupDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 64
?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z PROC	; AddRootWindowToDrawData

; 2811 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2812 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2813 : 	if (window->Flags & ImGuiWindowFlags_Tooltip)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN2@AddRootWin

; 2814 : 		AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+7560]
	mov	rdx, QWORD PTR window$[rsp]
	mov	rcx, rax
	call	?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z ; AddWindowToDrawData
	npad	1
	jmp	SHORT $LN3@AddRootWin
$LN2@AddRootWin:

; 2815 : 	else
; 2816 : 		AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+7560]
	mov	rdx, QWORD PTR window$[rsp]
	mov	rcx, rax
	call	?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z ; AddWindowToDrawData
	npad	1
$LN3@AddRootWin:

; 2817 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z ENDP	; AddRootWindowToDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
child$2 = 48
tv85 = 56
out_render_list$ = 80
window$ = 88
?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z PROC ; AddWindowToDrawData

; 2798 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2799 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2800 : 	g.IO.MetricsRenderWindows++;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+956]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+956], eax

; 2801 : 	AddDrawListToDrawData(out_render_list, window->DrawList);

	mov	rax, QWORD PTR window$[rsp]
	mov	rdx, QWORD PTR [rax+696]
	mov	rcx, QWORD PTR out_render_list$[rsp]
	call	?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z ; AddDrawListToDrawData
	npad	1

; 2802 : 	for (int i = 0; i < window->DC.ChildWindows.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AddWindowT
$LN2@AddWindowT:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AddWindowT:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+432]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@AddWindowT

; 2803 : 	{
; 2804 : 		ImGuiWindow* child = window->DC.ChildWindows[i];

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 432				; 000001b0H
	mov	QWORD PTR tv85[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv85[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR child$2[rsp], rax

; 2805 : 		if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active

	mov	rcx, QWORD PTR child$2[rsp]
	call	?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z ; IsWindowActiveAndVisible
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@AddWindowT

; 2806 : 			AddWindowToDrawData(out_render_list, child);

	mov	rdx, QWORD PTR child$2[rsp]
	mov	rcx, QWORD PTR out_render_list$[rsp]
	call	?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z ; AddWindowToDrawData
	npad	1
$LN5@AddWindowT:

; 2807 : 	}

	jmp	SHORT $LN2@AddWindowT
$LN3@AddWindowT:

; 2808 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddWindowToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImGuiWindow@@@Z ENDP ; AddWindowToDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
d$1 = 0
d$2 = 4
a$ = 8
b$ = 16
lhs$ = 48
rhs$ = 56
?ChildWindowComparer@@YAHPEBX0@Z PROC			; ChildWindowComparer

; 2737 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2738 : 	const ImGuiWindow* const a = *(const ImGuiWindow* const*)lhs;

	mov	rax, QWORD PTR lhs$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR a$[rsp], rax

; 2739 : 	const ImGuiWindow* const b = *(const ImGuiWindow* const*)rhs;

	mov	rax, QWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR b$[rsp], rax

; 2740 : 	if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	and	ecx, 67108864				; 04000000H
	sub	eax, ecx
	mov	DWORD PTR d$1[rsp], eax
	cmp	DWORD PTR d$1[rsp], 0
	je	SHORT $LN2@ChildWindo

; 2741 : 		return d;

	mov	eax, DWORD PTR d$1[rsp]
	jmp	SHORT $LN1@ChildWindo
$LN2@ChildWindo:

; 2742 : 	if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 33554432				; 02000000H
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	and	ecx, 33554432				; 02000000H
	sub	eax, ecx
	mov	DWORD PTR d$2[rsp], eax
	cmp	DWORD PTR d$2[rsp], 0
	je	SHORT $LN3@ChildWindo

; 2743 : 		return d;

	mov	eax, DWORD PTR d$2[rsp]
	jmp	SHORT $LN1@ChildWindo
$LN3@ChildWindo:

; 2744 : 	return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);

	mov	rax, QWORD PTR a$[rsp]
	movsx	eax, WORD PTR [rax+138]
	mov	rcx, QWORD PTR b$[rsp]
	movsx	ecx, WORD PTR [rcx+138]
	sub	eax, ecx
$LN1@ChildWindo:

; 2745 : }

	add	rsp, 40					; 00000028H
	ret	0
?ChildWindowComparer@@YAHPEBX0@Z ENDP			; ChildWindowComparer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z
_TEXT	SEGMENT
p$ = 48
??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z PROC ; IM_DELETE<ImGuiWindow>, COMDAT

; 1566 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@IM_DELETE
	xor	edx, edx
	mov	rcx, QWORD PTR p$[rsp]
	call	??_GImGuiWindow@@QEAAPEAXI@Z
	mov	rcx, QWORD PTR p$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@IM_DELETE:
	add	rsp, 40					; 00000028H
	ret	0
??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z ENDP ; IM_DELETE<ImGuiWindow>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z
_TEXT	SEGMENT
p$ = 48
??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z PROC ; IM_DELETE<ImFontAtlas>, COMDAT

; 1566 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@IM_DELETE
	xor	edx, edx
	mov	rcx, QWORD PTR p$[rsp]
	call	??_GImFontAtlas@@QEAAPEAXI@Z
	mov	rcx, QWORD PTR p$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@IM_DELETE:
	add	rsp, 40					; 00000028H
	ret	0
??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z ENDP ; IM_DELETE<ImFontAtlas>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR mn$[rsp]
	comiss	xmm0, DWORD PTR v$[rsp]
	jbe	SHORT $LN5@ImClamp
	movss	xmm0, DWORD PTR mn$[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	movss	xmm0, DWORD PTR v$[rsp]
	comiss	xmm0, DWORD PTR mx$[rsp]
	jbe	SHORT $LN3@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@ImClamp:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
$LN6@ImClamp:
	movss	xmm0, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv70 = 0
window$ = 32
?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z PROC	; IsWindowActiveAndVisible

; 2305 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2306 : 	return (window->Active) && (!window->Hidden);

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN3@IsWindowAc
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	jne	SHORT $LN3@IsWindowAc
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@IsWindowAc
$LN3@IsWindowAc:
	mov	DWORD PTR tv70[rsp], 0
$LN4@IsWindowAc:
	movzx	eax, BYTE PTR tv70[rsp]

; 2307 : }

	add	rsp, 24
	ret	0
?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z ENDP	; IsWindowActiveAndVisible
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
__formal$ = 8
?GetOverlayDrawList@@YAPEAUImDrawList@@PEAUImGuiWindow@@@Z PROC ; GetOverlayDrawList

; 2180 : {

	mov	QWORD PTR [rsp+8], rcx

; 2181 : 	// This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'viewport' branches.
; 2182 : 	return &GImGui->OverlayDrawList;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 7336				; 00001ca8H

; 2183 : }

	ret	0
?GetOverlayDrawList@@YAPEAUImDrawList@@PEAUImGuiWindow@@@Z ENDP ; GetOverlayDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z
_TEXT	SEGMENT
p$ = 48
??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z PROC ; IM_DELETE<ImGuiContext>, COMDAT

; 1566 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@IM_DELETE
	xor	edx, edx
	mov	rcx, QWORD PTR p$[rsp]
	call	??_GImGuiContext@@QEAAPEAXI@Z
	mov	rcx, QWORD PTR p$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@IM_DELETE:
	add	rsp, 40					; 00000028H
	ret	0
??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z ENDP ; IM_DELETE<ImGuiContext>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
focused_root_window$1 = 0
g$ = 8
window$ = 32
flags$ = 40
?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z PROC ; IsWindowContentHoverable

; 1833 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1834 : 	// An active popup disable hovering on other windows (apart from its own children)
; 1835 : 	// FIXME-OPT: This could be cached/stored within the window.
; 1836 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1837 : 	if (g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN2@IsWindowCo

; 1838 : 		if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rax, QWORD PTR [rax+688]
	mov	QWORD PTR focused_root_window$1[rsp], rax
	cmp	QWORD PTR focused_root_window$1[rsp], 0
	je	SHORT $LN3@IsWindowCo

; 1839 : 			if (focused_root_window->WasActive && focused_root_window != window->RootWindow)

	mov	rax, QWORD PTR focused_root_window$1[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	je	SHORT $LN4@IsWindowCo
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR focused_root_window$1[rsp], rax
	je	SHORT $LN4@IsWindowCo

; 1840 : 			{
; 1841 : 				// For the purpose of those flags we differentiate "standard popup" from "modal popup"
; 1842 : 				// NB: The order of those two tests is important because Modal windows are also Popups.
; 1843 : 				if (focused_root_window->Flags & ImGuiWindowFlags_Modal)

	mov	rax, QWORD PTR focused_root_window$1[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN5@IsWindowCo

; 1844 : 					return false;

	xor	al, al
	jmp	SHORT $LN1@IsWindowCo
$LN5@IsWindowCo:

; 1845 : 				if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	rax, QWORD PTR focused_root_window$1[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN6@IsWindowCo
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN6@IsWindowCo

; 1846 : 					return false;

	xor	al, al
	jmp	SHORT $LN1@IsWindowCo
$LN6@IsWindowCo:
$LN4@IsWindowCo:
$LN3@IsWindowCo:
$LN2@IsWindowCo:

; 1847 : 			}
; 1848 : 
; 1849 : 	return true;

	mov	al, 1
$LN1@IsWindowCo:

; 1850 : }

	add	rsp, 24
	ret	0
?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z ENDP ; IsWindowContentHoverable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
pos_y$ = 64
line_height$ = 72
?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z PROC	; SetCursorPosYAndSetupDummyPrevLine

; 1289 : {

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 1290 : 	// Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
; 1291 : 	// FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
; 1292 : 	// The clipper should probably have a 4th step to display the last item in a regular manner.
; 1293 : 	ImGui::SetCursorPosY(pos_y);

	movss	xmm0, DWORD PTR pos_y$[rsp]
	call	?SetCursorPosY@ImGui@@YAXM@Z		; ImGui::SetCursorPosY

; 1294 : 	ImGuiWindow* window = ImGui::GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1295 : 	window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR line_height$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+352], xmm0

; 1296 : 	window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR line_height$[rsp]
	subss	xmm0, DWORD PTR [rax+5544]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+336], xmm0

; 1297 : 	if (window->DC.ColumnsSet)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN2@SetCursorP

; 1298 : 		window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+344]
	movss	DWORD PTR [rax+12], xmm0
$LN2@SetCursorP:

; 1299 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z ENDP	; SetCursorPosYAndSetupDummyPrevLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
?PairCompareByID@StaticFunc@?1??BuildSortByKey@ImGuiStorage@@QEAAXXZ@SAHPEBX0@Z PROC ; `ImGuiStorage::BuildSortByKey'::`2'::StaticFunc::PairCompareByID

; 995  : 		{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 996  : 			// We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
; 997  : 			if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;

	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jbe	SHORT $LN2@PairCompar
	mov	eax, 1
	jmp	SHORT $LN1@PairCompar
$LN2@PairCompar:

; 998  : 			if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;

	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jae	SHORT $LN3@PairCompar
	mov	eax, -1
	jmp	SHORT $LN1@PairCompar
$LN3@PairCompar:

; 999  : 			return 0;

	xor	eax, eax
$LN1@PairCompar:

; 1000 : 		}

	ret	0
?PairCompareByID@StaticFunc@?1??BuildSortByKey@ImGuiStorage@@QEAAXXZ@SAHPEBX0@Z ENDP ; `ImGuiStorage::BuildSortByKey'::`2'::StaticFunc::PairCompareByID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
count$ = 0
mid$1 = 8
first$ = 16
count2$2 = 24
last$ = 32
data$ = 64
key$ = 72
?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z PROC ; LowerBound

; 968  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 969  : 	ImGuiStorage::Pair* first = data.Data;

	mov	rax, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR first$[rsp], rax

; 970  : 	ImGuiStorage::Pair* last = data.Data + data.Size;

	mov	rax, QWORD PTR data$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR data$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR last$[rsp], rax

; 971  : 	size_t count = (size_t)(last - first);

	mov	rax, QWORD PTR first$[rsp]
	mov	rcx, QWORD PTR last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 4
	mov	QWORD PTR count$[rsp], rax
$LN2@LowerBound:

; 972  : 	while (count > 0)

	cmp	QWORD PTR count$[rsp], 0
	jbe	SHORT $LN3@LowerBound

; 973  : 	{
; 974  : 		size_t count2 = count >> 1;

	mov	rax, QWORD PTR count$[rsp]
	shr	rax, 1
	mov	QWORD PTR count2$2[rsp], rax

; 975  : 		ImGuiStorage::Pair* mid = first + count2;

	imul	rax, QWORD PTR count2$2[rsp], 16
	mov	rcx, QWORD PTR first$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR mid$1[rsp], rax

; 976  : 		if (mid->key < key)

	mov	rax, QWORD PTR mid$1[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	jae	SHORT $LN4@LowerBound

; 977  : 		{
; 978  : 			first = ++mid;

	mov	rax, QWORD PTR mid$1[rsp]
	add	rax, 16
	mov	QWORD PTR mid$1[rsp], rax
	mov	rax, QWORD PTR mid$1[rsp]
	mov	QWORD PTR first$[rsp], rax

; 979  : 			count -= count2 + 1;

	mov	rax, QWORD PTR count2$2[rsp]
	inc	rax
	mov	rcx, QWORD PTR count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR count$[rsp], rax

; 980  : 		}

	jmp	SHORT $LN5@LowerBound
$LN4@LowerBound:

; 981  : 		else
; 982  : 		{
; 983  : 			count = count2;

	mov	rax, QWORD PTR count2$2[rsp]
	mov	QWORD PTR count$[rsp], rax
$LN5@LowerBound:

; 984  : 		}
; 985  : 	}

	jmp	SHORT $LN2@LowerBound
$LN3@LowerBound:

; 986  : 	return first;

	mov	rax, QWORD PTR first$[rsp]

; 987  : }

	add	rsp, 56					; 00000038H
	ret	0
?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ENDP ; LowerBound
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tmp$ = 0
a$ = 32
b$ = 40
??$ImSwap@M@@YAXAEAM0@Z PROC				; ImSwap<float>

; 231  : template<typename T> static inline void ImSwap(T& a, T& b) { T tmp = a; a = b; b = tmp; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tmp$[rsp], xmm0
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR tmp$[rsp]
	movss	DWORD PTR [rax], xmm0
	add	rsp, 24
	ret	0
??$ImSwap@M@@YAXAEAM0@Z ENDP				; ImSwap<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
c$ = 8
?ImTextCountUtf8BytesFromChar@@YAHI@Z PROC		; ImTextCountUtf8BytesFromChar

; 792  : {

	mov	DWORD PTR [rsp+8], ecx

; 793  : 	if (c < 0x80) return 1;

	cmp	DWORD PTR c$[rsp], 128			; 00000080H
	jae	SHORT $LN2@ImTextCoun
	mov	eax, 1
	jmp	SHORT $LN1@ImTextCoun
$LN2@ImTextCoun:

; 794  : 	if (c < 0x800) return 2;

	cmp	DWORD PTR c$[rsp], 2048			; 00000800H
	jae	SHORT $LN3@ImTextCoun
	mov	eax, 2
	jmp	SHORT $LN1@ImTextCoun
$LN3@ImTextCoun:

; 795  : 	if (c >= 0xdc00 && c < 0xe000) return 0;

	cmp	DWORD PTR c$[rsp], 56320		; 0000dc00H
	jb	SHORT $LN4@ImTextCoun
	cmp	DWORD PTR c$[rsp], 57344		; 0000e000H
	jae	SHORT $LN4@ImTextCoun
	xor	eax, eax
	jmp	SHORT $LN1@ImTextCoun
$LN4@ImTextCoun:

; 796  : 	if (c >= 0xd800 && c < 0xdc00) return 4;

	cmp	DWORD PTR c$[rsp], 55296		; 0000d800H
	jb	SHORT $LN5@ImTextCoun
	cmp	DWORD PTR c$[rsp], 56320		; 0000dc00H
	jae	SHORT $LN5@ImTextCoun
	mov	eax, 4
	jmp	SHORT $LN1@ImTextCoun
$LN5@ImTextCoun:

; 797  : 	return 3;

	mov	eax, 3
$LN1@ImTextCoun:

; 798  : }

	ret	0
?ImTextCountUtf8BytesFromChar@@YAHI@Z ENDP		; ImTextCountUtf8BytesFromChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
buf$ = 8
buf_size$ = 16
c$ = 24
?ImTextCharToUtf8@@YAHPEADHI@Z PROC			; ImTextCharToUtf8

; 748  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 749  : 	if (c < 0x80)

	cmp	DWORD PTR c$[rsp], 128			; 00000080H
	jae	SHORT $LN2@ImTextChar

; 750  : 	{
; 751  : 		buf[0] = (char)c;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	edx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 752  : 		return 1;

	mov	eax, 1
	jmp	$LN1@ImTextChar
$LN2@ImTextChar:

; 753  : 	}
; 754  : 	if (c < 0x800)

	cmp	DWORD PTR c$[rsp], 2048			; 00000800H
	jae	SHORT $LN3@ImTextChar

; 755  : 	{
; 756  : 		if (buf_size < 2) return 0;

	cmp	DWORD PTR buf_size$[rsp], 2
	jge	SHORT $LN4@ImTextChar
	xor	eax, eax
	jmp	$LN1@ImTextChar
$LN4@ImTextChar:

; 757  : 		buf[0] = (char)(0xc0 + (c >> 6));

	mov	eax, DWORD PTR c$[rsp]
	shr	eax, 6
	add	eax, 192				; 000000c0H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 758  : 		buf[1] = (char)(0x80 + (c & 0x3f));

	mov	eax, DWORD PTR c$[rsp]
	and	eax, 63					; 0000003fH
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 759  : 		return 2;

	mov	eax, 2
	jmp	$LN1@ImTextChar
$LN3@ImTextChar:

; 760  : 	}
; 761  : 	if (c >= 0xdc00 && c < 0xe000)

	cmp	DWORD PTR c$[rsp], 56320		; 0000dc00H
	jb	SHORT $LN5@ImTextChar
	cmp	DWORD PTR c$[rsp], 57344		; 0000e000H
	jae	SHORT $LN5@ImTextChar

; 762  : 	{
; 763  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ImTextChar
$LN5@ImTextChar:

; 764  : 	}
; 765  : 	if (c >= 0xd800 && c < 0xdc00)

	cmp	DWORD PTR c$[rsp], 55296		; 0000d800H
	jb	$LN6@ImTextChar
	cmp	DWORD PTR c$[rsp], 56320		; 0000dc00H
	jae	$LN6@ImTextChar

; 766  : 	{
; 767  : 		if (buf_size < 4) return 0;

	cmp	DWORD PTR buf_size$[rsp], 4
	jge	SHORT $LN7@ImTextChar
	xor	eax, eax
	jmp	$LN1@ImTextChar
$LN7@ImTextChar:

; 768  : 		buf[0] = (char)(0xf0 + (c >> 18));

	mov	eax, DWORD PTR c$[rsp]
	shr	eax, 18
	add	eax, 240				; 000000f0H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 769  : 		buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));

	mov	eax, DWORD PTR c$[rsp]
	shr	eax, 12
	and	eax, 63					; 0000003fH
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 770  : 		buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));

	mov	eax, DWORD PTR c$[rsp]
	shr	eax, 6
	and	eax, 63					; 0000003fH
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 771  : 		buf[3] = (char)(0x80 + ((c) & 0x3f));

	mov	eax, DWORD PTR c$[rsp]
	and	eax, 63					; 0000003fH
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 772  : 		return 4;

	mov	eax, 4
	jmp	SHORT $LN1@ImTextChar
$LN6@ImTextChar:

; 773  : 	}
; 774  : 	//else if (c < 0x10000)
; 775  : 	{
; 776  : 		if (buf_size < 3) return 0;

	cmp	DWORD PTR buf_size$[rsp], 3
	jge	SHORT $LN8@ImTextChar
	xor	eax, eax
	jmp	SHORT $LN1@ImTextChar
$LN8@ImTextChar:

; 777  : 		buf[0] = (char)(0xe0 + (c >> 12));

	mov	eax, DWORD PTR c$[rsp]
	shr	eax, 12
	add	eax, 224				; 000000e0H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 778  : 		buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));

	mov	eax, DWORD PTR c$[rsp]
	shr	eax, 6
	and	eax, 63					; 0000003fH
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 779  : 		buf[2] = (char)(0x80 + ((c) & 0x3f));

	mov	eax, DWORD PTR c$[rsp]
	and	eax, 63					; 0000003fH
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 780  : 		return 3;

	mov	eax, 3
$LN1@ImTextChar:

; 781  : 	}
; 782  : }

	ret	0
?ImTextCharToUtf8@@YAHPEADHI@Z ENDP			; ImTextCharToUtf8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ptr$ = 48
user_data$ = 56
?FreeWrapper@@YAXPEAX0@Z PROC				; FreeWrapper

; 144  : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR ptr$[rsp]
	call	free
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?FreeWrapper@@YAXPEAX0@Z ENDP				; FreeWrapper
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
size$ = 48
user_data$ = 56
?MallocWrapper@@YAPEAX_KPEAX@Z PROC			; MallocWrapper

; 143  : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR size$[rsp]
	call	malloc
	add	rsp, 40					; 00000028H
	ret	0
?MallocWrapper@@YAPEAX_KPEAX@Z ENDP			; MallocWrapper
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
rounding$ = 64
border_size$ = 68
def$1 = 72
border_held$ = 80
y$2 = 84
tv91 = 88
tv230 = 92
tv228 = 96
tv279 = 100
tv277 = 104
tv296 = 108
tv294 = 112
tv346 = 116
tv344 = 120
g$ = 128
border_r$3 = 136
tv93 = 152
tv217 = 160
tv215 = 168
tv223 = 176
tv221 = 184
tv226 = 192
tv232 = 200
tv266 = 208
tv264 = 216
tv272 = 224
tv270 = 232
tv275 = 240
tv281 = 248
tv298 = 256
tv342 = 264
tv340 = 272
tv348 = 280
tv89 = 288
$T4 = 296
$T5 = 304
$T6 = 312
$T7 = 320
$T8 = 328
$T9 = 336
$T10 = 344
$T11 = 352
$T12 = 360
$T13 = 368
$T14 = 376
$T15 = 384
$T16 = 392
window$ = 416
?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z PROC	; ImGui::RenderOuterBorders

; 3918 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 408				; 00000198H

; 3919 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3920 : 	float rounding = window->WindowRounding;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	movss	DWORD PTR rounding$[rsp], xmm0

; 3921 : 	float border_size = window->WindowBorderSize;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR border_size$[rsp], xmm0

; 3922 : 	if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))

	movss	xmm0, DWORD PTR border_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN3@RenderOute
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	$LN3@RenderOute

; 3923 : 		window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv93[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv91[rsp], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv89[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	movss	xmm0, DWORD PTR border_size$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv91[rsp]
	mov	r8, QWORD PTR tv89[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv93[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN3@RenderOute:

; 3924 : 
; 3925 : 	int border_held = window->ResizeBorderHeld;

	mov	rax, QWORD PTR window$[rsp]
	movsx	eax, BYTE PTR [rax+134]
	mov	DWORD PTR border_held$[rsp], eax

; 3926 : 	if (border_held != -1)

	cmp	DWORD PTR border_held$[rsp], -1
	je	$LN4@RenderOute

; 3927 : 	{
; 3928 : 		struct ImGuiResizeBorderDef
; 3929 : 		{
; 3930 : 			ImVec2 InnerDir;
; 3931 : 			ImVec2 CornerPosN1, CornerPosN2;
; 3932 : 			float  OuterAngle;
; 3933 : 		};
; 3934 : 		static const ImGuiResizeBorderDef resize_border_def[4] =

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA, eax
	jle	$LN2@RenderOute
	lea	rcx, OFFSET FLAT:?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA, -1
	jne	$LN2@RenderOute

; 3935 : 		{
; 3936 : 			{ ImVec2(0,+1), ImVec2(0,0), ImVec2(1,0), IM_PI * 1.50f }, // Top

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+8
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+16
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm0, DWORD PTR __real@4096cbe4
	movss	DWORD PTR ?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+24, xmm0

; 3937 : 			{ ImVec2(-1,0), ImVec2(1,0), ImVec2(1,1), IM_PI * 0.00f }, // Right

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+28
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+36
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+44
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm0, xmm0
	movss	DWORD PTR ?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+52, xmm0

; 3938 : 			{ ImVec2(0,-1), ImVec2(1,1), ImVec2(0,1), IM_PI * 0.50f }, // Bottom

	movss	xmm2, DWORD PTR __real@bf800000
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+56
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+64
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+72
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm0, DWORD PTR __real@3fc90fdb
	movss	DWORD PTR ?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+80, xmm0

; 3939 : 			{ ImVec2(+1,0), ImVec2(0,1), ImVec2(0,0), IM_PI * 1.00f }  // Left

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+84
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+92
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+100
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR ?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B+108, xmm0
	lea	rcx, OFFSET FLAT:?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
	call	_Init_thread_footer
	npad	1
$LN2@RenderOute:

; 3940 : 		};
; 3941 : 		const ImGuiResizeBorderDef& def = resize_border_def[border_held];

	movsxd	rax, DWORD PTR border_held$[rsp]
	imul	rax, rax, 28
	lea	rcx, OFFSET FLAT:?resize_border_def@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4QBUImGuiResizeBorderDef@?6??12@YAX0@Z@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR def$1[rsp], rax

; 3942 : 		ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	r8d, DWORD PTR border_held$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR border_r$3[rsp]
	call	?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z ; GetResizeBorderRect
	npad	1

; 3943 : 		window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv232[rsp], rax
	mov	rax, QWORD PTR def$1[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR tv230[rsp], xmm0
	mov	rax, QWORD PTR def$1[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	subss	xmm0, DWORD PTR __real@3f490fdb
	movss	DWORD PTR tv228[rsp], xmm0
	mov	rax, QWORD PTR def$1[rsp]
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv223[rsp], rax
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv217[rsp], rax
	mov	rax, QWORD PTR def$1[rsp]
	add	rax, 8
	mov	r9, rax
	lea	r8, QWORD PTR border_r$3[rsp+8]
	lea	rdx, QWORD PTR border_r$3[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	mov	QWORD PTR tv215[rsp], rax
	mov	r8, QWORD PTR tv217[rsp]
	mov	rdx, QWORD PTR tv215[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv221[rsp], rax
	mov	r8, QWORD PTR tv223[rsp]
	mov	rdx, QWORD PTR tv221[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv226[rsp], rax
	mov	DWORD PTR [rsp+40], 10
	movss	xmm0, DWORD PTR tv230[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv228[rsp]
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, QWORD PTR tv226[rsp]
	mov	rcx, QWORD PTR tv232[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
	npad	1

; 3944 : 		window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv281[rsp], rax
	mov	rax, QWORD PTR def$1[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	addss	xmm0, DWORD PTR __real@3f490fdb
	movss	DWORD PTR tv279[rsp], xmm0
	mov	rax, QWORD PTR def$1[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR tv277[rsp], xmm0
	mov	rax, QWORD PTR def$1[rsp]
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv272[rsp], rax
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv266[rsp], rax
	mov	rax, QWORD PTR def$1[rsp]
	add	rax, 16
	mov	r9, rax
	lea	r8, QWORD PTR border_r$3[rsp+8]
	lea	rdx, QWORD PTR border_r$3[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	mov	QWORD PTR tv264[rsp], rax
	mov	r8, QWORD PTR tv266[rsp]
	mov	rdx, QWORD PTR tv264[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv270[rsp], rax
	mov	r8, QWORD PTR tv272[rsp]
	mov	rdx, QWORD PTR tv270[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv275[rsp], rax
	mov	DWORD PTR [rsp+40], 10
	movss	xmm0, DWORD PTR tv279[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv277[rsp]
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, QWORD PTR tv275[rsp]
	mov	rcx, QWORD PTR tv281[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
	npad	1

; 3945 : 		window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), false, ImMax(2.0f, border_size)); // Thicker than usual

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv298[rsp], rax
	movss	xmm1, DWORD PTR border_size$[rsp]
	movss	xmm0, DWORD PTR __real@40000000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv296[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 29
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv294[rsp], eax
	movss	xmm3, DWORD PTR tv296[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR tv294[rsp]
	mov	rcx, QWORD PTR tv298[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN4@RenderOute:

; 3946 : 	}
; 3947 : 	if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar))

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5536]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN5@RenderOute
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	jne	$LN5@RenderOute

; 3948 : 	{
; 3949 : 		float y = window->Pos.y + window->TitleBarHeight() - 1;

	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR y$2[rsp], xmm0

; 3950 : 		window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv348[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5536]
	movss	DWORD PTR tv346[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv344[rsp], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx]
	subss	xmm0, DWORD PTR border_size$[rsp]
	movss	xmm2, DWORD PTR y$2[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv342[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR border_size$[rsp]
	movss	xmm2, DWORD PTR y$2[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv340[rsp], rax
	movss	xmm0, DWORD PTR tv346[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv344[rsp]
	mov	r8, QWORD PTR tv342[rsp]
	mov	rdx, QWORD PTR tv340[rsp]
	mov	rcx, QWORD PTR tv348[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
$LN5@RenderOute:

; 3951 : 	}
; 3952 : }

	add	rsp, 408				; 00000198H
	ret	0
?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP	; ImGui::RenderOuterBorders
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
rounding$ = 64
border_size$ = 68
def$1 = 72
border_held$ = 80
y$2 = 84
tv91 = 88
tv230 = 92
tv228 = 96
tv279 = 100
tv277 = 104
tv296 = 108
tv294 = 112
tv346 = 116
tv344 = 120
g$ = 128
border_r$3 = 136
tv93 = 152
tv217 = 160
tv215 = 168
tv223 = 176
tv221 = 184
tv226 = 192
tv232 = 200
tv266 = 208
tv264 = 216
tv272 = 224
tv270 = 232
tv275 = 240
tv281 = 248
tv298 = 256
tv342 = 264
tv340 = 272
tv348 = 280
tv89 = 288
$T4 = 296
$T5 = 304
$T6 = 312
$T7 = 320
$T8 = 328
$T9 = 336
$T10 = 344
$T11 = 352
$T12 = 360
$T13 = 368
$T14 = 376
$T15 = 384
$T16 = 392
window$ = 416
?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA PROC ; `ImGui::RenderOuterBorders'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?6??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z@4HA ENDP ; `ImGui::RenderOuterBorders'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
held$1 = 48
hovered$2 = 49
held$3 = 50
g$ = 56
border_n$4 = 64
resize_grip_n$5 = 68
hovered$6 = 72
grip_hover_inner_size$ = 76
grip$7 = 80
nav_resize_delta$8 = 88
size_target$ = 96
flags$ = 104
tv80 = 108
tv133 = 112
tv205 = 116
grip_hover_outer_size$ = 120
tv307 = 124
tv310 = 128
tv338 = 132
border_posn$9 = 136
border_target$10 = 144
pos_target$ = 152
resize_rect$11 = 160
tv89 = 176
grip_draw_size$ = 180
resize_border_count$ = 184
tv437 = 188
corner$12 = 192
tv147 = 200
tv183 = 208
tv181 = 216
tv275 = 224
tv273 = 232
tv289 = 240
tv287 = 248
corner_target$13 = 256
NAV_RESIZE_SPEED$14 = 264
$T15 = 268
$T16 = 276
$T17 = 284
$T18 = 292
$T19 = 300
$T20 = 308
$T21 = 316
$T22 = 324
$T23 = 332
$T24 = 340
$T25 = 348
$T26 = 356
$T27 = 364
$T28 = 372
$T29 = 380
$T30 = 388
$T31 = 396
$T32 = 404
$T33 = 412
border_rect$34 = 424
window$ = 464
size_auto_fit$ = 472
border_held$ = 480
resize_grip_count$ = 488
resize_grip_col$ = 496
?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z PROC ; ImGui::UpdateManualResize

; 3808 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 456				; 000001c8H

; 3809 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3810 : 	ImGuiWindowFlags flags = window->Flags;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR flags$[rsp], eax

; 3811 : 	if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN9@UpdateManu
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN9@UpdateManu
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	SHORT $LN9@UpdateManu
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jle	SHORT $LN8@UpdateManu
$LN9@UpdateManu:

; 3812 : 		return;

	jmp	$LN1@UpdateManu
$LN8@UpdateManu:

; 3813 : 	if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	jne	SHORT $LN10@UpdateManu

; 3814 : 		return;

	jmp	$LN1@UpdateManu
$LN10@UpdateManu:

; 3815 : 
; 3816 : 	const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+212]
	test	eax, eax
	je	SHORT $LN37@UpdateManu
	mov	DWORD PTR tv80[rsp], 4
	jmp	SHORT $LN38@UpdateManu
$LN37@UpdateManu:
	mov	DWORD PTR tv80[rsp], 0
$LN38@UpdateManu:
	mov	eax, DWORD PTR tv80[rsp]
	mov	DWORD PTR resize_border_count$[rsp], eax

; 3817 : 	const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3e4ccccd
	addss	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3faccccd
	movss	DWORD PTR tv89[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv89[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR grip_draw_size$[rsp], xmm0

; 3818 : 	const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);

	movss	xmm0, DWORD PTR grip_draw_size$[rsp]
	mulss	xmm0, DWORD PTR __real@3f400000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR grip_hover_inner_size$[rsp], xmm0

; 3819 : 	const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+212]
	test	eax, eax
	je	SHORT $LN39@UpdateManu
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR tv133[rsp], xmm0
	jmp	SHORT $LN40@UpdateManu
$LN39@UpdateManu:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv133[rsp], xmm0
$LN40@UpdateManu:
	movss	xmm0, DWORD PTR tv133[rsp]
	movss	DWORD PTR grip_hover_outer_size$[rsp], xmm0

; 3820 : 
; 3821 : 	ImVec2 pos_target(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR pos_target$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 3822 : 	ImVec2 size_target(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR size_target$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 3823 : 
; 3824 : 	// Manual resize grips
; 3825 : 	PushID(("#RESIZE"));

	lea	rcx, OFFSET FLAT:??_C@_07HDHBJEOI@?$CDRESIZE@
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID
	npad	1

; 3826 : 	for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)

	mov	DWORD PTR resize_grip_n$5[rsp], 0
	jmp	SHORT $LN4@UpdateManu
$LN2@UpdateManu:
	mov	eax, DWORD PTR resize_grip_n$5[rsp]
	inc	eax
	mov	DWORD PTR resize_grip_n$5[rsp], eax
$LN4@UpdateManu:
	mov	eax, DWORD PTR resize_grip_count$[rsp]
	cmp	DWORD PTR resize_grip_n$5[rsp], eax
	jge	$LN3@UpdateManu

; 3827 : 	{
; 3828 : 		const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];

	movsxd	rax, DWORD PTR resize_grip_n$5[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR grip$7[rsp], rax

; 3829 : 		const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);

	mov	rax, QWORD PTR grip$7[rsp]
	mov	QWORD PTR tv147[rsp], rax
	mov	rcx, QWORD PTR window$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	add	rdx, 48					; 00000030H
	mov	r8, rcx
	lea	rcx, QWORD PTR $T33[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	rdx, QWORD PTR tv147[rsp]
	mov	r9, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR corner$12[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	npad	1

; 3830 : 
; 3831 : 		// Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
; 3832 : 		ImRect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);

	mov	rax, QWORD PTR grip$7[rsp]
	add	rax, 8
	movss	xmm2, DWORD PTR grip_hover_inner_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T15[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR corner$12[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv183[rsp], rax
	mov	rax, QWORD PTR grip$7[rsp]
	add	rax, 8
	movss	xmm2, DWORD PTR grip_hover_outer_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T17[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR corner$12[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv181[rsp], rax
	mov	r8, QWORD PTR tv183[rsp]
	mov	rdx, QWORD PTR tv181[rsp]
	lea	rcx, QWORD PTR resize_rect$11[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 3833 : 		if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);

	movss	xmm0, DWORD PTR resize_rect$11[rsp]
	comiss	xmm0, DWORD PTR resize_rect$11[rsp+8]
	jbe	SHORT $LN11@UpdateManu
	lea	rdx, QWORD PTR resize_rect$11[rsp+8]
	lea	rcx, QWORD PTR resize_rect$11[rsp]
	call	??$ImSwap@M@@YAXAEAM0@Z			; ImSwap<float>
	npad	1
$LN11@UpdateManu:

; 3834 : 		if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);

	movss	xmm0, DWORD PTR resize_rect$11[rsp+4]
	comiss	xmm0, DWORD PTR resize_rect$11[rsp+12]
	jbe	SHORT $LN12@UpdateManu
	lea	rdx, QWORD PTR resize_rect$11[rsp+12]
	lea	rcx, QWORD PTR resize_rect$11[rsp+4]
	call	??$ImSwap@M@@YAXAEAM0@Z			; ImSwap<float>
	npad	1
$LN12@UpdateManu:

; 3835 : 		bool hovered, held;
; 3836 : 		ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);

	movsxd	rax, DWORD PTR resize_grip_n$5[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBX@Z		; ImGuiWindow::GetID
	mov	DWORD PTR [rsp+32], 8224		; 00002020H
	lea	r9, QWORD PTR held$1[rsp]
	lea	r8, QWORD PTR hovered$2[rsp]
	mov	edx, eax
	lea	rcx, QWORD PTR resize_rect$11[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	npad	1

; 3837 : 		//GetOverlayDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
; 3838 : 		if (hovered || held)

	movzx	eax, BYTE PTR hovered$2[rsp]
	test	eax, eax
	jne	SHORT $LN14@UpdateManu
	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	SHORT $LN13@UpdateManu
$LN14@UpdateManu:

; 3839 : 			g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

	mov	eax, DWORD PTR resize_grip_n$5[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN41@UpdateManu
	mov	DWORD PTR tv205[rsp], 5
	jmp	SHORT $LN42@UpdateManu
$LN41@UpdateManu:
	mov	DWORD PTR tv205[rsp], 6
$LN42@UpdateManu:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv205[rsp]
	mov	DWORD PTR [rax+7504], ecx
$LN13@UpdateManu:

; 3840 : 
; 3841 : 		if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)

	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	SHORT $LN15@UpdateManu
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1021]
	test	eax, eax
	je	SHORT $LN15@UpdateManu
	cmp	DWORD PTR resize_grip_n$5[rsp], 0
	jne	SHORT $LN15@UpdateManu

; 3842 : 		{
; 3843 : 			// Manual auto-fit when double-clicking
; 3844 : 			size_target = CalcSizeAfterConstraint(window, size_auto_fit);

	mov	rax, QWORD PTR size_auto_fit$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ; CalcSizeAfterConstraint
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR size_target$[rsp], rax

; 3845 : 			ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 3846 : 		}

	jmp	$LN16@UpdateManu
$LN15@UpdateManu:

; 3847 : 		else if (held)

	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	$LN17@UpdateManu

; 3848 : 		{
; 3849 : 			// Resize from any of the four corners
; 3850 : 			// We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
; 3851 : 			ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPosN); // Corner of the window corresponding to our corner grip

	movss	xmm0, DWORD PTR grip_hover_inner_size$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rax, QWORD PTR grip$7[rsp]
	add	rax, 8
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T20[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv275[rsp], rax
	mov	rax, QWORD PTR grip$7[rsp]
	add	rax, 8
	movss	xmm2, DWORD PTR grip_hover_outer_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T21[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv273[rsp], rax
	mov	rax, QWORD PTR grip$7[rsp]
	mov	r9, rax
	mov	r8, QWORD PTR tv275[rsp]
	mov	rdx, QWORD PTR tv273[rsp]
	lea	rcx, QWORD PTR $T22[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	mov	QWORD PTR tv289[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6812				; 00001a9cH
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T23[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv287[rsp], rax
	mov	r8, QWORD PTR tv289[rsp]
	mov	rdx, QWORD PTR tv287[rsp]
	lea	rcx, QWORD PTR corner_target$13[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 3852 : 			CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPosN, &pos_target, &size_target);

	mov	rax, QWORD PTR grip$7[rsp]
	lea	rcx, QWORD PTR size_target$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	lea	r9, QWORD PTR pos_target$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR corner_target$13[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z ; CalcResizePosSizeFromAnyCorner
	npad	1
$LN17@UpdateManu:
$LN16@UpdateManu:

; 3853 : 		}
; 3854 : 		if (resize_grip_n == 0 || held || hovered)

	cmp	DWORD PTR resize_grip_n$5[rsp], 0
	je	SHORT $LN19@UpdateManu
	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	jne	SHORT $LN19@UpdateManu
	movzx	eax, BYTE PTR hovered$2[rsp]
	test	eax, eax
	je	SHORT $LN18@UpdateManu
$LN19@UpdateManu:

; 3855 : 			resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);

	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	SHORT $LN45@UpdateManu
	mov	DWORD PTR tv310[rsp], 32		; 00000020H
	jmp	SHORT $LN46@UpdateManu
$LN45@UpdateManu:
	movzx	eax, BYTE PTR hovered$2[rsp]
	test	eax, eax
	je	SHORT $LN43@UpdateManu
	mov	DWORD PTR tv307[rsp], 31
	jmp	SHORT $LN44@UpdateManu
$LN43@UpdateManu:
	mov	DWORD PTR tv307[rsp], 30
$LN44@UpdateManu:
	mov	eax, DWORD PTR tv307[rsp]
	mov	DWORD PTR tv310[rsp], eax
$LN46@UpdateManu:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv310[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movsxd	rcx, DWORD PTR resize_grip_n$5[rsp]
	mov	rdx, QWORD PTR resize_grip_col$[rsp]
	mov	DWORD PTR [rdx+rcx*4], eax
$LN18@UpdateManu:

; 3856 : 	}

	jmp	$LN2@UpdateManu
$LN3@UpdateManu:

; 3857 : 	for (int border_n = 0; border_n < resize_border_count; border_n++)

	mov	DWORD PTR border_n$4[rsp], 0
	jmp	SHORT $LN7@UpdateManu
$LN5@UpdateManu:
	mov	eax, DWORD PTR border_n$4[rsp]
	inc	eax
	mov	DWORD PTR border_n$4[rsp], eax
$LN7@UpdateManu:
	mov	eax, DWORD PTR resize_border_count$[rsp]
	cmp	DWORD PTR border_n$4[rsp], eax
	jge	$LN6@UpdateManu

; 3858 : 	{
; 3859 : 		bool hovered, held;
; 3860 : 		ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS);

	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR grip_hover_inner_size$[rsp]
	mov	r8d, DWORD PTR border_n$4[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR border_rect$34[rsp]
	call	?GetResizeBorderRect@@YA?AUImRect@@PEAUImGuiWindow@@HMM@Z ; GetResizeBorderRect

; 3861 : 		ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);

	mov	eax, DWORD PTR border_n$4[rsp]
	add	eax, 4
	cdqe
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBX@Z		; ImGuiWindow::GetID
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	lea	r9, QWORD PTR held$3[rsp]
	lea	r8, QWORD PTR hovered$6[rsp]
	mov	edx, eax
	lea	rcx, QWORD PTR border_rect$34[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	npad	1

; 3862 : 		//GetOverlayDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
; 3863 : 		if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)

	movzx	eax, BYTE PTR hovered$6[rsp]
	test	eax, eax
	je	SHORT $LN22@UpdateManu
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6728]
	comiss	xmm0, DWORD PTR __real@3d23d70a
	ja	SHORT $LN21@UpdateManu
$LN22@UpdateManu:
	movzx	eax, BYTE PTR held$3[rsp]
	test	eax, eax
	je	SHORT $LN20@UpdateManu
$LN21@UpdateManu:

; 3864 : 		{
; 3865 : 			g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;

	mov	eax, DWORD PTR border_n$4[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN47@UpdateManu
	mov	DWORD PTR tv338[rsp], 4
	jmp	SHORT $LN48@UpdateManu
$LN47@UpdateManu:
	mov	DWORD PTR tv338[rsp], 3
$LN48@UpdateManu:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv338[rsp]
	mov	DWORD PTR [rax+7504], ecx

; 3866 : 			if (held)

	movzx	eax, BYTE PTR held$3[rsp]
	test	eax, eax
	je	SHORT $LN23@UpdateManu

; 3867 : 				*border_held = border_n;

	mov	rax, QWORD PTR border_held$[rsp]
	mov	ecx, DWORD PTR border_n$4[rsp]
	mov	DWORD PTR [rax], ecx
$LN23@UpdateManu:
$LN20@UpdateManu:

; 3868 : 		}
; 3869 : 		if (held)

	movzx	eax, BYTE PTR held$3[rsp]
	test	eax, eax
	je	$LN24@UpdateManu

; 3870 : 		{
; 3871 : 			ImVec2 border_target = window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR border_target$10[rsp], rax

; 3872 : 			ImVec2 border_posn;

	lea	rcx, QWORD PTR border_posn$9[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 3873 : 			if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Top

	cmp	DWORD PTR border_n$4[rsp], 0
	jne	SHORT $LN25@UpdateManu
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR border_posn$9[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+320]
	subss	xmm0, DWORD PTR [rcx+6816]
	addss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR border_target$10[rsp+4], xmm0
$LN25@UpdateManu:

; 3874 : 			if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Right

	cmp	DWORD PTR border_n$4[rsp], 1
	jne	SHORT $LN26@UpdateManu
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR border_posn$9[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	subss	xmm0, DWORD PTR [rcx+6812]
	addss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR border_target$10[rsp], xmm0
$LN26@UpdateManu:

; 3875 : 			if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Bottom

	cmp	DWORD PTR border_n$4[rsp], 2
	jne	SHORT $LN27@UpdateManu
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR border_posn$9[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+320]
	subss	xmm0, DWORD PTR [rcx+6816]
	addss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR border_target$10[rsp+4], xmm0
$LN27@UpdateManu:

; 3876 : 			if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Left

	cmp	DWORD PTR border_n$4[rsp], 3
	jne	SHORT $LN28@UpdateManu
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR border_posn$9[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	subss	xmm0, DWORD PTR [rcx+6812]
	addss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR border_target$10[rsp], xmm0
$LN28@UpdateManu:

; 3877 : 			CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);

	lea	rax, QWORD PTR size_target$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR pos_target$[rsp]
	lea	r8, QWORD PTR border_posn$9[rsp]
	lea	rdx, QWORD PTR border_target$10[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?CalcResizePosSizeFromAnyCorner@@YAXPEAUImGuiWindow@@AEBUImVec2@@1PEAU2@2@Z ; CalcResizePosSizeFromAnyCorner
	npad	1
$LN24@UpdateManu:

; 3878 : 		}
; 3879 : 	}

	jmp	$LN5@UpdateManu
$LN6@UpdateManu:

; 3880 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 3881 : 
; 3882 : 	// Navigation resize (keyboard/gamepad)
; 3883 : 	if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	$LN29@UpdateManu
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+688], rcx
	jne	$LN29@UpdateManu

; 3884 : 	{
; 3885 : 		ImVec2 nav_resize_delta;

	lea	rcx, QWORD PTR nav_resize_delta$8[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 3886 : 		if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 3
	jne	SHORT $LN30@UpdateManu
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN30@UpdateManu

; 3887 : 			nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xor	r8d, r8d
	mov	edx, 1
	lea	rcx, QWORD PTR $T28[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nav_resize_delta$8[rsp], rax
$LN30@UpdateManu:

; 3888 : 		if (g.NavInputSource == ImGuiInputSource_NavGamepad)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 4
	jne	SHORT $LN31@UpdateManu

; 3889 : 			nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xor	r8d, r8d
	mov	edx, 2
	lea	rcx, QWORD PTR $T29[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nav_resize_delta$8[rsp], rax
$LN31@UpdateManu:

; 3890 : 		if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)

	movss	xmm0, DWORD PTR nav_resize_delta$8[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN33@UpdateManu
	jne	SHORT $LN33@UpdateManu
	movss	xmm0, DWORD PTR nav_resize_delta$8[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN51@UpdateManu
	je	$LN32@UpdateManu
$LN51@UpdateManu:
$LN33@UpdateManu:

; 3891 : 		{
; 3892 : 			const float NAV_RESIZE_SPEED = 600.0f;

	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR NAV_RESIZE_SPEED$14[rsp], xmm0

; 3893 : 			nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@44160000
	mulss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv437[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+192]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+188]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	xmm1, DWORD PTR tv437[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR nav_resize_delta$8[rsp]
	call	??X@YAAEAUImVec2@@AEAU0@M@Z		; operator*=

; 3894 : 			g.NavWindowingToggleLayer = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7128], 0

; 3895 : 			g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1

; 3896 : 			resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);

	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 32					; 00000020H
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR resize_grip_col$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 3897 : 			// FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
; 3898 : 			size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 32					; 00000020H
	lea	r8, QWORD PTR nav_resize_delta$8[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T30[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	call	?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ; CalcSizeAfterConstraint
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR size_target$[rsp], rax
$LN32@UpdateManu:
$LN29@UpdateManu:

; 3899 : 		}
; 3900 : 	}
; 3901 : 
; 3902 : 	// Apply back modified position/size to window
; 3903 : 	if (size_target.x != FLT_MAX)

	movss	xmm0, DWORD PTR size_target$[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN50@UpdateManu
	je	SHORT $LN34@UpdateManu
$LN50@UpdateManu:

; 3904 : 	{
; 3905 : 		window->SizeFull = size_target;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR size_target$[rsp]
	mov	QWORD PTR [rax+32], rcx
$LN34@UpdateManu:

; 3906 : 		//MarkIniSettingsDirty(window);
; 3907 : 	}
; 3908 : 	if (pos_target.x != FLT_MAX)

	movss	xmm0, DWORD PTR pos_target$[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN49@UpdateManu
	je	SHORT $LN35@UpdateManu
$LN49@UpdateManu:

; 3909 : 	{
; 3910 : 		window->Pos = ImFloor(pos_target);

	lea	rdx, QWORD PTR pos_target$[rsp]
	lea	rcx, QWORD PTR $T32[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+48], rax
$LN35@UpdateManu:

; 3911 : 		//MarkIniSettingsDirty(window);
; 3912 : 	}
; 3913 : 
; 3914 : 	window->Size = window->SizeFull;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx], rax
$LN1@UpdateManu:

; 3915 : }

	add	rsp, 456				; 000001c8H
	ret	0
?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z ENDP ; ImGui::UpdateManualResize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv130 = 32
scroll_allowed$ = 33
scroll_window$ = 40
g$ = 48
window$ = 56
scale$1 = 64
scroll_amount$2 = 68
new_font_scale$3 = 72
scroll_amount$4 = 76
tv178 = 80
tv176 = 88
tv155 = 96
offset$5 = 104
$T6 = 112
$T7 = 120
$T8 = 128
?UpdateMouseWheel@ImGui@@YAXXZ PROC			; ImGui::UpdateMouseWheel

; 2364 : {

	sub	rsp, 152				; 00000098H

; 2365 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2366 : 	if (!g.HoveredWindow || g.HoveredWindow->Collapsed)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	je	SHORT $LN5@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	je	SHORT $LN4@UpdateMous
$LN5@UpdateMous:

; 2367 : 		return;

	jmp	$LN1@UpdateMous
$LN4@UpdateMous:

; 2368 : 	if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN6@UpdateMous
	jne	SHORT $LN6@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN6@UpdateMous
	jne	SHORT $LN6@UpdateMous

; 2369 : 		return;

	jmp	$LN1@UpdateMous
$LN6@UpdateMous:

; 2370 : 
; 2371 : 	// If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).
; 2372 : 	ImGuiWindow* window = g.HoveredWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	QWORD PTR window$[rsp], rax

; 2373 : 	ImGuiWindow* scroll_window = window;

	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR scroll_window$[rsp], rax
$LN2@UpdateMous:

; 2374 : 	while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs) && scroll_window->ParentWindow)

	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN3@UpdateMous
	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN3@UpdateMous
	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN3@UpdateMous
	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	SHORT $LN3@UpdateMous
	mov	rax, QWORD PTR scroll_window$[rsp]
	cmp	QWORD PTR [rax+880], 0
	je	SHORT $LN3@UpdateMous

; 2375 : 		scroll_window = scroll_window->ParentWindow;

	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR scroll_window$[rsp], rax
	jmp	SHORT $LN2@UpdateMous
$LN3@UpdateMous:

; 2376 : 	const bool scroll_allowed = !(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs);

	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN13@UpdateMous
	mov	rax, QWORD PTR scroll_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	SHORT $LN13@UpdateMous
	mov	BYTE PTR tv130[rsp], 1
	jmp	SHORT $LN14@UpdateMous
$LN13@UpdateMous:
	mov	BYTE PTR tv130[rsp], 0
$LN14@UpdateMous:
	movzx	eax, BYTE PTR tv130[rsp]
	mov	BYTE PTR scroll_allowed$[rsp], al

; 2377 : 
; 2378 : 	if (g.IO.MouseWheel != 0.0f)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN16@UpdateMous
	je	$LN7@UpdateMous
$LN16@UpdateMous:

; 2379 : 	{
; 2380 : 		if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	je	$LN8@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+184]
	test	eax, eax
	je	$LN8@UpdateMous

; 2381 : 		{
; 2382 : 			// Zoom / Scale window
; 2383 : 			const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+680]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR __real@40200000
	movss	xmm1, DWORD PTR __real@3f000000
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR new_font_scale$3[rsp], xmm0

; 2384 : 			const float scale = new_font_scale / window->FontWindowScale;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR new_font_scale$3[rsp]
	divss	xmm0, DWORD PTR [rax+680]
	movss	DWORD PTR scale$1[rsp], xmm0

; 2385 : 			window->FontWindowScale = new_font_scale;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR new_font_scale$3[rsp]
	movss	DWORD PTR [rax+680], xmm0

; 2386 : 
; 2387 : 			const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv178[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR scale$1[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv176[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR tv155[rsp], rax
	mov	r8, QWORD PTR tv178[rsp]
	mov	rdx, QWORD PTR tv176[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	rcx, QWORD PTR tv155[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, QWORD PTR offset$5[rsp]
	call	??K@YA?AUImVec2@@AEBU0@0@Z		; operator/
	npad	1

; 2388 : 			window->Pos += offset;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	lea	rdx, QWORD PTR offset$5[rsp]
	mov	rcx, rax
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=

; 2389 : 			window->Size *= scale;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR scale$1[rsp]
	mov	rcx, rax
	call	??X@YAAEAUImVec2@@AEAU0@M@Z		; operator*=

; 2390 : 			window->SizeFull *= scale;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 32					; 00000020H
	movss	xmm1, DWORD PTR scale$1[rsp]
	mov	rcx, rax
	call	??X@YAAEAUImVec2@@AEAU0@M@Z		; operator*=
	npad	1

; 2391 : 		}

	jmp	$LN9@UpdateMous
$LN8@UpdateMous:

; 2392 : 		else if (!g.IO.KeyCtrl && scroll_allowed)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	$LN10@UpdateMous
	movzx	eax, BYTE PTR scroll_allowed$[rsp]
	test	eax, eax
	je	$LN10@UpdateMous

; 2393 : 		{
; 2394 : 			// Mouse wheel vertical scrolling
; 2395 : 			float scroll_amount = 5 * scroll_window->CalcFontSize();

	mov	rcx, QWORD PTR scroll_window$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	movss	xmm1, DWORD PTR __real@40a00000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR scroll_amount$2[rsp], xmm0

; 2396 : 			scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);

	mov	rax, QWORD PTR scroll_window$[rsp]
	add	rax, 208				; 000000d0H
	mov	rcx, rax
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	mov	rax, QWORD PTR scroll_window$[rsp]
	movss	xmm1, DWORD PTR [rax+84]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f2b851f
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR scroll_amount$2[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR scroll_amount$2[rsp], xmm0

; 2397 : 			SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	mulss	xmm0, DWORD PTR scroll_amount$2[rsp]
	mov	rax, QWORD PTR scroll_window$[rsp]
	movss	xmm1, DWORD PTR [rax+96]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR scroll_window$[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
	npad	1
$LN10@UpdateMous:
$LN9@UpdateMous:
$LN7@UpdateMous:

; 2398 : 		}
; 2399 : 	}
; 2400 : 	if (g.IO.MouseWheelH != 0.0f && scroll_allowed && !g.IO.KeyCtrl)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN15@UpdateMous
	je	SHORT $LN11@UpdateMous
$LN15@UpdateMous:
	movzx	eax, BYTE PTR scroll_allowed$[rsp]
	test	eax, eax
	je	SHORT $LN11@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	SHORT $LN11@UpdateMous

; 2401 : 	{
; 2402 : 		// Mouse wheel horizontal scrolling (for hardware that supports it)
; 2403 : 		float scroll_amount = scroll_window->CalcFontSize();

	mov	rcx, QWORD PTR scroll_window$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	movss	DWORD PTR scroll_amount$4[rsp], xmm0

; 2404 : 		SetWindowScrollX(scroll_window, scroll_window->Scroll.x - g.IO.MouseWheelH * scroll_amount);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	mulss	xmm0, DWORD PTR scroll_amount$4[rsp]
	mov	rax, QWORD PTR scroll_window$[rsp]
	movss	xmm1, DWORD PTR [rax+92]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR scroll_window$[rsp]
	call	?SetWindowScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollX
	npad	1
$LN11@UpdateMous:
$LN1@UpdateMous:

; 2405 : 	}
; 2406 : }

	add	rsp, 152				; 00000098H
	ret	0
?UpdateMouseWheel@ImGui@@YAXXZ ENDP			; ImGui::UpdateMouseWheel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
delta_from_click_pos$2 = 48
tv177 = 56
tv197 = 60
tv233 = 64
tv236 = 68
tv389 = 72
tv407 = 76
tv379 = 80
tv377 = 84
tv282 = 88
tv359 = 96
$T3 = 104
delta_from_click_pos$4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 176
$T13 = 184
?UpdateMouseInputs@ImGui@@YAXXZ PROC			; ImGui::UpdateMouseInputs

; 2310 : {

	sub	rsp, 200				; 000000c8H

; 2311 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2312 : 
; 2313 : 	// Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
; 2314 : 	if (IsMousePosValid(&g.IO.MousePos))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@UpdateMous

; 2315 : 		g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rdx, rax
	lea	rcx, QWORD PTR $T6[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6832], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6832]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+316], rax
$LN5@UpdateMous:

; 2316 : 
; 2317 : 	// If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
; 2318 : 	if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 1028				; 00000404H
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@UpdateMous

; 2319 : 		g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 1028				; 00000404H
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T7[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+968], rax
	jmp	SHORT $LN7@UpdateMous
$LN6@UpdateMous:

; 2320 : 	else
; 2321 : 		g.IO.MouseDelta = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+968], rax
$LN7@UpdateMous:

; 2322 : 	if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+968]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN9@UpdateMous
	jne	SHORT $LN9@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+972]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN34@UpdateMous
	je	SHORT $LN8@UpdateMous
$LN34@UpdateMous:
$LN9@UpdateMous:

; 2323 : 		g.NavDisableMouseHover = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 0
$LN8@UpdateMous:

; 2324 : 
; 2325 : 	g.IO.MousePosPrev = g.IO.MousePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+316]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+1028], rax

; 2326 : 	for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@UpdateMous
$LN2@UpdateMous:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@UpdateMous:
	cmp	DWORD PTR i$1[rsp], 5
	jge	$LN3@UpdateMous

; 2327 : 	{
; 2328 : 		g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	SHORT $LN18@UpdateMous
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rcx+rax*4+1084]
	jbe	SHORT $LN18@UpdateMous
	mov	DWORD PTR tv177[rsp], 1
	jmp	SHORT $LN19@UpdateMous
$LN18@UpdateMous:
	mov	DWORD PTR tv177[rsp], 0
$LN19@UpdateMous:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	edx, BYTE PTR tv177[rsp]
	mov	BYTE PTR [rcx+rax+1016], dl

; 2329 : 		g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN20@UpdateMous
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+1084]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN20@UpdateMous
	mov	DWORD PTR tv197[rsp], 1
	jmp	SHORT $LN21@UpdateMous
$LN20@UpdateMous:
	mov	DWORD PTR tv197[rsp], 0
$LN21@UpdateMous:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	edx, BYTE PTR tv197[rsp]
	mov	BYTE PTR [rcx+rax+1076], dl

; 2330 : 		g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	r8, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [r8+rax*4+1084]
	movss	DWORD PTR [rdx+rcx*4+1112], xmm0

; 2331 : 		g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	SHORT $LN24@UpdateMous
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rcx+rax*4+1084]
	jbe	SHORT $LN22@UpdateMous
	xorps	xmm0, xmm0
	movss	DWORD PTR tv233[rsp], xmm0
	jmp	SHORT $LN23@UpdateMous
$LN22@UpdateMous:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+1084]
	addss	xmm0, DWORD PTR [rdx+48]
	movss	DWORD PTR tv233[rsp], xmm0
$LN23@UpdateMous:
	movss	xmm0, DWORD PTR tv233[rsp]
	movss	DWORD PTR tv236[rsp], xmm0
	jmp	SHORT $LN25@UpdateMous
$LN24@UpdateMous:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv236[rsp], xmm0
$LN25@UpdateMous:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv236[rsp]
	movss	DWORD PTR [rcx+rax*4+1084], xmm0

; 2332 : 		g.IO.MouseDoubleClicked[i] = false;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	BYTE PTR [rcx+rax+1021], 0

; 2333 : 		if (g.IO.MouseClicked[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	$LN10@UpdateMous

; 2334 : 		{
; 2335 : 			if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movsd	xmm0, QWORD PTR [rcx+6576]
	subsd	xmm0, QWORD PTR [rdx+rax*8+976]
	cvtsd2ss xmm0, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+144]
	comiss	xmm1, xmm0
	jbe	$LN12@UpdateMous

; 2336 : 			{
; 2337 : 				ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@UpdateMous
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+1036]
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T9[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv282[rsp], rax
	jmp	SHORT $LN27@UpdateMous
$LN26@UpdateMous:
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv282[rsp], rax
$LN27@UpdateMous:
	mov	rax, QWORD PTR tv282[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR delta_from_click_pos$4[rsp], rax

; 2338 : 				if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)

	lea	rcx, QWORD PTR delta_from_click_pos$4[rsp]
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	mulss	xmm1, DWORD PTR [rcx+52]
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@UpdateMous

; 2339 : 					g.IO.MouseDoubleClicked[i] = true;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	BYTE PTR [rcx+rax+1021], 1
$LN14@UpdateMous:

; 2340 : 				g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movsd	xmm0, QWORD PTR __real@c7efffffe0000000
	movsd	QWORD PTR [rcx+rax*8+976], xmm0

; 2341 : 			}

	jmp	SHORT $LN13@UpdateMous
$LN12@UpdateMous:

; 2342 : 			else
; 2343 : 			{
; 2344 : 				g.IO.MouseClickedTime[i] = g.Time;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movsd	xmm0, QWORD PTR [rdx+6576]
	movsd	QWORD PTR [rcx+rax*8+976], xmm0
$LN13@UpdateMous:

; 2345 : 			}
; 2346 : 			g.IO.MouseClickedPos[i] = g.IO.MousePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+316]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rdx+rcx*8+1036], rax

; 2347 : 			g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rdx+rcx*8+3180], rax

; 2348 : 			g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rcx+rax*4+3304], xmm0

; 2349 : 		}

	jmp	$LN11@UpdateMous
$LN10@UpdateMous:

; 2350 : 		else if (g.IO.MouseDown[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	$LN15@UpdateMous

; 2351 : 		{
; 2352 : 			// Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
; 2353 : 			ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@UpdateMous
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+1036]
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T12[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv359[rsp], rax
	jmp	SHORT $LN29@UpdateMous
$LN28@UpdateMous:
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv359[rsp], rax
$LN29@UpdateMous:
	mov	rax, QWORD PTR tv359[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR delta_from_click_pos$2[rsp], rax

; 2354 : 			g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));

	lea	rcx, QWORD PTR delta_from_click_pos$2[rsp]
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	movss	DWORD PTR tv379[rsp], xmm0
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+3304]
	movss	DWORD PTR tv377[rsp], xmm0
	movss	xmm1, DWORD PTR tv379[rsp]
	movss	xmm0, DWORD PTR tv377[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	DWORD PTR [rcx+rax*4+3304], xmm0

; 2355 : 			g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta_from_click_pos$2[rsp]
	jbe	SHORT $LN30@UpdateMous
	movss	xmm0, DWORD PTR delta_from_click_pos$2[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv389[rsp], xmm0
	jmp	SHORT $LN31@UpdateMous
$LN30@UpdateMous:
	movss	xmm0, DWORD PTR delta_from_click_pos$2[rsp]
	movss	DWORD PTR tv389[rsp], xmm0
$LN31@UpdateMous:
	movsxd	rax, DWORD PTR i$1[rsp]
	movss	xmm1, DWORD PTR tv389[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*8+3180]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	DWORD PTR [rcx+rax*8+3180], xmm0

; 2356 : 			g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta_from_click_pos$2[rsp+4]
	jbe	SHORT $LN32@UpdateMous
	movss	xmm0, DWORD PTR delta_from_click_pos$2[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv407[rsp], xmm0
	jmp	SHORT $LN33@UpdateMous
$LN32@UpdateMous:
	movss	xmm0, DWORD PTR delta_from_click_pos$2[rsp+4]
	movss	DWORD PTR tv407[rsp], xmm0
$LN33@UpdateMous:
	movsxd	rax, DWORD PTR i$1[rsp]
	movss	xmm1, DWORD PTR tv407[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*8+3184]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	DWORD PTR [rcx+rax*8+3184], xmm0
$LN15@UpdateMous:
$LN11@UpdateMous:

; 2357 : 		}
; 2358 : 		if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	SHORT $LN16@UpdateMous

; 2359 : 			g.NavDisableMouseHover = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 0
$LN16@UpdateMous:

; 2360 : 	}

	jmp	$LN2@UpdateMous
$LN3@UpdateMous:

; 2361 : }

	add	rsp, 200				; 000000c8H
	ret	0
?UpdateMouseInputs@ImGui@@YAXXZ ENDP			; ImGui::UpdateMouseInputs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv67 = 0
window$ = 32
?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z PROC ; ImGui::NavRestoreLastChildNavWindow

; 6551 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 6552 : 	return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+896], 0
	je	SHORT $LN3@NavRestore
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+896]
	mov	QWORD PTR tv67[rsp], rax
	jmp	SHORT $LN4@NavRestore
$LN3@NavRestore:
	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR tv67[rsp], rax
$LN4@NavRestore:
	mov	rax, QWORD PTR tv67[rsp]

; 6553 : }

	add	rsp, 24
	ret	0
?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z ENDP ; ImGui::NavRestoreLastChildNavWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
parent_window$ = 0
nav_window$ = 32
?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::NavSaveLastChildNavWindow

; 6541 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 6542 : 	ImGuiWindow* parent_window = nav_window;

	mov	rax, QWORD PTR nav_window$[rsp]
	mov	QWORD PTR parent_window$[rsp], rax
$LN2@NavSaveLas:

; 6543 : 	while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN3@NavSaveLas
	mov	rax, QWORD PTR parent_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN3@NavSaveLas
	mov	rax, QWORD PTR parent_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 335544320				; 14000000H
	test	eax, eax
	jne	SHORT $LN3@NavSaveLas

; 6544 : 		parent_window = parent_window->ParentWindow;

	mov	rax, QWORD PTR parent_window$[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR parent_window$[rsp], rax
	jmp	SHORT $LN2@NavSaveLas
$LN3@NavSaveLas:

; 6545 : 	if (parent_window && parent_window != nav_window)

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN4@NavSaveLas
	mov	rax, QWORD PTR nav_window$[rsp]
	cmp	QWORD PTR parent_window$[rsp], rax
	je	SHORT $LN4@NavSaveLas

; 6546 : 		parent_window->NavLastChildNavWindow = nav_window;

	mov	rax, QWORD PTR parent_window$[rsp]
	mov	rcx, QWORD PTR nav_window$[rsp]
	mov	QWORD PTR [rax+896], rcx
$LN4@NavSaveLas:

; 6547 : }

	add	rsp, 24
	ret	0
?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::NavSaveLastChildNavWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
rect_rel$1 = 40
tv137 = 48
tv135 = 52
tv154 = 56
tv152 = 60
tv160 = 64
tv158 = 68
tv169 = 72
tv167 = 80
pos$2 = 88
visible_rect$3 = 96
$T4 = 112
$T5 = 120
__$ReturnUdt$ = 144
?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::NavCalcPreferredRefPos

; 6600 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 6601 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6602 : 	if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN4@NavCalcPre
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	SHORT $LN4@NavCalcPre
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	jne	SHORT $LN2@NavCalcPre
$LN4@NavCalcPre:

; 6603 : 	{
; 6604 : 		// Mouse (we need a fallback in case the mouse becomes invalid after being used)
; 6605 : 		if (IsMousePosValid(&g.IO.MousePos))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@NavCalcPre

; 6606 : 			return g.IO.MousePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+316]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@NavCalcPre
$LN5@NavCalcPre:

; 6607 : 		return g.LastValidMousePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6832]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@NavCalcPre

; 6608 : 	}

	jmp	$LN3@NavCalcPre
$LN2@NavCalcPre:

; 6609 : 	else
; 6610 : 	{
; 6611 : 		// When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
; 6612 : 		const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	movsxd	rcx, DWORD PTR [rcx+7132]
	imul	rcx, rcx, 16
	lea	rax, QWORD PTR [rax+rcx+912]
	mov	QWORD PTR rect_rel$1[rsp], rax

; 6613 : 		ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));

	mov	rcx, QWORD PTR rect_rel$1[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv137[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	movss	DWORD PTR tv135[rsp], xmm0
	movss	xmm1, DWORD PTR tv137[rsp]
	movss	xmm0, DWORD PTR tv135[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR rect_rel$1[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv160[rsp], xmm0
	mov	rcx, QWORD PTR rect_rel$1[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv154[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5524]
	mulss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR tv152[rsp], xmm0
	movss	xmm1, DWORD PTR tv154[rsp]
	movss	xmm0, DWORD PTR tv152[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR rect_rel$1[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv158[rsp], xmm0
	movss	xmm2, DWORD PTR tv160[rsp]
	movss	xmm1, DWORD PTR tv158[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv169[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv167[rsp], rax
	mov	r8, QWORD PTR tv169[rsp]
	mov	rdx, QWORD PTR tv167[rsp]
	lea	rcx, QWORD PTR pos$2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 6614 : 		ImRect visible_rect = GetViewportRect();

	lea	rcx, QWORD PTR visible_rect$3[rsp]
	call	?GetViewportRect@@YA?AUImRect@@XZ	; GetViewportRect
	npad	1

; 6615 : 		return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.

	mov	r9, QWORD PTR visible_rect$3[rsp+8]
	lea	r8, QWORD PTR visible_rect$3[rsp]
	lea	rdx, QWORD PTR pos$2[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z	; ImClamp
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN3@NavCalcPre:
$LN1@NavCalcPre:

; 6616 : 	}
; 6617 : }

	add	rsp, 136				; 00000088H
	ret	0
?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::NavCalcPreferredRefPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
new_best$1 = 40
result$2 = 48
item_flags$ = 56
tv153 = 60
tv173 = 64
tv144 = 72
nav_bb_rel$ = 80
VISIBLE_RATIO$3 = 96
tv85 = 104
tv83 = 112
tv170 = 120
$T4 = 128
$T5 = 136
$T6 = 144
$T7 = 160
window$ = 208
nav_bb$ = 216
id$ = 224
?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z PROC ; ImGui::NavProcessItem

; 6411 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 6412 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6413 : 	//if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
; 6414 : 	//    return;
; 6415 : 
; 6416 : 	const ImGuiItemFlags item_flags = window->DC.ItemFlags;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	mov	DWORD PTR item_flags$[rsp], eax

; 6417 : 	const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR nav_bb$[rsp]
	add	rcx, 8
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T4[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR nav_bb$[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv83[rsp], rax
	mov	r8, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR tv83[rsp]
	lea	rcx, QWORD PTR nav_bb_rel$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 6418 : 
; 6419 : 	// Process Init Request
; 6420 : 	if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7168]
	test	eax, eax
	je	SHORT $LN2@NavProcess
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+400]
	cmp	DWORD PTR [rax+7132], ecx
	jne	SHORT $LN2@NavProcess

; 6421 : 	{
; 6422 : 		// Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
; 6423 : 		if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)

	mov	eax, DWORD PTR item_flags$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN4@NavProcess
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7148], 0
	jne	SHORT $LN3@NavProcess
$LN4@NavProcess:

; 6424 : 		{
; 6425 : 			g.NavInitResultId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7148], ecx

; 6426 : 			g.NavInitResultRectRel = nav_bb_rel;

	mov	rax, QWORD PTR g$[rsp]
	lea	rcx, QWORD PTR nav_bb_rel$[rsp]
	lea	rdi, QWORD PTR [rax+7152]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN3@NavProcess:

; 6427 : 		}
; 6428 : 		if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))

	mov	eax, DWORD PTR item_flags$[rsp]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN5@NavProcess

; 6429 : 		{
; 6430 : 			g.NavInitRequest = false; // Found a match, clear request

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 0

; 6431 : 			NavUpdateAnyRequestFlag();

	call	?NavUpdateAnyRequestFlag@ImGui@@YAXXZ	; ImGui::NavUpdateAnyRequestFlag
	npad	1
$LN5@NavProcess:
$LN2@NavProcess:

; 6432 : 		}
; 6433 : 	}
; 6434 : 
; 6435 : 	// Process Move Request (scoring for navigation)
; 6436 : 	// FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
; 6437 : 	if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_NoNav))

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	SHORT $LN7@NavProcess
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7172]
	and	eax, 16
	test	eax, eax
	je	$LN6@NavProcess
$LN7@NavProcess:
	mov	eax, DWORD PTR item_flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	$LN6@NavProcess

; 6438 : 	{
; 6439 : 		ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	cmp	QWORD PTR window$[rsp], rax
	jne	SHORT $LN14@NavProcess
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7176				; 00001c08H
	mov	QWORD PTR tv144[rsp], rax
	jmp	SHORT $LN15@NavProcess
$LN14@NavProcess:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7288				; 00001c78H
	mov	QWORD PTR tv144[rsp], rax
$LN15@NavProcess:
	mov	rax, QWORD PTR tv144[rsp]
	mov	QWORD PTR result$2[rsp], rax

; 6440 : #if IMGUI_DEBUG_NAV_SCORING
; 6441 : 		// [DEBUG] Score all items in NavWindow at all times
; 6442 : 		if (!g.NavMoveRequest)
; 6443 : 			g.NavMoveDir = g.NavMoveDirLast;
; 6444 : 		bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
; 6445 : #else
; 6446 : 		bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN16@NavProcess
	lea	rax, QWORD PTR $T6[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR nav_bb$[rsp]
	mov	ecx, 16
	rep movsb
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR result$2[rsp]
	call	?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z ; NavScoreItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@NavProcess
	mov	DWORD PTR tv153[rsp], 1
	jmp	SHORT $LN17@NavProcess
$LN16@NavProcess:
	mov	DWORD PTR tv153[rsp], 0
$LN17@NavProcess:
	movzx	eax, BYTE PTR tv153[rsp]
	mov	BYTE PTR new_best$1[rsp], al

; 6447 : #endif
; 6448 : 		if (new_best)

	movzx	eax, BYTE PTR new_best$1[rsp]
	test	eax, eax
	je	SHORT $LN8@NavProcess

; 6449 : 		{
; 6450 : 			result->ID = id;

	mov	rax, QWORD PTR result$2[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax], ecx

; 6451 : 			result->SelectScopeId = g.MultiSelectScopeId;

	mov	rax, QWORD PTR result$2[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+11728]
	mov	DWORD PTR [rax+20], ecx

; 6452 : 			result->Window = window;

	mov	rax, QWORD PTR result$2[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 6453 : 			result->RectRel = nav_bb_rel;

	mov	rax, QWORD PTR result$2[rsp]
	lea	rcx, QWORD PTR nav_bb_rel$[rsp]
	lea	rdi, QWORD PTR [rax+28]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN8@NavProcess:

; 6454 : 		}
; 6455 : 
; 6456 : 		const float VISIBLE_RATIO = 0.70f;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR VISIBLE_RATIO$3[rsp], xmm0

; 6457 : 		if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7172]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$LN9@NavProcess
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv170[rsp], rax
	mov	rdx, QWORD PTR nav_bb$[rsp]
	mov	rcx, QWORD PTR tv170[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps
	movzx	eax, al
	test	eax, eax
	je	$LN9@NavProcess

; 6458 : 			if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+260]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+252]
	mov	rax, QWORD PTR nav_bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv173[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+260]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+252]
	mov	rax, QWORD PTR nav_bb$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	xmm1, DWORD PTR tv173[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR nav_bb$[rsp]
	mov	rcx, QWORD PTR nav_bb$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	subss	xmm1, DWORD PTR [rcx+4]
	mulss	xmm1, DWORD PTR __real@3f333333
	comiss	xmm0, xmm1
	jb	$LN10@NavProcess

; 6459 : 				if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))

	lea	rax, QWORD PTR $T7[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR nav_bb$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7224				; 00001c38H
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, rax
	call	?NavScoreItem@@YA_NPEAUImGuiNavMoveResult@@UImRect@@@Z ; NavScoreItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@NavProcess

; 6460 : 				{
; 6461 : 					result = &g.NavMoveResultLocalVisibleSet;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7224				; 00001c38H
	mov	QWORD PTR result$2[rsp], rax

; 6462 : 					result->ID = id;

	mov	rax, QWORD PTR result$2[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax], ecx

; 6463 : 					result->SelectScopeId = g.MultiSelectScopeId;

	mov	rax, QWORD PTR result$2[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+11728]
	mov	DWORD PTR [rax+20], ecx

; 6464 : 					result->Window = window;

	mov	rax, QWORD PTR result$2[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 6465 : 					result->RectRel = nav_bb_rel;

	mov	rax, QWORD PTR result$2[rsp]
	lea	rcx, QWORD PTR nav_bb_rel$[rsp]
	lea	rdi, QWORD PTR [rax+28]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN11@NavProcess:
$LN10@NavProcess:
$LN9@NavProcess:
$LN6@NavProcess:

; 6466 : 				}
; 6467 : 	}
; 6468 : 
; 6469 : 	// Update window-relative bounding box of navigated item
; 6470 : 	if (g.NavId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	$LN12@NavProcess

; 6471 : 	{
; 6472 : 		g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+7024], rcx

; 6473 : 		g.NavLayer = window->DC.NavLayerCurrent;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+400]
	mov	DWORD PTR [rax+7132], ecx

; 6474 : 		g.NavIdIsAlive = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7141], 1

; 6475 : 		g.NavIdTabCounter = window->FocusIdxTabCounter;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+960]
	mov	DWORD PTR [rax+7136], ecx

; 6476 : 		window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)

	mov	rax, QWORD PTR window$[rsp]
	movsxd	rax, DWORD PTR [rax+400]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR window$[rsp]
	lea	rdx, QWORD PTR nav_bb_rel$[rsp]
	lea	rdi, QWORD PTR [rcx+rax+912]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb
$LN12@NavProcess:

; 6477 : 	}
; 6478 : }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z ENDP ; ImGui::NavProcessItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv72 = 0
g$ = 8
?NavUpdateAnyRequestFlag@ImGui@@YAXXZ PROC		; ImGui::NavUpdateAnyRequestFlag

; 6568 : {

	sub	rsp, 24

; 6569 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6570 : 	g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	jne	SHORT $LN4@NavUpdateA
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7168]
	test	eax, eax
	jne	SHORT $LN4@NavUpdateA
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@NavUpdateA
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN5@NavUpdateA
$LN4@NavUpdateA:
	mov	DWORD PTR tv72[rsp], 1
$LN5@NavUpdateA:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv72[rsp]
	mov	BYTE PTR [rax+7144], cl

; 6571 : 	if (g.NavAnyRequest)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7144]

; 6572 : 		IM_ASSERT(g.NavWindow != NULL);
; 6573 : }

	add	rsp, 24
	ret	0
?NavUpdateAnyRequestFlag@ImGui@@YAXXZ ENDP		; ImGui::NavUpdateAnyRequestFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
page_up_held$1 = 40
page_down_held$2 = 41
window$3 = 48
nav_scoring_rect_offset_y$4 = 56
tv87 = 60
tv131 = 64
page_offset_y$5 = 68
tv185 = 72
tv189 = 76
nav_rect_rel$6 = 80
allowed_dir_flags$ = 112
?NavUpdatePageUpPageDown@ImGui@@YAMH@Z PROC		; ImGui::NavUpdatePageUpPageDown

; 7016 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 7017 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7018 : 	if (g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], -1
	jne	$LN2@NavUpdateP
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN2@NavUpdateP
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	$LN2@NavUpdateP
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	$LN2@NavUpdateP
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	jne	$LN2@NavUpdateP

; 7019 : 	{
; 7020 : 		ImGuiWindow* window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR window$3[rsp], rax

; 7021 : 		bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@NavUpdateP
	mov	eax, DWORD PTR allowed_dir_flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN13@NavUpdateP
	mov	DWORD PTR tv87[rsp], 1
	jmp	SHORT $LN14@NavUpdateP
$LN13@NavUpdateP:
	mov	DWORD PTR tv87[rsp], 0
$LN14@NavUpdateP:
	movzx	eax, BYTE PTR tv87[rsp]
	mov	BYTE PTR page_up_held$1[rsp], al

; 7022 : 		bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@NavUpdateP
	mov	eax, DWORD PTR allowed_dir_flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN15@NavUpdateP
	mov	DWORD PTR tv131[rsp], 1
	jmp	SHORT $LN16@NavUpdateP
$LN15@NavUpdateP:
	mov	DWORD PTR tv131[rsp], 0
$LN16@NavUpdateP:
	movzx	eax, BYTE PTR tv131[rsp]
	mov	BYTE PTR page_down_held$2[rsp], al

; 7023 : 		if (page_up_held != page_down_held) // If either (not both) are pressed

	movzx	eax, BYTE PTR page_up_held$1[rsp]
	movzx	ecx, BYTE PTR page_down_held$2[rsp]
	cmp	eax, ecx
	je	$LN3@NavUpdateP

; 7024 : 		{
; 7025 : 			if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)

	mov	rax, QWORD PTR window$3[rsp]
	cmp	DWORD PTR [rax+420], 0
	jne	$LN4@NavUpdateP
	mov	rax, QWORD PTR window$3[rsp]
	movzx	eax, BYTE PTR [rax+456]
	test	eax, eax
	je	$LN4@NavUpdateP

; 7026 : 			{
; 7027 : 				// Fallback manual-scroll when window has no navigable item
; 7028 : 				if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))

	mov	eax, 4
	imul	rax, rax, 5
	mov	dl, 1
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@NavUpdateP

; 7029 : 					SetWindowScrollY(window, window->Scroll.y - window->InnerClipRect.GetHeight());

	mov	rax, QWORD PTR window$3[rsp]
	add	rax, 600				; 00000258H
	mov	rcx, rax
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	mov	rax, QWORD PTR window$3[rsp]
	movss	xmm1, DWORD PTR [rax+96]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR window$3[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
	npad	1
	jmp	SHORT $LN7@NavUpdateP
$LN6@NavUpdateP:

; 7030 : 				else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))

	mov	eax, 4
	imul	rax, rax, 6
	mov	dl, 1
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@NavUpdateP

; 7031 : 					SetWindowScrollY(window, window->Scroll.y + window->InnerClipRect.GetHeight());

	mov	rax, QWORD PTR window$3[rsp]
	add	rax, 600				; 00000258H
	mov	rcx, rax
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	mov	rax, QWORD PTR window$3[rsp]
	movss	xmm1, DWORD PTR [rax+96]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR window$3[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
	npad	1
$LN8@NavUpdateP:
$LN7@NavUpdateP:

; 7032 : 			}

	jmp	$LN5@NavUpdateP
$LN4@NavUpdateP:

; 7033 : 			else
; 7034 : 			{
; 7035 : 				const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+7132]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR window$3[rsp]
	lea	rax, QWORD PTR [rcx+rax+912]
	mov	QWORD PTR nav_rect_rel$6[rsp], rax

; 7036 : 				const float page_offset_y = ImMax(0.0f, window->InnerClipRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());

	mov	rax, QWORD PTR window$3[rsp]
	add	rax, 600				; 00000258H
	mov	rcx, rax
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv185[rsp], xmm0
	mov	rcx, QWORD PTR window$3[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR tv185[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv189[rsp], xmm0
	mov	rcx, QWORD PTR nav_rect_rel$6[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	xmm1, DWORD PTR tv189[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR page_offset_y$5[rsp], xmm0

; 7037 : 				float nav_scoring_rect_offset_y = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR nav_scoring_rect_offset_y$4[rsp], xmm0

; 7038 : 				if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))

	mov	eax, 4
	imul	rax, rax, 5
	mov	dl, 1
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@NavUpdateP

; 7039 : 				{
; 7040 : 					nav_scoring_rect_offset_y = -page_offset_y;

	movss	xmm0, DWORD PTR page_offset_y$5[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR nav_scoring_rect_offset_y$4[rsp], xmm0

; 7041 : 					g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], 3

; 7042 : 					g.NavMoveClipDir = ImGuiDir_Up;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7284], 2

; 7043 : 					g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7172], 48		; 00000030H

; 7044 : 				}

	jmp	SHORT $LN10@NavUpdateP
$LN9@NavUpdateP:

; 7045 : 				else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))

	mov	eax, 4
	imul	rax, rax, 6
	mov	dl, 1
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@NavUpdateP

; 7046 : 				{
; 7047 : 					nav_scoring_rect_offset_y = +page_offset_y;

	movss	xmm0, DWORD PTR page_offset_y$5[rsp]
	movss	DWORD PTR nav_scoring_rect_offset_y$4[rsp], xmm0

; 7048 : 					g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], 2

; 7049 : 					g.NavMoveClipDir = ImGuiDir_Down;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7284], 3

; 7050 : 					g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7172], 48		; 00000030H
$LN11@NavUpdateP:
$LN10@NavUpdateP:

; 7051 : 				}
; 7052 : 				return nav_scoring_rect_offset_y;

	movss	xmm0, DWORD PTR nav_scoring_rect_offset_y$4[rsp]
	jmp	SHORT $LN1@NavUpdateP
$LN5@NavUpdateP:
$LN3@NavUpdateP:
$LN2@NavUpdateP:

; 7053 : 			}
; 7054 : 		}
; 7055 : 	}
; 7056 : 	return 0.0f;

	xorps	xmm0, xmm0
$LN1@NavUpdateP:

; 7057 : }

	add	rsp, 104				; 00000068H
	ret	0
?NavUpdatePageUpPageDown@ImGui@@YAMH@Z ENDP		; ImGui::NavUpdatePageUpPageDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
result$ = 40
delta_scroll$1 = 48
tv79 = 56
tv171 = 64
tv169 = 72
next_scroll$2 = 80
tv187 = 88
tv207 = 96
tv205 = 104
tv215 = 112
tv213 = 120
rect_abs$3 = 128
$T4 = 144
$T5 = 152
$T6 = 160
$T7 = 168
$T8 = 176
?NavUpdateMoveResult@ImGui@@YAXXZ PROC			; ImGui::NavUpdateMoveResult

; 6960 : {

	sub	rsp, 200				; 000000c8H

; 6961 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6962 : 	if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7176], 0
	jne	SHORT $LN2@NavUpdateM
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7288], 0
	jne	SHORT $LN2@NavUpdateM

; 6963 : 	{
; 6964 : 		// In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
; 6965 : 		if (g.NavId != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	je	SHORT $LN3@NavUpdateM

; 6966 : 		{
; 6967 : 			g.NavDisableHighlight = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 0

; 6968 : 			g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1
$LN3@NavUpdateM:

; 6969 : 		}
; 6970 : 		return;

	jmp	$LN1@NavUpdateM
$LN2@NavUpdateM:

; 6971 : 	}
; 6972 : 
; 6973 : 	// Select which result to use
; 6974 : 	ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7176], 0
	je	SHORT $LN13@NavUpdateM
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7176				; 00001c08H
	mov	QWORD PTR tv79[rsp], rax
	jmp	SHORT $LN14@NavUpdateM
$LN13@NavUpdateM:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7288				; 00001c78H
	mov	QWORD PTR tv79[rsp], rax
$LN14@NavUpdateM:
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR result$[rsp], rax

; 6975 : 
; 6976 : 	// PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
; 6977 : 	if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7172]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN4@NavUpdateM

; 6978 : 		if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7224], 0
	je	SHORT $LN5@NavUpdateM
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	cmp	DWORD PTR [rax+7224], ecx
	je	SHORT $LN5@NavUpdateM

; 6979 : 			result = &g.NavMoveResultLocalVisibleSet;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7224				; 00001c38H
	mov	QWORD PTR result$[rsp], rax
$LN5@NavUpdateM:
$LN4@NavUpdateM:

; 6980 : 
; 6981 : 	// Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
; 6982 : 	if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7288				; 00001c78H
	cmp	QWORD PTR result$[rsp], rax
	je	$LN6@NavUpdateM
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7288], 0
	je	SHORT $LN6@NavUpdateM
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7296]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	cmp	QWORD PTR [rax+880], rcx
	jne	SHORT $LN6@NavUpdateM

; 6983 : 		if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))

	mov	rax, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+7292]
	ja	SHORT $LN8@NavUpdateM
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [rax+7292]
	ucomiss	xmm0, DWORD PTR [rcx+4]
	jp	SHORT $LN7@NavUpdateM
	jne	SHORT $LN7@NavUpdateM
	mov	rax, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	comiss	xmm0, DWORD PTR [rcx+7304]
	jbe	SHORT $LN7@NavUpdateM
$LN8@NavUpdateM:

; 6984 : 			result = &g.NavMoveResultOther;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7288				; 00001c78H
	mov	QWORD PTR result$[rsp], rax
$LN7@NavUpdateM:
$LN6@NavUpdateM:

; 6985 : 	IM_ASSERT(g.NavWindow && result->Window);
; 6986 : 
; 6987 : 	// Scroll to keep newly navigated item fully into view.
; 6988 : 	if (g.NavLayer == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	jne	$LN9@NavUpdateM

; 6989 : 	{
; 6990 : 		ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);

	mov	rax, QWORD PTR result$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR result$[rsp]
	add	rcx, 36					; 00000024H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv171[rsp], rax
	mov	rax, QWORD PTR result$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR result$[rsp]
	add	rcx, 28
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv169[rsp], rax
	mov	r8, QWORD PTR tv171[rsp]
	mov	rdx, QWORD PTR tv169[rsp]
	lea	rcx, QWORD PTR rect_abs$3[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 6991 : 		NavScrollToBringItemIntoView(result->Window, rect_abs);

	lea	rdx, QWORD PTR rect_abs$3[rsp]
	mov	rax, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; NavScrollToBringItemIntoView

; 6992 : 
; 6993 : 		// Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
; 6994 : 		ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);

	xor	r8d, r8d
	mov	rax, QWORD PTR result$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR next_scroll$2[rsp]
	call	?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z ; CalcNextScrollFromScrollTargetAndClamp

; 6995 : 		ImVec2 delta_scroll = result->Window->Scroll - next_scroll;

	mov	rax, QWORD PTR result$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 92					; 0000005cH
	lea	r8, QWORD PTR next_scroll$2[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR delta_scroll$1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 6996 : 		result->RectRel.Translate(delta_scroll);

	mov	rax, QWORD PTR result$[rsp]
	add	rax, 28
	mov	QWORD PTR tv187[rsp], rax
	lea	rdx, QWORD PTR delta_scroll$1[rsp]
	mov	rcx, QWORD PTR tv187[rsp]
	call	?Translate@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Translate
	npad	1

; 6997 : 
; 6998 : 		// Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
; 6999 : 		if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)

	mov	rax, QWORD PTR result$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN10@NavUpdateM

; 7000 : 			NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));

	lea	r8, QWORD PTR delta_scroll$1[rsp]
	lea	rdx, QWORD PTR rect_abs$3[rsp+8]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv207[rsp], rax
	lea	r8, QWORD PTR delta_scroll$1[rsp]
	lea	rdx, QWORD PTR rect_abs$3[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv205[rsp], rax
	mov	r8, QWORD PTR tv207[rsp]
	mov	rdx, QWORD PTR tv205[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	QWORD PTR tv215[rsp], rax
	mov	rax, QWORD PTR result$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR tv213[rsp], rax
	mov	rdx, QWORD PTR tv215[rsp]
	mov	rcx, QWORD PTR tv213[rsp]
	call	?NavScrollToBringItemIntoView@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; NavScrollToBringItemIntoView
	npad	1
$LN10@NavUpdateM:
$LN9@NavUpdateM:

; 7001 : 	}
; 7002 : 
; 7003 : 	ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID

; 7004 : 	g.NavWindow = result->Window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+7024], rcx

; 7005 : 	if (g.NavId != result->ID)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax+7040], ecx
	je	SHORT $LN11@NavUpdateM

; 7006 : 	{
; 7007 : 		// Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
; 7008 : 		g.NavJustMovedToId = result->ID;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+7064], ecx

; 7009 : 		g.NavJustMovedToSelectScopeId = result->SelectScopeId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rax+7068], ecx
$LN11@NavUpdateM:

; 7010 : 	}
; 7011 : 	SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);

	mov	rax, QWORD PTR result$[rsp]
	add	rax, 28
	mov	r8, rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+7132]
	mov	rax, QWORD PTR result$[rsp]
	mov	ecx, DWORD PTR [rax]
	call	?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z ; ImGui::SetNavIDWithRectRel

; 7012 : 	g.NavMoveFromClampedRefRect = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7170], 0
$LN1@NavUpdateM:

; 7013 : }

	add	rsp, 200				; 000000c8H
	ret	0
?NavUpdateMoveResult@ImGui@@YAXXZ ENDP			; ImGui::NavUpdateMoveResult
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 48
start_windowing_with_keyboard$ = 56
apply_toggle_layer$ = 57
tv166 = 58
start_windowing_with_gamepad$ = 59
apply_focus_window$ = 64
new_nav_window$1 = 72
tv92 = 80
tv141 = 84
tv170 = 88
focus_change_dir$2 = 92
tv215 = 96
tv257 = 100
tv399 = 104
move_delta$3 = 112
tv247 = 120
tv245 = 124
tv278 = 128
tv319 = 132
move_speed$4 = 136
tv193 = 140
tv191 = 144
tv197 = 148
tv217 = 152
window$5 = 160
tv157 = 168
NAV_MOVE_SPEED$6 = 176
modal_window$ = 184
tv344 = 192
tv342 = 200
old_nav_window$7 = 208
$T8 = 216
$T9 = 224
$T10 = 232
?NavUpdateWindowing@ImGui@@YAXXZ PROC			; ImGui::NavUpdateWindowing

; 7095 : {

	sub	rsp, 248				; 000000f8H

; 7096 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7097 : 	ImGuiWindow* apply_focus_window = NULL;

	mov	QWORD PTR apply_focus_window$[rsp], 0

; 7098 : 	bool apply_toggle_layer = false;

	mov	BYTE PTR apply_toggle_layer$[rsp], 0

; 7099 : 
; 7100 : 	ImGuiWindow* modal_window = GetFrontMostPopupModal();

	call	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
	mov	QWORD PTR modal_window$[rsp], rax

; 7101 : 	if (modal_window != NULL)

	cmp	QWORD PTR modal_window$[rsp], 0
	je	SHORT $LN4@NavUpdateW

; 7102 : 	{
; 7103 : 		g.NavWindowingTarget = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+7104], 0

; 7104 : 		return;

	jmp	$LN1@NavUpdateW
$LN4@NavUpdateW:

; 7105 : 	}
; 7106 : 
; 7107 : 	// Fade out
; 7108 : 	if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7112], 0
	je	SHORT $LN5@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	SHORT $LN5@NavUpdateW

; 7109 : 	{
; 7110 : 		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+7096]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	xorps	xmm1, xmm1
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7096], xmm0

; 7111 : 		if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+7592]
	jb	SHORT $LN6@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+7096]
	jb	SHORT $LN6@NavUpdateW

; 7112 : 			g.NavWindowingTargetAnim = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+7112], 0
$LN6@NavUpdateW:
$LN5@NavUpdateW:

; 7113 : 	}
; 7114 : 
; 7115 : 	// Start CTRL-TAB or Square+L/R window selection
; 7116 : 	bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	SHORT $LN35@NavUpdateW
	mov	edx, 1
	mov	ecx, 3
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN35@NavUpdateW
	mov	DWORD PTR tv92[rsp], 1
	jmp	SHORT $LN36@NavUpdateW
$LN35@NavUpdateW:
	mov	DWORD PTR tv92[rsp], 0
$LN36@NavUpdateW:
	movzx	eax, BYTE PTR tv92[rsp]
	mov	BYTE PTR start_windowing_with_gamepad$[rsp], al

; 7117 : 	bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	SHORT $LN37@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	je	SHORT $LN37@NavUpdateW
	mov	dl, 1
	xor	ecx, ecx
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN37@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN37@NavUpdateW
	mov	DWORD PTR tv141[rsp], 1
	jmp	SHORT $LN38@NavUpdateW
$LN37@NavUpdateW:
	mov	DWORD PTR tv141[rsp], 0
$LN38@NavUpdateW:
	movzx	eax, BYTE PTR tv141[rsp]
	mov	BYTE PTR start_windowing_with_keyboard$[rsp], al

; 7118 : 	if (start_windowing_with_gamepad || start_windowing_with_keyboard)

	movzx	eax, BYTE PTR start_windowing_with_gamepad$[rsp]
	test	eax, eax
	jne	SHORT $LN8@NavUpdateW
	movzx	eax, BYTE PTR start_windowing_with_keyboard$[rsp]
	test	eax, eax
	je	$LN7@NavUpdateW
$LN8@NavUpdateW:

; 7119 : 		if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN39@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR tv157[rsp], rax
	jmp	SHORT $LN40@NavUpdateW
$LN39@NavUpdateW:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	dec	eax
	mov	r8d, -1
	mov	edx, -2147483647			; ffffffff80000001H
	mov	ecx, eax
	call	?FindWindowNavFocusable@@YAPEAUImGuiWindow@@HHH@Z ; FindWindowNavFocusable
	mov	QWORD PTR tv157[rsp], rax
$LN40@NavUpdateW:
	mov	rax, QWORD PTR tv157[rsp]
	mov	QWORD PTR window$5[rsp], rax
	cmp	QWORD PTR window$5[rsp], 0
	je	$LN9@NavUpdateW

; 7120 : 		{
; 7121 : 			g.NavWindowingTarget = g.NavWindowingTargetAnim = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$5[rsp]
	mov	QWORD PTR [rax+7112], rcx
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$5[rsp]
	mov	QWORD PTR [rax+7104], rcx

; 7122 : 			g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+7096], xmm0
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+7092], xmm0

; 7123 : 			g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;

	movzx	eax, BYTE PTR start_windowing_with_keyboard$[rsp]
	test	eax, eax
	je	SHORT $LN41@NavUpdateW
	mov	BYTE PTR tv166[rsp], 0
	jmp	SHORT $LN42@NavUpdateW
$LN41@NavUpdateW:
	mov	BYTE PTR tv166[rsp], 1
$LN42@NavUpdateW:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv166[rsp]
	mov	BYTE PTR [rax+7128], cl

; 7124 : 			g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;

	movzx	eax, BYTE PTR start_windowing_with_keyboard$[rsp]
	test	eax, eax
	je	SHORT $LN43@NavUpdateW
	mov	DWORD PTR tv170[rsp], 3
	jmp	SHORT $LN44@NavUpdateW
$LN43@NavUpdateW:
	mov	DWORD PTR tv170[rsp], 4
$LN44@NavUpdateW:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv170[rsp]
	mov	DWORD PTR [rax+7060], ecx
$LN9@NavUpdateW:
$LN7@NavUpdateW:

; 7125 : 		}
; 7126 : 
; 7127 : 	// Gamepad update
; 7128 : 	g.NavWindowingTimer += g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7092]
	addss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7092], xmm0

; 7129 : 	if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	$LN10@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 4
	jne	$LN10@NavUpdateW

; 7130 : 	{
; 7131 : 		// Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
; 7132 : 		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7092]
	subss	xmm0, DWORD PTR __real@3e4ccccd
	divss	xmm0, DWORD PTR __real@3d4ccccd
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR tv193[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7096]
	movss	DWORD PTR tv191[rsp], xmm0
	movss	xmm1, DWORD PTR tv193[rsp]
	movss	xmm0, DWORD PTR tv191[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7096], xmm0

; 7133 : 
; 7134 : 		// Select window to focus
; 7135 : 		const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);

	mov	edx, 4
	mov	ecx, 12
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	mov	DWORD PTR tv197[rsp], eax
	mov	edx, 4
	mov	ecx, 13
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	mov	ecx, DWORD PTR tv197[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR focus_change_dir$2[rsp], eax

; 7136 : 		if (focus_change_dir != 0)

	cmp	DWORD PTR focus_change_dir$2[rsp], 0
	je	SHORT $LN11@NavUpdateW

; 7137 : 		{
; 7138 : 			NavUpdateWindowingHighlightWindow(focus_change_dir);

	mov	ecx, DWORD PTR focus_change_dir$2[rsp]
	call	?NavUpdateWindowingHighlightWindow@@YAXH@Z ; NavUpdateWindowingHighlightWindow

; 7139 : 			g.NavWindowingHighlightAlpha = 1.0f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+7096], xmm0
$LN11@NavUpdateW:

; 7140 : 		}
; 7141 : 
; 7142 : 		// Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
; 7143 : 		if (!IsNavInputDown(ImGuiNavInput_Menu))

	mov	ecx, 3
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	jne	$LN12@NavUpdateW

; 7144 : 		{
; 7145 : 			g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7128]
	mov	DWORD PTR tv217[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [rax+7096]
	jbe	SHORT $LN45@NavUpdateW
	mov	DWORD PTR tv215[rsp], 1
	jmp	SHORT $LN46@NavUpdateW
$LN45@NavUpdateW:
	mov	DWORD PTR tv215[rsp], 0
$LN46@NavUpdateW:
	mov	eax, DWORD PTR tv215[rsp]
	mov	ecx, DWORD PTR tv217[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	mov	BYTE PTR [rcx+7128], al

; 7146 : 			if (g.NavWindowingToggleLayer && g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7128]
	test	eax, eax
	je	SHORT $LN13@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN13@NavUpdateW

; 7147 : 				apply_toggle_layer = true;

	mov	BYTE PTR apply_toggle_layer$[rsp], 1
	jmp	SHORT $LN14@NavUpdateW
$LN13@NavUpdateW:

; 7148 : 			else if (!g.NavWindowingToggleLayer)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7128]
	test	eax, eax
	jne	SHORT $LN15@NavUpdateW

; 7149 : 				apply_focus_window = g.NavWindowingTarget;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	QWORD PTR apply_focus_window$[rsp], rax
$LN15@NavUpdateW:
$LN14@NavUpdateW:

; 7150 : 			g.NavWindowingTarget = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+7104], 0
$LN12@NavUpdateW:
$LN10@NavUpdateW:

; 7151 : 		}
; 7152 : 	}
; 7153 : 
; 7154 : 	// Keyboard: Focus
; 7155 : 	if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	$LN16@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 3
	jne	$LN16@NavUpdateW

; 7156 : 	{
; 7157 : 		// Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
; 7158 : 		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7092]
	subss	xmm0, DWORD PTR __real@3e4ccccd
	divss	xmm0, DWORD PTR __real@3d4ccccd
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR tv247[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7096]
	movss	DWORD PTR tv245[rsp], xmm0
	movss	xmm1, DWORD PTR tv247[rsp]
	movss	xmm0, DWORD PTR tv245[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7096], xmm0

; 7159 : 		if (IsKeyPressedMap(ImGuiKey_Tab, true))

	mov	dl, 1
	xor	ecx, ecx
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@NavUpdateW

; 7160 : 			NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN47@NavUpdateW
	mov	DWORD PTR tv257[rsp], 1
	jmp	SHORT $LN48@NavUpdateW
$LN47@NavUpdateW:
	mov	DWORD PTR tv257[rsp], -1
$LN48@NavUpdateW:
	mov	ecx, DWORD PTR tv257[rsp]
	call	?NavUpdateWindowingHighlightWindow@@YAXH@Z ; NavUpdateWindowingHighlightWindow
	npad	1
$LN17@NavUpdateW:

; 7161 : 		if (!g.IO.KeyCtrl)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	SHORT $LN18@NavUpdateW

; 7162 : 			apply_focus_window = g.NavWindowingTarget;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	QWORD PTR apply_focus_window$[rsp], rax
$LN18@NavUpdateW:
$LN16@NavUpdateW:

; 7163 : 	}
; 7164 : 
; 7165 : 	// Keyboard: Press and Release ALT to toggle menu layer
; 7166 : 	// FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
; 7167 : 	if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN20@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6753]
	test	eax, eax
	je	SHORT $LN19@NavUpdateW
$LN20@NavUpdateW:
	mov	edx, 2
	mov	ecx, 16
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@NavUpdateW

; 7168 : 		if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	mov	DWORD PTR tv278[rsp], eax
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 1028				; 00000404H
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	mov	ecx, DWORD PTR tv278[rsp]
	cmp	ecx, eax
	jne	SHORT $LN21@NavUpdateW

; 7169 : 			apply_toggle_layer = true;

	mov	BYTE PTR apply_toggle_layer$[rsp], 1
$LN21@NavUpdateW:
$LN19@NavUpdateW:

; 7170 : 
; 7171 : 	// Move window
; 7172 : 	if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	$LN22@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 4
	test	eax, eax
	jne	$LN22@NavUpdateW

; 7173 : 	{
; 7174 : 		ImVec2 move_delta;

	lea	rcx, QWORD PTR move_delta$3[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 7175 : 		if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 3
	jne	SHORT $LN23@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	jne	SHORT $LN23@NavUpdateW

; 7176 : 			move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xor	r8d, r8d
	mov	edx, 1
	lea	rcx, QWORD PTR $T8[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR move_delta$3[rsp], rax
$LN23@NavUpdateW:

; 7177 : 		if (g.NavInputSource == ImGuiInputSource_NavGamepad)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 4
	jne	SHORT $LN24@NavUpdateW

; 7178 : 			move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xor	r8d, r8d
	mov	edx, 4
	lea	rcx, QWORD PTR $T9[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR move_delta$3[rsp], rax
$LN24@NavUpdateW:

; 7179 : 		if (move_delta.x != 0.0f || move_delta.y != 0.0f)

	movss	xmm0, DWORD PTR move_delta$3[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN26@NavUpdateW
	jne	SHORT $LN26@NavUpdateW
	movss	xmm0, DWORD PTR move_delta$3[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN51@NavUpdateW
	je	$LN25@NavUpdateW
$LN51@NavUpdateW:
$LN26@NavUpdateW:

; 7180 : 		{
; 7181 : 			const float NAV_MOVE_SPEED = 800.0f;

	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR NAV_MOVE_SPEED$6[rsp], xmm0

; 7182 : 			const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@44480000
	mulss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv319[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+192]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+188]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	xmm1, DWORD PTR tv319[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR move_speed$4[rsp], xmm0

; 7183 : 			g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;

	movss	xmm2, DWORD PTR move_speed$4[rsp]
	lea	rdx, QWORD PTR move_delta$3[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv344[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	rax, QWORD PTR [rax+688]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv342[rsp], rax
	mov	rdx, QWORD PTR tv344[rsp]
	mov	rcx, QWORD PTR tv342[rsp]
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1

; 7184 : 			g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1
$LN25@NavUpdateW:
$LN22@NavUpdateW:

; 7185 : 			//MarkIniSettingsDirty(g.NavWindowingTarget);
; 7186 : 		}
; 7187 : 	}
; 7188 : 
; 7189 : 	// Apply final focus
; 7190 : 	if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))

	cmp	QWORD PTR apply_focus_window$[rsp], 0
	je	$LN27@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN28@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR apply_focus_window$[rsp], rax
	je	SHORT $LN27@NavUpdateW
$LN28@NavUpdateW:

; 7191 : 	{
; 7192 : 		g.NavDisableHighlight = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 0

; 7193 : 		g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1

; 7194 : 		apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);

	mov	rcx, QWORD PTR apply_focus_window$[rsp]
	call	?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z ; ImGui::NavRestoreLastChildNavWindow
	mov	QWORD PTR apply_focus_window$[rsp], rax

; 7195 : 		ClosePopupsOverWindow(apply_focus_window);

	mov	rcx, QWORD PTR apply_focus_window$[rsp]
	call	?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::ClosePopupsOverWindow

; 7196 : 		FocusWindow(apply_focus_window);

	mov	rcx, QWORD PTR apply_focus_window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1

; 7197 : 		if (apply_focus_window->NavLastIds[0] == 0)

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR apply_focus_window$[rsp]
	cmp	DWORD PTR [rcx+rax+904], 0
	jne	SHORT $LN29@NavUpdateW

; 7198 : 			NavInitWindow(apply_focus_window, false);

	xor	edx, edx
	mov	rcx, QWORD PTR apply_focus_window$[rsp]
	call	?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z ; ImGui::NavInitWindow
	npad	1
$LN29@NavUpdateW:

; 7199 : 
; 7200 : 		// If the window only has a menu layer, select it directly
; 7201 : 		if (apply_focus_window->DC.NavLayerActiveMask == (1 << ImGuiNavLayer_Menu))

	mov	rax, QWORD PTR apply_focus_window$[rsp]
	cmp	DWORD PTR [rax+420], 2
	jne	SHORT $LN30@NavUpdateW

; 7202 : 			g.NavLayer = ImGuiNavLayer_Menu;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7132], 1
$LN30@NavUpdateW:
$LN27@NavUpdateW:

; 7203 : 	}
; 7204 : 	if (apply_focus_window)

	cmp	QWORD PTR apply_focus_window$[rsp], 0
	je	SHORT $LN31@NavUpdateW

; 7205 : 		g.NavWindowingTarget = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+7104], 0
$LN31@NavUpdateW:

; 7206 : 
; 7207 : 	// Apply menu/layer toggle
; 7208 : 	if (apply_toggle_layer && g.NavWindow)

	movzx	eax, BYTE PTR apply_toggle_layer$[rsp]
	test	eax, eax
	je	$LN32@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN32@NavUpdateW

; 7209 : 	{
; 7210 : 		// Move to parent menu if necessary
; 7211 : 		ImGuiWindow* new_nav_window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR new_nav_window$1[rsp], rax
$LN2@NavUpdateW:

; 7212 : 		while ((new_nav_window->DC.NavLayerActiveMask & (1 << 1)) == 0
; 7213 : 			&& (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
; 7214 : 			&& (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)

	mov	rax, QWORD PTR new_nav_window$1[rsp]
	mov	eax, DWORD PTR [rax+420]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN3@NavUpdateW
	mov	rax, QWORD PTR new_nav_window$1[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN3@NavUpdateW
	mov	rax, QWORD PTR new_nav_window$1[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 335544320				; 14000000H
	test	eax, eax
	jne	SHORT $LN3@NavUpdateW

; 7215 : 			new_nav_window = new_nav_window->ParentWindow;

	mov	rax, QWORD PTR new_nav_window$1[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR new_nav_window$1[rsp], rax
	jmp	SHORT $LN2@NavUpdateW
$LN3@NavUpdateW:

; 7216 : 		if (new_nav_window != g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	cmp	QWORD PTR new_nav_window$1[rsp], rax
	je	SHORT $LN33@NavUpdateW

; 7217 : 		{
; 7218 : 			ImGuiWindow* old_nav_window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR old_nav_window$7[rsp], rax

; 7219 : 			FocusWindow(new_nav_window);

	mov	rcx, QWORD PTR new_nav_window$1[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 7220 : 			new_nav_window->NavLastChildNavWindow = old_nav_window;

	mov	rax, QWORD PTR new_nav_window$1[rsp]
	mov	rcx, QWORD PTR old_nav_window$7[rsp]
	mov	QWORD PTR [rax+896], rcx
$LN33@NavUpdateW:

; 7221 : 		}
; 7222 : 		g.NavDisableHighlight = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 0

; 7223 : 		g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1

; 7224 : 		NavRestoreLayer((g.NavWindow->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+420]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN49@NavUpdateW
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7132]
	xor	eax, 1
	mov	DWORD PTR tv399[rsp], eax
	jmp	SHORT $LN50@NavUpdateW
$LN49@NavUpdateW:
	mov	DWORD PTR tv399[rsp], 0
$LN50@NavUpdateW:
	mov	ecx, DWORD PTR tv399[rsp]
	call	?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z ; NavRestoreLayer
	npad	1
$LN32@NavUpdateW:
$LN1@NavUpdateW:

; 7225 : 	}
; 7226 : }

	add	rsp, 248				; 000000f8H
	ret	0
?NavUpdateWindowing@ImGui@@YAXXZ ENDP			; ImGui::NavUpdateWindowing
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 48
nav_keyboard_active$ = 56
nav_gamepad_active$ = 57
activate_down$1 = 58
activate_pressed$2 = 59
i$3 = 60
allowed_dir_flags$ = 64
window$4 = 72
scroll_speed$5 = 80
window$6 = 88
tv70 = 96
tv80 = 100
tv288 = 104
tv289 = 108
tv400 = 112
tv415 = 116
tv511 = 120
tv573 = 124
tv681 = 128
tv696 = 132
pad$7 = 136
nav_scoring_rect_offset_y$ = 140
scroll_dir$8 = 144
tv823 = 152
tv821 = 156
tv861 = 160
tv920 = 168
window_rect_rel$9 = 176
child_window$10 = 192
tv765 = 200
tv763 = 208
tv785 = 216
tv783 = 224
tv790 = 232
tv788 = 240
tv833 = 248
$T11 = 256
tv916 = 264
tv914 = 272
$T12 = 280
tv926 = 288
parent_window$13 = 296
nav_rect_rel$ = 304
$T14 = 320
$T15 = 328
$T16 = 336
$T17 = 344
$T18 = 352
$T19 = 360
$T20 = 368
$T21 = 376
$T22 = 384
$T23 = 392
$T24 = 400
$T25 = 416
$T26 = 432
$T27 = 448
?NavUpdate@ImGui@@YAXXZ PROC				; ImGui::NavUpdate

; 6690 : {

	push	rsi
	push	rdi
	sub	rsp, 472				; 000001d8H

; 6691 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6692 : 	g.IO.WantSetMousePos = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+936], 0

; 6693 : #if 0
; 6694 : 	if (g.NavScoringCount > 0) IMGUI_DEBUG_LOG("NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
; 6695 : #endif
; 6696 : 
; 6697 : 	// Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)
; 6698 : 	bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN78@NavUpdate
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN79@NavUpdate
$LN78@NavUpdate:
	mov	DWORD PTR tv70[rsp], 0
$LN79@NavUpdate:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR nav_keyboard_active$[rsp], al

; 6699 : 	bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN80@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN80@NavUpdate
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN81@NavUpdate
$LN80@NavUpdate:
	mov	DWORD PTR tv80[rsp], 0
$LN81@NavUpdate:
	movzx	eax, BYTE PTR tv80[rsp]
	mov	BYTE PTR nav_gamepad_active$[rsp], al

; 6700 : 	if (nav_gamepad_active)

	movzx	eax, BYTE PTR nav_gamepad_active$[rsp]
	test	eax, eax
	je	$LN5@NavUpdate

; 6701 : 		if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+848]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN7@NavUpdate
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+848]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN7@NavUpdate
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+848]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN7@NavUpdate
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+848]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@NavUpdate
$LN7@NavUpdate:

; 6702 : 			g.NavInputSource = ImGuiInputSource_NavGamepad;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 4
$LN6@NavUpdate:
$LN5@NavUpdate:

; 6703 : 
; 6704 : 	// Update Keyboard->Nav inputs mapping
; 6705 : 	if (nav_keyboard_active)

	movzx	eax, BYTE PTR nav_keyboard_active$[rsp]
	test	eax, eax
	je	$LN8@NavUpdate

; 6706 : 	{
; 6707 : #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }
; 6708 : 		NAV_MAP_KEY(ImGuiKey_Space, ImGuiNavInput_Activate);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@NavUpdate
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN9@NavUpdate:

; 6709 : 		NAV_MAP_KEY(ImGuiKey_Enter, ImGuiNavInput_Input);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@NavUpdate
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN10@NavUpdate:

; 6710 : 		NAV_MAP_KEY(ImGuiKey_Escape, ImGuiNavInput_Cancel);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@NavUpdate
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN11@NavUpdate:

; 6711 : 		NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@NavUpdate
	mov	eax, 4
	imul	rax, rax, 17
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN12@NavUpdate:

; 6712 : 		NAV_MAP_KEY(ImGuiKey_RightArrow, ImGuiNavInput_KeyRight_);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@NavUpdate
	mov	eax, 4
	imul	rax, rax, 18
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN13@NavUpdate:

; 6713 : 		NAV_MAP_KEY(ImGuiKey_UpArrow, ImGuiNavInput_KeyUp_);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@NavUpdate
	mov	eax, 4
	imul	rax, rax, 19
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN14@NavUpdate:

; 6714 : 		NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+60]
	call	?IsKeyDown@ImGui@@YA_NH@Z		; ImGui::IsKeyDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@NavUpdate
	mov	eax, 4
	imul	rax, rax, 20
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7060], 3
$LN15@NavUpdate:

; 6715 : 		if (g.IO.KeyCtrl)   g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	je	SHORT $LN16@NavUpdate
	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
$LN16@NavUpdate:

; 6716 : 		if (g.IO.KeyShift)  g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN17@NavUpdate
	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
$LN17@NavUpdate:

; 6717 : 		if (g.IO.KeyAlt)    g.IO.NavInputs[ImGuiNavInput_KeyMenu_] = 1.0f;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN18@NavUpdate
	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax+848], xmm0
$LN18@NavUpdate:
$LN8@NavUpdate:

; 6718 : #undef NAV_MAP_KEY
; 6719 : 	}
; 6720 : 	memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 3220				; 00000c94H
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 5372				; 000014fcH
	mov	r8d, 84					; 00000054H
	mov	rdx, rax
	call	memcpy
	npad	1

; 6721 : 	for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN4@NavUpdate
$LN2@NavUpdate:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN4@NavUpdate:
	cmp	DWORD PTR i$3[rsp], 21
	jge	$LN3@NavUpdate

; 6722 : 		g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+848]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN84@NavUpdate
	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rcx+rax*4+3220]
	jbe	SHORT $LN82@NavUpdate
	xorps	xmm0, xmm0
	movss	DWORD PTR tv288[rsp], xmm0
	jmp	SHORT $LN83@NavUpdate
$LN82@NavUpdate:
	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+3220]
	addss	xmm0, DWORD PTR [rdx+48]
	movss	DWORD PTR tv288[rsp], xmm0
$LN83@NavUpdate:
	movss	xmm0, DWORD PTR tv288[rsp]
	movss	DWORD PTR tv289[rsp], xmm0
	jmp	SHORT $LN85@NavUpdate
$LN84@NavUpdate:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv289[rsp], xmm0
$LN85@NavUpdate:
	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv289[rsp]
	movss	DWORD PTR [rcx+rax*4+3220], xmm0
	jmp	$LN2@NavUpdate
$LN3@NavUpdate:

; 6723 : 
; 6724 : 	// Process navigation init request (select first/default focus)
; 6725 : 	if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7148], 0
	je	$LN19@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	je	SHORT $LN20@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7169]
	test	eax, eax
	je	$LN19@NavUpdate
$LN20@NavUpdate:

; 6726 : 	{
; 6727 : 		// Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
; 6728 : 		IM_ASSERT(g.NavWindow);
; 6729 : 		if (g.NavInitRequestFromMove)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7169]
	test	eax, eax
	je	SHORT $LN21@NavUpdate

; 6730 : 			SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7152				; 00001bf0H
	mov	r8, rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+7132]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7148]
	call	?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z ; ImGui::SetNavIDWithRectRel
	npad	1
	jmp	SHORT $LN22@NavUpdate
$LN21@NavUpdate:

; 6731 : 		else
; 6732 : 			SetNavID(g.NavInitResultId, g.NavLayer);

	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+7132]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7148]
	call	?SetNavID@ImGui@@YAXIH@Z		; ImGui::SetNavID
	npad	1
$LN22@NavUpdate:

; 6733 : 		if (g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN23@NavUpdate

; 6734 : 			g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	movsxd	rcx, DWORD PTR [rcx+7132]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rax+rcx+912]
	lea	rsi, QWORD PTR [rdx+7152]
	mov	ecx, 16
	rep movsb
$LN23@NavUpdate:
$LN19@NavUpdate:

; 6735 : 	}
; 6736 : 	g.NavInitRequest = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 0

; 6737 : 	g.NavInitRequestFromMove = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7169], 0

; 6738 : 	g.NavInitResultId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7148], 0

; 6739 : 	g.NavJustMovedToId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7064], 0

; 6740 : 
; 6741 : 	// Process navigation move request
; 6742 : 	if (g.NavMoveRequest)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN24@NavUpdate

; 6743 : 		NavUpdateMoveResult();

	call	?NavUpdateMoveResult@ImGui@@YAXXZ	; ImGui::NavUpdateMoveResult
	npad	1
$LN24@NavUpdate:

; 6744 : 
; 6745 : 	// When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
; 6746 : 	if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7272], 2
	jne	SHORT $LN25@NavUpdate

; 6747 : 	{
; 6748 : 		IM_ASSERT(g.NavMoveRequest);
; 6749 : 		if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7176], 0
	jne	SHORT $LN26@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7288], 0
	jne	SHORT $LN26@NavUpdate

; 6750 : 			g.NavDisableHighlight = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 0
$LN26@NavUpdate:

; 6751 : 		g.NavMoveRequestForward = ImGuiNavForward_None;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7272], 0
$LN25@NavUpdate:

; 6752 : 	}
; 6753 : 
; 6754 : 	// Apply application mouse position movement, after we had a chance to process move request result.
; 6755 : 	if (g.NavMousePosDirty && g.NavIdIsAlive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7142]
	test	eax, eax
	je	$LN27@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7141]
	test	eax, eax
	je	$LN27@NavUpdate

; 6756 : 	{
; 6757 : 		// Set mouse position given our knowledge of the navigated item position from last frame
; 6758 : 		if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN28@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN28@NavUpdate

; 6759 : 		{
; 6760 : 			if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN29@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	SHORT $LN29@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN29@NavUpdate

; 6761 : 			{
; 6762 : 				g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();

	lea	rcx, QWORD PTR $T23[rsp]
	call	?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::NavCalcPreferredRefPos
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+1028], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+1028]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+316], rax

; 6763 : 				g.IO.WantSetMousePos = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+936], 1
$LN29@NavUpdate:
$LN28@NavUpdate:

; 6764 : 			}
; 6765 : 		}
; 6766 : 		g.NavMousePosDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7142], 0
$LN27@NavUpdate:

; 6767 : 	}
; 6768 : 	g.NavIdIsAlive = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7141], 0

; 6769 : 	g.NavJustTabbedId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7052], 0

; 6770 : 	IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);
; 6771 : 
; 6772 : 	// Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
; 6773 : 	if (g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN30@NavUpdate

; 6774 : 		NavSaveLastChildNavWindow(g.NavWindow);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7024]
	call	?NavSaveLastChildNavWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::NavSaveLastChildNavWindow
	npad	1
$LN30@NavUpdate:

; 6775 : 	if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN31@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	cmp	QWORD PTR [rax+896], 0
	je	SHORT $LN31@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	jne	SHORT $LN31@NavUpdate

; 6776 : 		g.NavWindow->NavLastChildNavWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR [rax+896], 0
$LN31@NavUpdate:

; 6777 : 
; 6778 : 	// Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
; 6779 : 	NavUpdateWindowing();

	call	?NavUpdateWindowing@ImGui@@YAXXZ	; ImGui::NavUpdateWindowing

; 6780 : 
; 6781 : 	// Set output flags for user application
; 6782 : 	g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);

	movzx	eax, BYTE PTR nav_keyboard_active$[rsp]
	test	eax, eax
	jne	SHORT $LN86@NavUpdate
	movzx	eax, BYTE PTR nav_gamepad_active$[rsp]
	test	eax, eax
	je	SHORT $LN87@NavUpdate
$LN86@NavUpdate:
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN87@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	SHORT $LN87@NavUpdate
	mov	DWORD PTR tv400[rsp], 1
	jmp	SHORT $LN88@NavUpdate
$LN87@NavUpdate:
	mov	DWORD PTR tv400[rsp], 0
$LN88@NavUpdate:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv400[rsp]
	mov	BYTE PTR [rax+944], cl

; 6783 : 	g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+944]
	test	eax, eax
	je	SHORT $LN89@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	je	SHORT $LN89@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	je	SHORT $LN90@NavUpdate
$LN89@NavUpdate:
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	SHORT $LN90@NavUpdate
	mov	DWORD PTR tv415[rsp], 0
	jmp	SHORT $LN91@NavUpdate
$LN90@NavUpdate:
	mov	DWORD PTR tv415[rsp], 1
$LN91@NavUpdate:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv415[rsp]
	mov	BYTE PTR [rax+935], cl

; 6784 : 
; 6785 : 	// Process NavCancel input (to close a popup, get back to parent, clear focus)
; 6786 : 	if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))

	mov	edx, 1
	mov	ecx, 1
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	test	eax, eax
	je	$LN32@NavUpdate

; 6787 : 	{
; 6788 : 		if (g.ActiveId != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN33@NavUpdate

; 6789 : 		{
; 6790 : 			if (!(g.ActiveIdBlockNavInputFlags & (1 << ImGuiNavInput_Cancel)))

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6808]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN35@NavUpdate

; 6791 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN35@NavUpdate:

; 6792 : 		}

	jmp	$LN34@NavUpdate
$LN33@NavUpdate:

; 6793 : 		else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN36@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	$LN36@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	$LN36@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	cmp	QWORD PTR [rax+880], 0
	je	SHORT $LN36@NavUpdate

; 6794 : 		{
; 6795 : 			// Exit child window
; 6796 : 			ImGuiWindow* child_window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR child_window$10[rsp], rax

; 6797 : 			ImGuiWindow* parent_window = g.NavWindow->ParentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR parent_window$13[rsp], rax

; 6798 : 			IM_ASSERT(child_window->ChildId != 0);
; 6799 : 			FocusWindow(parent_window);

	mov	rcx, QWORD PTR parent_window$13[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 6800 : 			SetNavID(child_window->ChildId, 0);

	xor	edx, edx
	mov	rax, QWORD PTR child_window$10[rsp]
	mov	ecx, DWORD PTR [rax+60]
	call	?SetNavID@ImGui@@YAXIH@Z		; ImGui::SetNavID

; 6801 : 			g.NavIdIsAlive = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7141], 0

; 6802 : 			if (g.NavDisableMouseHover)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	SHORT $LN38@NavUpdate

; 6803 : 				g.NavMousePosDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7142], 1
$LN38@NavUpdate:

; 6804 : 		}

	jmp	$LN37@NavUpdate
$LN36@NavUpdate:

; 6805 : 		else if (g.OpenPopupStack.Size > 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6872], 0
	jle	SHORT $LN39@NavUpdate

; 6806 : 		{
; 6807 : 			// Close open popup/menu
; 6808 : 			if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@XZ ; ImVector<ImGuiPopupRef>::back
	mov	rax, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $LN41@NavUpdate

; 6809 : 				ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	dec	eax
	mov	dl, 1
	mov	ecx, eax
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
	npad	1
$LN41@NavUpdate:

; 6810 : 		}

	jmp	$LN40@NavUpdate
$LN39@NavUpdate:

; 6811 : 		else if (g.NavLayer != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	je	SHORT $LN42@NavUpdate

; 6812 : 		{
; 6813 : 			// Leave the "menu" layer
; 6814 : 			NavRestoreLayer(ImGuiNavLayer_Main);

	xor	ecx, ecx
	call	?NavRestoreLayer@@YAXW4ImGuiNavLayer@@@Z ; NavRestoreLayer
	npad	1

; 6815 : 		}

	jmp	SHORT $LN43@NavUpdate
$LN42@NavUpdate:

; 6816 : 		else
; 6817 : 		{
; 6818 : 			// Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
; 6819 : 			if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN44@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $LN45@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN44@NavUpdate
$LN45@NavUpdate:

; 6820 : 				g.NavWindow->NavLastIds[0] = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	DWORD PTR [rax+rcx+904], 0
$LN44@NavUpdate:

; 6821 : 			g.NavId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7040], 0
$LN43@NavUpdate:
$LN40@NavUpdate:
$LN37@NavUpdate:
$LN34@NavUpdate:
$LN32@NavUpdate:

; 6822 : 		}
; 6823 : 	}
; 6824 : 
; 6825 : 	// Process manual activation request
; 6826 : 	g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7048], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7036], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7032], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7044], 0

; 6827 : 	if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	je	$LN46@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	$LN46@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	$LN46@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN46@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	$LN46@NavUpdate

; 6828 : 	{
; 6829 : 		bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);

	xor	ecx, ecx
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	mov	BYTE PTR activate_down$1[rsp], al

; 6830 : 		bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);

	movzx	eax, BYTE PTR activate_down$1[rsp]
	test	eax, eax
	je	SHORT $LN92@NavUpdate
	mov	edx, 1
	xor	ecx, ecx
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN92@NavUpdate
	mov	DWORD PTR tv511[rsp], 1
	jmp	SHORT $LN93@NavUpdate
$LN92@NavUpdate:
	mov	DWORD PTR tv511[rsp], 0
$LN93@NavUpdate:
	movzx	eax, BYTE PTR tv511[rsp]
	mov	BYTE PTR activate_pressed$2[rsp], al

; 6831 : 		if (g.ActiveId == 0 && activate_pressed)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	SHORT $LN47@NavUpdate
	movzx	eax, BYTE PTR activate_pressed$2[rsp]
	test	eax, eax
	je	SHORT $LN47@NavUpdate

; 6832 : 			g.NavActivateId = g.NavId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	mov	DWORD PTR [rax+7044], ecx
$LN47@NavUpdate:

; 6833 : 		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN49@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN48@NavUpdate
$LN49@NavUpdate:
	movzx	eax, BYTE PTR activate_down$1[rsp]
	test	eax, eax
	je	SHORT $LN48@NavUpdate

; 6834 : 			g.NavActivateDownId = g.NavId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	mov	DWORD PTR [rax+7032], ecx
$LN48@NavUpdate:

; 6835 : 		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN51@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN50@NavUpdate
$LN51@NavUpdate:
	movzx	eax, BYTE PTR activate_pressed$2[rsp]
	test	eax, eax
	je	SHORT $LN50@NavUpdate

; 6836 : 			g.NavActivatePressedId = g.NavId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	mov	DWORD PTR [rax+7036], ecx
$LN50@NavUpdate:

; 6837 : 		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN53@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN52@NavUpdate
$LN53@NavUpdate:
	mov	edx, 1
	mov	ecx, 2
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN52@NavUpdate

; 6838 : 			g.NavInputId = g.NavId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7040]
	mov	DWORD PTR [rax+7048], ecx
$LN52@NavUpdate:
$LN46@NavUpdate:

; 6839 : 	}
; 6840 : 	if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN54@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN54@NavUpdate

; 6841 : 		g.NavDisableHighlight = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1
$LN54@NavUpdate:

; 6842 : 	if (g.NavActivateId != 0)

	mov	rax, QWORD PTR g$[rsp]

; 6843 : 		IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
; 6844 : 	g.NavMoveRequest = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7171], 0

; 6845 : 
; 6846 : 	// Process programmatic activation request
; 6847 : 	if (g.NavNextActivateId != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7056], 0
	je	SHORT $LN56@NavUpdate

; 6848 : 		g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7056]
	mov	DWORD PTR [rax+7048], ecx
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7048]
	mov	DWORD PTR [rax+7036], ecx
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7036]
	mov	DWORD PTR [rax+7032], ecx
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7032]
	mov	DWORD PTR [rax+7044], ecx
$LN56@NavUpdate:

; 6849 : 	g.NavNextActivateId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7056], 0

; 6850 : 
; 6851 : 	// Initiate directional inputs request
; 6852 : 	const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	SHORT $LN94@NavUpdate
	mov	DWORD PTR tv573[rsp], -1
	jmp	SHORT $LN95@NavUpdate
$LN94@NavUpdate:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6804]
	mov	DWORD PTR tv573[rsp], eax
$LN95@NavUpdate:
	mov	eax, DWORD PTR tv573[rsp]
	mov	DWORD PTR allowed_dir_flags$[rsp], eax

; 6853 : 	if (g.NavMoveRequestForward == ImGuiNavForward_None)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7272], 0
	jne	$LN57@NavUpdate

; 6854 : 	{
; 6855 : 		g.NavMoveDir = ImGuiDir_None;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], -1

; 6856 : 		g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7172], 0

; 6857 : 		if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN59@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	$LN59@NavUpdate
	cmp	DWORD PTR allowed_dir_flags$[rsp], 0
	je	$LN59@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	$LN59@NavUpdate

; 6858 : 		{
; 6859 : 			if ((allowed_dir_flags & (1 << ImGuiDir_Left)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;

	mov	eax, DWORD PTR allowed_dir_flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN60@NavUpdate
	mov	r8d, 3
	mov	edx, 17
	mov	ecx, 4
	call	?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressedAnyOfTwo
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN60@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], 0
$LN60@NavUpdate:

; 6860 : 			if ((allowed_dir_flags & (1 << ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight, ImGuiNavInput_KeyRight_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;

	mov	eax, DWORD PTR allowed_dir_flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN61@NavUpdate
	mov	r8d, 3
	mov	edx, 18
	mov	ecx, 5
	call	?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressedAnyOfTwo
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN61@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], 1
$LN61@NavUpdate:

; 6861 : 			if ((allowed_dir_flags & (1 << ImGuiDir_Up)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp, ImGuiNavInput_KeyUp_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;

	mov	eax, DWORD PTR allowed_dir_flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN62@NavUpdate
	mov	r8d, 3
	mov	edx, 19
	mov	ecx, 6
	call	?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressedAnyOfTwo
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN62@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], 2
$LN62@NavUpdate:

; 6862 : 			if ((allowed_dir_flags & (1 << ImGuiDir_Down)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;

	mov	eax, DWORD PTR allowed_dir_flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN63@NavUpdate
	mov	r8d, 3
	mov	edx, 20
	mov	ecx, 7
	call	?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressedAnyOfTwo
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN63@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7276], 3
$LN63@NavUpdate:
$LN59@NavUpdate:

; 6863 : 		}
; 6864 : 		g.NavMoveClipDir = g.NavMoveDir;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7276]
	mov	DWORD PTR [rax+7284], ecx

; 6865 : 	}

	jmp	SHORT $LN58@NavUpdate
$LN57@NavUpdate:

; 6866 : 	else
; 6867 : 	{
; 6868 : 		// Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
; 6869 : 		// (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
; 6870 : 		IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
; 6871 : 		IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
; 6872 : 		g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7272], 2
$LN58@NavUpdate:

; 6873 : 	}
; 6874 : 
; 6875 : 	// Update PageUp/PageDown scroll
; 6876 : 	float nav_scoring_rect_offset_y = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR nav_scoring_rect_offset_y$[rsp], xmm0

; 6877 : 	if (nav_keyboard_active)

	movzx	eax, BYTE PTR nav_keyboard_active$[rsp]
	test	eax, eax
	je	SHORT $LN64@NavUpdate

; 6878 : 		nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);

	mov	ecx, DWORD PTR allowed_dir_flags$[rsp]
	call	?NavUpdatePageUpPageDown@ImGui@@YAMH@Z	; ImGui::NavUpdatePageUpPageDown
	movss	DWORD PTR nav_scoring_rect_offset_y$[rsp], xmm0
$LN64@NavUpdate:

; 6879 : 
; 6880 : 	// If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
; 6881 : 	if (g.NavMoveDir != ImGuiDir_None)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], -1
	je	SHORT $LN65@NavUpdate

; 6882 : 	{
; 6883 : 		g.NavMoveRequest = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7171], 1

; 6884 : 		g.NavMoveDirLast = g.NavMoveDir;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7276]
	mov	DWORD PTR [rax+7280], ecx
$LN65@NavUpdate:

; 6885 : 	}
; 6886 : 	if (g.NavMoveRequest && g.NavId == 0)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN66@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	jne	SHORT $LN66@NavUpdate

; 6887 : 	{
; 6888 : 		g.NavInitRequest = g.NavInitRequestFromMove = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7169], 1
	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 1

; 6889 : 		g.NavInitResultId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7148], 0

; 6890 : 		g.NavDisableHighlight = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 0
$LN66@NavUpdate:

; 6891 : 	}
; 6892 : 	NavUpdateAnyRequestFlag();

	call	?NavUpdateAnyRequestFlag@ImGui@@YAXXZ	; ImGui::NavUpdateAnyRequestFlag
	npad	1

; 6893 : 
; 6894 : 	// Scrolling
; 6895 : 	if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN67@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	$LN67@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	jne	$LN67@NavUpdate

; 6896 : 	{
; 6897 : 		// *Fallback* manual-scroll with Nav directional keys when window has no navigable item
; 6898 : 		ImGuiWindow* window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR window$4[rsp], rax

; 6899 : 		const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.

	mov	rcx, QWORD PTR window$4[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR scroll_speed$5[rsp], xmm0

; 6900 : 		if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)

	mov	rax, QWORD PTR window$4[rsp]
	cmp	DWORD PTR [rax+420], 0
	jne	$LN68@NavUpdate
	mov	rax, QWORD PTR window$4[rsp]
	movzx	eax, BYTE PTR [rax+456]
	test	eax, eax
	je	$LN68@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	$LN68@NavUpdate

; 6901 : 		{
; 6902 : 			if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	je	SHORT $LN70@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 1
	jne	SHORT $LN69@NavUpdate
$LN70@NavUpdate:

; 6903 : 				SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	jne	SHORT $LN96@NavUpdate
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv681[rsp], xmm0
	jmp	SHORT $LN97@NavUpdate
$LN96@NavUpdate:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv681[rsp], xmm0
$LN97@NavUpdate:
	movss	xmm0, DWORD PTR tv681[rsp]
	mulss	xmm0, DWORD PTR scroll_speed$5[rsp]
	mov	rax, QWORD PTR window$4[rsp]
	movss	xmm1, DWORD PTR [rax+92]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR window$4[rsp]
	call	?SetWindowScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollX
	npad	1
$LN69@NavUpdate:

; 6904 : 			if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 2
	je	SHORT $LN72@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 3
	jne	SHORT $LN71@NavUpdate
$LN72@NavUpdate:

; 6905 : 				SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 2
	jne	SHORT $LN98@NavUpdate
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv696[rsp], xmm0
	jmp	SHORT $LN99@NavUpdate
$LN98@NavUpdate:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv696[rsp], xmm0
$LN99@NavUpdate:
	movss	xmm0, DWORD PTR tv696[rsp]
	mulss	xmm0, DWORD PTR scroll_speed$5[rsp]
	mov	rax, QWORD PTR window$4[rsp]
	movss	xmm1, DWORD PTR [rax+96]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR window$4[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
	npad	1
$LN71@NavUpdate:
$LN68@NavUpdate:

; 6906 : 		}
; 6907 : 
; 6908 : 		// *Normal* Manual scroll with NavScrollXXX keys
; 6909 : 		// Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
; 6910 : 		ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f / 10.0f, 10.0f);

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	xor	r8d, r8d
	mov	edx, 4
	lea	rcx, QWORD PTR scroll_dir$8[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	npad	1

; 6911 : 		if (scroll_dir.x != 0.0f && window->ScrollbarX)

	movss	xmm0, DWORD PTR scroll_dir$8[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN105@NavUpdate
	je	SHORT $LN73@NavUpdate
$LN105@NavUpdate:
	mov	rax, QWORD PTR window$4[rsp]
	movzx	eax, BYTE PTR [rax+100]
	test	eax, eax
	je	SHORT $LN73@NavUpdate

; 6912 : 		{
; 6913 : 			SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));

	movss	xmm0, DWORD PTR scroll_dir$8[rsp]
	mulss	xmm0, DWORD PTR scroll_speed$5[rsp]
	mov	rax, QWORD PTR window$4[rsp]
	movss	xmm1, DWORD PTR [rax+92]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR window$4[rsp]
	call	?SetWindowScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollX

; 6914 : 			g.NavMoveFromClampedRefRect = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7170], 1
$LN73@NavUpdate:

; 6915 : 		}
; 6916 : 		if (scroll_dir.y != 0.0f)

	movss	xmm0, DWORD PTR scroll_dir$8[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN104@NavUpdate
	je	SHORT $LN74@NavUpdate
$LN104@NavUpdate:

; 6917 : 		{
; 6918 : 			SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));

	movss	xmm0, DWORD PTR scroll_dir$8[rsp+4]
	mulss	xmm0, DWORD PTR scroll_speed$5[rsp]
	mov	rax, QWORD PTR window$4[rsp]
	movss	xmm1, DWORD PTR [rax+96]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR window$4[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY

; 6919 : 			g.NavMoveFromClampedRefRect = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7170], 1
$LN74@NavUpdate:
$LN67@NavUpdate:

; 6920 : 		}
; 6921 : 	}
; 6922 : 
; 6923 : 	// Reset search results
; 6924 : 	g.NavMoveResultLocal.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7176				; 00001c08H
	mov	rcx, rax
	call	?Clear@ImGuiNavMoveResult@@QEAAXXZ	; ImGuiNavMoveResult::Clear

; 6925 : 	g.NavMoveResultLocalVisibleSet.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7224				; 00001c38H
	mov	rcx, rax
	call	?Clear@ImGuiNavMoveResult@@QEAAXXZ	; ImGuiNavMoveResult::Clear

; 6926 : 	g.NavMoveResultOther.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7288				; 00001c78H
	mov	rcx, rax
	call	?Clear@ImGuiNavMoveResult@@QEAAXXZ	; ImGuiNavMoveResult::Clear
	npad	1

; 6927 : 
; 6928 : 	// When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
; 6929 : 	if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	$LN75@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7170]
	test	eax, eax
	je	$LN75@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	jne	$LN75@NavUpdate

; 6930 : 	{
; 6931 : 		ImGuiWindow* window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR window$6[rsp], rax

; 6932 : 		ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1, 1), window->InnerMainRect.Max - window->Pos + ImVec2(1, 1));

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv765[rsp], rax
	mov	rax, QWORD PTR window$6[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$6[rsp]
	add	rcx, 592				; 00000250H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T15[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv763[rsp], rax
	mov	r8, QWORD PTR tv765[rsp]
	mov	rdx, QWORD PTR tv763[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv790[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv785[rsp], rax
	mov	rax, QWORD PTR window$6[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$6[rsp]
	add	rcx, 584				; 00000248H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T18[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv783[rsp], rax
	mov	r8, QWORD PTR tv785[rsp]
	mov	rdx, QWORD PTR tv783[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv788[rsp], rax
	mov	r8, QWORD PTR tv790[rsp]
	mov	rdx, QWORD PTR tv788[rsp]
	lea	rcx, QWORD PTR window_rect_rel$9[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 6933 : 		if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+7132]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR window$6[rsp]
	lea	rax, QWORD PTR [rcx+rax+912]
	mov	rdx, rax
	lea	rcx, QWORD PTR window_rect_rel$9[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	$LN76@NavUpdate

; 6934 : 		{
; 6935 : 			float pad = window->CalcFontSize() * 0.5f;

	mov	rcx, QWORD PTR window$6[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR pad$7[rsp], xmm0

; 6936 : 			window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item

	lea	rcx, QWORD PTR window_rect_rel$9[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	xmm1, DWORD PTR pad$7[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv823[rsp], xmm0
	lea	rcx, QWORD PTR window_rect_rel$9[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	xmm1, DWORD PTR pad$7[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv821[rsp], xmm0
	movss	xmm2, DWORD PTR tv823[rsp]
	movss	xmm1, DWORD PTR tv821[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR window_rect_rel$9[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1

; 6937 : 			window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+7132]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR window$6[rsp]
	lea	rax, QWORD PTR [rcx+rax+912]
	mov	QWORD PTR tv833[rsp], rax
	lea	rdx, QWORD PTR window_rect_rel$9[rsp]
	mov	rcx, QWORD PTR tv833[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith

; 6938 : 			g.NavId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7040], 0
$LN76@NavUpdate:

; 6939 : 		}
; 6940 : 		g.NavMoveFromClampedRefRect = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7170], 0
$LN75@NavUpdate:

; 6941 : 	}
; 6942 : 
; 6943 : 	// For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
; 6944 : 	ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN100@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	movsxd	rcx, DWORD PTR [rcx+7132]
	imul	rcx, rcx, 16
	lea	rax, QWORD PTR [rax+rcx+912]
	mov	rcx, rax
	call	?IsInverted@ImRect@@QEBA_NXZ		; ImRect::IsInverted
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN100@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	movsxd	rcx, DWORD PTR [rcx+7132]
	imul	rcx, rcx, 16
	lea	rdx, QWORD PTR $T24[rsp]
	mov	rdi, rdx
	lea	rsi, QWORD PTR [rax+rcx+912]
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T24[rsp]
	mov	QWORD PTR tv861[rsp], rax
	jmp	SHORT $LN101@NavUpdate
$LN100@NavUpdate:
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	QWORD PTR tv861[rsp], rax
$LN101@NavUpdate:
	mov	rax, QWORD PTR tv861[rsp]
	mov	QWORD PTR $T11[rsp], rax
	lea	rax, QWORD PTR nav_rect_rel$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T11[rsp]
	mov	ecx, 16
	rep movsb

; 6945 : 	g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN102@NavUpdate
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	add	rax, 48					; 00000030H
	lea	r8, QWORD PTR nav_rect_rel$[rsp+8]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T21[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv916[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	add	rax, 48					; 00000030H
	lea	r8, QWORD PTR nav_rect_rel$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T22[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv914[rsp], rax
	mov	r8, QWORD PTR tv916[rsp]
	mov	rdx, QWORD PTR tv914[rsp]
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	QWORD PTR tv920[rsp], rax
	jmp	SHORT $LN103@NavUpdate
$LN102@NavUpdate:
	lea	rcx, QWORD PTR $T27[rsp]
	call	?GetViewportRect@@YA?AUImRect@@XZ	; GetViewportRect
	mov	QWORD PTR tv920[rsp], rax
$LN103@NavUpdate:
	mov	rax, QWORD PTR tv920[rsp]
	mov	QWORD PTR $T12[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rax+7072]
	mov	rsi, QWORD PTR $T12[rsp]
	mov	ecx, 16
	rep movsb

; 6946 : 	g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7072				; 00001ba0H
	mov	QWORD PTR tv926[rsp], rax
	movss	xmm1, DWORD PTR nav_scoring_rect_offset_y$[rsp]
	mov	rcx, QWORD PTR tv926[rsp]
	call	?TranslateY@ImRect@@QEAAXM@Z		; ImRect::TranslateY

; 6947 : 	g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7072]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+7080]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7072], xmm0

; 6948 : 	g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+7072]
	movss	DWORD PTR [rax+7080], xmm0

; 6949 : 	IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
; 6950 : 	//g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
; 6951 : 	g.NavScoringCount = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7088], 0

; 6952 : #if IMGUI_DEBUG_NAV_RECTS
; 6953 : 	if (g.NavWindow) { for (int layer = 0; layer < 2; layer++) GetOverlayDrawList(g.NavWindow)->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
; 6954 : 	if (g.NavWindow) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255, 0, 255, 255) : IM_COL32(255, 0, 0, 255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); GetOverlayDrawList(g.NavWindow)->AddCircleFilled(p, 3.0f, col); GetOverlayDrawList(g.NavWindow)->AddText(NULL, 13.0f, p + ImVec2(8, -4), col, buf); }
; 6955 : #endif
; 6956 : }

	add	rsp, 472				; 000001d8H
	pop	rdi
	pop	rsi
	ret	0
?NavUpdate@ImGui@@YAXXZ ENDP				; ImGui::NavUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ret$ = 48
size$ = 56
child_window$ = 64
g$ = 72
tv75 = 80
tv73 = 84
parent_window$ = 88
backup_border_size$ = 96
auto_fit_axises$ = 100
content_avail$ = 104
title$ = 112
__$ArrayPad$ = 368
name$ = 400
id$ = 408
size_arg$ = 416
border$ = 424
flags$ = 432
?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z PROC	; ImGui::BeginChildEx

; 3432 : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 392				; 00000188H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3433 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3434 : 	ImGuiWindow* parent_window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR parent_window$[rsp], rax

; 3435 : 
; 3436 : 	flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |/*ImGuiWindowFlags_NoSavedSettings|*/ImGuiWindowFlags_ChildWindow;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 16777219				; 01000003H
	mov	DWORD PTR flags$[rsp], eax

; 3437 : 	flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

	mov	rax, QWORD PTR parent_window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 4
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 3438 : 
; 3439 : 	// Size
; 3440 : 	const ImVec2 content_avail = GetContentRegionAvail();

	lea	rcx, QWORD PTR content_avail$[rsp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail

; 3441 : 	ImVec2 size = ImFloor(size_arg);

	mov	rdx, QWORD PTR size_arg$[rsp]
	lea	rcx, QWORD PTR size$[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor

; 3442 : 	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);

	movss	xmm0, DWORD PTR size$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN11@BeginChild
	jne	SHORT $LN11@BeginChild
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN12@BeginChild
$LN11@BeginChild:
	mov	DWORD PTR tv73[rsp], 0
$LN12@BeginChild:
	movss	xmm0, DWORD PTR size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN13@BeginChild
	jne	SHORT $LN13@BeginChild
	mov	DWORD PTR tv75[rsp], 2
	jmp	SHORT $LN14@BeginChild
$LN13@BeginChild:
	mov	DWORD PTR tv75[rsp], 0
$LN14@BeginChild:
	mov	eax, DWORD PTR tv75[rsp]
	mov	ecx, DWORD PTR tv73[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR auto_fit_axises$[rsp], eax

; 3443 : 	if (size.x <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR size$[rsp]
	jb	SHORT $LN2@BeginChild

; 3444 : 		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)

	movss	xmm0, DWORD PTR content_avail$[rsp]
	addss	xmm0, DWORD PTR size$[rsp]
	movss	xmm1, DWORD PTR __real@40800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR size$[rsp], xmm0
$LN2@BeginChild:

; 3445 : 	if (size.y <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR size$[rsp+4]
	jb	SHORT $LN3@BeginChild

; 3446 : 		size.y = ImMax(content_avail.y + size.y, 4.0f);

	movss	xmm0, DWORD PTR content_avail$[rsp+4]
	addss	xmm0, DWORD PTR size$[rsp+4]
	movss	xmm1, DWORD PTR __real@40800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR size$[rsp+4], xmm0
$LN3@BeginChild:

; 3447 : 	SetNextWindowSize(size);

	xor	edx, edx
	lea	rcx, QWORD PTR size$[rsp]
	call	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ; ImGui::SetNextWindowSize
	npad	1

; 3448 : 
; 3449 : 	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
; 3450 : 	char title[256];
; 3451 : 	if (name)

	cmp	QWORD PTR name$[rsp], 0
	je	SHORT $LN4@BeginChild

; 3452 : 		ImFormatString(title, IM_ARRAYSIZE(title), ("%lld-%s+%08X"), parent_window->Name, name, id);

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR name$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR parent_window$[rsp]
	mov	r9, QWORD PTR [rax+16]
	lea	r8, OFFSET FLAT:??_C@_0N@CCJDMNMD@?$CFlld?9?$CFs?$CL?$CF08X@
	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR title$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
	jmp	SHORT $LN5@BeginChild
$LN4@BeginChild:

; 3453 : 	else
; 3454 : 		ImFormatString(title, IM_ARRAYSIZE(title), ("%lld-%08X"), parent_window->Name, id);

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR parent_window$[rsp]
	mov	r9, QWORD PTR [rax+16]
	lea	r8, OFFSET FLAT:??_C@_09ONMJNNOG@?$CFlld?9?$CF08X@
	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR title$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN5@BeginChild:

; 3455 : 
; 3456 : 	const float backup_border_size = g.Style.ChildBorderSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5512]
	movss	DWORD PTR backup_border_size$[rsp], xmm0

; 3457 : 	if (!border)

	movzx	eax, BYTE PTR border$[rsp]
	test	eax, eax
	jne	SHORT $LN6@BeginChild

; 3458 : 		g.Style.ChildBorderSize = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+5512], xmm0
$LN6@BeginChild:

; 3459 : 	bool ret = Begin(title, NULL, flags);

	mov	r8d, DWORD PTR flags$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR title$[rsp]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	mov	BYTE PTR ret$[rsp], al

; 3460 : 	g.Style.ChildBorderSize = backup_border_size;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR backup_border_size$[rsp]
	movss	DWORD PTR [rax+5512], xmm0

; 3461 : 
; 3462 : 	ImGuiWindow* child_window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR child_window$[rsp], rax

; 3463 : 	child_window->ChildId = id;

	mov	rax, QWORD PTR child_window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+60], ecx

; 3464 : 	child_window->AutoFitChildAxises = auto_fit_axises;

	mov	rax, QWORD PTR child_window$[rsp]
	mov	ecx, DWORD PTR auto_fit_axises$[rsp]
	mov	DWORD PTR [rax+180], ecx

; 3465 : 
; 3466 : 	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
; 3467 : 	// While this is not really documented/defined, it seems that the expected thing to do.
; 3468 : 	if (child_window->BeginCount == 1)

	mov	rax, QWORD PTR child_window$[rsp]
	movsx	eax, WORD PTR [rax+136]
	cmp	eax, 1
	jne	SHORT $LN7@BeginChild

; 3469 : 		parent_window->DC.CursorPos = child_window->Pos;

	mov	rax, QWORD PTR child_window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	QWORD PTR [rcx+340], rax
$LN7@BeginChild:

; 3470 : 
; 3471 : 	// Process navigation-in immediately so NavInit can run on first frame
; 3472 : 	if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	jne	SHORT $LN8@BeginChild
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	jne	SHORT $LN8@BeginChild
	mov	rax, QWORD PTR child_window$[rsp]
	cmp	DWORD PTR [rax+420], 0
	jne	SHORT $LN9@BeginChild
	mov	rax, QWORD PTR child_window$[rsp]
	movzx	eax, BYTE PTR [rax+456]
	test	eax, eax
	je	SHORT $LN8@BeginChild
$LN9@BeginChild:

; 3473 : 	{
; 3474 : 		FocusWindow(child_window);

	mov	rcx, QWORD PTR child_window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 3475 : 		NavInitWindow(child_window, false);

	xor	edx, edx
	mov	rcx, QWORD PTR child_window$[rsp]
	call	?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z ; ImGui::NavInitWindow

; 3476 : 		SetActiveID(id + 1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item

	mov	eax, DWORD PTR id$[rsp]
	inc	eax
	mov	rdx, QWORD PTR child_window$[rsp]
	mov	ecx, eax
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 3477 : 		g.ActiveIdSource = ImGuiInputSource_Nav;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6820], 2
$LN8@BeginChild:

; 3478 : 	}
; 3479 : 	return ret;

	movzx	eax, BYTE PTR ret$[rsp]

; 3480 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 392				; 00000188H
	ret	0
?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z ENDP	; ImGui::BeginChildEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
himc$1 = 32
hwnd$2 = 40
cf$3 = 48
__$ArrayPad$ = 80
x$ = 112
y$ = 120
?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z PROC	; ImeSetInputScreenPosFn_DefaultImpl

; 8375 : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 8376 : 	// Notify OS Input Method Editor of text input position
; 8377 : 	if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+288]
	mov	QWORD PTR hwnd$2[rsp], rax
	cmp	QWORD PTR hwnd$2[rsp], 0
	je	SHORT $LN2@ImeSetInpu

; 8378 : 		if (HIMC himc = ::ImmGetContext(hwnd))

	mov	rcx, QWORD PTR hwnd$2[rsp]
	call	ImmGetContext
	mov	QWORD PTR himc$1[rsp], rax
	cmp	QWORD PTR himc$1[rsp], 0
	je	SHORT $LN3@ImeSetInpu

; 8379 : 		{
; 8380 : 			COMPOSITIONFORM cf;
; 8381 : 			cf.ptCurrentPos.x = x;

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR cf$3[rsp+4], eax

; 8382 : 			cf.ptCurrentPos.y = y;

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR cf$3[rsp+8], eax

; 8383 : 			cf.dwStyle = CFS_FORCE_POSITION;

	mov	DWORD PTR cf$3[rsp], 32			; 00000020H

; 8384 : 			::ImmSetCompositionWindow(himc, &cf);

	lea	rdx, QWORD PTR cf$3[rsp]
	mov	rcx, QWORD PTR himc$1[rsp]
	call	ImmSetCompositionWindow

; 8385 : 			::ImmReleaseContext(hwnd, himc);

	mov	rdx, QWORD PTR himc$1[rsp]
	mov	rcx, QWORD PTR hwnd$2[rsp]
	call	ImmReleaseContext
	npad	1
$LN3@ImeSetInpu:
$LN2@ImeSetInpu:

; 8386 : 		}
; 8387 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z ENDP	; ImeSetInputScreenPosFn_DefaultImpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
wbuf_length$ = 48
wbuf_handle$ = 56
wbuf_global$ = 64
__formal$ = 96
text$ = 104
?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z PROC	; SetClipboardTextFn_DefaultImpl

; 8325 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 8326 : 	if (!::OpenClipboard(NULL))

	xor	ecx, ecx
	call	QWORD PTR __imp_OpenClipboard
	test	eax, eax
	jne	SHORT $LN2@SetClipboa

; 8327 : 		return;

	jmp	$LN1@SetClipboa
$LN2@SetClipboa:

; 8328 : 	const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;

	xor	edx, edx
	mov	rcx, QWORD PTR text$[rsp]
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	inc	eax
	mov	DWORD PTR wbuf_length$[rsp], eax

; 8329 : 	HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));

	movsxd	rax, DWORD PTR wbuf_length$[rsp]
	shl	rax, 1
	mov	rdx, rax
	mov	ecx, 2
	call	QWORD PTR __imp_GlobalAlloc
	mov	QWORD PTR wbuf_handle$[rsp], rax

; 8330 : 	if (wbuf_handle == NULL)

	cmp	QWORD PTR wbuf_handle$[rsp], 0
	jne	SHORT $LN3@SetClipboa

; 8331 : 	{
; 8332 : 		::CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard
	npad	1

; 8333 : 		return;

	jmp	SHORT $LN1@SetClipboa
$LN3@SetClipboa:

; 8334 : 	}
; 8335 : 	ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);

	mov	rcx, QWORD PTR wbuf_handle$[rsp]
	call	QWORD PTR __imp_GlobalLock
	mov	QWORD PTR wbuf_global$[rsp], rax

; 8336 : 	ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);

	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR text$[rsp]
	mov	edx, DWORD PTR wbuf_length$[rsp]
	mov	rcx, QWORD PTR wbuf_global$[rsp]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8

; 8337 : 	::GlobalUnlock(wbuf_handle);

	mov	rcx, QWORD PTR wbuf_handle$[rsp]
	call	QWORD PTR __imp_GlobalUnlock

; 8338 : 	::EmptyClipboard();

	call	QWORD PTR __imp_EmptyClipboard
	npad	1

; 8339 : 	if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)

	mov	rdx, QWORD PTR wbuf_handle$[rsp]
	mov	ecx, 13
	call	QWORD PTR __imp_SetClipboardData
	test	rax, rax
	jne	SHORT $LN4@SetClipboa

; 8340 : 		::GlobalFree(wbuf_handle);

	mov	rcx, QWORD PTR wbuf_handle$[rsp]
	call	QWORD PTR __imp_GlobalFree
	npad	1
$LN4@SetClipboa:

; 8341 : 	::CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard
	npad	1
$LN1@SetClipboa:

; 8342 : }

	add	rsp, 88					; 00000058H
	ret	0
?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z ENDP	; SetClipboardTextFn_DefaultImpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
buf_len$1 = 32
wbuf_global$2 = 40
wbuf_handle$ = 48
__formal$ = 80
?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z PROC	; GetClipboardTextFn_DefaultImpl

; 8302 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 8303 : 	static ImVector<char> buf_local;

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA, eax
	jle	SHORT $LN2@GetClipboa
	lea	rcx, OFFSET FLAT:?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA, -1
	jne	SHORT $LN2@GetClipboa
	lea	rcx, OFFSET FLAT:?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A
	call	??0?$ImVector@D@@QEAA@XZ		; ImVector<char>::ImVector<char>
	lea	rcx, OFFSET FLAT:??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@YAXXZ ; `GetClipboardTextFn_DefaultImpl'::`2'::`dynamic atexit destructor for 'buf_local''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
	call	_Init_thread_footer
	npad	1
$LN2@GetClipboa:

; 8304 : 	buf_local.clear();

	lea	rcx, OFFSET FLAT:?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A
	call	?clear@?$ImVector@D@@QEAAXXZ		; ImVector<char>::clear
	npad	1

; 8305 : 	if (!::OpenClipboard(NULL))

	xor	ecx, ecx
	call	QWORD PTR __imp_OpenClipboard
	test	eax, eax
	jne	SHORT $LN3@GetClipboa

; 8306 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@GetClipboa
$LN3@GetClipboa:

; 8307 : 	HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);

	mov	ecx, 13
	call	QWORD PTR __imp_GetClipboardData
	mov	QWORD PTR wbuf_handle$[rsp], rax

; 8308 : 	if (wbuf_handle == NULL)

	cmp	QWORD PTR wbuf_handle$[rsp], 0
	jne	SHORT $LN4@GetClipboa

; 8309 : 	{
; 8310 : 		::CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard

; 8311 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@GetClipboa
$LN4@GetClipboa:

; 8312 : 	}
; 8313 : 	if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))

	mov	rcx, QWORD PTR wbuf_handle$[rsp]
	call	QWORD PTR __imp_GlobalLock
	mov	QWORD PTR wbuf_global$2[rsp], rax
	cmp	QWORD PTR wbuf_global$2[rsp], 0
	je	SHORT $LN5@GetClipboa

; 8314 : 	{
; 8315 : 		int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;

	xor	edx, edx
	mov	rcx, QWORD PTR wbuf_global$2[rsp]
	call	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ; ImTextCountUtf8BytesFromStr
	inc	eax
	mov	DWORD PTR buf_len$1[rsp], eax

; 8316 : 		buf_local.resize(buf_len);

	mov	edx, DWORD PTR buf_len$1[rsp]
	lea	rcx, OFFSET FLAT:?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 8317 : 		ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);

	xor	r9d, r9d
	mov	r8, QWORD PTR wbuf_global$2[rsp]
	mov	edx, DWORD PTR buf_len$1[rsp]
	mov	rcx, QWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A+8
	call	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z	; ImTextStrToUtf8
	npad	1
$LN5@GetClipboa:

; 8318 : 	}
; 8319 : 	::GlobalUnlock(wbuf_handle);

	mov	rcx, QWORD PTR wbuf_handle$[rsp]
	call	QWORD PTR __imp_GlobalUnlock

; 8320 : 	::CloseClipboard();

	call	QWORD PTR __imp_CloseClipboard

; 8321 : 	return buf_local.Data;

	mov	rax, QWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4U?$ImVector@D@@A+8
$LN1@GetClipboa:

; 8322 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z ENDP	; GetClipboardTextFn_DefaultImpl
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
buf_len$1 = 32
wbuf_global$2 = 40
wbuf_handle$ = 48
__formal$ = 80
?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA PROC ; `GetClipboardTextFn_DefaultImpl'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z@4HA ENDP ; `GetClipboardTextFn_DefaultImpl'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 48
__$ReturnUdt$ = 80
?GetViewportRect@@YA?AUImRect@@XZ PROC			; GetViewportRect

; 3426 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3427 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3428 : 	return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm3, DWORD PTR [rax+20]
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3429 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetViewportRect@@YA?AUImRect@@XZ ENDP			; GetViewportRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
count$2 = 36
child$3 = 40
tv75 = 48
tv90 = 56
out_sorted_windows$ = 80
window$ = 88
?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z PROC ; AddWindowToSortBuffer

; 2748 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2749 : 	out_sorted_windows->push_back(window);

	lea	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR out_sorted_windows$[rsp]
	call	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
	npad	1

; 2750 : 	if (window->Active)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	$LN5@AddWindowT

; 2751 : 	{
; 2752 : 		int count = window->DC.ChildWindows.Size;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+432]
	mov	DWORD PTR count$2[rsp], eax

; 2753 : 		if (count > 1)

	cmp	DWORD PTR count$2[rsp], 1
	jle	SHORT $LN6@AddWindowT

; 2754 : 			ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);

	movsxd	rax, DWORD PTR count$2[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 432				; 000001b0H
	call	?begin@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::begin
	lea	r9, OFFSET FLAT:?ChildWindowComparer@@YAHPEBX0@Z ; ChildWindowComparer
	mov	r8d, 8
	mov	rcx, QWORD PTR tv75[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	qsort
	npad	1
$LN6@AddWindowT:

; 2755 : 		for (int i = 0; i < count; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AddWindowT
$LN2@AddWindowT:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AddWindowT:
	mov	eax, DWORD PTR count$2[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@AddWindowT

; 2756 : 		{
; 2757 : 			ImGuiWindow* child = window->DC.ChildWindows[i];

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 432				; 000001b0H
	mov	QWORD PTR tv90[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR child$3[rsp], rax

; 2758 : 			if (child->Active)

	mov	rax, QWORD PTR child$3[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN7@AddWindowT

; 2759 : 				AddWindowToSortBuffer(out_sorted_windows, child);

	mov	rdx, QWORD PTR child$3[rsp]
	mov	rcx, QWORD PTR out_sorted_windows$[rsp]
	call	?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z ; AddWindowToSortBuffer
	npad	1
$LN7@AddWindowT:

; 2760 : 		}

	jmp	SHORT $LN2@AddWindowT
$LN3@AddWindowT:
$LN5@AddWindowT:

; 2761 : 	}
; 2762 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z ENDP ; AddWindowToSortBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
last_cmd$ = 32
out_list$ = 64
draw_list$ = 72
?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z PROC ; AddDrawListToDrawData

; 2765 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2766 : 	if (draw_list->CmdBuffer.empty())

	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ ; ImVector<ImDrawCmd>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@AddDrawLis

; 2767 : 		return;

	jmp	SHORT $LN1@AddDrawLis
$LN2@AddDrawLis:

; 2768 : 
; 2769 : 	// Remove trailing command if unused
; 2770 : 	ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();

	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
	mov	QWORD PTR last_cmd$[rsp], rax

; 2771 : 	if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)

	mov	rax, QWORD PTR last_cmd$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN3@AddDrawLis
	mov	rax, QWORD PTR last_cmd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN3@AddDrawLis

; 2772 : 	{
; 2773 : 		draw_list->CmdBuffer.pop_back();

	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
	npad	1

; 2774 : 		if (draw_list->CmdBuffer.empty())

	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ ; ImVector<ImDrawCmd>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@AddDrawLis

; 2775 : 			return;

	jmp	SHORT $LN1@AddDrawLis
$LN4@AddDrawLis:
$LN3@AddDrawLis:

; 2776 : 	}
; 2777 : 
; 2778 : 	// Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
; 2779 : 	IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
; 2780 : 	IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
; 2781 : 	IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
; 2782 : 
; 2783 : 	// Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
; 2784 : 	// If this assert triggers because you are drawing lots of stuff manually:
; 2785 : 	// A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
; 2786 : 	// B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
; 2787 : 	//    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
; 2788 : 	//      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
; 2789 : 	//    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
; 2790 : 	// C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
; 2791 : 	if (sizeof(ImDrawIdx) == 2)

	xor	eax, eax

; 2792 : 		IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
; 2793 : 
; 2794 : 	out_list->push_back(draw_list);

	lea	rdx, QWORD PTR draw_list$[rsp]
	mov	rcx, QWORD PTR out_list$[rsp]
	call	?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z ; ImVector<ImDrawList *>::push_back
	npad	1
$LN1@AddDrawLis:

; 2795 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z ENDP ; AddDrawListToDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
target_y$1 = 32
cr_y$2 = 36
scroll$ = 40
cr_x$3 = 48
tv142 = 52
tv140 = 56
g$ = 64
$T4 = 72
$T5 = 80
__$ReturnUdt$ = 112
window$ = 120
snap_on_edges$ = 128
?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z PROC ; CalcNextScrollFromScrollTargetAndClamp

; 3728 : {

	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3729 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3730 : 	ImVec2 scroll = window->Scroll;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+92]
	mov	QWORD PTR scroll$[rsp], rax

; 3731 : 	if (window->ScrollTarget.x < FLT_MAX)

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	comiss	xmm0, DWORD PTR [rax+104]
	jbe	SHORT $LN2@CalcNextSc

; 3732 : 	{
; 3733 : 		float cr_x = window->ScrollTargetCenterRatio.x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+116]
	movss	DWORD PTR cr_x$3[rsp], xmm0

; 3734 : 		scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	subss	xmm0, DWORD PTR [rcx+124]
	movss	xmm1, DWORD PTR cr_x$3[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+104]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR scroll$[rsp], xmm0
$LN2@CalcNextSc:

; 3735 : 	}
; 3736 : 	if (window->ScrollTarget.y < FLT_MAX)

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	comiss	xmm0, DWORD PTR [rax+108]
	jbe	$LN3@CalcNextSc

; 3737 : 	{
; 3738 : 		// 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
; 3739 : 		float cr_y = window->ScrollTargetCenterRatio.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+120]
	movss	DWORD PTR cr_y$2[rsp], xmm0

; 3740 : 		float target_y = window->ScrollTarget.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR target_y$1[rsp], xmm0

; 3741 : 		if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)

	movzx	eax, BYTE PTR snap_on_edges$[rsp]
	test	eax, eax
	je	SHORT $LN4@CalcNextSc
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR cr_y$2[rsp]
	jb	SHORT $LN4@CalcNextSc
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+84]
	comiss	xmm0, DWORD PTR target_y$1[rsp]
	jb	SHORT $LN4@CalcNextSc

; 3742 : 			target_y = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR target_y$1[rsp], xmm0
$LN4@CalcNextSc:

; 3743 : 		if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)

	movzx	eax, BYTE PTR snap_on_edges$[rsp]
	test	eax, eax
	je	SHORT $LN5@CalcNextSc
	movss	xmm0, DWORD PTR cr_y$2[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN5@CalcNextSc
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+84]
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5544]
	movss	xmm1, DWORD PTR target_y$1[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN5@CalcNextSc

; 3744 : 			target_y = window->SizeContents.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR target_y$1[rsp], xmm0
$LN5@CalcNextSc:

; 3745 : 		scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR cr_y$2[rsp]
	movss	DWORD PTR tv140[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	DWORD PTR tv142[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv142[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv140[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR target_y$1[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+36]
	subss	xmm1, DWORD PTR [rcx+128]
	movss	xmm2, DWORD PTR cr_y$2[rsp]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR scroll$[rsp+4], xmm0
$LN3@CalcNextSc:

; 3746 : 	}
; 3747 : 	scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR scroll$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR scroll$[rsp], rax

; 3748 : 	if (!window->Collapsed && !window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	SHORT $LN6@CalcNextSc
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	jne	SHORT $LN6@CalcNextSc

; 3749 : 	{
; 3750 : 		scroll.x = ImMin(scroll.x, ImGui::GetWindowScrollMaxX(window));

	mov	rcx, QWORD PTR window$[rsp]
	call	?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxX
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR scroll$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR scroll$[rsp], xmm0

; 3751 : 		scroll.y = ImMin(scroll.y, ImGui::GetWindowScrollMaxY(window));

	mov	rcx, QWORD PTR window$[rsp]
	call	?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxY
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR scroll$[rsp+4]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR scroll$[rsp+4], xmm0
$LN6@CalcNextSc:

; 3752 : 	}
; 3753 : 	return scroll;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR scroll$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3754 : }

	add	rsp, 104				; 00000068H
	ret	0
?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z ENDP ; CalcNextScrollFromScrollTargetAndClamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
current$1 = 0
current$2 = 4
current$3 = 8
current$4 = 12
current$5 = 16
current$6 = 20
p_backup$ = 24
g$ = 32
window$ = 64
write$ = 72
?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z PROC		; CheckStacksSize

; 3555 : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3556 : 	// NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
; 3557 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3558 : 	short* p_backup = &window->DC.StackSizesBackup[0];

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	lea	rax, QWORD PTR [rcx+rax+552]
	mov	QWORD PTR p_backup$[rsp], rax

; 3559 : 	{ int current = window->IDStack.Size;       if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+232]
	mov	DWORD PTR current$1[rsp], eax
	movzx	eax, BYTE PTR write$[rsp]
	test	eax, eax
	je	SHORT $LN2@CheckStack
	mov	rax, QWORD PTR p_backup$[rsp]
	movzx	ecx, WORD PTR current$1[rsp]
	mov	WORD PTR [rax], cx
$LN2@CheckStack:
	mov	rax, QWORD PTR p_backup$[rsp]
	add	rax, 2
	mov	QWORD PTR p_backup$[rsp], rax

; 3560 : 	{ int current = window->DC.GroupStack.Size; if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+536]
	mov	DWORD PTR current$2[rsp], eax
	movzx	eax, BYTE PTR write$[rsp]
	test	eax, eax
	je	SHORT $LN4@CheckStack
	mov	rax, QWORD PTR p_backup$[rsp]
	movzx	ecx, WORD PTR current$2[rsp]
	mov	WORD PTR [rax], cx
$LN4@CheckStack:
	mov	rax, QWORD PTR p_backup$[rsp]
	add	rax, 2
	mov	QWORD PTR p_backup$[rsp], rax

; 3561 : 	{ int current = g.BeginPopupStack.Size;     if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++; }// Too few or too many EndMenu()/EndPopup()

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6888]
	mov	DWORD PTR current$3[rsp], eax
	movzx	eax, BYTE PTR write$[rsp]
	test	eax, eax
	je	SHORT $LN6@CheckStack
	mov	rax, QWORD PTR p_backup$[rsp]
	movzx	ecx, WORD PTR current$3[rsp]
	mov	WORD PTR [rax], cx
$LN6@CheckStack:
	mov	rax, QWORD PTR p_backup$[rsp]
	add	rax, 2
	mov	QWORD PTR p_backup$[rsp], rax

; 3562 : 	// For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
; 3563 : 	{ int current = g.ColorModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6784]
	mov	DWORD PTR current$4[rsp], eax
	movzx	eax, BYTE PTR write$[rsp]
	test	eax, eax
	je	SHORT $LN8@CheckStack
	mov	rax, QWORD PTR p_backup$[rsp]
	movzx	ecx, WORD PTR current$4[rsp]
	mov	WORD PTR [rax], cx
$LN8@CheckStack:
	mov	rax, QWORD PTR p_backup$[rsp]
	add	rax, 2
	mov	QWORD PTR p_backup$[rsp], rax

; 3564 : 	{ int current = g.StyleModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6840]
	mov	DWORD PTR current$5[rsp], eax
	movzx	eax, BYTE PTR write$[rsp]
	test	eax, eax
	je	SHORT $LN10@CheckStack
	mov	rax, QWORD PTR p_backup$[rsp]
	movzx	ecx, WORD PTR current$5[rsp]
	mov	WORD PTR [rax], cx
$LN10@CheckStack:
	mov	rax, QWORD PTR p_backup$[rsp]
	add	rax, 2
	mov	QWORD PTR p_backup$[rsp], rax

; 3565 : 	{ int current = g.FontStack.Size;           if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6856]
	mov	DWORD PTR current$6[rsp], eax
	movzx	eax, BYTE PTR write$[rsp]
	test	eax, eax
	je	SHORT $LN12@CheckStack
	mov	rax, QWORD PTR p_backup$[rsp]
	movzx	ecx, WORD PTR current$6[rsp]
	mov	WORD PTR [rax], cx
$LN12@CheckStack:
	mov	rax, QWORD PTR p_backup$[rsp]
	add	rax, 2
	mov	QWORD PTR p_backup$[rsp], rax

; 3566 : 	IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
; 3567 : }

	add	rsp, 56					; 00000038H
	ret	0
?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z ENDP		; CheckStacksSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
tv163 = 44
g$ = 48
$T2 = 56
tv82 = 64
$T3 = 72
$T4 = 80
$T5 = 88
tv89 = 96
$T6 = 104
$T7 = 112
tv169 = 120
tv176 = 128
tv181 = 136
$T8 = 144
$T9 = 152
name$ = 176
size$ = 184
flags$ = 192
?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z PROC ; CreateNewWindow

; 3589 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 3590 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3591 : 
; 3592 : 	// Create window the first time
; 3593 : 	ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);

	mov	ecx, 968				; 000003c8H
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	r8, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR $T4[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 968				; 000003c8H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN9@CreateNewW
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z ; ImGuiWindow::ImGuiWindow
	mov	QWORD PTR tv82[rsp], rax
	jmp	SHORT $LN10@CreateNewW
$LN9@CreateNewW:
	mov	QWORD PTR tv82[rsp], 0
$LN10@CreateNewW:
	mov	rax, QWORD PTR tv82[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR window$[rsp], rax

; 3594 : 	window->Flags = flags;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 3595 : 	g.WindowsById.SetVoidPtr(window->ID, window);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6616				; 000019d8H
	mov	QWORD PTR tv89[rsp], rax
	mov	r8, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR tv89[rsp]
	call	?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z	; ImGuiStorage::SetVoidPtr
	npad	1

; 3596 : 
; 3597 : 	// Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
; 3598 : 	window->Pos = ImVec2(60, 60);

	movss	xmm2, DWORD PTR __real@42700000
	movss	xmm1, DWORD PTR __real@42700000
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T6[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rax+48], rcx

; 3599 : 
; 3600 : 	// User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
; 3601 : 	//if (!(flags & ImGuiWindowFlags_NoSavedSettings))
; 3602 : 	//    if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
; 3603 : 	//    {
; 3604 : 	//        // Retrieve settings from .ini file
; 3605 : 	//        window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
; 3606 : 	//        SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
; 3607 : 	//        window->Pos = ImFloor(settings->Pos);
; 3608 : 	//        window->Collapsed = settings->Collapsed;
; 3609 : 	//        if (ImLengthSqr(settings->Size) > 0.00001f)
; 3610 : 	//            size = ImFloor(settings->Size);
; 3611 : 	//    }
; 3612 : 	window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);

	lea	rdx, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T7[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rax+40], rcx
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx], rax

; 3613 : 	window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+312], rax

; 3614 : 
; 3615 : 	if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN2@CreateNewW

; 3616 : 	{
; 3617 : 		window->AutoFitFramesX = window->AutoFitFramesY = 2;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+160], 2
	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+156], 2

; 3618 : 		window->AutoFitOnlyGrows = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+164], 0

; 3619 : 	}

	jmp	SHORT $LN3@CreateNewW
$LN2@CreateNewW:

; 3620 : 	else
; 3621 : 	{
; 3622 : 		if (window->Size.x <= 0.0f)

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	jb	SHORT $LN4@CreateNewW

; 3623 : 			window->AutoFitFramesX = 2;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+156], 2
$LN4@CreateNewW:

; 3624 : 		if (window->Size.y <= 0.0f)

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+4]
	jb	SHORT $LN5@CreateNewW

; 3625 : 			window->AutoFitFramesY = 2;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+160], 2
$LN5@CreateNewW:

; 3626 : 		window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	SHORT $LN11@CreateNewW
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jg	SHORT $LN11@CreateNewW
	mov	DWORD PTR tv163[rsp], 0
	jmp	SHORT $LN12@CreateNewW
$LN11@CreateNewW:
	mov	DWORD PTR tv163[rsp], 1
$LN12@CreateNewW:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv163[rsp]
	mov	BYTE PTR [rax+164], cl
$LN3@CreateNewW:

; 3627 : 	}
; 3628 : 
; 3629 : 	g.WindowsFocusOrder.push_back(window);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv169[rsp], rax
	lea	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv169[rsp]
	call	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
	npad	1

; 3630 : 	if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $LN6@CreateNewW

; 3631 : 		g.Windows.push_front(window); // Quite slow but rare and only once

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv176[rsp], rax
	lea	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv176[rsp]
	call	?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_front
	npad	1
	jmp	SHORT $LN7@CreateNewW
$LN6@CreateNewW:

; 3632 : 	else
; 3633 : 		g.Windows.push_back(window);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv181[rsp], rax
	lea	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv181[rsp]
	call	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
	npad	1
$LN7@CreateNewW:

; 3634 : 	return window;

	mov	rax, QWORD PTR window$[rsp]

; 3635 : }

	add	rsp, 168				; 000000a8H
	ret	0
?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z ENDP ; CreateNewWindow
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
window$ = 32
$T1 = 40
tv163 = 44
g$ = 48
$T2 = 56
tv82 = 64
$T3 = 72
$T4 = 80
$T5 = 88
tv89 = 96
$T6 = 104
$T7 = 112
tv169 = 120
tv176 = 128
tv181 = 136
$T8 = 144
$T9 = 152
name$ = 176
size$ = 184
flags$ = 192
?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA PROC ; `CreateNewWindow'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z@4HA ENDP ; `CreateNewWindow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
i$1 = 40
window$2 = 48
hovered_window$ = 56
tv88 = 64
padding_regular$ = 72
tv169 = 80
$T3 = 88
$T4 = 96
tv132 = 104
padding_for_resize_from_edges$ = 112
bb$5 = 120
$T6 = 136
$T7 = 144
?FindHoveredWindow@@YAXXZ PROC				; FindHoveredWindow

; 3076 : {

	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 3077 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3078 : 
; 3079 : 	ImGuiWindow* hovered_window = NULL;

	mov	QWORD PTR hovered_window$[rsp], 0

; 3080 : 	if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6776], 0
	je	SHORT $LN5@FindHovere
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6776]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	SHORT $LN5@FindHovere

; 3081 : 		hovered_window = g.MovingWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6776]
	mov	QWORD PTR hovered_window$[rsp], rax
$LN5@FindHovere:

; 3082 : 
; 3083 : 	ImVec2 padding_regular = g.Style.TouchExtraPadding;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+5556]
	mov	QWORD PTR padding_regular$[rsp], rax

; 3084 : 	ImVec2 padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS)) : padding_regular;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+212]
	test	eax, eax
	je	SHORT $LN16@FindHovere
	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 5556				; 000015b4H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T7[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN17@FindHovere
$LN16@FindHovere:
	mov	rax, QWORD PTR padding_regular$[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR tv88[rsp], rax
$LN17@FindHovere:
	mov	rax, QWORD PTR tv88[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR $T4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR padding_for_resize_from_edges$[rsp], rax

; 3085 : 	for (int i = g.Windows.Size - 1; i >= 0; i--)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@FindHovere
$LN2@FindHovere:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FindHovere:
	cmp	DWORD PTR i$1[rsp], 0
	jl	$LN3@FindHovere

; 3086 : 	{
; 3087 : 		ImGuiWindow* window = g.Windows[i];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv132[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$2[rsp], rax

; 3088 : 		if (!window->Active || window->Hidden)

	mov	rax, QWORD PTR window$2[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN7@FindHovere
	mov	rax, QWORD PTR window$2[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	je	SHORT $LN6@FindHovere
$LN7@FindHovere:

; 3089 : 			continue;

	jmp	SHORT $LN2@FindHovere
$LN6@FindHovere:

; 3090 : 		if (window->Flags & ImGuiWindowFlags_NoMouseInputs)

	mov	rax, QWORD PTR window$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN8@FindHovere

; 3091 : 			continue;

	jmp	SHORT $LN2@FindHovere
$LN8@FindHovere:

; 3092 : 
; 3093 : 		// Using the clipped AABB, a child window will typically be clipped by its parent (not always)
; 3094 : 		ImRect bb(window->OuterRectClipped);

	lea	rax, QWORD PTR bb$5[rsp]
	mov	rcx, QWORD PTR window$2[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+264]
	mov	ecx, 16
	rep movsb

; 3095 : 		if ((window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_NoResize))

	mov	rax, QWORD PTR window$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN11@FindHovere
	mov	rax, QWORD PTR window$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN9@FindHovere
$LN11@FindHovere:

; 3096 : 			bb.Expand(padding_regular);

	lea	rdx, QWORD PTR padding_regular$[rsp]
	lea	rcx, QWORD PTR bb$5[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1
	jmp	SHORT $LN10@FindHovere
$LN9@FindHovere:

; 3097 : 		else
; 3098 : 			bb.Expand(padding_for_resize_from_edges);

	lea	rdx, QWORD PTR padding_for_resize_from_edges$[rsp]
	lea	rcx, QWORD PTR bb$5[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1
$LN10@FindHovere:

; 3099 : 		if (!bb.Contains(g.IO.MousePos))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rdx, rax
	lea	rcx, QWORD PTR bb$5[rsp]
	call	?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@FindHovere

; 3100 : 			continue;

	jmp	$LN2@FindHovere
$LN12@FindHovere:

; 3101 : 
; 3102 : 		// Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.
; 3103 : 		if (hovered_window == NULL)

	cmp	QWORD PTR hovered_window$[rsp], 0
	jne	SHORT $LN13@FindHovere

; 3104 : 			hovered_window = window;

	mov	rax, QWORD PTR window$2[rsp]
	mov	QWORD PTR hovered_window$[rsp], rax
$LN13@FindHovere:

; 3105 : 		if (hovered_window)

	cmp	QWORD PTR hovered_window$[rsp], 0
	je	SHORT $LN14@FindHovere

; 3106 : 			break;

	jmp	SHORT $LN3@FindHovere
$LN14@FindHovere:

; 3107 : 	}

	jmp	$LN2@FindHovere
$LN3@FindHovere:

; 3108 : 
; 3109 : 	g.HoveredWindow = hovered_window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR hovered_window$[rsp]
	mov	QWORD PTR [rax+6560], rcx

; 3110 : 	g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	je	SHORT $LN18@FindHovere
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	rax, QWORD PTR [rax+688]
	mov	QWORD PTR tv169[rsp], rax
	jmp	SHORT $LN19@FindHovere
$LN18@FindHovere:
	mov	QWORD PTR tv169[rsp], 0
$LN19@FindHovere:
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR tv169[rsp]
	mov	QWORD PTR [rax+6688], rcx

; 3111 : 
; 3112 : }

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?FindHoveredWindow@@YAXXZ ENDP				; FindHoveredWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv70 = 32
g$ = 40
window$ = 64
?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z PROC		; SetCurrentWindow

; 1715 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1716 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1717 : 	g.CurrentWindow = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+6584], rcx

; 1718 : 	if (window)

	cmp	QWORD PTR window$[rsp], 0
	je	SHORT $LN2@SetCurrent

; 1719 : 		g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();

	mov	rcx, QWORD PTR window$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv70[rsp]
	movss	DWORD PTR [rax+6432], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv70[rsp]
	movss	DWORD PTR [rax+6408], xmm0
$LN2@SetCurrent:

; 1720 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z ENDP		; SetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
text_display_end$ = 0
text$ = 32
text_end$ = 40
?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z PROC		; ImGui::FindRenderedTextEnd

; 1375 : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1376 : 	const char* text_display_end = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR text_display_end$[rsp], rax

; 1377 : 	if (!text_end)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN4@FindRender

; 1378 : 		text_end = (const char*)-1;

	mov	QWORD PTR text_end$[rsp], -1
$LN4@FindRender:
$LN2@FindRender:

; 1379 : 
; 1380 : 	while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR text_display_end$[rsp], rax
	jae	SHORT $LN3@FindRender
	mov	rax, QWORD PTR text_display_end$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@FindRender
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR text_display_end$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN5@FindRender
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR text_display_end$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN3@FindRender
$LN5@FindRender:

; 1381 : 		text_display_end++;

	mov	rax, QWORD PTR text_display_end$[rsp]
	inc	rax
	mov	QWORD PTR text_display_end$[rsp], rax
	jmp	SHORT $LN2@FindRender
$LN3@FindRender:

; 1382 : 	return text_display_end;

	mov	rax, QWORD PTR text_display_end$[rsp]

; 1383 : }

	add	rsp, 24
	ret	0
?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ENDP		; ImGui::FindRenderedTextEnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
fully_visible$1 = 64
window$ = 72
tv80 = 80
rounding$ = 84
g$ = 88
display_rect$ = 96
tv172 = 112
tv193 = 116
THICKNESS$2 = 120
DISTANCE$3 = 124
tv130 = 128
tv139 = 136
tv170 = 144
tv168 = 152
tv174 = 160
tv195 = 168
$T4 = 176
$T5 = 184
$T6 = 192
$T7 = 200
$T8 = 208
bb$ = 256
id$ = 264
flags$ = 272
?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z PROC	; ImGui::RenderNavHighlight

; 1569 : {

$LN12:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 1570 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1571 : 	if (id != g.NavId)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7040]
	cmp	DWORD PTR id$[rsp], eax
	je	SHORT $LN2@RenderNavH

; 1572 : 		return;

	jmp	$LN1@RenderNavH
$LN2@RenderNavH:

; 1573 : 	if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	je	SHORT $LN3@RenderNavH
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN3@RenderNavH

; 1574 : 		return;

	jmp	$LN1@RenderNavH
$LN3@RenderNavH:

; 1575 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1576 : 	if (window->DC.NavHideHighlightOneFrame)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+428]
	test	eax, eax
	je	SHORT $LN4@RenderNavH

; 1577 : 		return;

	jmp	$LN1@RenderNavH
$LN4@RenderNavH:

; 1578 : 
; 1579 : 	float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN10@RenderNavH
	xorps	xmm0, xmm0
	movss	DWORD PTR tv80[rsp], xmm0
	jmp	SHORT $LN11@RenderNavH
$LN10@RenderNavH:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5532]
	movss	DWORD PTR tv80[rsp], xmm0
$LN11@RenderNavH:
	movss	xmm0, DWORD PTR tv80[rsp]
	movss	DWORD PTR rounding$[rsp], xmm0

; 1580 : 	ImRect display_rect = bb;

	lea	rax, QWORD PTR display_rect$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR bb$[rsp]
	mov	ecx, 16
	rep movsb

; 1581 : 	display_rect.ClipWith(window->ClipRect);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	rdx, rax
	lea	rcx, QWORD PTR display_rect$[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith
	npad	1

; 1582 : 	if (flags & ImGuiNavHighlightFlags_TypeDefault)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN5@RenderNavH

; 1583 : 	{
; 1584 : 		const float THICKNESS = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR THICKNESS$2[rsp], xmm0

; 1585 : 		const float DISTANCE = 3.0f + THICKNESS * 0.5f;

	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR DISTANCE$3[rsp], xmm0

; 1586 : 		display_rect.Expand(ImVec2(DISTANCE, DISTANCE));

	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR display_rect$[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1

; 1587 : 		bool fully_visible = window->ClipRect.Contains(display_rect);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv130[rsp], rax
	lea	rdx, QWORD PTR display_rect$[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	mov	BYTE PTR fully_visible$1[rsp], al

; 1588 : 		if (!fully_visible)

	movzx	eax, BYTE PTR fully_visible$1[rsp]
	test	eax, eax
	jne	SHORT $LN6@RenderNavH

; 1589 : 			window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv139[rsp], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR display_rect$[rsp+8]
	mov	rdx, QWORD PTR display_rect$[rsp]
	mov	rcx, QWORD PTR tv139[rsp]
	call	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z ; ImDrawList::PushClipRect
	npad	1
$LN6@RenderNavH:

; 1590 : 		window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv174[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 44					; 0000002cH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv172[rsp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR display_rect$[rsp+8]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv170[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR display_rect$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv168[rsp], rax
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv172[rsp]
	mov	r8, QWORD PTR tv170[rsp]
	mov	rdx, QWORD PTR tv168[rsp]
	mov	rcx, QWORD PTR tv174[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1

; 1591 : 		if (!fully_visible)

	movzx	eax, BYTE PTR fully_visible$1[rsp]
	test	eax, eax
	jne	SHORT $LN7@RenderNavH

; 1592 : 			window->DrawList->PopClipRect();

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?PopClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::PopClipRect
	npad	1
$LN7@RenderNavH:
$LN5@RenderNavH:

; 1593 : 	}
; 1594 : 	if (flags & ImGuiNavHighlightFlags_TypeThin)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@RenderNavH

; 1595 : 	{
; 1596 : 		window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv195[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 44					; 0000002cH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv193[rsp], eax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], -1
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv193[rsp]
	lea	r8, QWORD PTR display_rect$[rsp+8]
	lea	rdx, QWORD PTR display_rect$[rsp]
	mov	rcx, QWORD PTR tv195[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN8@RenderNavH:
$LN1@RenderNavH:

; 1597 : 	}
; 1598 : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ENDP	; ImGui::RenderNavHighlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
third$ = 32
thickness$ = 36
by$ = 40
bx$ = 44
window$ = 48
g$ = 56
tv94 = 64
tv128 = 72
tv137 = 80
tv139 = 88
tv152 = 96
tv154 = 104
tv161 = 112
$T1 = 120
$T2 = 128
$T3 = 136
$T4 = 144
pos$ = 176
col$ = 184
sz$ = 192
?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z PROC		; ImGui::RenderCheckMark

; 1551 : {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1552 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1553 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1554 : 
; 1555 : 	float thickness = ImMax(sz / 5.0f, 1.0f);

	movss	xmm0, DWORD PTR sz$[rsp]
	divss	xmm0, DWORD PTR __real@40a00000
	movss	xmm1, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR thickness$[rsp], xmm0

; 1556 : 	sz -= thickness * 0.5f;

	movss	xmm0, DWORD PTR thickness$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR sz$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR sz$[rsp], xmm0

; 1557 : 	pos += ImVec2(thickness * 0.25f, thickness * 0.25f);

	movss	xmm0, DWORD PTR thickness$[rsp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	xmm1, DWORD PTR thickness$[rsp]
	mulss	xmm1, DWORD PTR __real@3e800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR pos$[rsp]
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1

; 1558 : 
; 1559 : 	float third = sz / 3.0f;

	movss	xmm0, DWORD PTR sz$[rsp]
	divss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR third$[rsp], xmm0

; 1560 : 	float bx = pos.x + third;

	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR third$[rsp]
	movss	DWORD PTR bx$[rsp], xmm0

; 1561 : 	float by = pos.y + sz - third * 0.5f;

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR sz$[rsp]
	movss	xmm1, DWORD PTR third$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR by$[rsp], xmm0

; 1562 : 	window->DrawList->PathLineTo(ImVec2(bx - third, by - third));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv128[rsp], rax
	movss	xmm0, DWORD PTR by$[rsp]
	subss	xmm0, DWORD PTR third$[rsp]
	movss	xmm1, DWORD PTR bx$[rsp]
	subss	xmm1, DWORD PTR third$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv94[rsp], rax
	mov	rdx, QWORD PTR tv94[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1563 : 	window->DrawList->PathLineTo(ImVec2(bx, by));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv139[rsp], rax
	movss	xmm2, DWORD PTR by$[rsp]
	movss	xmm1, DWORD PTR bx$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv137[rsp], rax
	mov	rdx, QWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR tv139[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1564 : 	window->DrawList->PathLineTo(ImVec2(bx + third * 2, by - third * 2));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv154[rsp], rax
	movss	xmm0, DWORD PTR third$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR by$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR third$[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR bx$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv152[rsp], rax
	mov	rdx, QWORD PTR tv152[rsp]
	mov	rcx, QWORD PTR tv154[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1565 : 	window->DrawList->PathStroke(col, false, thickness);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv161[rsp], rax
	movss	xmm3, DWORD PTR thickness$[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR tv161[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1

; 1566 : }

	add	rsp, 168				; 000000a8H
	ret	0
?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z ENDP		; ImGui::RenderCheckMark
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv79 = 48
tv77 = 52
g$ = 56
window$ = 64
tv81 = 72
pos$ = 96
?RenderBullet@ImGui@@YAXUImVec2@@@Z PROC		; ImGui::RenderBullet

; 1544 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1545 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1546 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1547 : 	window->DrawList->AddCircleFilled(pos, g.FontSize * 0.20f, GetColorU32(ImGuiCol_Text), 8);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv81[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv79[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR tv77[rsp], xmm0
	mov	DWORD PTR [rsp+32], 8
	mov	r9d, DWORD PTR tv79[rsp]
	movss	xmm2, DWORD PTR tv77[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1548 : }

	add	rsp, 88					; 00000058H
	ret	0
?RenderBullet@ImGui@@YAXUImVec2@@@Z ENDP		; ImGui::RenderBullet
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
r$ = 48
tv81 = 52
h$ = 56
tv205 = 60
c$ = 64
b$ = 72
a$ = 80
center$ = 88
g$ = 96
tv203 = 104
tv201 = 112
tv199 = 120
tv207 = 128
$T1 = 136
$T2 = 144
$T3 = 152
$T4 = 160
$T5 = 168
$T6 = 176
$T7 = 184
$T8 = 192
$T9 = 200
$T10 = 208
$T11 = 216
$T12 = 224
$T13 = 232
$T14 = 240
$T15 = 248
$T16 = 256
p_min$ = 288
dir$ = 296
scale$ = 304
?RenderArrow@ImGui@@YAXUImVec2@@HM@Z PROC		; ImGui::RenderArrow

; 1510 : {

$LN13:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H

; 1511 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1512 : 
; 1513 : 	const float h = g.FontSize * 1.00f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR h$[rsp], xmm0

; 1514 : 	float r = h * 0.40f * scale;

	movss	xmm0, DWORD PTR h$[rsp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR r$[rsp], xmm0

; 1515 : 	ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);

	movss	xmm0, DWORD PTR h$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	xmm1, DWORD PTR h$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR p_min$[rsp]
	lea	rcx, QWORD PTR center$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 1516 : 
; 1517 : 	ImVec2 a, b, c;

	lea	rcx, QWORD PTR a$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	lea	rcx, QWORD PTR b$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	lea	rcx, QWORD PTR c$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 1518 : 	switch (dir)

	mov	eax, DWORD PTR dir$[rsp]
	mov	DWORD PTR tv81[rsp], eax
	cmp	DWORD PTR tv81[rsp], 0
	je	$LN7@RenderArro
	cmp	DWORD PTR tv81[rsp], 1
	je	$LN8@RenderArro
	cmp	DWORD PTR tv81[rsp], 2
	je	SHORT $LN4@RenderArro
	cmp	DWORD PTR tv81[rsp], 3
	je	SHORT $LN5@RenderArro
	jmp	$LN2@RenderArro
$LN4@RenderArro:
$LN5@RenderArro:

; 1519 : 	{
; 1520 : 	case ImGuiDir_Up:
; 1521 : 	case ImGuiDir_Down:
; 1522 : 		if (dir == ImGuiDir_Up) r = -r;

	cmp	DWORD PTR dir$[rsp], 2
	jne	SHORT $LN6@RenderArro
	movss	xmm0, DWORD PTR r$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR r$[rsp], xmm0
$LN6@RenderArro:

; 1523 : 		a = ImVec2(+0.000f, +0.750f) * r;

	movss	xmm2, DWORD PTR __real@3f400000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR a$[rsp], rax

; 1524 : 		b = ImVec2(-0.866f, -0.750f) * r;

	movss	xmm2, DWORD PTR __real@bf400000
	movss	xmm1, DWORD PTR __real@bf5db22d
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR b$[rsp], rax

; 1525 : 		c = ImVec2(+0.866f, -0.750f) * r;

	movss	xmm2, DWORD PTR __real@bf400000
	movss	xmm1, DWORD PTR __real@3f5db22d
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c$[rsp], rax

; 1526 : 		break;

	jmp	$LN2@RenderArro
$LN7@RenderArro:
$LN8@RenderArro:

; 1527 : 	case ImGuiDir_Left:
; 1528 : 	case ImGuiDir_Right:
; 1529 : 		if (dir == ImGuiDir_Left) r = -r;

	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN9@RenderArro
	movss	xmm0, DWORD PTR r$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR r$[rsp], xmm0
$LN9@RenderArro:

; 1530 : 		a = ImVec2(+0.750f, +0.000f) * r;

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f400000
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR a$[rsp], rax

; 1531 : 		b = ImVec2(-0.750f, +0.866f) * r;

	movss	xmm2, DWORD PTR __real@3f5db22d
	movss	xmm1, DWORD PTR __real@bf400000
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR b$[rsp], rax

; 1532 : 		c = ImVec2(-0.750f, -0.866f) * r;

	movss	xmm2, DWORD PTR __real@bf5db22d
	movss	xmm1, DWORD PTR __real@bf400000
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T13[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c$[rsp], rax
$LN2@RenderArro:

; 1533 : 		break;
; 1534 : 	case ImGuiDir_None:
; 1535 : 	case ImGuiDir_COUNT:
; 1536 : 		IM_ASSERT(0);
; 1537 : 		break;
; 1538 : 	}
; 1539 : 
; 1540 : 	g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv207[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv205[rsp], eax
	lea	r8, QWORD PTR c$[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv203[rsp], rax
	lea	r8, QWORD PTR b$[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv201[rsp], rax
	lea	r8, QWORD PTR a$[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv199[rsp], rax
	mov	eax, DWORD PTR tv205[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv203[rsp]
	mov	r8, QWORD PTR tv201[rsp]
	mov	rdx, QWORD PTR tv199[rsp]
	mov	rcx, QWORD PTR tv207[rsp]
	call	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	npad	1

; 1541 : }

	add	rsp, 280				; 00000118H
	ret	0
?RenderArrow@ImGui@@YAXUImVec2@@HM@Z ENDP		; ImGui::RenderArrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
border_size$ = 64
tv132 = 68
tv147 = 72
g$ = 80
window$ = 88
tv130 = 96
tv128 = 104
tv134 = 112
tv149 = 120
$T1 = 128
$T2 = 136
$T3 = 144
$T4 = 152
p_min$ = 176
p_max$ = 184
rounding$ = 192
?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z PROC		; ImGui::RenderFrameBorder

; 1497 : {

$LN4:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1498 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1499 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1500 : 	const float border_size = g.Style.FrameBorderSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5536]
	movss	DWORD PTR border_size$[rsp], xmm0

; 1501 : 	if (border_size > 0.0f)

	movss	xmm0, DWORD PTR border_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN2@RenderFram

; 1502 : 	{
; 1503 : 		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv134[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 6
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv132[rsp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR p_max$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv130[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR p_min$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv128[rsp], rax
	movss	xmm0, DWORD PTR border_size$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv132[rsp]
	mov	r8, QWORD PTR tv130[rsp]
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR tv134[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1

; 1504 : 		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv149[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv147[rsp], eax
	movss	xmm0, DWORD PTR border_size$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv147[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	lea	rdx, QWORD PTR p_min$[rsp]
	mov	rcx, QWORD PTR tv149[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN2@RenderFram:

; 1505 : 	}
; 1506 : }

	add	rsp, 168				; 000000a8H
	ret	0
?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ENDP		; ImGui::RenderFrameBorder
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
border_size$ = 64
tv143 = 68
tv158 = 72
window$ = 80
g$ = 88
tv73 = 96
tv141 = 104
tv139 = 112
tv145 = 120
tv160 = 128
$T1 = 136
$T2 = 144
$T3 = 152
$T4 = 160
p_min$ = 192
p_max$ = 200
fill_col$ = 208
border$ = 216
rounding$ = 224
?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z PROC		; ImGui::RenderFrame

; 1484 : {

$LN4:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1485 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1486 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1487 : 	window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv73[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR fill_col$[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	lea	rdx, QWORD PTR p_min$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1488 : 	const float border_size = g.Style.FrameBorderSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5536]
	movss	DWORD PTR border_size$[rsp], xmm0

; 1489 : 	if (border && border_size > 0.0f)

	movzx	eax, BYTE PTR border$[rsp]
	test	eax, eax
	je	$LN2@RenderFram
	movss	xmm0, DWORD PTR border_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN2@RenderFram

; 1490 : 	{
; 1491 : 		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv145[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 6
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv143[rsp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR p_max$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv141[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR p_min$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv139[rsp], rax
	movss	xmm0, DWORD PTR border_size$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv143[rsp]
	mov	r8, QWORD PTR tv141[rsp]
	mov	rdx, QWORD PTR tv139[rsp]
	mov	rcx, QWORD PTR tv145[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1

; 1492 : 		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv160[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv158[rsp], eax
	movss	xmm0, DWORD PTR border_size$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv158[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	lea	rdx, QWORD PTR p_min$[rsp]
	mov	rcx, QWORD PTR tv160[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN2@RenderFram:

; 1493 : 	}
; 1494 : }

	add	rsp, 184				; 000000b8H
	ret	0
?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ENDP		; ImGui::RenderFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
need_clipping$ = 80
pos$ = 88
tv87 = 96
tv95 = 100
text_size$ = 104
clip_max$ = 112
clip_min$ = 120
tv129 = 128
tv73 = 136
tv77 = 144
tv80 = 152
$T1 = 160
$T2 = 168
$T3 = 176
fine_clip_rect$4 = 184
draw_list$ = 224
pos_min$ = 232
pos_max$ = 240
text$ = 248
text_display_end$ = 256
text_size_if_known$ = 264
align$ = 272
clip_rect$ = 280
?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z PROC ; ImGui::RenderTextClippedEx

; 1440 : {

$LN18:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 1441 : 	// Perform CPU side clipping for single clipped element to avoid using scissor state
; 1442 : 	ImVec2 pos = pos_min;

	mov	rax, QWORD PTR pos_min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$[rsp], rax

; 1443 : 	const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

	cmp	QWORD PTR text_size_if_known$[rsp], 0
	je	SHORT $LN8@RenderText
	mov	rax, QWORD PTR text_size_if_known$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN9@RenderText
$LN8@RenderText:
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR text_display_end$[rsp]
	mov	rdx, QWORD PTR text$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	mov	QWORD PTR tv73[rsp], rax
$LN9@RenderText:
	mov	rax, QWORD PTR tv73[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR text_size$[rsp], rax

; 1444 : 
; 1445 : 	const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;

	cmp	QWORD PTR clip_rect$[rsp], 0
	je	SHORT $LN10@RenderText
	mov	rax, QWORD PTR clip_rect$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN11@RenderText
$LN10@RenderText:
	mov	rax, QWORD PTR pos_min$[rsp]
	mov	QWORD PTR tv77[rsp], rax
$LN11@RenderText:
	mov	rax, QWORD PTR tv77[rsp]
	mov	QWORD PTR clip_min$[rsp], rax

; 1446 : 	const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;

	cmp	QWORD PTR clip_rect$[rsp], 0
	je	SHORT $LN12@RenderText
	mov	rax, QWORD PTR clip_rect$[rsp]
	add	rax, 8
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN13@RenderText
$LN12@RenderText:
	mov	rax, QWORD PTR pos_max$[rsp]
	mov	QWORD PTR tv80[rsp], rax
$LN13@RenderText:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR clip_max$[rsp], rax

; 1447 : 	bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);

	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR text_size$[rsp]
	mov	rax, QWORD PTR clip_max$[rsp]
	comiss	xmm0, DWORD PTR [rax]
	jae	SHORT $LN14@RenderText
	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR text_size$[rsp+4]
	mov	rax, QWORD PTR clip_max$[rsp]
	comiss	xmm0, DWORD PTR [rax+4]
	jae	SHORT $LN14@RenderText
	mov	DWORD PTR tv87[rsp], 0
	jmp	SHORT $LN15@RenderText
$LN14@RenderText:
	mov	DWORD PTR tv87[rsp], 1
$LN15@RenderText:
	movzx	eax, BYTE PTR tv87[rsp]
	mov	BYTE PTR need_clipping$[rsp], al

; 1448 : 	if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min

	cmp	QWORD PTR clip_rect$[rsp], 0
	je	SHORT $LN2@RenderText

; 1449 : 		need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

	movzx	eax, BYTE PTR need_clipping$[rsp]
	mov	DWORD PTR tv129[rsp], eax
	mov	rax, QWORD PTR clip_min$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR pos$[rsp]
	ja	SHORT $LN16@RenderText
	mov	rax, QWORD PTR clip_min$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR pos$[rsp+4]
	ja	SHORT $LN16@RenderText
	mov	DWORD PTR tv95[rsp], 0
	jmp	SHORT $LN17@RenderText
$LN16@RenderText:
	mov	DWORD PTR tv95[rsp], 1
$LN17@RenderText:
	mov	eax, DWORD PTR tv95[rsp]
	mov	ecx, DWORD PTR tv129[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR need_clipping$[rsp], al
$LN2@RenderText:

; 1450 : 
; 1451 : 	// Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
; 1452 : 	if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);

	mov	rax, QWORD PTR align$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@RenderText
	mov	rax, QWORD PTR pos_max$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR pos$[rsp]
	subss	xmm0, DWORD PTR text_size$[rsp]
	mov	rax, QWORD PTR align$[rsp]
	mulss	xmm0, DWORD PTR [rax]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR pos$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pos$[rsp], xmm0
$LN3@RenderText:

; 1453 : 	if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

	mov	rax, QWORD PTR align$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@RenderText
	mov	rax, QWORD PTR pos_max$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR text_size$[rsp+4]
	mov	rax, QWORD PTR align$[rsp]
	mulss	xmm0, DWORD PTR [rax+4]
	movss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR pos$[rsp+4]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pos$[rsp+4], xmm0
$LN4@RenderText:

; 1454 : 
; 1455 : 	// Render
; 1456 : 	if (need_clipping)

	movzx	eax, BYTE PTR need_clipping$[rsp]
	test	eax, eax
	je	$LN5@RenderText

; 1457 : 	{
; 1458 : 		ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);

	mov	rax, QWORD PTR clip_max$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR clip_max$[rsp]
	movss	xmm3, DWORD PTR [rax]
	mov	rax, QWORD PTR clip_min$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR clip_min$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR fine_clip_rect$4[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 1459 : 		draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);

	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	lea	rcx, QWORD PTR fine_clip_rect$4[rsp]
	mov	QWORD PTR [rsp+64], rcx
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rcx, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	xorps	xmm2, xmm2
	xor	edx, edx
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1460 : 	}

	jmp	SHORT $LN6@RenderText
$LN5@RenderText:

; 1461 : 	else
; 1462 : 	{
; 1463 : 		draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);

	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rcx, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	xorps	xmm2, xmm2
	xor	edx, edx
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN6@RenderText:

; 1464 : 	}
; 1465 : }

	add	rsp, 216				; 000000d8H
	ret	0
?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z ENDP ; ImGui::RenderTextClippedEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
text_len$ = 64
text_display_end$ = 72
g$ = 80
window$ = 88
pos_min$ = 112
pos_max$ = 120
text$ = 128
text_end$ = 136
text_size_if_known$ = 144
align$ = 152
clip_rect$ = 160
?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z PROC ; ImGui::RenderTextClipped

; 1468 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1469 : 	// Hide anything after a '##' string
; 1470 : 	const char* text_display_end = FindRenderedTextEnd(text, text_end);

	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR text_display_end$[rsp], rax

; 1471 : 	const int text_len = (int)(text_display_end - text);

	mov	rax, QWORD PTR text$[rsp]
	mov	rcx, QWORD PTR text_display_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR text_len$[rsp], eax

; 1472 : 	if (text_len == 0)

	cmp	DWORD PTR text_len$[rsp], 0
	jne	SHORT $LN2@RenderText

; 1473 : 		return;

	jmp	SHORT $LN1@RenderText
$LN2@RenderText:

; 1474 : 
; 1475 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1476 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1477 : 	RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);

	mov	rax, QWORD PTR clip_rect$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR align$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text_size_if_known$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR text$[rsp]
	mov	r8, QWORD PTR pos_max$[rsp]
	mov	rdx, QWORD PTR pos_min$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z ; ImGui::RenderTextClippedEx
	npad	1
$LN1@RenderText:

; 1478 : 	/*if (g.LogEnabled)
; 1479 : 		LogRenderedText(&pos_min, text, text_display_end);*/
; 1480 : }

	add	rsp, 104				; 00000068H
	ret	0
?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ENDP ; ImGui::RenderTextClipped
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 80
window$ = 88
tv95 = 96
tv155 = 100
tv183 = 104
tv211 = 108
tv232 = 112
tv234 = 116
tv93 = 120
tv91 = 128
tv129 = 136
tv153 = 144
tv151 = 152
tv157 = 160
tv181 = 168
tv179 = 176
tv185 = 184
tv209 = 192
tv207 = 200
tv213 = 208
tv230 = 216
tv236 = 224
$T1 = 232
$T2 = 240
$T3 = 248
$T4 = 256
$T5 = 264
$T6 = 272
$T7 = 280
$T8 = 288
pos$ = 320
text$ = 328
text_end$ = 336
wrap_width$ = 344
?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z PROC	; ImGui::RenderTextWrapped

; 1418 : {

$LN5:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H

; 1419 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1420 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1421 : 
; 1422 : 	if (!text_end)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN2@RenderText

; 1423 : 		text_end = text + strlen(text); // FIXME-OPT

	mov	rcx, QWORD PTR text$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN2@RenderText:

; 1424 : 
; 1425 : 	if (text != text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR text$[rsp], rax
	je	$LN3@RenderText

; 1426 : 	{
; 1427 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(1, 0), 0xFF050505, text, text_end, wrap_width);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv129[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv95[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv91[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv93[rsp]
	movss	xmm2, DWORD PTR tv95[rsp]
	mov	rdx, QWORD PTR tv91[rsp]
	mov	rcx, QWORD PTR tv129[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1428 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(0, 1), 0xFF050505, text, text_end, wrap_width);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv157[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv153[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv155[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv151[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv153[rsp]
	movss	xmm2, DWORD PTR tv155[rsp]
	mov	rdx, QWORD PTR tv151[rsp]
	mov	rcx, QWORD PTR tv157[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1429 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(-1, 0), 0xFF050505, text, text_end, wrap_width);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv185[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv181[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv183[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv179[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv181[rsp]
	movss	xmm2, DWORD PTR tv183[rsp]
	mov	rdx, QWORD PTR tv179[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1430 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(0, -1), 0xFF050505, text, text_end, wrap_width);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv213[rsp], rax
	movss	xmm2, DWORD PTR __real@bf800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv209[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv211[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv207[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv209[rsp]
	movss	xmm2, DWORD PTR tv211[rsp]
	mov	rdx, QWORD PTR tv207[rsp]
	mov	rcx, QWORD PTR tv213[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1431 : 		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv236[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv232[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv234[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv230[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv232[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR tv234[rsp]
	mov	rdx, QWORD PTR tv230[rsp]
	mov	rcx, QWORD PTR tv236[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN3@RenderText:

; 1432 : 		/*if (g.LogEnabled)
; 1433 : 			LogRenderedText(&pos, text, text_end);*/
; 1434 : 	}
; 1435 : }

	add	rsp, 312				; 00000138H
	ret	0
?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z ENDP	; ImGui::RenderTextWrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 80
text_display_end$ = 88
window$ = 96
tv132 = 104
tv160 = 108
tv188 = 112
tv216 = 116
tv237 = 120
tv239 = 124
tv130 = 128
tv128 = 136
tv134 = 144
tv158 = 152
tv156 = 160
tv162 = 168
tv186 = 176
tv184 = 184
tv190 = 192
tv214 = 200
tv212 = 208
tv218 = 216
tv235 = 224
tv241 = 232
$T1 = 240
$T2 = 248
$T3 = 256
$T4 = 264
$T5 = 272
$T6 = 280
$T7 = 288
$T8 = 296
pos$ = 320
text$ = 328
text_end$ = 336
hide_text_after_hash$ = 344
?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z PROC		; ImGui::RenderText

; 1388 : {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H

; 1389 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1390 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1391 : 
; 1392 : 	// Hide anything after a '##' string
; 1393 : 	const char* text_display_end;
; 1394 : 	if (hide_text_after_hash)

	movzx	eax, BYTE PTR hide_text_after_hash$[rsp]
	test	eax, eax
	je	SHORT $LN2@RenderText

; 1395 : 	{
; 1396 : 		text_display_end = FindRenderedTextEnd(text, text_end);

	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR text_display_end$[rsp], rax

; 1397 : 	}

	jmp	SHORT $LN3@RenderText
$LN2@RenderText:

; 1398 : 	else
; 1399 : 	{
; 1400 : 		if (!text_end)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN4@RenderText

; 1401 : 			text_end = text + strlen(text); // FIXME-OPT

	mov	rcx, QWORD PTR text$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN4@RenderText:

; 1402 : 		text_display_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR text_display_end$[rsp], rax
$LN3@RenderText:

; 1403 : 	}
; 1404 : 
; 1405 : 	if (text != text_display_end)

	mov	rax, QWORD PTR text_display_end$[rsp]
	cmp	QWORD PTR text$[rsp], rax
	je	$LN5@RenderText

; 1406 : 	{
; 1407 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(1, 0), 0xFF050505, text, text_display_end);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv134[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv130[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv132[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv128[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv130[rsp]
	movss	xmm2, DWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR tv134[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1408 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(0, 1), 0xFF050505, text, text_display_end);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv162[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv158[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv160[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv156[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv158[rsp]
	movss	xmm2, DWORD PTR tv160[rsp]
	mov	rdx, QWORD PTR tv156[rsp]
	mov	rcx, QWORD PTR tv162[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1409 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(-1, 0), 0xFF050505, text, text_display_end);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv190[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv186[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv188[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv184[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv186[rsp]
	movss	xmm2, DWORD PTR tv188[rsp]
	mov	rdx, QWORD PTR tv184[rsp]
	mov	rcx, QWORD PTR tv190[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1410 : 		window->DrawList->AddText(g.Font, g.FontSize, pos + ImVec2(0, -1), 0xFF050505, text, text_display_end);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv218[rsp], rax
	movss	xmm2, DWORD PTR __real@bf800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv214[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv216[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv212[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], -16448251		; ff050505H
	mov	r9, QWORD PTR tv214[rsp]
	movss	xmm2, DWORD PTR tv216[rsp]
	mov	rdx, QWORD PTR tv212[rsp]
	mov	rcx, QWORD PTR tv218[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1411 : 		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv241[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv237[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv239[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv235[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv237[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR tv239[rsp]
	mov	rdx, QWORD PTR tv235[rsp]
	mov	rcx, QWORD PTR tv241[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN5@RenderText:

; 1412 : 		/*if (g.LogEnabled)
; 1413 : 			LogRenderedText(&pos, text, text_display_end);*/
; 1414 : 	}
; 1415 : }

	add	rsp, 312				; 00000138H
	ret	0
?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ENDP		; ImGui::RenderText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
columns$ = 32
window$ = 40
tv75 = 48
tv84 = 56
tv91 = 64
tv89 = 72
column_index$ = 96
?PushColumnClipRect@ImGui@@YAXH@Z PROC			; ImGui::PushColumnClipRect

; 7420 : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 7421 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 7422 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7423 : 	if (column_index < 0)

	cmp	DWORD PTR column_index$[rsp], 0
	jge	SHORT $LN2@PushColumn

; 7424 : 		column_index = columns->Current;

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR column_index$[rsp], eax
$LN2@PushColumn:

; 7425 : 
; 7426 : 	PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv75[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	add	rax, 16
	mov	QWORD PTR tv91[rsp], rax
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv84[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	add	rax, 8
	mov	QWORD PTR tv89[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv91[rsp]
	mov	rcx, QWORD PTR tv89[rsp]
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1

; 7427 : }

	add	rsp, 88					; 00000058H
	ret	0
?PushColumnClipRect@ImGui@@YAXH@Z ENDP			; ImGui::PushColumnClipRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
held$1 = 48
hovered$2 = 49
is_being_resized$ = 50
columns$ = 56
window$ = 64
n$3 = 72
n$4 = 76
dragging_column$5 = 80
column_id$6 = 84
x$7 = 88
column_hw$8 = 92
tv193 = 96
tv196 = 100
y2$9 = 104
y1$10 = 108
xi$11 = 112
x$12 = 116
col$13 = 120
tv256 = 124
tv158 = 128
tv156 = 136
g$ = 144
tv185 = 152
tv230 = 160
tv228 = 168
tv232 = 176
tv253 = 184
tv246 = 192
column_rect$14 = 200
$T15 = 216
$T16 = 224
$T17 = 232
$T18 = 240
?EndColumns@ImGui@@YAXXZ PROC				; ImGui::EndColumns

; 7506 : {

$LN22:
	sub	rsp, 264				; 00000108H

; 7507 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7508 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 7509 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7510 : 	IM_ASSERT(columns != NULL);
; 7511 : 
; 7512 : 	PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 7513 : 	PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 7514 : 	window->DrawList->ChannelsMerge();

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?ChannelsMerge@ImDrawList@@QEAAXXZ	; ImDrawList::ChannelsMerge

; 7515 : 
; 7516 : 	columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+344]
	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR columns$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 7517 : 	window->DC.CursorPos.y = columns->LineMaxY;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rcx+16]
	movss	DWORD PTR [rax+344], xmm0

; 7518 : 	if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN8@EndColumns

; 7519 : 		window->DC.CursorMaxPos.x = columns->StartMaxPosX;  // Restore cursor max pos, as columns don't grow parent

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rcx+44]
	movss	DWORD PTR [rax+312], xmm0
$LN8@EndColumns:

; 7520 : 
; 7521 : 	// Draw columns borders and handle resize
; 7522 : 	bool is_being_resized = false;

	mov	BYTE PTR is_being_resized$[rsp], 0

; 7523 : 	if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 1
	test	eax, eax
	jne	$LN9@EndColumns
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	jne	$LN9@EndColumns

; 7524 : 	{
; 7525 : 		const float y1 = columns->StartPosY;

	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+40]
	movss	DWORD PTR y1$10[rsp], xmm0

; 7526 : 		const float y2 = window->DC.CursorPos.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	movss	DWORD PTR y2$9[rsp], xmm0

; 7527 : 		int dragging_column = -1;

	mov	DWORD PTR dragging_column$5[rsp], -1

; 7528 : 		for (int n = 1; n < columns->Count; n++)

	mov	DWORD PTR n$3[rsp], 1
	jmp	SHORT $LN4@EndColumns
$LN2@EndColumns:
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN4@EndColumns:
	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR n$3[rsp], eax
	jge	$LN3@EndColumns

; 7529 : 		{
; 7530 : 			float x = window->Pos.x + GetColumnOffset(n);

	mov	ecx, DWORD PTR n$3[rsp]
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x$7[rsp], xmm0

; 7531 : 			const ImGuiID column_id = columns->ID + ImGuiID(n);

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, DWORD PTR n$3[rsp]
	mov	DWORD PTR column_id$6[rsp], eax

; 7532 : 			const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction

	call	?GetColumnsRectHalfWidth@@YAMXZ		; GetColumnsRectHalfWidth
	movss	DWORD PTR column_hw$8[rsp], xmm0

; 7533 : 			const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));

	movss	xmm0, DWORD PTR x$7[rsp]
	addss	xmm0, DWORD PTR column_hw$8[rsp]
	movss	xmm2, DWORD PTR y2$9[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv158[rsp], rax
	movss	xmm0, DWORD PTR x$7[rsp]
	subss	xmm0, DWORD PTR column_hw$8[rsp]
	movss	xmm2, DWORD PTR y1$10[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv156[rsp], rax
	mov	r8, QWORD PTR tv158[rsp]
	mov	rdx, QWORD PTR tv156[rsp]
	lea	rcx, QWORD PTR column_rect$14[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 7534 : 			KeepAliveID(column_id);

	mov	ecx, DWORD PTR column_id$6[rsp]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	npad	1

; 7535 : 			if (IsClippedEx(column_rect, column_id, false))

	xor	r8d, r8d
	mov	edx, DWORD PTR column_id$6[rsp]
	lea	rcx, QWORD PTR column_rect$14[rsp]
	call	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z ; ImGui::IsClippedEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@EndColumns

; 7536 : 				continue;

	jmp	$LN2@EndColumns
$LN10@EndColumns:

; 7537 : 
; 7538 : 			bool hovered = false, held = false;

	mov	BYTE PTR hovered$2[rsp], 0
	mov	BYTE PTR held$1[rsp], 0

; 7539 : 			if (!(columns->Flags & ImGuiColumnsFlags_NoResize))

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 2
	test	eax, eax
	jne	$LN11@EndColumns

; 7540 : 			{
; 7541 : 				ButtonBehavior(column_rect, column_id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$1[rsp]
	lea	r8, QWORD PTR hovered$2[rsp]
	mov	edx, DWORD PTR column_id$6[rsp]
	lea	rcx, QWORD PTR column_rect$14[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	npad	1

; 7542 : 				if (hovered || held)

	movzx	eax, BYTE PTR hovered$2[rsp]
	test	eax, eax
	jne	SHORT $LN13@EndColumns
	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	SHORT $LN12@EndColumns
$LN13@EndColumns:

; 7543 : 					g.MouseCursor = ImGuiMouseCursor_ResizeEW;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7504], 4
$LN12@EndColumns:

; 7544 : 				if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))

	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	SHORT $LN14@EndColumns
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv185[rsp], rax
	mov	edx, DWORD PTR n$3[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	mov	eax, DWORD PTR [rax+4]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN14@EndColumns

; 7545 : 					dragging_column = n;

	mov	eax, DWORD PTR n$3[rsp]
	mov	DWORD PTR dragging_column$5[rsp], eax
$LN14@EndColumns:
$LN11@EndColumns:

; 7546 : 			}
; 7547 : 
; 7548 : 			// Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)
; 7549 : 			const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

	movzx	eax, BYTE PTR held$1[rsp]
	test	eax, eax
	je	SHORT $LN20@EndColumns
	mov	DWORD PTR tv196[rsp], 29
	jmp	SHORT $LN21@EndColumns
$LN20@EndColumns:
	movzx	eax, BYTE PTR hovered$2[rsp]
	test	eax, eax
	je	SHORT $LN18@EndColumns
	mov	DWORD PTR tv193[rsp], 28
	jmp	SHORT $LN19@EndColumns
$LN18@EndColumns:
	mov	DWORD PTR tv193[rsp], 27
$LN19@EndColumns:
	mov	eax, DWORD PTR tv193[rsp]
	mov	DWORD PTR tv196[rsp], eax
$LN21@EndColumns:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv196[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$13[rsp], eax

; 7550 : 			const float xi = (float)(int)x;

	cvttss2si eax, DWORD PTR x$7[rsp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR xi$11[rsp], xmm0

; 7551 : 			window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv232[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+260]
	movss	xmm0, DWORD PTR y2$9[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR xi$11[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv230[rsp], rax
	movss	xmm0, DWORD PTR y1$10[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+252]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR xi$11[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv228[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col$13[rsp]
	mov	r8, QWORD PTR tv230[rsp]
	mov	rdx, QWORD PTR tv228[rsp]
	mov	rcx, QWORD PTR tv232[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 7552 : 		}

	jmp	$LN2@EndColumns
$LN3@EndColumns:

; 7553 : 
; 7554 : 		// Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
; 7555 : 		if (dragging_column != -1)

	cmp	DWORD PTR dragging_column$5[rsp], -1
	je	$LN15@EndColumns

; 7556 : 		{
; 7557 : 			if (!columns->IsBeingResized)

	mov	rax, QWORD PTR columns$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	test	eax, eax
	jne	SHORT $LN16@EndColumns

; 7558 : 				for (int n = 0; n < columns->Count + 1; n++)

	mov	DWORD PTR n$4[rsp], 0
	jmp	SHORT $LN7@EndColumns
$LN5@EndColumns:
	mov	eax, DWORD PTR n$4[rsp]
	inc	eax
	mov	DWORD PTR n$4[rsp], eax
$LN7@EndColumns:
	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+36]
	inc	eax
	cmp	DWORD PTR n$4[rsp], eax
	jge	SHORT $LN6@EndColumns

; 7559 : 					columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv253[rsp], rax
	mov	edx, DWORD PTR n$4[rsp]
	mov	rcx, QWORD PTR tv253[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv256[rsp], xmm0
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv246[rsp], rax
	mov	edx, DWORD PTR n$4[rsp]
	mov	rcx, QWORD PTR tv246[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR tv256[rsp]
	movss	DWORD PTR [rax+24], xmm0
	jmp	SHORT $LN5@EndColumns
$LN6@EndColumns:
$LN16@EndColumns:

; 7560 : 			columns->IsBeingResized = is_being_resized = true;

	mov	BYTE PTR is_being_resized$[rsp], 1
	mov	rax, QWORD PTR columns$[rsp]
	movzx	ecx, BYTE PTR is_being_resized$[rsp]
	mov	BYTE PTR [rax+20], cl

; 7561 : 			float x = GetDraggedColumnOffset(columns, dragging_column);

	mov	edx, DWORD PTR dragging_column$5[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	call	?GetDraggedColumnOffset@@YAMPEAUImGuiColumnsSet@@H@Z ; GetDraggedColumnOffset
	movss	DWORD PTR x$12[rsp], xmm0

; 7562 : 			SetColumnOffset(dragging_column, x);

	movss	xmm1, DWORD PTR x$12[rsp]
	mov	ecx, DWORD PTR dragging_column$5[rsp]
	call	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
	npad	1
$LN15@EndColumns:
$LN9@EndColumns:

; 7563 : 		}
; 7564 : 	}
; 7565 : 	columns->IsBeingResized = is_being_resized;

	mov	rax, QWORD PTR columns$[rsp]
	movzx	ecx, BYTE PTR is_being_resized$[rsp]
	mov	BYTE PTR [rax+20], cl

; 7566 : 
; 7567 : 	window->DC.ColumnsSet = NULL;

	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+568], 0

; 7568 : 	window->DC.ColumnsOffset.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+564], xmm0

; 7569 : 	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+576]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 7570 : }

	add	rsp, 264				; 00000108H
	ret	0
?EndColumns@ImGui@@YAXXZ ENDP				; ImGui::EndColumns
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
columns$ = 48
window$ = 56
n$1 = 64
n$2 = 68
tv66 = 72
tv94 = 76
tv193 = 80
id$ = 84
content_region_width$ = 88
tv142 = 92
tv227 = 96
tv236 = 100
clip_x2$3 = 104
clip_x1$4 = 108
tv73 = 112
column$5 = 120
g$ = 128
tv188 = 136
tv203 = 144
tv215 = 152
tv223 = 160
tv256 = 168
tv262 = 176
column$6 = 184
$T7 = 216
str_id$ = 272
columns_count$ = 280
flags$ = 288
?BeginColumns@ImGui@@YAXPEBDHH@Z PROC			; ImGui::BeginColumns

; 7442 : {

$LN20:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 248				; 000000f8H

; 7443 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7444 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 7445 : 
; 7446 : 	IM_ASSERT(columns_count > 1);
; 7447 : 	IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported
; 7448 : 
; 7449 : 	// Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
; 7450 : 	// In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
; 7451 : 	PushID(0x11223347 + (str_id ? 0 : columns_count));

	cmp	QWORD PTR str_id$[rsp], 0
	je	SHORT $LN11@BeginColum
	mov	DWORD PTR tv66[rsp], 0
	jmp	SHORT $LN12@BeginColum
$LN11@BeginColum:
	mov	eax, DWORD PTR columns_count$[rsp]
	mov	DWORD PTR tv66[rsp], eax
$LN12@BeginColum:
	mov	eax, DWORD PTR tv66[rsp]
	add	eax, 287454023				; 11223347H
	mov	ecx, eax
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 7452 : 	ImGuiID id = window->GetID(str_id ? str_id : ("columns"));

	cmp	QWORD PTR str_id$[rsp], 0
	je	SHORT $LN13@BeginColum
	mov	rax, QWORD PTR str_id$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN14@BeginColum
$LN13@BeginColum:
	lea	rax, OFFSET FLAT:??_C@_07HIFEPIJN@columns@
	mov	QWORD PTR tv73[rsp], rax
$LN14@BeginColum:
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv73[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 7453 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7454 : 
; 7455 : 	// Acquire storage for the columns set
; 7456 : 	ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);

	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?FindOrAddColumnsSet@@YAPEAUImGuiColumnsSet@@PEAUImGuiWindow@@I@Z ; FindOrAddColumnsSet
	mov	QWORD PTR columns$[rsp], rax

; 7457 : 	IM_ASSERT(columns->ID == id);
; 7458 : 	columns->Current = 0;

	mov	rax, QWORD PTR columns$[rsp]
	mov	DWORD PTR [rax+24], 0

; 7459 : 	columns->Count = columns_count;

	mov	rax, QWORD PTR columns$[rsp]
	mov	ecx, DWORD PTR columns_count$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 7460 : 	columns->Flags = flags;

	mov	rax, QWORD PTR columns$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+32], ecx

; 7461 : 	window->DC.ColumnsSet = columns;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	mov	QWORD PTR [rax+568], rcx

; 7462 : 
; 7463 : 	// Set state for first column
; 7464 : 	const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN19@BeginColum
	je	SHORT $LN15@BeginColum
$LN19@BeginColum:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	movss	DWORD PTR tv94[rsp], xmm0
	jmp	SHORT $LN16@BeginColum
$LN15@BeginColum:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+608]
	subss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR tv94[rsp], xmm0
$LN16@BeginColum:
	movss	xmm0, DWORD PTR tv94[rsp]
	movss	DWORD PTR content_region_width$[rsp], xmm0

; 7465 : 	columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+576]
	subss	xmm0, DWORD PTR [rcx+5540]
	mov	rax, QWORD PTR columns$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 7466 : 	columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);

	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR content_region_width$[rsp]
	subss	xmm1, DWORD PTR [rax+92]
	movss	DWORD PTR tv142[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv142[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR columns$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 7467 : 	columns->StartPosY = window->DC.CursorPos.y;

	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+344]
	movss	DWORD PTR [rax+40], xmm0

; 7468 : 	columns->StartMaxPosX = window->DC.CursorMaxPos.x;

	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+312]
	movss	DWORD PTR [rax+44], xmm0

; 7469 : 	columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+344]
	movss	DWORD PTR [rax+16], xmm0
	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rcx+16]
	movss	DWORD PTR [rax+12], xmm0

; 7470 : 	window->DC.ColumnsOffset.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+564], xmm0

; 7471 : 	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+576]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 7472 : 
; 7473 : 	// Clear data if columns count changed
; 7474 : 	if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)

	mov	rax, QWORD PTR columns$[rsp]
	cmp	DWORD PTR [rax+48], 0
	je	SHORT $LN8@BeginColum
	mov	eax, DWORD PTR columns_count$[rsp]
	inc	eax
	mov	rcx, QWORD PTR columns$[rsp]
	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN8@BeginColum

; 7475 : 		columns->Columns.resize(0);

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv188[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv188[rsp]
	call	?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ; ImVector<ImGuiColumnData>::resize
	npad	1
$LN8@BeginColum:

; 7476 : 
; 7477 : 	// Initialize defaults
; 7478 : 	columns->IsFirstFrame = (columns->Columns.Size == 0);

	mov	rax, QWORD PTR columns$[rsp]
	cmp	DWORD PTR [rax+48], 0
	jne	SHORT $LN17@BeginColum
	mov	DWORD PTR tv193[rsp], 1
	jmp	SHORT $LN18@BeginColum
$LN17@BeginColum:
	mov	DWORD PTR tv193[rsp], 0
$LN18@BeginColum:
	mov	rax, QWORD PTR columns$[rsp]
	movzx	ecx, BYTE PTR tv193[rsp]
	mov	BYTE PTR [rax], cl

; 7479 : 	if (columns->Columns.Size == 0)

	mov	rax, QWORD PTR columns$[rsp]
	cmp	DWORD PTR [rax+48], 0
	jne	$LN9@BeginColum

; 7480 : 	{
; 7481 : 		columns->Columns.reserve(columns_count + 1);

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv203[rsp], rax
	mov	eax, DWORD PTR columns_count$[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv203[rsp]
	call	?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ; ImVector<ImGuiColumnData>::reserve
	npad	1

; 7482 : 		for (int n = 0; n < columns_count + 1; n++)

	mov	DWORD PTR n$2[rsp], 0
	jmp	SHORT $LN4@BeginColum
$LN2@BeginColum:
	mov	eax, DWORD PTR n$2[rsp]
	inc	eax
	mov	DWORD PTR n$2[rsp], eax
$LN4@BeginColum:
	mov	eax, DWORD PTR columns_count$[rsp]
	inc	eax
	cmp	DWORD PTR n$2[rsp], eax
	jge	SHORT $LN3@BeginColum

; 7483 : 		{
; 7484 : 			ImGuiColumnData column;

	lea	rcx, QWORD PTR column$6[rsp]
	call	??0ImGuiColumnData@@QEAA@XZ		; ImGuiColumnData::ImGuiColumnData

; 7485 : 			column.OffsetNorm = n / (float)columns_count;

	cvtsi2ss xmm0, DWORD PTR n$2[rsp]
	cvtsi2ss xmm1, DWORD PTR columns_count$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR column$6[rsp], xmm0

; 7486 : 			columns->Columns.push_back(column);

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv215[rsp], rax
	lea	rdx, QWORD PTR column$6[rsp]
	mov	rcx, QWORD PTR tv215[rsp]
	call	?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z ; ImVector<ImGuiColumnData>::push_back
	npad	1

; 7487 : 		}

	jmp	SHORT $LN2@BeginColum
$LN3@BeginColum:
$LN9@BeginColum:

; 7488 : 	}
; 7489 : 
; 7490 : 	for (int n = 0; n < columns_count; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN7@BeginColum
$LN5@BeginColum:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN7@BeginColum:
	mov	eax, DWORD PTR columns_count$[rsp]
	cmp	DWORD PTR n$1[rsp], eax
	jge	$LN6@BeginColum

; 7491 : 	{
; 7492 : 		// Compute clipping rectangle
; 7493 : 		ImGuiColumnData* column = &columns->Columns[n];

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv223[rsp], rax
	mov	edx, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR tv223[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	mov	QWORD PTR column$5[rsp], rax

; 7494 : 		float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv227[rsp], xmm0
	mov	ecx, DWORD PTR n$1[rsp]
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	movss	xmm1, DWORD PTR tv227[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR clip_x1$4[rsp], xmm0

; 7495 : 		float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv236[rsp], xmm0
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	ecx, eax
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	movss	xmm1, DWORD PTR tv236[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR clip_x2$3[rsp], xmm0

; 7496 : 		column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);

	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR clip_x2$3[rsp]
	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR clip_x1$4[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rcx, QWORD PTR column$5[rsp]
	lea	rdi, QWORD PTR [rcx+8]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 7497 : 		column->ClipRect.ClipWith(window->ClipRect);

	mov	rax, QWORD PTR column$5[rsp]
	add	rax, 8
	mov	QWORD PTR tv256[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv256[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith
	npad	1

; 7498 : 	}

	jmp	$LN5@BeginColum
$LN6@BeginColum:

; 7499 : 
; 7500 : 	window->DrawList->ChannelsSplit(columns->Count);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv262[rsp], rax
	mov	rax, QWORD PTR columns$[rsp]
	mov	edx, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR tv262[rsp]
	call	?ChannelsSplit@ImDrawList@@QEAAXH@Z	; ImDrawList::ChannelsSplit

; 7501 : 	PushColumnClipRect();

	mov	ecx, -1
	call	?PushColumnClipRect@ImGui@@YAXH@Z	; ImGui::PushColumnClipRect

; 7502 : 	PushItemWidth(GetColumnWidth() * 0.65f);

	mov	ecx, -1
	call	?GetColumnWidth@ImGui@@YAMH@Z		; ImGui::GetColumnWidth
	mulss	xmm0, DWORD PTR __real@3f266666
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1

; 7503 : }

	add	rsp, 248				; 000000f8H
	pop	rdi
	pop	rsi
	ret	0
?BeginColumns@ImGui@@YAXPEBDHH@Z ENDP			; ImGui::BeginColumns
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 0
g$ = 8
?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ PROC	; ImGui::IsDragDropPayloadBeingAccepted

; 7820 : {

$LN5:
	sub	rsp, 24

; 7821 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7822 : 	return g.DragDropActive && g.DragDropAcceptIdPrev != 0;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN3@IsDragDrop
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7736], 0
	je	SHORT $LN3@IsDragDrop
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@IsDragDrop
$LN3@IsDragDrop:
	mov	DWORD PTR tv69[rsp], 0
$LN4@IsDragDrop:
	movzx	eax, BYTE PTR tv69[rsp]

; 7823 : }

	add	rsp, 24
	ret	0
?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ ENDP	; ImGui::IsDragDropPayloadBeingAccepted
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
?ClearDragDrop@ImGui@@YAXXZ PROC			; ImGui::ClearDragDrop

; 7595 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 7596 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7597 : 	g.DragDropActive = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7596], 0

; 7598 : 	g.DragDropPayload.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7616				; 00001dc0H
	mov	rcx, rax
	call	?Clear@ImGuiPayload@@QEAAXXZ		; ImGuiPayload::Clear

; 7599 : 	g.DragDropAcceptFlags = ImGuiDragDropFlags_None;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7704], 0

; 7600 : 	g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7736], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7708], 0

; 7601 : 	g.DragDropAcceptIdCurrRectSurface = FLT_MAX;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+7696], xmm0

; 7602 : 	g.DragDropAcceptFrameCount = -1;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7740], -1

; 7603 : 
; 7604 : 	g.DragDropPayloadBufHeap.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7712				; 00001e20H
	mov	rcx, rax
	call	?clear@?$ImVector@E@@QEAAXXZ		; ImVector<unsigned char>::clear

; 7605 : 	memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7728				; 00001e30H
	mov	r8d, 8
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 7606 : }

	add	rsp, 56					; 00000038H
	ret	0
?ClearDragDrop@ImGui@@YAXXZ ENDP			; ImGui::ClearDragDrop
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
bb$ = 80
id$ = 88
?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z PROC ; ImGui::BeginDragDropTargetCustom

; 7768 : {

$LN9:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 7769 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7770 : 	if (!g.DragDropActive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	jne	SHORT $LN2@BeginDragD

; 7771 : 		return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN2@BeginDragD:

; 7772 : 
; 7773 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 7774 : 	if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	je	SHORT $LN4@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR [rcx+688], rax
	je	SHORT $LN3@BeginDragD
$LN4@BeginDragD:

; 7775 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginDragD
$LN3@BeginDragD:

; 7776 : 	IM_ASSERT(id != 0);
; 7777 : 	if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR bb$[rsp]
	mov	r8b, 1
	mov	rdx, rax
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7628]
	cmp	DWORD PTR id$[rsp], eax
	jne	SHORT $LN5@BeginDragD
$LN6@BeginDragD:

; 7778 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginDragD
$LN5@BeginDragD:

; 7779 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN7@BeginDragD

; 7780 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginDragD
$LN7@BeginDragD:

; 7781 : 
; 7782 : 	IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
; 7783 : 	g.DragDropTargetRect = bb;

	mov	rax, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rax+7680]
	mov	rsi, QWORD PTR bb$[rsp]
	mov	ecx, 16
	rep movsb

; 7784 : 	g.DragDropTargetId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7700], ecx

; 7785 : 	g.DragDropWithinSourceOrTarget = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 1

; 7786 : 	return true;

	mov	al, 1
$LN1@BeginDragD:

; 7787 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z ENDP ; ImGui::BeginDragDropTargetCustom
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z
_TEXT	SEGMENT
tv72 = 32
tv64 = 36
n1$ = 64
n2$ = 72
mode$ = 80
?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z PROC ; ImGui::IsNavInputPressedAnyOfTwo, COMDAT

; 1422 :     inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, DWORD PTR n1$[rsp]
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv64[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, DWORD PTR n2$[rsp]
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv64[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@IsNavInput
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@IsNavInput
$LN3@IsNavInput:
	mov	DWORD PTR tv72[rsp], 0
$LN4@IsNavInput:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsNavInputPressedAnyOfTwo@ImGui@@YA_NHHW4ImGuiInputReadMode@@@Z ENDP ; ImGui::IsNavInputPressedAnyOfTwo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z
_TEXT	SEGMENT
tv68 = 32
n$ = 64
mode$ = 72
?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z PROC ; ImGui::IsNavInputPressed, COMDAT

; 1421 :     inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@IsNavInput
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@IsNavInput
$LN3@IsNavInput:
	mov	DWORD PTR tv68[rsp], 0
$LN4@IsNavInput:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ENDP ; ImGui::IsNavInputPressed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsNavInputDown@ImGui@@YA_NH@Z
_TEXT	SEGMENT
tv70 = 0
n$ = 32
?IsNavInputDown@ImGui@@YA_NH@Z PROC			; ImGui::IsNavInputDown, COMDAT

; 1420 :     inline bool             IsNavInputDown(ImGuiNavInput n) { return GImGui->IO.NavInputs[n] > 0.0f; }

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rcx+rax*4+848]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@IsNavInput
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@IsNavInput
$LN3@IsNavInput:
	mov	DWORD PTR tv70[rsp], 0
$LN4@IsNavInput:
	movzx	eax, BYTE PTR tv70[rsp]
	add	rsp, 24
	ret	0
?IsNavInputDown@ImGui@@YA_NH@Z ENDP			; ImGui::IsNavInputDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsKeyPressedMap@ImGui@@YA_NH_N@Z
_TEXT	SEGMENT
tv73 = 32
key_index$ = 36
key$ = 64
repeat$ = 72
?IsKeyPressedMap@ImGui@@YA_NH_N@Z PROC			; ImGui::IsKeyPressedMap, COMDAT

; 1419 :     inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true) { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	movsxd	rax, DWORD PTR key$[rsp]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	eax, DWORD PTR [rcx+rax*4+60]
	mov	DWORD PTR key_index$[rsp], eax
	cmp	DWORD PTR key_index$[rsp], 0
	jl	SHORT $LN3@IsKeyPress
	movzx	edx, BYTE PTR repeat$[rsp]
	mov	ecx, DWORD PTR key_index$[rsp]
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	mov	BYTE PTR tv73[rsp], al
	jmp	SHORT $LN4@IsKeyPress
$LN3@IsKeyPress:
	mov	BYTE PTR tv73[rsp], 0
$LN4@IsKeyPress:
	movzx	eax, BYTE PTR tv73[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsKeyPressedMap@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsKeyPressedMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
id$ = 80
nav_layer$ = 88
rect_rel$ = 96
?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z PROC	; ImGui::SetNavIDWithRectRel

; 1732 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 1733 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1734 : 	SetNavID(id, nav_layer);

	mov	edx, DWORD PTR nav_layer$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetNavID@ImGui@@YAXIH@Z		; ImGui::SetNavID

; 1735 : 	g.NavWindow->NavRectRel[nav_layer] = rect_rel;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	movsxd	rcx, DWORD PTR nav_layer$[rsp]
	imul	rcx, rcx, 16
	lea	rdi, QWORD PTR [rax+rcx+912]
	mov	rsi, QWORD PTR rect_rel$[rsp]
	mov	ecx, 16
	rep movsb

; 1736 : 	g.NavMousePosDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7142], 1

; 1737 : 	g.NavDisableHighlight = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 0

; 1738 : 	g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1

; 1739 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z ENDP	; ImGui::SetNavIDWithRectRel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
id$ = 32
nav_layer$ = 40
?SetNavID@ImGui@@YAXIH@Z PROC				; ImGui::SetNavID

; 1723 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1724 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1725 : 	IM_ASSERT(g.NavWindow);
; 1726 : 	IM_ASSERT(nav_layer == 0 || nav_layer == 1);
; 1727 : 	g.NavId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7040], ecx

; 1728 : 	g.NavWindow->NavLastIds[nav_layer] = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	movsxd	rcx, DWORD PTR nav_layer$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+rcx*4+904], edx

; 1729 : }

	add	rsp, 24
	ret	0
?SetNavID@ImGui@@YAXIH@Z ENDP				; ImGui::SetNavID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
id$ = 32
?ActivateItem@ImGui@@YAXI@Z PROC			; ImGui::ActivateItem

; 5557 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 5558 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5559 : 	g.NavNextActivateId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7056], ecx

; 5560 : }

	add	rsp, 24
	ret	0
?ActivateItem@ImGui@@YAXI@Z ENDP			; ImGui::ActivateItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
count$ = 0
tv77 = 4
t$ = 32
t_prev$ = 40
repeat_delay$ = 48
repeat_rate$ = 56
?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z PROC	; ImGui::CalcTypematicPressedRepeatAmount

; 3148 : {

$LN8:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 3149 : 	if (t == 0.0f)

	movss	xmm0, DWORD PTR t$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@CalcTypema
	jne	SHORT $LN2@CalcTypema

; 3150 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@CalcTypema
$LN2@CalcTypema:

; 3151 : 	if (t <= repeat_delay || repeat_rate <= 0.0f)

	movss	xmm0, DWORD PTR repeat_delay$[rsp]
	comiss	xmm0, DWORD PTR t$[rsp]
	jae	SHORT $LN4@CalcTypema
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR repeat_rate$[rsp]
	jb	SHORT $LN3@CalcTypema
$LN4@CalcTypema:

; 3152 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CalcTypema
$LN3@CalcTypema:

; 3153 : 	const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);

	movss	xmm0, DWORD PTR t$[rsp]
	subss	xmm0, DWORD PTR repeat_delay$[rsp]
	divss	xmm0, DWORD PTR repeat_rate$[rsp]
	cvttss2si eax, xmm0
	movss	xmm0, DWORD PTR t_prev$[rsp]
	subss	xmm0, DWORD PTR repeat_delay$[rsp]
	divss	xmm0, DWORD PTR repeat_rate$[rsp]
	cvttss2si ecx, xmm0
	sub	eax, ecx
	mov	DWORD PTR count$[rsp], eax

; 3154 : 	return (count > 0) ? count : 0;

	cmp	DWORD PTR count$[rsp], 0
	jle	SHORT $LN6@CalcTypema
	mov	eax, DWORD PTR count$[rsp]
	mov	DWORD PTR tv77[rsp], eax
	jmp	SHORT $LN7@CalcTypema
$LN6@CalcTypema:
	mov	DWORD PTR tv77[rsp], 0
$LN7@CalcTypema:
	mov	eax, DWORD PTR tv77[rsp]
$LN1@CalcTypema:

; 3155 : }

	add	rsp, 24
	ret	0
?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ENDP	; ImGui::CalcTypematicPressedRepeatAmount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
delta$ = 32
tv72 = 40
tv80 = 44
tv91 = 48
tv89 = 52
tv130 = 56
tv138 = 60
tv149 = 64
tv147 = 68
tv156 = 72
tv164 = 76
tv175 = 80
tv173 = 84
$T1 = 88
$T2 = 96
$T3 = 104
__$ReturnUdt$ = 128
dir_sources$ = 136
mode$ = 144
slow_factor$ = 152
fast_factor$ = 160
?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z PROC ; ImGui::GetNavInputAmount2d

; 6642 : {

$LN10:
	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 6643 : 	ImVec2 delta(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR delta$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 6644 : 	if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)

	mov	eax, DWORD PTR dir_sources$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN2@GetNavInpu

; 6645 : 		delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode) - GetNavInputAmount(ImGuiNavInput_KeyLeft_, mode), GetNavInputAmount(ImGuiNavInput_KeyDown_, mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_, mode));

	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 20
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv72[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 19
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv72[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv91[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 18
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv80[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 17
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv80[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv89[rsp], xmm0
	movss	xmm2, DWORD PTR tv91[rsp]
	movss	xmm1, DWORD PTR tv89[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR delta$[rsp]
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1
$LN2@GetNavInpu:

; 6646 : 	if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)

	mov	eax, DWORD PTR dir_sources$[rsp]
	and	eax, 2
	test	eax, eax
	je	$LN3@GetNavInpu

; 6647 : 		delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode) - GetNavInputAmount(ImGuiNavInput_DpadLeft, mode), GetNavInputAmount(ImGuiNavInput_DpadDown, mode) - GetNavInputAmount(ImGuiNavInput_DpadUp, mode));

	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 7
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv130[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 6
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv130[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv149[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 5
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv138[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 4
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv138[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv147[rsp], xmm0
	movss	xmm2, DWORD PTR tv149[rsp]
	movss	xmm1, DWORD PTR tv147[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR delta$[rsp]
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1
$LN3@GetNavInpu:

; 6648 : 	if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)

	mov	eax, DWORD PTR dir_sources$[rsp]
	and	eax, 4
	test	eax, eax
	je	$LN4@GetNavInpu

; 6649 : 		delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));

	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 11
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv156[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 10
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv156[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv175[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 9
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	DWORD PTR tv164[rsp], xmm0
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, 8
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	movss	xmm1, DWORD PTR tv164[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv173[rsp], xmm0
	movss	xmm2, DWORD PTR tv175[rsp]
	movss	xmm1, DWORD PTR tv173[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR delta$[rsp]
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1
$LN4@GetNavInpu:

; 6650 : 	if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))

	movss	xmm0, DWORD PTR slow_factor$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN9@GetNavInpu
	je	SHORT $LN5@GetNavInpu
$LN9@GetNavInpu:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@GetNavInpu

; 6651 : 		delta *= slow_factor;

	movss	xmm1, DWORD PTR slow_factor$[rsp]
	lea	rcx, QWORD PTR delta$[rsp]
	call	??X@YAAEAUImVec2@@AEAU0@M@Z		; operator*=
	npad	1
$LN5@GetNavInpu:

; 6652 : 	if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))

	movss	xmm0, DWORD PTR fast_factor$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN8@GetNavInpu
	je	SHORT $LN6@GetNavInpu
$LN8@GetNavInpu:
	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@GetNavInpu

; 6653 : 		delta *= fast_factor;

	movss	xmm1, DWORD PTR fast_factor$[rsp]
	lea	rcx, QWORD PTR delta$[rsp]
	call	??X@YAAEAUImVec2@@AEAU0@M@Z		; operator*=
	npad	1
$LN6@GetNavInpu:

; 6654 : 	return delta;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR delta$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 6655 : }

	add	rsp, 120				; 00000078H
	ret	0
?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ENDP ; ImGui::GetNavInputAmount2d
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
t$ = 32
tv83 = 36
tv87 = 40
tv132 = 44
tv148 = 48
tv164 = 52
g$ = 56
n$ = 80
mode$ = 88
?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z PROC ; ImGui::GetNavInputAmount

; 6620 : {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 6621 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6622 : 	if (mode == ImGuiInputReadMode_Down)

	cmp	DWORD PTR mode$[rsp], 0
	jne	SHORT $LN2@GetNavInpu

; 6623 : 		return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+848]
	jmp	$LN1@GetNavInpu
$LN2@GetNavInpu:

; 6624 : 
; 6625 : 	const float t = g.IO.NavInputsDownDuration[n];

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+3220]
	movss	DWORD PTR t$[rsp], xmm0

; 6626 : 	if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR t$[rsp]
	jbe	SHORT $LN3@GetNavInpu
	cmp	DWORD PTR mode$[rsp], 2
	jne	SHORT $LN3@GetNavInpu

; 6627 : 		return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+5372]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN10@GetNavInpu
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv83[rsp], xmm0
	jmp	SHORT $LN11@GetNavInpu
$LN10@GetNavInpu:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv83[rsp], xmm0
$LN11@GetNavInpu:
	movss	xmm0, DWORD PTR tv83[rsp]
	jmp	$LN1@GetNavInpu
$LN3@GetNavInpu:

; 6628 : 	if (t < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR t$[rsp]
	jbe	SHORT $LN4@GetNavInpu

; 6629 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@GetNavInpu
$LN4@GetNavInpu:

; 6630 : 	if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.

	cmp	DWORD PTR mode$[rsp], 1
	jne	SHORT $LN5@GetNavInpu

; 6631 : 		return (t == 0.0f) ? 1.0f : 0.0f;

	movss	xmm0, DWORD PTR t$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN12@GetNavInpu
	jne	SHORT $LN12@GetNavInpu
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv87[rsp], xmm0
	jmp	SHORT $LN13@GetNavInpu
$LN12@GetNavInpu:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv87[rsp], xmm0
$LN13@GetNavInpu:
	movss	xmm0, DWORD PTR tv87[rsp]
	jmp	$LN1@GetNavInpu
$LN5@GetNavInpu:

; 6632 : 	if (mode == ImGuiInputReadMode_Repeat)

	cmp	DWORD PTR mode$[rsp], 3
	jne	SHORT $LN6@GetNavInpu

; 6633 : 		return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+168]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+152]
	mulss	xmm1, DWORD PTR __real@3f4ccccd
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR t$[rsp]
	subss	xmm2, DWORD PTR [rax+48]
	movss	DWORD PTR tv132[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv132[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR t$[rsp]
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	cvtsi2ss xmm0, eax
	jmp	$LN1@GetNavInpu
$LN6@GetNavInpu:

; 6634 : 	if (mode == ImGuiInputReadMode_RepeatSlow)

	cmp	DWORD PTR mode$[rsp], 4
	jne	SHORT $LN7@GetNavInpu

; 6635 : 		return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+168]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+152]
	mulss	xmm1, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR t$[rsp]
	subss	xmm2, DWORD PTR [rax+48]
	movss	DWORD PTR tv148[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv148[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR t$[rsp]
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	cvtsi2ss xmm0, eax
	jmp	SHORT $LN1@GetNavInpu
$LN7@GetNavInpu:

; 6636 : 	if (mode == ImGuiInputReadMode_RepeatFast)

	cmp	DWORD PTR mode$[rsp], 5
	jne	SHORT $LN8@GetNavInpu

; 6637 : 		return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+168]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+152]
	mulss	xmm1, DWORD PTR __real@3f4ccccd
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR t$[rsp]
	subss	xmm2, DWORD PTR [rax+48]
	movss	DWORD PTR tv164[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv164[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR t$[rsp]
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	cvtsi2ss xmm0, eax
	jmp	SHORT $LN1@GetNavInpu
$LN8@GetNavInpu:

; 6638 : 	return 0.0f;

	xorps	xmm0, xmm0
$LN1@GetNavInpu:

; 6639 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ENDP ; ImGui::GetNavInputAmount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
clip_dir$ = 32
g$ = 40
bb_rel$ = 48
window$ = 96
move_flags$ = 104
?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z PROC ; ImGui::NavMoveRequestTryWrapping

; 6506 : {

$LN13:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 6507 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6508 : 	if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+7024], rcx
	jne	SHORT $LN3@NavMoveReq
	call	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@NavMoveReq
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7272], 0
	jne	SHORT $LN3@NavMoveReq
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	je	SHORT $LN2@NavMoveReq
$LN3@NavMoveReq:

; 6509 : 		return;

	jmp	$LN1@NavMoveReq
$LN2@NavMoveReq:

; 6510 : 	IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
; 6511 : 	ImRect bb_rel = window->NavRectRel[0];

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, QWORD PTR bb_rel$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+912]
	mov	ecx, 16
	rep movsb

; 6512 : 
; 6513 : 	ImGuiDir clip_dir = g.NavMoveDir;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7276]
	mov	DWORD PTR clip_dir$[rsp], eax

; 6514 : 	if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	jne	$LN4@NavMoveReq
	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 5
	test	eax, eax
	je	$LN4@NavMoveReq

; 6515 : 	{
; 6516 : 		bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+92]
	movss	DWORD PTR bb_rel$[rsp+8], xmm0
	movss	xmm0, DWORD PTR bb_rel$[rsp+8]
	movss	DWORD PTR bb_rel$[rsp], xmm0

; 6517 : 		if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }

	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN5@NavMoveReq
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?TranslateY@ImRect@@QEAAXM@Z		; ImRect::TranslateY
	mov	DWORD PTR clip_dir$[rsp], 2
$LN5@NavMoveReq:

; 6518 : 		NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);

	mov	r9d, DWORD PTR move_flags$[rsp]
	lea	r8, QWORD PTR bb_rel$[rsp]
	mov	edx, DWORD PTR clip_dir$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7276]
	call	?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z ; ImGui::NavMoveRequestForward
	npad	1
$LN4@NavMoveReq:

; 6519 : 	}
; 6520 : 	if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 1
	jne	SHORT $LN6@NavMoveReq
	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN6@NavMoveReq

; 6521 : 	{
; 6522 : 		bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+92]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR bb_rel$[rsp+8], xmm0
	movss	xmm0, DWORD PTR bb_rel$[rsp+8]
	movss	DWORD PTR bb_rel$[rsp], xmm0

; 6523 : 		if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }

	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN7@NavMoveReq
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?TranslateY@ImRect@@QEAAXM@Z		; ImRect::TranslateY
	mov	DWORD PTR clip_dir$[rsp], 3
$LN7@NavMoveReq:

; 6524 : 		NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);

	mov	r9d, DWORD PTR move_flags$[rsp]
	lea	r8, QWORD PTR bb_rel$[rsp]
	mov	edx, DWORD PTR clip_dir$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7276]
	call	?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z ; ImGui::NavMoveRequestForward
	npad	1
$LN6@NavMoveReq:

; 6525 : 	}
; 6526 : 	if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 2
	jne	$LN8@NavMoveReq
	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 10
	test	eax, eax
	je	$LN8@NavMoveReq

; 6527 : 	{
; 6528 : 		bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+96]
	movss	DWORD PTR bb_rel$[rsp+12], xmm0
	movss	xmm0, DWORD PTR bb_rel$[rsp+12]
	movss	DWORD PTR bb_rel$[rsp+4], xmm0

; 6529 : 		if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }

	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN9@NavMoveReq
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?TranslateX@ImRect@@QEAAXM@Z		; ImRect::TranslateX
	mov	DWORD PTR clip_dir$[rsp], 0
$LN9@NavMoveReq:

; 6530 : 		NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);

	mov	r9d, DWORD PTR move_flags$[rsp]
	lea	r8, QWORD PTR bb_rel$[rsp]
	mov	edx, DWORD PTR clip_dir$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7276]
	call	?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z ; ImGui::NavMoveRequestForward
	npad	1
$LN8@NavMoveReq:

; 6531 : 	}
; 6532 : 	if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 3
	jne	SHORT $LN10@NavMoveReq
	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 10
	test	eax, eax
	je	SHORT $LN10@NavMoveReq

; 6533 : 	{
; 6534 : 		bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR bb_rel$[rsp+12], xmm0
	movss	xmm0, DWORD PTR bb_rel$[rsp+12]
	movss	DWORD PTR bb_rel$[rsp+4], xmm0

; 6535 : 		if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }

	mov	eax, DWORD PTR move_flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN11@NavMoveReq
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb_rel$[rsp]
	call	?TranslateX@ImRect@@QEAAXM@Z		; ImRect::TranslateX
	mov	DWORD PTR clip_dir$[rsp], 1
$LN11@NavMoveReq:

; 6536 : 		NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);

	mov	r9d, DWORD PTR move_flags$[rsp]
	lea	r8, QWORD PTR bb_rel$[rsp]
	mov	edx, DWORD PTR clip_dir$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7276]
	call	?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z ; ImGui::NavMoveRequestForward
	npad	1
$LN10@NavMoveReq:
$LN1@NavMoveReq:

; 6537 : 	}
; 6538 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z ENDP ; ImGui::NavMoveRequestTryWrapping
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
move_dir$ = 80
clip_dir$ = 88
bb_rel$ = 96
move_flags$ = 104
?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z PROC	; ImGui::NavMoveRequestForward

; 6494 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 6495 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6496 : 	IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);
; 6497 : 	ImGui::NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel

; 6498 : 	g.NavMoveDir = move_dir;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR move_dir$[rsp]
	mov	DWORD PTR [rax+7276], ecx

; 6499 : 	g.NavMoveClipDir = clip_dir;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR clip_dir$[rsp]
	mov	DWORD PTR [rax+7284], ecx

; 6500 : 	g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7272], 1

; 6501 : 	g.NavMoveRequestFlags = move_flags;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR move_flags$[rsp]
	mov	DWORD PTR [rax+7172], ecx

; 6502 : 	g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	movsxd	rcx, DWORD PTR [rcx+7132]
	imul	rcx, rcx, 16
	lea	rdi, QWORD PTR [rax+rcx+912]
	mov	rsi, QWORD PTR bb_rel$[rsp]
	mov	ecx, 16
	rep movsb

; 6503 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z ENDP	; ImGui::NavMoveRequestForward
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
?NavMoveRequestCancel@ImGui@@YAXXZ PROC			; ImGui::NavMoveRequestCancel

; 6487 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 6488 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6489 : 	g.NavMoveRequest = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7171], 0

; 6490 : 	NavUpdateAnyRequestFlag();

	call	?NavUpdateAnyRequestFlag@ImGui@@YAXXZ	; ImGui::NavUpdateAnyRequestFlag
	npad	1

; 6491 : }

	add	rsp, 56					; 00000038H
	ret	0
?NavMoveRequestCancel@ImGui@@YAXXZ ENDP			; ImGui::NavMoveRequestCancel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv73 = 0
g$ = 8
?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ PROC	; ImGui::NavMoveRequestButNoResultYet

; 6481 : {

$LN5:
	sub	rsp, 24

; 6482 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6483 : 	return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN3@NavMoveReq
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7176], 0
	jne	SHORT $LN3@NavMoveReq
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7288], 0
	jne	SHORT $LN3@NavMoveReq
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN4@NavMoveReq
$LN3@NavMoveReq:
	mov	DWORD PTR tv73[rsp], 0
$LN4@NavMoveReq:
	movzx	eax, BYTE PTR tv73[rsp]

; 6484 : }

	add	rsp, 24
	ret	0
?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ENDP	; ImGui::NavMoveRequestButNoResultYet
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
init_for_nav$ = 32
g$ = 40
$T1 = 48
window$ = 96
force_reinit$ = 104
?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z PROC	; ImGui::NavInitWindow

; 6577 : {

$LN8:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 6578 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6579 : 	IM_ASSERT(window == g.NavWindow);
; 6580 : 	bool init_for_nav = false;

	mov	BYTE PTR init_for_nav$[rsp], 0

; 6581 : 	if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	SHORT $LN2@NavInitWin

; 6582 : 		if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN4@NavInitWin
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $LN4@NavInitWin
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rcx+rax+904], 0
	je	SHORT $LN4@NavInitWin
	movzx	eax, BYTE PTR force_reinit$[rsp]
	test	eax, eax
	je	SHORT $LN3@NavInitWin
$LN4@NavInitWin:

; 6583 : 			init_for_nav = true;

	mov	BYTE PTR init_for_nav$[rsp], 1
$LN3@NavInitWin:
$LN2@NavInitWin:

; 6584 : 	if (init_for_nav)

	movzx	eax, BYTE PTR init_for_nav$[rsp]
	test	eax, eax
	je	SHORT $LN5@NavInitWin

; 6585 : 	{
; 6586 : 		SetNavID(0, g.NavLayer);

	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+7132]
	xor	ecx, ecx
	call	?SetNavID@ImGui@@YAXIH@Z		; ImGui::SetNavID

; 6587 : 		g.NavInitRequest = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 1

; 6588 : 		g.NavInitRequestFromMove = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7169], 0

; 6589 : 		g.NavInitResultId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7148], 0

; 6590 : 		g.NavInitResultRectRel = ImRect();

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rcx+7152]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 6591 : 		NavUpdateAnyRequestFlag();

	call	?NavUpdateAnyRequestFlag@ImGui@@YAXXZ	; ImGui::NavUpdateAnyRequestFlag
	npad	1

; 6592 : 	}

	jmp	SHORT $LN6@NavInitWin
$LN5@NavInitWin:

; 6593 : 	else
; 6594 : 	{
; 6595 : 		g.NavId = window->NavLastIds[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rdx+rax+904]
	mov	DWORD PTR [rcx+7040], eax
$LN6@NavInitWin:

; 6596 : 	}
; 6597 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z ENDP	; ImGui::NavInitWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
dir$1 = 32
n$2 = 36
dir$3 = 40
n$4 = 44
pos$5 = 48
tv76 = 56
tv83 = 60
tv181 = 64
tv188 = 68
tv228 = 72
tv234 = 76
tv241 = 80
tv247 = 84
tv262 = 88
tv263 = 92
tv272 = 96
tv273 = 100
pos$ = 104
tv292 = 112
tv290 = 116
tv310 = 120
tv308 = 124
avail_w$6 = 128
avail_h$7 = 132
pos$8 = 136
base_pos_clamped$ = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 176
$T13 = 184
$T14 = 192
$T15 = 200
dir_prefered_order$16 = 216
dir_prefered_order$ = 232
__$ArrayPad$ = 248
__$ReturnUdt$ = 272
ref_pos$ = 280
size$ = 288
last_dir$ = 296
r_outer$ = 304
r_avoid$ = 312
policy$ = 320
?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z PROC ; ImGui::FindBestWindowPosForPopupEx

; 6142 : {

$LN43:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6143 : 	ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);

	mov	rax, QWORD PTR r_outer$[rsp]
	add	rax, 8
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, QWORD PTR r_outer$[rsp]
	mov	r9, QWORD PTR [rax]
	mov	r8, rcx
	mov	rdx, QWORD PTR ref_pos$[rsp]
	lea	rcx, QWORD PTR base_pos_clamped$[rsp]
	call	?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z	; ImClamp
	npad	1

; 6144 : 	//GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
; 6145 : 	//GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));
; 6146 : 
; 6147 : 	// Combo Box policy (we want a connecting edge)
; 6148 : 	if (policy == ImGuiPopupPositionPolicy_ComboBox)

	cmp	DWORD PTR policy$[rsp], 1
	jne	$LN8@FindBestWi

; 6149 : 	{
; 6150 : 		const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };

	mov	DWORD PTR dir_prefered_order$16[rsp], 3
	mov	DWORD PTR dir_prefered_order$16[rsp+4], 1
	mov	DWORD PTR dir_prefered_order$16[rsp+8], 0
	mov	DWORD PTR dir_prefered_order$16[rsp+12], 2

; 6151 : 		for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)

	mov	rax, QWORD PTR last_dir$[rsp]
	cmp	DWORD PTR [rax], -1
	je	SHORT $LN19@FindBestWi
	mov	DWORD PTR tv76[rsp], -1
	jmp	SHORT $LN20@FindBestWi
$LN19@FindBestWi:
	mov	DWORD PTR tv76[rsp], 0
$LN20@FindBestWi:
	mov	eax, DWORD PTR tv76[rsp]
	mov	DWORD PTR n$2[rsp], eax
	jmp	SHORT $LN4@FindBestWi
$LN2@FindBestWi:
	mov	eax, DWORD PTR n$2[rsp]
	inc	eax
	mov	DWORD PTR n$2[rsp], eax
$LN4@FindBestWi:
	cmp	DWORD PTR n$2[rsp], 4
	jge	$LN3@FindBestWi

; 6152 : 		{
; 6153 : 			const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];

	cmp	DWORD PTR n$2[rsp], -1
	jne	SHORT $LN21@FindBestWi
	mov	rax, QWORD PTR last_dir$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv83[rsp], eax
	jmp	SHORT $LN22@FindBestWi
$LN21@FindBestWi:
	movsxd	rax, DWORD PTR n$2[rsp]
	mov	eax, DWORD PTR dir_prefered_order$16[rsp+rax*4]
	mov	DWORD PTR tv83[rsp], eax
$LN22@FindBestWi:
	mov	eax, DWORD PTR tv83[rsp]
	mov	DWORD PTR dir$3[rsp], eax

; 6154 : 			if (n != -1 && dir == *last_dir) // Already tried this direction?

	cmp	DWORD PTR n$2[rsp], -1
	je	SHORT $LN9@FindBestWi
	mov	rax, QWORD PTR last_dir$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR dir$3[rsp], eax
	jne	SHORT $LN9@FindBestWi

; 6155 : 				continue;

	jmp	SHORT $LN2@FindBestWi
$LN9@FindBestWi:

; 6156 : 			ImVec2 pos;

	lea	rcx, QWORD PTR pos$5[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 6157 : 			if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)

	cmp	DWORD PTR dir$3[rsp], 3
	jne	SHORT $LN10@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$5[rsp], rax
$LN10@FindBestWi:

; 6158 : 			if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right

	cmp	DWORD PTR dir$3[rsp], 1
	jne	SHORT $LN11@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$5[rsp], rax
$LN11@FindBestWi:

; 6159 : 			if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left

	cmp	DWORD PTR dir$3[rsp], 0
	jne	SHORT $LN12@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$5[rsp], rax
$LN12@FindBestWi:

; 6160 : 			if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left

	cmp	DWORD PTR dir$3[rsp], 2
	jne	SHORT $LN13@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR r_avoid$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$5[rsp], rax
$LN13@FindBestWi:

; 6161 : 			if (!r_outer.Contains(ImRect(pos, pos + size)))

	mov	r8, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR pos$5[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$5[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	rdx, rax
	mov	rcx, QWORD PTR r_outer$[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@FindBestWi

; 6162 : 				continue;

	jmp	$LN2@FindBestWi
$LN14@FindBestWi:

; 6163 : 			*last_dir = dir;

	mov	rax, QWORD PTR last_dir$[rsp]
	mov	ecx, DWORD PTR dir$3[rsp]
	mov	DWORD PTR [rax], ecx

; 6164 : 			return pos;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR pos$5[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@FindBestWi

; 6165 : 		}

	jmp	$LN2@FindBestWi
$LN3@FindBestWi:
$LN8@FindBestWi:

; 6166 : 	}
; 6167 : 
; 6168 : 	// Default popup policy
; 6169 : 	const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };

	mov	DWORD PTR dir_prefered_order$[rsp], 1
	mov	DWORD PTR dir_prefered_order$[rsp+4], 3
	mov	DWORD PTR dir_prefered_order$[rsp+8], 2
	mov	DWORD PTR dir_prefered_order$[rsp+12], 0

; 6170 : 	for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)

	mov	rax, QWORD PTR last_dir$[rsp]
	cmp	DWORD PTR [rax], -1
	je	SHORT $LN23@FindBestWi
	mov	DWORD PTR tv181[rsp], -1
	jmp	SHORT $LN24@FindBestWi
$LN23@FindBestWi:
	mov	DWORD PTR tv181[rsp], 0
$LN24@FindBestWi:
	mov	eax, DWORD PTR tv181[rsp]
	mov	DWORD PTR n$4[rsp], eax
	jmp	SHORT $LN7@FindBestWi
$LN5@FindBestWi:
	mov	eax, DWORD PTR n$4[rsp]
	inc	eax
	mov	DWORD PTR n$4[rsp], eax
$LN7@FindBestWi:
	cmp	DWORD PTR n$4[rsp], 4
	jge	$LN6@FindBestWi

; 6171 : 	{
; 6172 : 		const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];

	cmp	DWORD PTR n$4[rsp], -1
	jne	SHORT $LN25@FindBestWi
	mov	rax, QWORD PTR last_dir$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv188[rsp], eax
	jmp	SHORT $LN26@FindBestWi
$LN25@FindBestWi:
	movsxd	rax, DWORD PTR n$4[rsp]
	mov	eax, DWORD PTR dir_prefered_order$[rsp+rax*4]
	mov	DWORD PTR tv188[rsp], eax
$LN26@FindBestWi:
	mov	eax, DWORD PTR tv188[rsp]
	mov	DWORD PTR dir$1[rsp], eax

; 6173 : 		if (n != -1 && dir == *last_dir) // Already tried this direction?

	cmp	DWORD PTR n$4[rsp], -1
	je	SHORT $LN15@FindBestWi
	mov	rax, QWORD PTR last_dir$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR dir$1[rsp], eax
	jne	SHORT $LN15@FindBestWi

; 6174 : 			continue;

	jmp	SHORT $LN5@FindBestWi
$LN15@FindBestWi:

; 6175 : 		float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);

	cmp	DWORD PTR dir$1[rsp], 0
	jne	SHORT $LN27@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv228[rsp], xmm0
	jmp	SHORT $LN28@FindBestWi
$LN27@FindBestWi:
	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR tv228[rsp], xmm0
$LN28@FindBestWi:
	cmp	DWORD PTR dir$1[rsp], 1
	jne	SHORT $LN29@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR tv234[rsp], xmm0
	jmp	SHORT $LN30@FindBestWi
$LN29@FindBestWi:
	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv234[rsp], xmm0
$LN30@FindBestWi:
	movss	xmm0, DWORD PTR tv228[rsp]
	subss	xmm0, DWORD PTR tv234[rsp]
	movss	DWORD PTR avail_w$6[rsp], xmm0

; 6176 : 		float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);

	cmp	DWORD PTR dir$1[rsp], 2
	jne	SHORT $LN31@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv241[rsp], xmm0
	jmp	SHORT $LN32@FindBestWi
$LN31@FindBestWi:
	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv241[rsp], xmm0
$LN32@FindBestWi:
	cmp	DWORD PTR dir$1[rsp], 3
	jne	SHORT $LN33@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv247[rsp], xmm0
	jmp	SHORT $LN34@FindBestWi
$LN33@FindBestWi:
	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv247[rsp], xmm0
$LN34@FindBestWi:
	movss	xmm0, DWORD PTR tv241[rsp]
	subss	xmm0, DWORD PTR tv247[rsp]
	movss	DWORD PTR avail_h$7[rsp], xmm0

; 6177 : 		if (avail_w < size.x || avail_h < size.y)

	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR avail_w$6[rsp]
	ja	SHORT $LN17@FindBestWi
	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR avail_h$7[rsp]
	jbe	SHORT $LN16@FindBestWi
$LN17@FindBestWi:

; 6178 : 			continue;

	jmp	$LN5@FindBestWi
$LN16@FindBestWi:

; 6179 : 		ImVec2 pos;

	lea	rcx, QWORD PTR pos$8[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 6180 : 		pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;

	cmp	DWORD PTR dir$1[rsp], 0
	jne	SHORT $LN37@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR tv263[rsp], xmm0
	jmp	SHORT $LN38@FindBestWi
$LN37@FindBestWi:
	cmp	DWORD PTR dir$1[rsp], 1
	jne	SHORT $LN35@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR tv262[rsp], xmm0
	jmp	SHORT $LN36@FindBestWi
$LN35@FindBestWi:
	movss	xmm0, DWORD PTR base_pos_clamped$[rsp]
	movss	DWORD PTR tv262[rsp], xmm0
$LN36@FindBestWi:
	movss	xmm0, DWORD PTR tv262[rsp]
	movss	DWORD PTR tv263[rsp], xmm0
$LN38@FindBestWi:
	movss	xmm0, DWORD PTR tv263[rsp]
	movss	DWORD PTR pos$8[rsp], xmm0

; 6181 : 		pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;

	cmp	DWORD PTR dir$1[rsp], 2
	jne	SHORT $LN41@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR tv273[rsp], xmm0
	jmp	SHORT $LN42@FindBestWi
$LN41@FindBestWi:
	cmp	DWORD PTR dir$1[rsp], 3
	jne	SHORT $LN39@FindBestWi
	mov	rax, QWORD PTR r_avoid$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv272[rsp], xmm0
	jmp	SHORT $LN40@FindBestWi
$LN39@FindBestWi:
	movss	xmm0, DWORD PTR base_pos_clamped$[rsp+4]
	movss	DWORD PTR tv272[rsp], xmm0
$LN40@FindBestWi:
	movss	xmm0, DWORD PTR tv272[rsp]
	movss	DWORD PTR tv273[rsp], xmm0
$LN42@FindBestWi:
	movss	xmm0, DWORD PTR tv273[rsp]
	movss	DWORD PTR pos$8[rsp+4], xmm0

; 6182 : 		*last_dir = dir;

	mov	rax, QWORD PTR last_dir$[rsp]
	mov	ecx, DWORD PTR dir$1[rsp]
	mov	DWORD PTR [rax], ecx

; 6183 : 		return pos;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR pos$8[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@FindBestWi

; 6184 : 	}

	jmp	$LN5@FindBestWi
$LN6@FindBestWi:

; 6185 : 
; 6186 : 	// Fallback, try to keep within display
; 6187 : 	*last_dir = ImGuiDir_None;

	mov	rax, QWORD PTR last_dir$[rsp]
	mov	DWORD PTR [rax], -1

; 6188 : 	ImVec2 pos = ref_pos;

	mov	rax, QWORD PTR ref_pos$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$[rsp], rax

; 6189 : 	pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);

	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv292[rsp], xmm0
	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR size$[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv290[rsp], xmm0
	movss	xmm1, DWORD PTR tv292[rsp]
	movss	xmm0, DWORD PTR tv290[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pos$[rsp], xmm0

; 6190 : 	pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);

	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv310[rsp], xmm0
	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR [rax+4]
	mov	rax, QWORD PTR r_outer$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR size$[rsp]
	subss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv308[rsp], xmm0
	movss	xmm1, DWORD PTR tv310[rsp]
	movss	xmm0, DWORD PTR tv308[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pos$[rsp+4], xmm0

; 6191 : 	return pos;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@FindBestWi:

; 6192 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	ret	0
?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ENDP ; ImGui::FindBestWindowPosForPopupEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
parent_window$1 = 64
ref_pos$2 = 72
g$ = 80
horizontal_overlap$3 = 88
sc$4 = 92
tv92 = 96
tv140 = 100
tv138 = 104
tv190 = 108
tv226 = 112
tv239 = 116
pos$5 = 120
tv77 = 128
r_avoid$6 = 136
r_avoid$7 = 152
r_outer$ = 168
$T8 = 184
$T9 = 192
r_avoid$10 = 200
$T11 = 216
$T12 = 232
$T13 = 248
$T14 = 264
__$ReturnUdt$ = 320
window$ = 328
?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z PROC ; ImGui::FindBestWindowPosForPopup

; 6195 : {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 296				; 00000128H

; 6196 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6197 : 
; 6198 : 	ImRect r_outer = GetWindowAllowedExtentRect(window);

	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR r_outer$[rsp]
	call	?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z ; ImGui::GetWindowAllowedExtentRect
	npad	1

; 6199 : 	if (window->Flags & ImGuiWindowFlags_ChildMenu)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	$LN2@FindBestWi

; 6200 : 	{
; 6201 : 		// Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
; 6202 : 		// This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
; 6203 : 		IM_ASSERT(g.CurrentWindow == window);
; 6204 : 		ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6672]
	sub	eax, 2
	mov	edx, eax
	mov	rcx, QWORD PTR tv77[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR parent_window$1[rsp], rax

; 6205 : 		float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5548]
	movss	DWORD PTR horizontal_overlap$3[rsp], xmm0

; 6206 : 		ImRect r_avoid;

	lea	rcx, QWORD PTR r_avoid$6[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	npad	1

; 6207 : 		if (parent_window->DC.MenuBarAppending)

	mov	rax, QWORD PTR parent_window$1[rsp]
	movzx	eax, BYTE PTR [rax+457]
	test	eax, eax
	je	$LN3@FindBestWi

; 6208 : 			r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());

	mov	rcx, QWORD PTR parent_window$1[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	mov	rax, QWORD PTR parent_window$1[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv92[rsp], xmm0
	mov	rcx, QWORD PTR parent_window$1[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv92[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv140[rsp], xmm0
	mov	rcx, QWORD PTR parent_window$1[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	mov	rax, QWORD PTR parent_window$1[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv138[rsp], xmm0
	movss	xmm0, DWORD PTR tv140[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@7f7fffff
	movss	xmm2, DWORD PTR tv138[rsp]
	movss	xmm1, DWORD PTR __real@ff7fffff
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	lea	rcx, QWORD PTR r_avoid$6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	SHORT $LN4@FindBestWi
$LN3@FindBestWi:

; 6209 : 		else
; 6210 : 			r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);

	mov	rax, QWORD PTR parent_window$1[rsp]
	mov	rcx, QWORD PTR parent_window$1[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx]
	subss	xmm0, DWORD PTR horizontal_overlap$3[rsp]
	mov	rax, QWORD PTR parent_window$1[rsp]
	subss	xmm0, DWORD PTR [rax+124]
	mov	rax, QWORD PTR parent_window$1[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	addss	xmm1, DWORD PTR horizontal_overlap$3[rsp]
	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rsp+32], xmm2
	movaps	xmm3, xmm0
	movss	xmm2, DWORD PTR __real@ff7fffff
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	lea	rcx, QWORD PTR r_avoid$6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN4@FindBestWi:

; 6211 : 		return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 184				; 000000b8H
	mov	rcx, QWORD PTR window$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	add	rdx, 48					; 00000030H
	mov	DWORD PTR [rsp+48], 0
	lea	rdi, QWORD PTR r_avoid$6[rsp]
	mov	QWORD PTR [rsp+40], rdi
	lea	rdi, QWORD PTR r_outer$[rsp]
	mov	QWORD PTR [rsp+32], rdi
	mov	r9, rax
	mov	r8, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@FindBestWi
$LN2@FindBestWi:

; 6212 : 	}
; 6213 : 	if (window->Flags & ImGuiWindowFlags_Popup)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$LN5@FindBestWi

; 6214 : 	{
; 6215 : 		ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	addss	xmm1, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	subss	xmm2, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm3, DWORD PTR [rax+48]
	subss	xmm3, DWORD PTR __real@3f800000
	movss	DWORD PTR tv190[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv190[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR r_avoid$10[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect

; 6216 : 		return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 184				; 000000b8H
	mov	rcx, QWORD PTR window$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	add	rdx, 48					; 00000030H
	mov	DWORD PTR [rsp+48], 0
	lea	rdi, QWORD PTR r_avoid$10[rsp]
	mov	QWORD PTR [rsp+40], rdi
	lea	rdi, QWORD PTR r_outer$[rsp]
	mov	QWORD PTR [rsp+32], rdi
	mov	r9, rax
	mov	r8, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@FindBestWi
$LN5@FindBestWi:

; 6217 : 	}
; 6218 : 	if (window->Flags & ImGuiWindowFlags_Tooltip)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	$LN6@FindBestWi

; 6219 : 	{
; 6220 : 		// Position tooltip (always follows mouse)
; 6221 : 		float sc = g.Style.MouseCursorScale;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5628]
	movss	DWORD PTR sc$4[rsp], xmm0

; 6222 : 		ImVec2 ref_pos = NavCalcPreferredRefPos();

	lea	rcx, QWORD PTR ref_pos$2[rsp]
	call	?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::NavCalcPreferredRefPos

; 6223 : 		ImRect r_avoid;

	lea	rcx, QWORD PTR r_avoid$7[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	npad	1

; 6224 : 		if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	$LN7@FindBestWi
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	$LN7@FindBestWi
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN7@FindBestWi

; 6225 : 			r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);

	movss	xmm0, DWORD PTR ref_pos$2[rsp+4]
	addss	xmm0, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR ref_pos$2[rsp]
	addss	xmm1, DWORD PTR __real@41800000
	movss	xmm2, DWORD PTR ref_pos$2[rsp+4]
	subss	xmm2, DWORD PTR __real@41000000
	movss	xmm3, DWORD PTR ref_pos$2[rsp]
	subss	xmm3, DWORD PTR __real@41800000
	movss	DWORD PTR tv226[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv226[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	lea	rcx, QWORD PTR r_avoid$7[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN8@FindBestWi
$LN7@FindBestWi:

; 6226 : 		else
; 6227 : 			r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.

	movss	xmm0, DWORD PTR __real@41c00000
	mulss	xmm0, DWORD PTR sc$4[rsp]
	movss	xmm1, DWORD PTR ref_pos$2[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@41c00000
	mulss	xmm1, DWORD PTR sc$4[rsp]
	movss	xmm2, DWORD PTR ref_pos$2[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movss	xmm2, DWORD PTR ref_pos$2[rsp+4]
	subss	xmm2, DWORD PTR __real@41000000
	movss	xmm3, DWORD PTR ref_pos$2[rsp]
	subss	xmm3, DWORD PTR __real@41800000
	movss	DWORD PTR tv239[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv239[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	lea	rcx, QWORD PTR r_avoid$7[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN8@FindBestWi:

; 6228 : 		ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 184				; 000000b8H
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rsp+48], 0
	lea	rdx, QWORD PTR r_avoid$7[rsp]
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR r_outer$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, rax
	mov	r8, rcx
	lea	rdx, QWORD PTR ref_pos$2[rsp]
	lea	rcx, QWORD PTR pos$5[rsp]
	call	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
	npad	1

; 6229 : 		if (window->AutoPosLastDirection == ImGuiDir_None)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+184], -1
	jne	SHORT $LN9@FindBestWi

; 6230 : 			pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.

	movss	xmm2, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR ref_pos$2[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pos$5[rsp], rax
$LN9@FindBestWi:

; 6231 : 		return pos;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR pos$5[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@FindBestWi
$LN6@FindBestWi:

; 6232 : 	}
; 6233 : 	IM_ASSERT(0);
; 6234 : 	return window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@FindBestWi:

; 6235 : }

	add	rsp, 296				; 00000128H
	pop	rdi
	pop	rsi
	ret	0
?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ENDP ; ImGui::FindBestWindowPosForPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
n$1 = 0
popup$2 = 8
g$ = 16
?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ PROC ; ImGui::GetFrontMostPopupModal

; 5856 : {

$LN8:
	sub	rsp, 40					; 00000028H

; 5857 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5858 : 	for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	dec	eax
	mov	DWORD PTR n$1[rsp], eax
	jmp	SHORT $LN4@GetFrontMo
$LN2@GetFrontMo:
	mov	eax, DWORD PTR n$1[rsp]
	dec	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@GetFrontMo:
	cmp	DWORD PTR n$1[rsp], 0
	jl	SHORT $LN3@GetFrontMo

; 5859 : 		if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+6880]
	mov	rax, QWORD PTR [rcx+rax+16]
	mov	QWORD PTR popup$2[rsp], rax
	cmp	QWORD PTR popup$2[rsp], 0
	je	SHORT $LN5@GetFrontMo

; 5860 : 			if (popup->Flags & ImGuiWindowFlags_Modal)

	mov	rax, QWORD PTR popup$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN6@GetFrontMo

; 5861 : 				return popup;

	mov	rax, QWORD PTR popup$2[rsp]
	jmp	SHORT $LN1@GetFrontMo
$LN6@GetFrontMo:
$LN5@GetFrontMo:
	jmp	SHORT $LN2@GetFrontMo
$LN3@GetFrontMo:

; 5862 : 	return NULL;

	xor	eax, eax
$LN1@GetFrontMo:

; 5863 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ENDP ; ImGui::GetFrontMostPopupModal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv82 = 32
window$1 = 40
flags$ = 48
g$ = 56
window_name$ = 64
__$ArrayPad$ = 80
extra_flags$ = 112
override_previous_tooltip$ = 120
?BeginTooltipEx@ImGui@@YAXH_N@Z PROC			; ImGui::BeginTooltipEx

; 5797 : {

$LN6:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5798 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5799 : 	char window_name[16];
; 5800 : 	ImFormatString(window_name, IM_ARRAYSIZE(window_name), ("##+-Tooip+-_%02d"), g.TooltipOverrideCount);

	mov	rax, QWORD PTR g$[rsp]
	mov	r9d, DWORD PTR [rax+11700]
	lea	r8, OFFSET FLAT:??_C@_0BB@PMCDEDKJ@?$CD?$CD?$CL?9Tooip?$CL?9_?$CF02d@
	mov	edx, 16
	lea	rcx, QWORD PTR window_name$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1

; 5801 : 	if (override_previous_tooltip)

	movzx	eax, BYTE PTR override_previous_tooltip$[rsp]
	test	eax, eax
	je	SHORT $LN2@BeginToolt

; 5802 : 		if (ImGuiWindow* window = FindWindowByName(window_name))

	lea	rcx, QWORD PTR window_name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR window$1[rsp], rax
	cmp	QWORD PTR window$1[rsp], 0
	je	SHORT $LN3@BeginToolt

; 5803 : 			if (window->Active)

	mov	rax, QWORD PTR window$1[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN4@BeginToolt

; 5804 : 			{
; 5805 : 				// Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
; 5806 : 				window->Hidden = true;

	mov	rax, QWORD PTR window$1[rsp]
	mov	BYTE PTR [rax+140], 1

; 5807 : 				window->HiddenFramesRegular = 1;

	mov	rax, QWORD PTR window$1[rsp]
	mov	DWORD PTR [rax+188], 1

; 5808 : 				ImFormatString(window_name, IM_ARRAYSIZE(window_name), ("##+-Tooip+-_%02d"), ++g.TooltipOverrideCount);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11700]
	inc	eax
	mov	DWORD PTR tv82[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv82[rsp]
	mov	DWORD PTR [rax+11700], ecx
	mov	r9d, DWORD PTR tv82[rsp]
	lea	r8, OFFSET FLAT:??_C@_0BB@PMCDEDKJ@?$CD?$CD?$CL?9Tooip?$CL?9_?$CF02d@
	mov	edx, 16
	lea	rcx, QWORD PTR window_name$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN4@BeginToolt:
$LN3@BeginToolt:
$LN2@BeginToolt:

; 5809 : 			}
; 5810 : 	ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize |/*ImGuiWindowFlags_NoSavedSettings|*/ImGuiWindowFlags_AlwaysAutoResize;

	mov	DWORD PTR flags$[rsp], 34341447		; 020c0247H

; 5811 : 	Begin(window_name, NULL, flags | extra_flags);

	mov	eax, DWORD PTR extra_flags$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	r8d, eax
	xor	edx, edx
	lea	rcx, QWORD PTR window_name$[rsp]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	npad	1

; 5812 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?BeginTooltipEx@ImGui@@YAXH_N@Z ENDP			; ImGui::BeginTooltipEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
is_open$ = 32
g$ = 40
name$ = 48
__$ArrayPad$ = 72
id$ = 96
extra_flags$ = 104
?BeginPopupEx@ImGui@@YA_NIH@Z PROC			; ImGui::BeginPopupEx

; 6022 : {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6023 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6024 : 	if (!IsPopupOpen(id))

	mov	ecx, DWORD PTR id$[rsp]
	call	?IsPopupOpen@ImGui@@YA_NI@Z		; ImGui::IsPopupOpen
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@BeginPopup

; 6025 : 	{
; 6026 : 		g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6912				; 00001b00H
	mov	rcx, rax
	call	?Clear@ImGuiNextWindowData@@QEAAXXZ	; ImGuiNextWindowData::Clear

; 6027 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginPopup
$LN2@BeginPopup:

; 6028 : 	}
; 6029 : 
; 6030 : 	char name[20];
; 6031 : 	if (extra_flags & ImGuiWindowFlags_ChildMenu)

	mov	eax, DWORD PTR extra_flags$[rsp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN3@BeginPopup

; 6032 : 		ImFormatString(name, IM_ARRAYSIZE(name), ("##+-M.e.n.u_+-%02d"), g.BeginPopupStack.Size); // Recycle windows based on depth

	mov	rax, QWORD PTR g$[rsp]
	mov	r9d, DWORD PTR [rax+6888]
	lea	r8, OFFSET FLAT:??_C@_0BD@IMJHKMJC@?$CD?$CD?$CL?9M?4e?4n?4u_?$CL?9?$CF02d@
	mov	edx, 20
	lea	rcx, QWORD PTR name$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
	jmp	SHORT $LN4@BeginPopup
$LN3@BeginPopup:

; 6033 : 	else
; 6034 : 		ImFormatString(name, IM_ARRAYSIZE(name), ("##+-P.o.p.u.p_+-%08x"), id); // Not recycling, so we can close/open during the same frame

	mov	r9d, DWORD PTR id$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0BF@DKJDPJG@?$CD?$CD?$CL?9P?4o?4p?4u?4p_?$CL?9?$CF08x@
	mov	edx, 20
	lea	rcx, QWORD PTR name$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN4@BeginPopup:

; 6035 : 
; 6036 : 	bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);

	mov	eax, DWORD PTR extra_flags$[rsp]
	bts	eax, 26
	mov	r8d, eax
	xor	edx, edx
	lea	rcx, QWORD PTR name$[rsp]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	mov	BYTE PTR is_open$[rsp], al

; 6037 : 	if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN5@BeginPopup

; 6038 : 		EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1
$LN5@BeginPopup:

; 6039 : 
; 6040 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
$LN1@BeginPopup:

; 6041 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
?BeginPopupEx@ImGui@@YA_NIH@Z ENDP			; ImGui::BeginPopupEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv79 = 32
g$ = 40
tv76 = 48
id$ = 80
?IsPopupOpen@ImGui@@YA_NI@Z PROC			; ImGui::IsPopupOpen

; 5844 : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 5845 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5846 : 	return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6888]
	cmp	DWORD PTR [rax+6872], ecx
	jle	SHORT $LN3@IsPopupOpe
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6888]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN3@IsPopupOpe
	mov	DWORD PTR tv79[rsp], 1
	jmp	SHORT $LN4@IsPopupOpe
$LN3@IsPopupOpe:
	mov	DWORD PTR tv79[rsp], 0
$LN4@IsPopupOpe:
	movzx	eax, BYTE PTR tv79[rsp]

; 5847 : }

	add	rsp, 72					; 00000048H
	ret	0
?IsPopupOpen@ImGui@@YA_NI@Z ENDP			; ImGui::IsPopupOpen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
popup_or_descendent_has_focus$1 = 32
popup_count_to_keep$ = 36
m$2 = 40
g$ = 48
popup$3 = 56
tv79 = 64
tv129 = 72
tv137 = 80
ref_window$ = 112
?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::ClosePopupsOverWindow

; 5931 : {

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 5932 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5933 : 	if (g.OpenPopupStack.empty())

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ ; ImVector<ImGuiPopupRef>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@ClosePopup

; 5934 : 		return;

	jmp	$LN1@ClosePopup
$LN8@ClosePopup:

; 5935 : 
; 5936 : 	// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
; 5937 : 	// Don't close our own child popup windows.
; 5938 : 	int popup_count_to_keep = 0;

	mov	DWORD PTR popup_count_to_keep$[rsp], 0

; 5939 : 	if (ref_window)

	cmp	QWORD PTR ref_window$[rsp], 0
	je	$LN9@ClosePopup

; 5940 : 	{
; 5941 : 		// Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
; 5942 : 		for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)

	jmp	SHORT $LN4@ClosePopup
$LN2@ClosePopup:
	mov	eax, DWORD PTR popup_count_to_keep$[rsp]
	inc	eax
	mov	DWORD PTR popup_count_to_keep$[rsp], eax
$LN4@ClosePopup:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	cmp	DWORD PTR popup_count_to_keep$[rsp], eax
	jge	$LN3@ClosePopup

; 5943 : 		{
; 5944 : 			ImGuiPopupRef& popup = g.OpenPopupStack[popup_count_to_keep];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv79[rsp], rax
	mov	edx, DWORD PTR popup_count_to_keep$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	QWORD PTR popup$3[rsp], rax

; 5945 : 			if (!popup.Window)

	mov	rax, QWORD PTR popup$3[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN10@ClosePopup

; 5946 : 				continue;

	jmp	SHORT $LN2@ClosePopup
$LN10@ClosePopup:

; 5947 : 			IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
; 5948 : 			if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)

	mov	rax, QWORD PTR popup$3[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN11@ClosePopup

; 5949 : 				continue;

	jmp	SHORT $LN2@ClosePopup
$LN11@ClosePopup:

; 5950 : 
; 5951 : 			// Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)
; 5952 : 			bool popup_or_descendent_has_focus = false;

	mov	BYTE PTR popup_or_descendent_has_focus$1[rsp], 0

; 5953 : 			for (int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_has_focus; m++)

	mov	eax, DWORD PTR popup_count_to_keep$[rsp]
	mov	DWORD PTR m$2[rsp], eax
	jmp	SHORT $LN7@ClosePopup
$LN5@ClosePopup:
	mov	eax, DWORD PTR m$2[rsp]
	inc	eax
	mov	DWORD PTR m$2[rsp], eax
$LN7@ClosePopup:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	cmp	DWORD PTR m$2[rsp], eax
	jge	SHORT $LN6@ClosePopup
	movzx	eax, BYTE PTR popup_or_descendent_has_focus$1[rsp]
	test	eax, eax
	jne	SHORT $LN6@ClosePopup

; 5954 : 				if (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv129[rsp], rax
	mov	edx, DWORD PTR m$2[rsp]
	mov	rcx, QWORD PTR tv129[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN12@ClosePopup
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv137[rsp], rax
	mov	edx, DWORD PTR m$2[rsp]
	mov	rcx, QWORD PTR tv137[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR ref_window$[rsp]
	mov	rcx, QWORD PTR [rcx+688]
	cmp	QWORD PTR [rax+688], rcx
	jne	SHORT $LN12@ClosePopup

; 5955 : 					popup_or_descendent_has_focus = true;

	mov	BYTE PTR popup_or_descendent_has_focus$1[rsp], 1
$LN12@ClosePopup:
	jmp	$LN5@ClosePopup
$LN6@ClosePopup:

; 5956 : 			if (!popup_or_descendent_has_focus)

	movzx	eax, BYTE PTR popup_or_descendent_has_focus$1[rsp]
	test	eax, eax
	jne	SHORT $LN13@ClosePopup

; 5957 : 				break;

	jmp	SHORT $LN3@ClosePopup
$LN13@ClosePopup:

; 5958 : 		}

	jmp	$LN2@ClosePopup
$LN3@ClosePopup:
$LN9@ClosePopup:

; 5959 : 	}
; 5960 : 	if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	cmp	DWORD PTR popup_count_to_keep$[rsp], eax
	jge	SHORT $LN14@ClosePopup

; 5961 : 	{
; 5962 : 		//IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
; 5963 : 		ClosePopupToLevel(popup_count_to_keep, false);

	xor	edx, edx
	mov	ecx, DWORD PTR popup_count_to_keep$[rsp]
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
	npad	1
$LN14@ClosePopup:
$LN1@ClosePopup:

; 5964 : 	}
; 5965 : }

	add	rsp, 104				; 00000068H
	ret	0
?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::ClosePopupsOverWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
focus_window$ = 40
tv80 = 48
tv71 = 56
tv78 = 64
tv85 = 72
remaining$ = 96
apply_focus_to_window_under$ = 104
?ClosePopupToLevel@ImGui@@YAXH_N@Z PROC			; ImGui::ClosePopupToLevel

; 5968 : {

$LN7:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 5969 : 	IM_ASSERT(remaining >= 0);
; 5970 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5971 : 	ImGuiWindow* focus_window = (remaining > 0) ? g.OpenPopupStack[remaining - 1].Window : g.OpenPopupStack[0].ParentWindow;

	cmp	DWORD PTR remaining$[rsp], 0
	jle	SHORT $LN5@ClosePopup
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv71[rsp], rax
	mov	eax, DWORD PTR remaining$[rsp]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv71[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN6@ClosePopup
$LN5@ClosePopup:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv78[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv78[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR tv80[rsp], rax
$LN6@ClosePopup:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR focus_window$[rsp], rax

; 5972 : 	g.OpenPopupStack.resize(remaining);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv85[rsp], rax
	mov	edx, DWORD PTR remaining$[rsp]
	mov	rcx, QWORD PTR tv85[rsp]
	call	?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ; ImVector<ImGuiPopupRef>::resize
	npad	1

; 5973 : 
; 5974 : 	// FIXME: This code is faulty and we may want to eventually to replace or remove the 'apply_focus_to_window_under=true' path completely.
; 5975 : 	// Instead of using g.OpenPopupStack[remaining-1].Window etc. we should find the highest root window that is behind the popups we are closing.
; 5976 : 	// The current code will set focus to the parent of the popup window which is incorrect.
; 5977 : 	// It rarely manifested until now because UpdateMouseMovingWindowNewFrame() would call FocusWindow() again on the clicked window,
; 5978 : 	// leading to a chain of focusing A (clicked window) then B (parent window of the popup) then A again.
; 5979 : 	// However if the clicked window has the _NoMove flag set we would be left with B focused.
; 5980 : 	// For now, we have disabled this path when called from ClosePopupsOverWindow() because the users of ClosePopupsOverWindow() don't need to alter focus anyway,
; 5981 : 	// but we should inspect and fix this properly.
; 5982 : 	if (apply_focus_to_window_under)

	movzx	eax, BYTE PTR apply_focus_to_window_under$[rsp]
	test	eax, eax
	je	SHORT $LN2@ClosePopup

; 5983 : 	{
; 5984 : 		if (g.NavLayer == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	jne	SHORT $LN3@ClosePopup

; 5985 : 			focus_window = NavRestoreLastChildNavWindow(focus_window);

	mov	rcx, QWORD PTR focus_window$[rsp]
	call	?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z ; ImGui::NavRestoreLastChildNavWindow
	mov	QWORD PTR focus_window$[rsp], rax
$LN3@ClosePopup:

; 5986 : 		FocusWindow(focus_window);

	mov	rcx, QWORD PTR focus_window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN2@ClosePopup:

; 5987 : 	}
; 5988 : }

	add	rsp, 88					; 00000058H
	ret	0
?ClosePopupToLevel@ImGui@@YAXH_N@Z ENDP			; ImGui::ClosePopupToLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
current_stack_size$ = 32
g$ = 40
parent_window$ = 48
tv83 = 56
$T1 = 64
tv93 = 72
tv131 = 80
tv139 = 88
tv149 = 96
tv156 = 104
tv162 = 112
popup_ref$ = 120
$T2 = 168
$T3 = 176
id$ = 256
?OpenPopupEx@ImGui@@YAXI@Z PROC				; ImGui::OpenPopupEx

; 5876 : {

$LN9:
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 5877 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5878 : 	ImGuiWindow* parent_window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR parent_window$[rsp], rax

; 5879 : 	int current_stack_size = g.BeginPopupStack.Size;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6888]
	mov	DWORD PTR current_stack_size$[rsp], eax

; 5880 : 	ImGuiPopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.

	lea	rcx, QWORD PTR popup_ref$[rsp]
	call	??0ImGuiPopupRef@@QEAA@XZ

; 5881 : 	popup_ref.PopupId = id;

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR popup_ref$[rsp], eax

; 5882 : 	popup_ref.Window = NULL;

	mov	QWORD PTR popup_ref$[rsp+16], 0

; 5883 : 	popup_ref.ParentWindow = parent_window;

	mov	rax, QWORD PTR parent_window$[rsp]
	mov	QWORD PTR popup_ref$[rsp+40], rax

; 5884 : 	popup_ref.OpenFrameCount = g.FrameCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6552]
	mov	DWORD PTR popup_ref$[rsp+24], eax

; 5885 : 	popup_ref.OpenParentId = parent_window->IDStack.back();

	mov	rax, QWORD PTR parent_window$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR popup_ref$[rsp+4], eax

; 5886 : 	popup_ref.OpenPopupPos = NavCalcPreferredRefPos();

	lea	rcx, QWORD PTR $T2[rsp]
	call	?NavCalcPreferredRefPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::NavCalcPreferredRefPos
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR popup_ref$[rsp+8], rax

; 5887 : 	popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@OpenPopupE
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv83[rsp], rax
	jmp	SHORT $LN8@OpenPopupE
$LN7@OpenPopupE:
	lea	rax, QWORD PTR popup_ref$[rsp+8]
	mov	QWORD PTR tv83[rsp], rax
$LN8@OpenPopupE:
	mov	rax, QWORD PTR tv83[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR popup_ref$[rsp+28], rax

; 5888 : 
; 5889 : 	//IMGUI_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);
; 5890 : 	if (g.OpenPopupStack.Size < current_stack_size + 1)

	mov	eax, DWORD PTR current_stack_size$[rsp]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rcx+6872], eax
	jge	SHORT $LN2@OpenPopupE

; 5891 : 	{
; 5892 : 		g.OpenPopupStack.push_back(popup_ref);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv93[rsp], rax
	lea	rdx, QWORD PTR popup_ref$[rsp]
	mov	rcx, QWORD PTR tv93[rsp]
	call	?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z ; ImVector<ImGuiPopupRef>::push_back
	npad	1

; 5893 : 	}

	jmp	$LN3@OpenPopupE
$LN2@OpenPopupE:

; 5894 : 	else
; 5895 : 	{
; 5896 : 		// Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
; 5897 : 		// would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
; 5898 : 		// situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
; 5899 : 		if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv131[rsp], rax
	mov	edx, DWORD PTR current_stack_size$[rsp]
	mov	rcx, QWORD PTR tv131[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN4@OpenPopupE
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv139[rsp], rax
	mov	edx, DWORD PTR current_stack_size$[rsp]
	mov	rcx, QWORD PTR tv139[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	dec	ecx
	cmp	DWORD PTR [rax+24], ecx
	jne	SHORT $LN4@OpenPopupE

; 5900 : 		{
; 5901 : 			g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv149[rsp], rax
	mov	edx, DWORD PTR current_stack_size$[rsp]
	mov	rcx, QWORD PTR tv149[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	ecx, DWORD PTR popup_ref$[rsp+24]
	mov	DWORD PTR [rax+24], ecx

; 5902 : 		}

	jmp	SHORT $LN5@OpenPopupE
$LN4@OpenPopupE:

; 5903 : 		else
; 5904 : 		{
; 5905 : 			// Close child popups if any, then flag popup for open/reopen
; 5906 : 			g.OpenPopupStack.resize(current_stack_size + 1);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv156[rsp], rax
	mov	eax, DWORD PTR current_stack_size$[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv156[rsp]
	call	?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ; ImVector<ImGuiPopupRef>::resize
	npad	1

; 5907 : 			g.OpenPopupStack[current_stack_size] = popup_ref;

	lea	rax, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR popup_ref$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 48					; 00000030H
	rep movsb
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv162[rsp], rax
	mov	edx, DWORD PTR current_stack_size$[rsp]
	mov	rcx, QWORD PTR tv162[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	lea	rcx, QWORD PTR $T3[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 48					; 00000030H
	rep movsb
$LN5@OpenPopupE:
$LN3@OpenPopupE:

; 5908 : 		}
; 5909 : 
; 5910 : 		// When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
; 5911 : 		// This is equivalent to what ClosePopupToLevel() does.
; 5912 : 		//if (g.OpenPopupStack[current_stack_size].PopupId == id)
; 5913 : 		//    FocusWindow(parent_window);
; 5914 : 	}
; 5915 : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?OpenPopupEx@ImGui@@YAXI@Z ENDP				; ImGui::OpenPopupEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv80 = 32
window$ = 40
?PopItemFlag@ImGui@@YAXXZ PROC				; ImGui::PopItemFlag

; 4827 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 4828 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4829 : 	window->DC.ItemFlagsStack.pop_back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 520				; 00000208H
	mov	rcx, rax
	call	?pop_back@?$ImVector@H@@QEAAXXZ		; ImVector<int>::pop_back

; 4830 : 	window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 520				; 00000208H
	mov	rcx, rax
	call	?empty@?$ImVector@H@@QEBA_NXZ		; ImVector<int>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PopItemFla
	mov	DWORD PTR tv80[rsp], 0
	jmp	SHORT $LN4@PopItemFla
$LN3@PopItemFla:
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 520				; 00000208H
	mov	rcx, rax
	call	?back@?$ImVector@H@@QEAAAEAHXZ		; ImVector<int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv80[rsp], eax
$LN4@PopItemFla:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv80[rsp]
	mov	DWORD PTR [rax+476], ecx

; 4831 : }

	add	rsp, 56					; 00000038H
	ret	0
?PopItemFlag@ImGui@@YAXXZ ENDP				; ImGui::PopItemFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv85 = 40
option$ = 64
enabled$ = 72
?PushItemFlag@ImGui@@YAXH_N@Z PROC			; ImGui::PushItemFlag

; 4817 : {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 4818 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4819 : 	if (enabled)

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN2@PushItemFl

; 4820 : 		window->DC.ItemFlags |= option;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR option$[rsp]
	mov	eax, DWORD PTR [rax+476]
	or	eax, ecx
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+476], eax
	jmp	SHORT $LN3@PushItemFl
$LN2@PushItemFl:

; 4821 : 	else
; 4822 : 		window->DC.ItemFlags &= ~option;

	mov	eax, DWORD PTR option$[rsp]
	not	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+476]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+476], eax
$LN3@PushItemFl:

; 4823 : 	window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 520				; 00000208H
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 476				; 000001dcH
	mov	rdx, rax
	mov	rcx, QWORD PTR tv85[rsp]
	call	?push_back@?$ImVector@H@@QEAAXAEBH@Z	; ImVector<int>::push_back
	npad	1

; 4824 : }

	add	rsp, 56					; 00000038H
	ret	0
?PushItemFlag@ImGui@@YAXH_N@Z ENDP			; ImGui::PushItemFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
w_item_one$ = 36
w_item_last$ = 40
window$ = 48
style$ = 56
tv132 = 64
tv141 = 72
components$ = 96
w_full$ = 104
?PushMultiItemsWidths@ImGui@@YAXHM@Z PROC		; ImGui::PushMultiItemsWidths

; 4749 : {

$LN7:
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 4750 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4751 : 	const ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 4752 : 	if (w_full <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR w_full$[rsp]
	jb	SHORT $LN5@PushMultiI

; 4753 : 		w_full = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR w_full$[rsp], xmm0
$LN5@PushMultiI:

; 4754 : 	const float w_item_one = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));

	mov	eax, DWORD PTR components$[rsp]
	dec	eax
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR w_full$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR components$[rsp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR w_item_one$[rsp], xmm0

; 4755 : 	const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR w_item_one$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	mov	eax, DWORD PTR components$[rsp]
	dec	eax
	cvtsi2ss xmm1, eax
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR w_full$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR w_item_last$[rsp], xmm0

; 4756 : 	window->DC.ItemWidthStack.push_back(w_item_last);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	QWORD PTR tv132[rsp], rax
	lea	rdx, QWORD PTR w_item_last$[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	?push_back@?$ImVector@M@@QEAAXAEBM@Z	; ImVector<float>::push_back
	npad	1

; 4757 : 	for (int i = 0; i < components - 1; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@PushMultiI
$LN2@PushMultiI:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@PushMultiI:
	mov	eax, DWORD PTR components$[rsp]
	dec	eax
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@PushMultiI

; 4758 : 		window->DC.ItemWidthStack.push_back(w_item_one);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	QWORD PTR tv141[rsp], rax
	lea	rdx, QWORD PTR w_item_one$[rsp]
	mov	rcx, QWORD PTR tv141[rsp]
	call	?push_back@?$ImVector@M@@QEAAXAEBM@Z	; ImVector<float>::push_back
	npad	1
	jmp	SHORT $LN2@PushMultiI
$LN3@PushMultiI:

; 4759 : 	window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	rcx, rax
	call	?back@?$ImVector@M@@QEAAAEAMXZ		; ImVector<float>::back
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx+512], xmm0

; 4760 : }

	add	rsp, 88					; 00000058H
	ret	0
?PushMultiItemsWidths@ImGui@@YAXHM@Z ENDP		; ImGui::PushMultiItemsWidths
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
pos$ = 64
wrap_pos_x$ = 72
?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z PROC	; ImGui::CalcWrapWidthForPos

; 2050 : {

$LN7:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2051 : 	if (wrap_pos_x < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	jbe	SHORT $LN2@CalcWrapWi

; 2052 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@CalcWrapWi
$LN2@CalcWrapWi:

; 2053 : 
; 2054 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 2055 : 	if (wrap_pos_x == 0.0f)

	movss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@CalcWrapWi
	jne	SHORT $LN3@CalcWrapWi

; 2056 : 		wrap_pos_x = GetContentRegionMax().x + window->Pos.x;

	lea	rcx, QWORD PTR $T1[rsp]
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR wrap_pos_x$[rsp], xmm0
	jmp	SHORT $LN4@CalcWrapWi
$LN3@CalcWrapWi:

; 2057 : 	else if (wrap_pos_x > 0.0f)

	movss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@CalcWrapWi

; 2058 : 		wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	subss	xmm0, DWORD PTR [rcx+92]
	movss	xmm1, DWORD PTR wrap_pos_x$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR wrap_pos_x$[rsp], xmm0
$LN5@CalcWrapWi:
$LN4@CalcWrapWi:

; 2059 : 
; 2060 : 	return ImMax(wrap_pos_x - pos.x, 1.0f);

	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	xmm1, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
$LN1@CalcWrapWi:

; 2061 : }

	add	rsp, 56					; 00000038H
	ret	0
?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z ENDP	; ImGui::CalcWrapWidthForPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv91 = 32
tv135 = 36
g$ = 40
content_max$ = 48
tv78 = 56
tv76 = 64
$T1 = 72
$T2 = 80
__$ReturnUdt$ = 112
size$ = 120
default_x$ = 128
default_y$ = 136
?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z PROC		; ImGui::CalcItemSize

; 2037 : {

$LN11:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2038 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2039 : 	ImVec2 content_max;

	lea	rcx, QWORD PTR content_max$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 2040 : 	if (size.x < 0.0f || size.y < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR size$[rsp]
	ja	SHORT $LN3@CalcItemSi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR size$[rsp+4]
	jbe	SHORT $LN2@CalcItemSi
$LN3@CalcItemSi:

; 2041 : 		content_max = g.CurrentWindow->Pos + GetContentRegionMax();

	lea	rcx, QWORD PTR $T1[rsp]
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR content_max$[rsp], rax
$LN2@CalcItemSi:

; 2042 : 	if (size.x <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR size$[rsp]
	jb	SHORT $LN4@CalcItemSi

; 2043 : 		size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;

	movss	xmm0, DWORD PTR size$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN7@CalcItemSi
	jne	SHORT $LN7@CalcItemSi
	movss	xmm0, DWORD PTR default_x$[rsp]
	movss	DWORD PTR tv91[rsp], xmm0
	jmp	SHORT $LN8@CalcItemSi
$LN7@CalcItemSi:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movss	xmm0, DWORD PTR content_max$[rsp]
	subss	xmm0, DWORD PTR [rax+340]
	movss	xmm1, DWORD PTR __real@40800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	addss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR tv91[rsp], xmm0
$LN8@CalcItemSi:
	movss	xmm0, DWORD PTR tv91[rsp]
	movss	DWORD PTR size$[rsp], xmm0
$LN4@CalcItemSi:

; 2044 : 	if (size.y <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR size$[rsp+4]
	jb	SHORT $LN5@CalcItemSi

; 2045 : 		size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;

	movss	xmm0, DWORD PTR size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN9@CalcItemSi
	jne	SHORT $LN9@CalcItemSi
	movss	xmm0, DWORD PTR default_y$[rsp]
	movss	DWORD PTR tv135[rsp], xmm0
	jmp	SHORT $LN10@CalcItemSi
$LN9@CalcItemSi:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movss	xmm0, DWORD PTR content_max$[rsp+4]
	subss	xmm0, DWORD PTR [rax+344]
	movss	xmm1, DWORD PTR __real@40800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	addss	xmm0, DWORD PTR size$[rsp+4]
	movss	DWORD PTR tv135[rsp], xmm0
$LN10@CalcItemSi:
	movss	xmm0, DWORD PTR tv135[rsp]
	movss	DWORD PTR size$[rsp+4], xmm0
$LN5@CalcItemSi:

; 2046 : 	return size;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2047 : }

	add	rsp, 104				; 00000068H
	ret	0
?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ENDP		; ImGui::CalcItemSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 8
?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::FocusableItemUnregister

; 2031 : {

	mov	QWORD PTR [rsp+8], rcx

; 2032 : 	window->FocusIdxAllCounter--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+944]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+944], eax

; 2033 : 	window->FocusIdxTabCounter--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+960]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+960], eax

; 2034 : }

	ret	0
?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::FocusableItemUnregister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
is_tab_stop$ = 32
tv68 = 33
tv134 = 36
tv137 = 40
g$ = 48
window$ = 80
id$ = 88
tab_stop$ = 96
?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z PROC ; ImGui::FocusableItemRegister

; 2006 : {

$LN13:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2007 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2008 : 
; 2009 : 	const bool is_tab_stop = (window->DC.ItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	and	eax, 5
	test	eax, eax
	jne	SHORT $LN7@FocusableI
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN8@FocusableI
$LN7@FocusableI:
	mov	BYTE PTR tv68[rsp], 0
$LN8@FocusableI:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_tab_stop$[rsp], al

; 2010 : 	window->FocusIdxAllCounter++;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+944]
	inc	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+944], eax

; 2011 : 	if (is_tab_stop)

	movzx	eax, BYTE PTR is_tab_stop$[rsp]
	test	eax, eax
	je	SHORT $LN2@FocusableI

; 2012 : 		window->FocusIdxTabCounter++;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+960]
	inc	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+960], eax
$LN2@FocusableI:

; 2013 : 
; 2014 : 	// Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.
; 2015 : 	// Note that we can always TAB out of a widget that doesn't allow tabbing in.
; 2016 : 	if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))

	movzx	eax, BYTE PTR tab_stop$[rsp]
	test	eax, eax
	je	$LN3@FocusableI
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN3@FocusableI
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+952], 2147483647		; 7fffffffH
	jne	$LN3@FocusableI
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+964], 2147483647		; 7fffffffH
	jne	SHORT $LN3@FocusableI
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	SHORT $LN3@FocusableI
	mov	dl, 1
	xor	ecx, ecx
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@FocusableI

; 2017 : 		window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN11@FocusableI
	movzx	eax, BYTE PTR is_tab_stop$[rsp]
	test	eax, eax
	je	SHORT $LN9@FocusableI
	mov	DWORD PTR tv134[rsp], -1
	jmp	SHORT $LN10@FocusableI
$LN9@FocusableI:
	mov	DWORD PTR tv134[rsp], 0
$LN10@FocusableI:
	mov	eax, DWORD PTR tv134[rsp]
	mov	DWORD PTR tv137[rsp], eax
	jmp	SHORT $LN12@FocusableI
$LN11@FocusableI:
	mov	DWORD PTR tv137[rsp], 1
$LN12@FocusableI:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+960]
	add	eax, DWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+964], eax
$LN3@FocusableI:

; 2018 : 
; 2019 : 	if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+948]
	cmp	DWORD PTR [rax+944], ecx
	jne	SHORT $LN4@FocusableI

; 2020 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@FocusableI
$LN4@FocusableI:

; 2021 : 	if (is_tab_stop && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)

	movzx	eax, BYTE PTR is_tab_stop$[rsp]
	test	eax, eax
	je	SHORT $LN5@FocusableI
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+956]
	cmp	DWORD PTR [rax+960], ecx
	jne	SHORT $LN5@FocusableI

; 2022 : 	{
; 2023 : 		g.NavJustTabbedId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7052], ecx

; 2024 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@FocusableI
$LN5@FocusableI:

; 2025 : 	}
; 2026 : 
; 2027 : 	return false;

	xor	al, al
$LN1@FocusableI:

; 2028 : }

	add	rsp, 72					; 00000048H
	ret	0
?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z ENDP ; ImGui::FocusableItemRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
bb$ = 64
id$ = 72
clip_even_when_logged$ = 80
?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z PROC		; ImGui::IsClippedEx

; 1995 : {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1996 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1997 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1998 : 	if (!bb.Overlaps(window->ClipRect))

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	rdx, rax
	mov	rcx, QWORD PTR bb$[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsClippedE

; 1999 : 		if (id == 0 || id != g.ActiveId)

	cmp	DWORD PTR id$[rsp], 0
	je	SHORT $LN4@IsClippedE
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6704]
	cmp	DWORD PTR id$[rsp], eax
	je	SHORT $LN3@IsClippedE
$LN4@IsClippedE:

; 2000 : 			if (clip_even_when_logged/* || !g.LogEnabled*/)

	movzx	eax, BYTE PTR clip_even_when_logged$[rsp]
	test	eax, eax
	je	SHORT $LN5@IsClippedE

; 2001 : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@IsClippedE
$LN5@IsClippedE:
$LN3@IsClippedE:
$LN2@IsClippedE:

; 2002 : 	return false;

	xor	al, al
$LN1@IsClippedE:

; 2003 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z ENDP		; ImGui::IsClippedEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
bb$ = 64
id$ = 72
?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z PROC		; ImGui::ItemHoverable

; 1973 : {

$LN10:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1974 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1975 : 	if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	je	SHORT $LN2@ItemHovera
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	je	SHORT $LN2@ItemHovera
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6700]
	test	eax, eax
	jne	SHORT $LN2@ItemHovera

; 1976 : 		return false;

	xor	al, al
	jmp	$LN1@ItemHovera
$LN2@ItemHovera:

; 1977 : 
; 1978 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1979 : 	if (g.HoveredWindow != window)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6560], rcx
	je	SHORT $LN3@ItemHovera

; 1980 : 		return false;

	xor	al, al
	jmp	$LN1@ItemHovera
$LN3@ItemHovera:

; 1981 : 	if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN4@ItemHovera
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN4@ItemHovera
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6753]
	test	eax, eax
	jne	SHORT $LN4@ItemHovera

; 1982 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@ItemHovera
$LN4@ItemHovera:

; 1983 : 	if (!IsMouseHoveringRect(bb.Min, bb.Max))

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR bb$[rsp]
	mov	r8b, 1
	mov	rdx, rax
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@ItemHovera

; 1984 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@ItemHovera
$LN5@ItemHovera:

; 1985 : 	if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	jne	SHORT $LN7@ItemHovera
	xor	edx, edx
	mov	rcx, QWORD PTR window$[rsp]
	call	?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z ; IsWindowContentHoverable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@ItemHovera
$LN7@ItemHovera:

; 1986 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@ItemHovera
$LN6@ItemHovera:

; 1987 : 	if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN8@ItemHovera

; 1988 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@ItemHovera
$LN8@ItemHovera:

; 1989 : 
; 1990 : 	SetHoveredID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID

; 1991 : 	return true;

	mov	al, 1
$LN1@ItemHovera:

; 1992 : }

	add	rsp, 56					; 00000038H
	ret	0
?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ENDP		; ImGui::ItemHoverable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
is_clipped$ = 32
tv128 = 36
window$ = 40
g$ = 48
tv92 = 56
$T1 = 64
bb$ = 112
id$ = 120
nav_bb_arg$ = 128
?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z PROC		; ImGui::ItemAdd

; 1889 : {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 1890 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1891 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1892 : 
; 1893 : 	if (id != 0)

	cmp	DWORD PTR id$[rsp], 0
	je	$LN2@ItemAdd

; 1894 : 	{
; 1895 : 		// Navigation processing runs prior to clipping early-out
; 1896 : 		//  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 1897 : 		//  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
; 1898 : 		//      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 1899 : 		//      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
; 1900 : 		window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+404]
	mov	eax, DWORD PTR [rax+424]
	or	eax, ecx
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+424], eax

; 1901 : 		if (g.NavId == id || g.NavAnyRequest)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	je	SHORT $LN4@ItemAdd
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7144]
	test	eax, eax
	je	$LN3@ItemAdd
$LN4@ItemAdd:

; 1902 : 			if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rcx+888]
	cmp	QWORD PTR [rax+888], rcx
	jne	$LN5@ItemAdd

; 1903 : 				if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	cmp	QWORD PTR window$[rsp], rax
	je	SHORT $LN7@ItemAdd
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, DWORD PTR [rcx+28]
	or	ecx, eax
	mov	eax, ecx
	and	eax, 8388608				; 00800000H
	test	eax, eax
	je	SHORT $LN6@ItemAdd
$LN7@ItemAdd:

; 1904 : 					NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR tv128[rsp], eax
	cmp	QWORD PTR nav_bb_arg$[rsp], 0
	je	SHORT $LN11@ItemAdd
	mov	rax, QWORD PTR nav_bb_arg$[rsp]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN12@ItemAdd
$LN11@ItemAdd:
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv92[rsp], rax
$LN12@ItemAdd:
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	r8d, DWORD PTR tv128[rsp]
	mov	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?NavProcessItem@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@I@Z ; ImGui::NavProcessItem
	npad	1
$LN6@ItemAdd:
$LN5@ItemAdd:
$LN3@ItemAdd:
$LN2@ItemAdd:

; 1905 : 	}
; 1906 : 
; 1907 : 	window->DC.LastItemId = id;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+412], ecx

; 1908 : 	window->DC.LastItemRect = bb;

	mov	rax, QWORD PTR window$[rsp]
	lea	rdi, QWORD PTR [rax+368]
	mov	rsi, QWORD PTR bb$[rsp]
	mov	ecx, 16
	rep movsb

; 1909 : 	window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+416], 0

; 1910 : 
; 1911 : #ifdef IMGUI_ENABLE_TEST_ENGINE
; 1912 : 	if (id != 0)
; 1913 : 		ImGuiTestEngineHook_ItemAdd(&g, nav_bb_arg ? *nav_bb_arg : bb, id);
; 1914 : #endif
; 1915 : 
; 1916 : 	// Clipping test
; 1917 : 	const bool is_clipped = IsClippedEx(bb, id, false);

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z ; ImGui::IsClippedEx
	mov	BYTE PTR is_clipped$[rsp], al

; 1918 : 	if (is_clipped)

	movzx	eax, BYTE PTR is_clipped$[rsp]
	test	eax, eax
	je	SHORT $LN8@ItemAdd

; 1919 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@ItemAdd
$LN8@ItemAdd:

; 1920 : 	//if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
; 1921 : 
; 1922 : 	// We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
; 1923 : 	if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR bb$[rsp]
	mov	r8b, 1
	mov	rdx, rax
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ItemAdd

; 1924 : 		window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	or	eax, 1
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+416], eax
$LN9@ItemAdd:

; 1925 : 	return true;

	mov	al, 1
$LN1@ItemAdd:

; 1926 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ENDP		; ImGui::ItemAdd
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
bb$ = 64
text_offset_y$ = 72
?ItemSize@ImGui@@YAXAEBUImRect@@M@Z PROC		; ImGui::ItemSize

; 1881 : {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1882 : 	ItemSize(bb.GetSize(), text_offset_y);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	movss	xmm1, DWORD PTR text_offset_y$[rsp]
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 1883 : }

	add	rsp, 56					; 00000038H
	ret	0
?ItemSize@ImGui@@YAXAEBUImRect@@M@Z ENDP		; ImGui::ItemSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
line_height$ = 32
text_base_offset$ = 36
window$ = 40
g$ = 48
$T1 = 56
size$ = 80
text_offset_y$ = 88
?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z PROC		; ImGui::ItemSize

; 1854 : {

$LN5:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1855 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1856 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1857 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@ItemSize

; 1858 : 		return;

	jmp	$LN1@ItemSize
$LN2@ItemSize:

; 1859 : 
; 1860 : 	// Always align ourselves on pixel boundaries
; 1861 : 	const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);

	mov	rax, QWORD PTR size$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+324]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR line_height$[rsp], xmm0

; 1862 : 	const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);

	movss	xmm1, DWORD PTR text_offset_y$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_base_offset$[rsp], xmm0

; 1863 : 	//if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
; 1864 : 	window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+340]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+344]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+348], rax

; 1865 : 	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+576]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 1866 : 	window->DC.CursorPos.y = (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR line_height$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5544]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+344], xmm0

; 1867 : 	window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+348]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+312], xmm0

; 1868 : 	window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR [rcx+5544]
	movaps	xmm1, xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+316], xmm0

; 1869 : 	//if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
; 1870 : 
; 1871 : 	window->DC.PrevLineSize.y = line_height;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR [rax+336], xmm0

; 1872 : 	window->DC.PrevLineTextBaseOffset = text_base_offset;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR text_base_offset$[rsp]
	movss	DWORD PTR [rax+356], xmm0

; 1873 : 	window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+328], xmm0
	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+324], xmm0

; 1874 : 
; 1875 : 	// Horizontal layout mode
; 1876 : 	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+468], 0
	jne	SHORT $LN3@ItemSize

; 1877 : 		SameLine();

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN3@ItemSize:
$LN1@ItemSize:

; 1878 : }

	add	rsp, 72					; 00000048H
	ret	0
?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z ENDP		; ImGui::ItemSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
id$ = 32
?MarkItemEdited@ImGui@@YAXI@Z PROC			; ImGui::MarkItemEdited

; 1821 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1822 : 	// This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
; 1823 : 	// ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
; 1824 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1825 : 	IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
; 1826 : 	IM_UNUSED(id); // Avoid unused variable warnings when asserts are compiled out.
; 1827 : 	//IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 1828 : 	g.ActiveIdHasBeenEdited = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6732], 1

; 1829 : 	g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	eax, DWORD PTR [rax+416]
	or	eax, 4
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+6584]
	mov	DWORD PTR [rcx+416], eax

; 1830 : }

	add	rsp, 24
	ret	0
?MarkItemEdited@ImGui@@YAXI@Z ENDP			; ImGui::MarkItemEdited
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
id$ = 32
?KeepAliveID@ImGui@@YAXI@Z PROC				; ImGui::KeepAliveID

; 1812 : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1813 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1814 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN2@KeepAliveI

; 1815 : 		g.ActiveIdIsAlive = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+6720], ecx
$LN2@KeepAliveI:

; 1816 : 	if (g.ActiveIdPreviousFrame == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6708], ecx
	jne	SHORT $LN3@KeepAliveI

; 1817 : 		g.ActiveIdPreviousFrameIsAlive = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6768], 1
$LN3@KeepAliveI:

; 1818 : }

	add	rsp, 24
	ret	0
?KeepAliveID@ImGui@@YAXI@Z ENDP				; ImGui::KeepAliveID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
id$ = 32
?SetHoveredID@ImGui@@YAXI@Z PROC			; ImGui::SetHoveredID

; 1797 : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1798 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1799 : 	g.HoveredId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+6696], ecx

; 1800 : 	g.HoveredIdAllowOverlap = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6700], 0

; 1801 : 	if (id != 0 && g.HoveredIdPreviousFrame != id)

	cmp	DWORD PTR id$[rsp], 0
	je	SHORT $LN2@SetHovered
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6724], ecx
	je	SHORT $LN2@SetHovered

; 1802 : 		g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6712], xmm0
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6728], xmm0
$LN2@SetHovered:

; 1803 : }

	add	rsp, 24
	ret	0
?SetHoveredID@ImGui@@YAXI@Z ENDP			; ImGui::SetHoveredID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv68 = 0
g$ = 8
?GetHoveredID@ImGui@@YAIXZ PROC				; ImGui::GetHoveredID

; 1806 : {

$LN5:
	sub	rsp, 24

; 1807 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1808 : 	return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	je	SHORT $LN3@GetHovered
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6696]
	mov	DWORD PTR tv68[rsp], eax
	jmp	SHORT $LN4@GetHovered
$LN3@GetHovered:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6724]
	mov	DWORD PTR tv68[rsp], eax
$LN4@GetHovered:
	mov	eax, DWORD PTR tv68[rsp]

; 1809 : }

	add	rsp, 24
	ret	0
?GetHoveredID@ImGui@@YAIXZ ENDP				; ImGui::GetHoveredID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?ClearActiveID@ImGui@@YAXXZ PROC			; ImGui::ClearActiveID

; 1792 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 1793 : 	SetActiveID(0, NULL);

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
	npad	1

; 1794 : }

	add	rsp, 40					; 00000028H
	ret	0
?ClearActiveID@ImGui@@YAXXZ ENDP			; ImGui::ClearActiveID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
nav_layer$ = 32
g$ = 40
tv138 = 48
tv136 = 56
$T1 = 64
$T2 = 72
$T3 = 80
id$ = 128
window$ = 136
?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z PROC		; ImGui::SetFocusID

; 1770 : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 1771 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1772 : 	IM_ASSERT(id != 0);
; 1773 : 
; 1774 : 	// Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
; 1775 : 	const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+400]
	mov	DWORD PTR nav_layer$[rsp], eax

; 1776 : 	if (g.NavWindow != window)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+7024], rcx
	je	SHORT $LN2@SetFocusID

; 1777 : 		g.NavInitRequest = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 0
$LN2@SetFocusID:

; 1778 : 	g.NavId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7040], ecx

; 1779 : 	g.NavWindow = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+7024], rcx

; 1780 : 	g.NavLayer = nav_layer;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR nav_layer$[rsp]
	mov	DWORD PTR [rax+7132], ecx

; 1781 : 	window->NavLastIds[nav_layer] = id;

	movsxd	rax, DWORD PTR nav_layer$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rcx+rax*4+904], edx

; 1782 : 	if (window->DC.LastItemId == id)

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+412], ecx
	jne	$LN3@SetFocusID

; 1783 : 		window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 376				; 00000178H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 368				; 00000170H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv136[rsp], rax
	mov	r8, QWORD PTR tv138[rsp]
	mov	rdx, QWORD PTR tv136[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	movsxd	rcx, DWORD PTR nav_layer$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR window$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+912]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@SetFocusID:

; 1784 : 
; 1785 : 	if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	SHORT $LN4@SetFocusID

; 1786 : 		g.NavDisableMouseHover = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7143], 1
	jmp	SHORT $LN5@SetFocusID
$LN4@SetFocusID:

; 1787 : 	else
; 1788 : 		g.NavDisableHighlight = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1
$LN5@SetFocusID:

; 1789 : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ENDP		; ImGui::SetFocusID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv67 = 0
tv94 = 4
g$ = 8
id$ = 32
window$ = 40
?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z PROC	; ImGui::SetActiveID

; 1742 : {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1743 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1744 : 	g.ActiveIdIsJustActivated = (g.ActiveId != id);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN6@SetActiveI
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN7@SetActiveI
$LN6@SetActiveI:
	mov	DWORD PTR tv67[rsp], 0
$LN7@SetActiveI:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv67[rsp]
	mov	BYTE PTR [rax+6752], cl

; 1745 : 	if (g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	je	SHORT $LN2@SetActiveI

; 1746 : 	{
; 1747 : 		g.ActiveIdTimer = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6736], xmm0

; 1748 : 		g.ActiveIdHasBeenPressed = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6716], 0

; 1749 : 		g.ActiveIdHasBeenEdited = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6732], 0

; 1750 : 		if (id != 0)

	cmp	DWORD PTR id$[rsp], 0
	je	SHORT $LN3@SetActiveI

; 1751 : 		{
; 1752 : 			g.LastActiveId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+6824], ecx

; 1753 : 			g.LastActiveIdTimer = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6828], xmm0
$LN3@SetActiveI:
$LN2@SetActiveI:

; 1754 : 		}
; 1755 : 	}
; 1756 : 	g.ActiveId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+6704], ecx

; 1757 : 	g.ActiveIdAllowNavDirFlags = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6804], 0

; 1758 : 	g.ActiveIdBlockNavInputFlags = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6808], 0

; 1759 : 	g.ActiveIdAllowOverlap = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6753], 0

; 1760 : 	g.ActiveIdWindow = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+6744], rcx

; 1761 : 	if (id)

	cmp	DWORD PTR id$[rsp], 0
	je	SHORT $LN4@SetActiveI

; 1762 : 	{
; 1763 : 		g.ActiveIdIsAlive = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+6720], ecx

; 1764 : 		g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	je	SHORT $LN8@SetActiveI
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	je	SHORT $LN8@SetActiveI
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7052], ecx
	je	SHORT $LN8@SetActiveI
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7064], ecx
	je	SHORT $LN8@SetActiveI
	mov	DWORD PTR tv94[rsp], 1
	jmp	SHORT $LN9@SetActiveI
$LN8@SetActiveI:
	mov	DWORD PTR tv94[rsp], 2
$LN9@SetActiveI:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv94[rsp]
	mov	DWORD PTR [rax+6820], ecx
$LN4@SetActiveI:

; 1765 : 	}
; 1766 : }

	add	rsp, 24
	ret	0
?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ENDP	; ImGui::SetActiveID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
hovered_window_above_modal$1 = 32
g$ = 40
i$2 = 48
modal$3 = 56
window$4 = 64
tv174 = 72
tv129 = 80
tv138 = 88
tv167 = 96
$T5 = 104
?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ PROC	; ImGui::UpdateMouseMovingWindowEndFrame

; 2255 : {

$LN21:
	sub	rsp, 136				; 00000088H

; 2256 : 	// Initiate moving window
; 2257 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2258 : 	if (g.ActiveId != 0 || g.HoveredId != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	SHORT $LN6@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	je	SHORT $LN5@UpdateMous
$LN6@UpdateMous:

; 2259 : 		return;

	jmp	$LN1@UpdateMous
$LN5@UpdateMous:

; 2260 : 
; 2261 : 	// Unless we just made a window/popup appear
; 2262 : 	if (g.NavWindow && g.NavWindow->Appearing)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN7@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	movzx	eax, BYTE PTR [rax+133]
	test	eax, eax
	je	SHORT $LN7@UpdateMous

; 2263 : 		return;

	jmp	$LN1@UpdateMous
$LN7@UpdateMous:

; 2264 : 
; 2265 : 	// Click to focus window and start moving (after we're done with all our widgets)
; 2266 : 	if (g.IO.MouseClicked[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	$LN8@UpdateMous

; 2267 : 	{
; 2268 : 		if (g.HoveredRootWindow != NULL)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6688], 0
	je	$LN9@UpdateMous

; 2269 : 		{
; 2270 : 			StartMouseMovingWindow(g.HoveredWindow);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6560]
	call	?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::StartMouseMovingWindow
	npad	1

; 2271 : 			if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoTitleBar))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+211]
	test	eax, eax
	je	SHORT $LN11@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6688]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN11@UpdateMous

; 2272 : 				if (!g.HoveredRootWindow->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6688]
	mov	QWORD PTR tv129[rsp], rax
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, QWORD PTR tv129[rsp]
	call	?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::TitleBarRect
	mov	QWORD PTR tv138[rsp], rax
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1036]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv138[rsp]
	call	?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@UpdateMous

; 2273 : 					g.MovingWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6776], 0
$LN12@UpdateMous:
$LN11@UpdateMous:

; 2274 : 		}

	jmp	SHORT $LN10@UpdateMous
$LN9@UpdateMous:

; 2275 : 		else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN13@UpdateMous
	call	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
	test	rax, rax
	jne	SHORT $LN13@UpdateMous

; 2276 : 		{
; 2277 : 			// Clicking on void disable focus
; 2278 : 			FocusWindow(NULL);

	xor	ecx, ecx
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN13@UpdateMous:
$LN10@UpdateMous:
$LN8@UpdateMous:

; 2279 : 		}
; 2280 : 	}
; 2281 : 
; 2282 : 	// With right mouse button we close popups without changing focus
; 2283 : 	// (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
; 2284 : 	if (g.IO.MouseClicked[1])

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	$LN14@UpdateMous

; 2285 : 	{
; 2286 : 		// Find the top-most window between HoveredWindow and the front most Modal Window.
; 2287 : 		// This is where we can trim the popup stack.
; 2288 : 		ImGuiWindow* modal = GetFrontMostPopupModal();

	call	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
	mov	QWORD PTR modal$3[rsp], rax

; 2289 : 		bool hovered_window_above_modal = false;

	mov	BYTE PTR hovered_window_above_modal$1[rsp], 0

; 2290 : 		if (modal == NULL)

	cmp	QWORD PTR modal$3[rsp], 0
	jne	SHORT $LN15@UpdateMous

; 2291 : 			hovered_window_above_modal = true;

	mov	BYTE PTR hovered_window_above_modal$1[rsp], 1
$LN15@UpdateMous:

; 2292 : 		for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	dec	eax
	mov	DWORD PTR i$2[rsp], eax
	jmp	SHORT $LN4@UpdateMous
$LN2@UpdateMous:
	mov	eax, DWORD PTR i$2[rsp]
	dec	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@UpdateMous:
	cmp	DWORD PTR i$2[rsp], 0
	jl	SHORT $LN3@UpdateMous
	movzx	eax, BYTE PTR hovered_window_above_modal$1[rsp]
	test	eax, eax
	jne	SHORT $LN3@UpdateMous

; 2293 : 		{
; 2294 : 			ImGuiWindow* window = g.Windows[i];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv167[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv167[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$4[rsp], rax

; 2295 : 			if (window == modal)

	mov	rax, QWORD PTR modal$3[rsp]
	cmp	QWORD PTR window$4[rsp], rax
	jne	SHORT $LN16@UpdateMous

; 2296 : 				break;

	jmp	SHORT $LN3@UpdateMous
$LN16@UpdateMous:

; 2297 : 			if (window == g.HoveredWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	cmp	QWORD PTR window$4[rsp], rax
	jne	SHORT $LN17@UpdateMous

; 2298 : 				hovered_window_above_modal = true;

	mov	BYTE PTR hovered_window_above_modal$1[rsp], 1
$LN17@UpdateMous:

; 2299 : 		}

	jmp	SHORT $LN2@UpdateMous
$LN3@UpdateMous:

; 2300 : 		ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);

	movzx	eax, BYTE PTR hovered_window_above_modal$1[rsp]
	test	eax, eax
	je	SHORT $LN19@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	QWORD PTR tv174[rsp], rax
	jmp	SHORT $LN20@UpdateMous
$LN19@UpdateMous:
	mov	rax, QWORD PTR modal$3[rsp]
	mov	QWORD PTR tv174[rsp], rax
$LN20@UpdateMous:
	mov	rcx, QWORD PTR tv174[rsp]
	call	?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::ClosePopupsOverWindow
	npad	1
$LN14@UpdateMous:
$LN1@UpdateMous:

; 2301 : 	}
; 2302 : }

	add	rsp, 136				; 00000088H
	ret	0
?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ ENDP	; ImGui::UpdateMouseMovingWindowEndFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
pos$1 = 40
moving_window$2 = 48
?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ PROC	; ImGui::UpdateMouseMovingWindowNewFrame

; 2216 : {

$LN12:
	sub	rsp, 72					; 00000048H

; 2217 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2218 : 	if (g.MovingWindow != NULL)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6776], 0
	je	$LN2@UpdateMous

; 2219 : 	{
; 2220 : 		// We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
; 2221 : 		// We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
; 2222 : 		KeepAliveID(g.ActiveId);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+6704]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID

; 2223 : 		IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
; 2224 : 		ImGuiWindow* moving_window = g.MovingWindow->RootWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6776]
	mov	rax, QWORD PTR [rax+688]
	mov	QWORD PTR moving_window$2[rsp], rax

; 2225 : 		if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	$LN4@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rcx, rax
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@UpdateMous

; 2226 : 		{
; 2227 : 			ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6812				; 00001a9cH
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR pos$1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1

; 2228 : 			if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)

	mov	rax, QWORD PTR moving_window$2[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	ucomiss	xmm0, DWORD PTR pos$1[rsp]
	jp	SHORT $LN7@UpdateMous
	jne	SHORT $LN7@UpdateMous
	mov	rax, QWORD PTR moving_window$2[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	ucomiss	xmm0, DWORD PTR pos$1[rsp+4]
	jp	SHORT $LN11@UpdateMous
	je	SHORT $LN6@UpdateMous
$LN11@UpdateMous:
$LN7@UpdateMous:

; 2229 : 			{
; 2230 : 				//MarkIniSettingsDirty(moving_window);
; 2231 : 				SetWindowPos(moving_window, pos, ImGuiCond_Always);

	mov	r8d, 1
	lea	rdx, QWORD PTR pos$1[rsp]
	mov	rcx, QWORD PTR moving_window$2[rsp]
	call	?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowPos
	npad	1
$LN6@UpdateMous:

; 2232 : 			}
; 2233 : 			FocusWindow(g.MovingWindow);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6776]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1

; 2234 : 		}

	jmp	SHORT $LN5@UpdateMous
$LN4@UpdateMous:

; 2235 : 		else
; 2236 : 		{
; 2237 : 			ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID

; 2238 : 			g.MovingWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6776], 0
$LN5@UpdateMous:

; 2239 : 		}
; 2240 : 	}

	jmp	SHORT $LN3@UpdateMous
$LN2@UpdateMous:

; 2241 : 	else
; 2242 : 	{
; 2243 : 		// When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
; 2244 : 		if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6744], 0
	je	SHORT $LN8@UpdateMous
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6744]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	cmp	DWORD PTR [rax+68], ecx
	jne	SHORT $LN8@UpdateMous

; 2245 : 		{
; 2246 : 			KeepAliveID(g.ActiveId);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+6704]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	npad	1

; 2247 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN9@UpdateMous

; 2248 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN9@UpdateMous:
$LN8@UpdateMous:
$LN3@UpdateMous:

; 2249 : 		}
; 2250 : 	}
; 2251 : }

	add	rsp, 72					; 00000048H
	ret	0
?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ ENDP	; ImGui::UpdateMouseMovingWindowNewFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
can_move_window$ = 32
g$ = 40
$T1 = 48
window$ = 80
?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::StartMouseMovingWindow

; 2196 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2197 : 	// Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
; 2198 : 	// We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
; 2199 : 	// This is because we want ActiveId to be set even when the window is not permitted to move.
; 2200 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2201 : 	FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 2202 : 	SetActiveID(window->MoveId, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rax+68]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 2203 : 	g.NavDisableHighlight = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1

; 2204 : 	g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6812], rax

; 2205 : 
; 2206 : 	bool can_move_window = true;

	mov	BYTE PTR can_move_window$[rsp], 1

; 2207 : 	if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN3@StartMouse
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN2@StartMouse
$LN3@StartMouse:

; 2208 : 		can_move_window = false;

	mov	BYTE PTR can_move_window$[rsp], 0
$LN2@StartMouse:

; 2209 : 	if (can_move_window)

	movzx	eax, BYTE PTR can_move_window$[rsp]
	test	eax, eax
	je	SHORT $LN4@StartMouse

; 2210 : 		g.MovingWindow = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+6776], rcx
$LN4@StartMouse:

; 2211 : }

	add	rsp, 72					; 00000048H
	ret	0
?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::StartMouseMovingWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
mouse_any_down$ = 40
tv173 = 41
tv180 = 42
mouse_avail_to_imgui$ = 43
i$1 = 44
mouse_dragging_extern_payload$ = 48
mouse_earliest_button_down$ = 52
tv135 = 56
tv193 = 60
tv208 = 64
tv216 = 68
tv223 = 72
tv245 = 76
tv246 = 80
modal_window$ = 88
?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ PROC	; ImGui::UpdateHoveredWindowAndCaptureFlags

; 2410 : {

$LN38:
	sub	rsp, 104				; 00000068H

; 2411 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2412 : 
; 2413 : 	// Find the window hovered by mouse:
; 2414 : 	// - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
; 2415 : 	// - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
; 2416 : 	// - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
; 2417 : 	FindHoveredWindow();

	call	?FindHoveredWindow@@YAXXZ		; FindHoveredWindow

; 2418 : 
; 2419 : 	// Modal windows prevents cursor from hovering behind them.
; 2420 : 	ImGuiWindow* modal_window = GetFrontMostPopupModal();

	call	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
	mov	QWORD PTR modal_window$[rsp], rax

; 2421 : 	if (modal_window)

	cmp	QWORD PTR modal_window$[rsp], 0
	je	SHORT $LN5@UpdateHove

; 2422 : 		if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6688], 0
	je	SHORT $LN6@UpdateHove
	mov	rdx, QWORD PTR modal_window$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6688]
	call	?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z ; ImGui::IsWindowChildOf
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@UpdateHove

; 2423 : 			g.HoveredRootWindow = g.HoveredWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6560], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6688], 0
$LN6@UpdateHove:
$LN5@UpdateHove:

; 2424 : 
; 2425 : 	// Disabled mouse?
; 2426 : 	if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN7@UpdateHove

; 2427 : 		g.HoveredWindow = g.HoveredRootWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6688], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6560], 0
$LN7@UpdateHove:

; 2428 : 
; 2429 : 	// We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
; 2430 : 	int mouse_earliest_button_down = -1;

	mov	DWORD PTR mouse_earliest_button_down$[rsp], -1

; 2431 : 	bool mouse_any_down = false;

	mov	BYTE PTR mouse_any_down$[rsp], 0

; 2432 : 	for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@UpdateHove
$LN2@UpdateHove:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@UpdateHove:
	cmp	DWORD PTR i$1[rsp], 5
	jge	$LN3@UpdateHove

; 2433 : 	{
; 2434 : 		if (g.IO.MouseClicked[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	SHORT $LN8@UpdateHove

; 2435 : 			g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	jne	SHORT $LN19@UpdateHove
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ ; ImVector<ImGuiPopupRef>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@UpdateHove
	mov	DWORD PTR tv135[rsp], 0
	jmp	SHORT $LN20@UpdateHove
$LN19@UpdateHove:
	mov	DWORD PTR tv135[rsp], 1
$LN20@UpdateHove:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	edx, BYTE PTR tv135[rsp]
	mov	BYTE PTR [rcx+rax+1104], dl
$LN8@UpdateHove:

; 2436 : 		mouse_any_down |= g.IO.MouseDown[i];

	movzx	eax, BYTE PTR mouse_any_down$[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx+305]
	or	eax, ecx
	mov	BYTE PTR mouse_any_down$[rsp], al

; 2437 : 		if (g.IO.MouseDown[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	SHORT $LN9@UpdateHove

; 2438 : 			if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])

	cmp	DWORD PTR mouse_earliest_button_down$[rsp], -1
	je	SHORT $LN11@UpdateHove
	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR mouse_earliest_button_down$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	r8, QWORD PTR g$[rsp]
	movsd	xmm0, QWORD PTR [rdx+rcx*8+976]
	comisd	xmm0, QWORD PTR [r8+rax*8+976]
	jbe	SHORT $LN10@UpdateHove
$LN11@UpdateHove:

; 2439 : 				mouse_earliest_button_down = i;

	mov	eax, DWORD PTR i$1[rsp]
	mov	DWORD PTR mouse_earliest_button_down$[rsp], eax
$LN10@UpdateHove:
$LN9@UpdateHove:

; 2440 : 	}

	jmp	$LN2@UpdateHove
$LN3@UpdateHove:

; 2441 : 	const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

	cmp	DWORD PTR mouse_earliest_button_down$[rsp], -1
	je	SHORT $LN21@UpdateHove
	movsxd	rax, DWORD PTR mouse_earliest_button_down$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1104]
	test	eax, eax
	jne	SHORT $LN21@UpdateHove
	mov	BYTE PTR tv173[rsp], 0
	jmp	SHORT $LN22@UpdateHove
$LN21@UpdateHove:
	mov	BYTE PTR tv173[rsp], 1
$LN22@UpdateHove:
	movzx	eax, BYTE PTR tv173[rsp]
	mov	BYTE PTR mouse_avail_to_imgui$[rsp], al

; 2442 : 
; 2443 : 	// If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
; 2444 : 	// FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
; 2445 : 	const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN23@UpdateHove
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7608]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN23@UpdateHove
	mov	BYTE PTR tv180[rsp], 1
	jmp	SHORT $LN24@UpdateHove
$LN23@UpdateHove:
	mov	BYTE PTR tv180[rsp], 0
$LN24@UpdateHove:
	movzx	eax, BYTE PTR tv180[rsp]
	mov	BYTE PTR mouse_dragging_extern_payload$[rsp], al

; 2446 : 	if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)

	movzx	eax, BYTE PTR mouse_avail_to_imgui$[rsp]
	test	eax, eax
	jne	SHORT $LN12@UpdateHove
	movzx	eax, BYTE PTR mouse_dragging_extern_payload$[rsp]
	test	eax, eax
	jne	SHORT $LN12@UpdateHove

; 2447 : 		g.HoveredWindow = g.HoveredRootWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6688], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6560], 0
$LN12@UpdateHove:

; 2448 : 
; 2449 : 	// Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)
; 2450 : 	if (g.WantCaptureMouseNextFrame != -1)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+15316], -1
	je	SHORT $LN13@UpdateHove

; 2451 : 		g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+15316], 0
	je	SHORT $LN25@UpdateHove
	mov	DWORD PTR tv193[rsp], 1
	jmp	SHORT $LN26@UpdateHove
$LN25@UpdateHove:
	mov	DWORD PTR tv193[rsp], 0
$LN26@UpdateHove:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv193[rsp]
	mov	BYTE PTR [rax+933], cl
	jmp	SHORT $LN14@UpdateHove
$LN13@UpdateHove:

; 2452 : 	else
; 2453 : 		g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

	movzx	eax, BYTE PTR mouse_avail_to_imgui$[rsp]
	test	eax, eax
	je	SHORT $LN28@UpdateHove
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	jne	SHORT $LN27@UpdateHove
	movzx	eax, BYTE PTR mouse_any_down$[rsp]
	test	eax, eax
	jne	SHORT $LN27@UpdateHove
$LN28@UpdateHove:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ ; ImVector<ImGuiPopupRef>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@UpdateHove
	mov	DWORD PTR tv208[rsp], 0
	jmp	SHORT $LN29@UpdateHove
$LN27@UpdateHove:
	mov	DWORD PTR tv208[rsp], 1
$LN29@UpdateHove:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv208[rsp]
	mov	BYTE PTR [rax+933], cl
$LN14@UpdateHove:

; 2454 : 
; 2455 : 	// Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)
; 2456 : 	if (g.WantCaptureKeyboardNextFrame != -1)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+15320], -1
	je	SHORT $LN15@UpdateHove

; 2457 : 		g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+15320], 0
	je	SHORT $LN30@UpdateHove
	mov	DWORD PTR tv216[rsp], 1
	jmp	SHORT $LN31@UpdateHove
$LN30@UpdateHove:
	mov	DWORD PTR tv216[rsp], 0
$LN31@UpdateHove:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv216[rsp]
	mov	BYTE PTR [rax+934], cl
	jmp	SHORT $LN16@UpdateHove
$LN15@UpdateHove:

; 2458 : 	else
; 2459 : 		g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	SHORT $LN32@UpdateHove
	cmp	QWORD PTR modal_window$[rsp], 0
	jne	SHORT $LN32@UpdateHove
	mov	DWORD PTR tv223[rsp], 0
	jmp	SHORT $LN33@UpdateHove
$LN32@UpdateHove:
	mov	DWORD PTR tv223[rsp], 1
$LN33@UpdateHove:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv223[rsp]
	mov	BYTE PTR [rax+934], cl
$LN16@UpdateHove:

; 2460 : 	if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+944]
	test	eax, eax
	je	SHORT $LN17@UpdateHove
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@UpdateHove
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN17@UpdateHove

; 2461 : 		g.IO.WantCaptureKeyboard = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+934], 1
$LN17@UpdateHove:

; 2462 : 
; 2463 : 	// Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
; 2464 : 	g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+12236], -1
	je	SHORT $LN36@UpdateHove
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+12236], 0
	je	SHORT $LN34@UpdateHove
	mov	DWORD PTR tv245[rsp], 1
	jmp	SHORT $LN35@UpdateHove
$LN34@UpdateHove:
	mov	DWORD PTR tv245[rsp], 0
$LN35@UpdateHove:
	mov	eax, DWORD PTR tv245[rsp]
	mov	DWORD PTR tv246[rsp], eax
	jmp	SHORT $LN37@UpdateHove
$LN36@UpdateHove:
	mov	DWORD PTR tv246[rsp], 0
$LN37@UpdateHove:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv246[rsp]
	mov	BYTE PTR [rax+932], cl

; 2465 : }

	add	rsp, 104				; 00000068H
	ret	0
?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ ENDP	; ImGui::UpdateHoveredWindowAndCaptureFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
tv90 = 48
context$ = 80
?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z PROC		; ImGui::Shutdown

; 2672 : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2673 : 	// The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
; 2674 : 	ImGuiContext& g = *context;

	mov	rax, QWORD PTR context$[rsp]
	mov	QWORD PTR g$[rsp], rax

; 2675 : 	if (g.IO.Fonts && g.FontAtlasOwnedByContext)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+176], 0
	je	SHORT $LN5@Shutdown
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+2]
	test	eax, eax
	je	SHORT $LN5@Shutdown

; 2676 : 	{
; 2677 : 		g.IO.Fonts->Locked = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+176]
	mov	BYTE PTR [rax], 0

; 2678 : 		IM_DELETE(g.IO.Fonts);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+176]
	call	??$IM_DELETE@UImFontAtlas@@@@YAXPEAUImFontAtlas@@@Z ; IM_DELETE<ImFontAtlas>
	npad	1
$LN5@Shutdown:

; 2679 : 	}
; 2680 : 	g.IO.Fonts = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+176], 0

; 2681 : 
; 2682 : 	// Cleanup of other data are conditional on actually having initialized ImGui.
; 2683 : 	if (!g.Initialized)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	test	eax, eax
	jne	SHORT $LN6@Shutdown

; 2684 : 		return;

	jmp	$LN1@Shutdown
$LN6@Shutdown:

; 2685 : 
; 2686 : 	//// Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
; 2687 : 	//if (g.SettingsLoaded && g.IO.IniFilename != NULL)
; 2688 : 	//{
; 2689 : 	//    ImGuiContext* backup_context = GImGui;
; 2690 : 	//    SetCurrentContext(context);
; 2691 : 	//    SaveIniSettingsToDisk(g.IO.IniFilename);
; 2692 : 	//    SetCurrentContext(backup_context);
; 2693 : 	//}
; 2694 : 
; 2695 : 	// Clear everything else
; 2696 : 	for (int i = 0; i < g.Windows.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@Shutdown
$LN2@Shutdown:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@Shutdown:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@Shutdown

; 2697 : 		IM_DELETE(g.Windows[i]);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv90[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR [rax]
	call	??$IM_DELETE@UImGuiWindow@@@@YAXPEAUImGuiWindow@@@Z ; IM_DELETE<ImGuiWindow>
	npad	1
	jmp	SHORT $LN2@Shutdown
$LN3@Shutdown:

; 2698 : 	g.Windows.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ; ImVector<ImGuiWindow *>::clear

; 2699 : 	g.WindowsFocusOrder.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ; ImVector<ImGuiWindow *>::clear

; 2700 : 	g.WindowsSortBuffer.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6632				; 000019e8H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ; ImVector<ImGuiWindow *>::clear

; 2701 : 	g.CurrentWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6584], 0

; 2702 : 	g.CurrentWindowStack.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ; ImVector<ImGuiWindow *>::clear

; 2703 : 	g.WindowsById.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6616				; 000019d8H
	mov	rcx, rax
	call	?Clear@ImGuiStorage@@QEAAXXZ		; ImGuiStorage::Clear

; 2704 : 	g.NavWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+7024], 0

; 2705 : 	g.HoveredWindow = g.HoveredRootWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6688], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6560], 0

; 2706 : 	g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6760], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6744], 0

; 2707 : 	g.MovingWindow = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	QWORD PTR [rax+6776], 0

; 2708 : 	g.ColorModifiers.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6784				; 00001a80H
	mov	rcx, rax
	call	?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ ; ImVector<ImGuiColorMod>::clear

; 2709 : 	g.StyleModifiers.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6840				; 00001ab8H
	mov	rcx, rax
	call	?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ ; ImVector<ImGuiStyleMod>::clear

; 2710 : 	g.FontStack.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ	; ImVector<ImFont *>::clear

; 2711 : 	g.OpenPopupStack.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ ; ImVector<ImGuiPopupRef>::clear

; 2712 : 	g.BeginPopupStack.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	rcx, rax
	call	?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ ; ImVector<ImGuiPopupRef>::clear

; 2713 : 	g.DrawDataBuilder.ClearFreeMemory();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7560				; 00001d88H
	mov	rcx, rax
	call	?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ ; ImDrawDataBuilder::ClearFreeMemory

; 2714 : 	g.OverlayDrawList.ClearFreeMemory();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	rcx, rax
	call	?ClearFreeMemory@ImDrawList@@QEAAXXZ	; ImDrawList::ClearFreeMemory

; 2715 : 	g.PrivateClipboard.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 11704				; 00002db8H
	mov	rcx, rax
	call	?clear@?$ImVector@D@@QEAAXXZ		; ImVector<char>::clear

; 2716 : 	g.InputTextState.TextW.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7944				; 00001f08H
	mov	rcx, rax
	call	?clear@?$ImVector@G@@QEAAXXZ		; ImVector<unsigned short>::clear

; 2717 : 	g.InputTextState.InitialText.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7976				; 00001f28H
	mov	rcx, rax
	call	?clear@?$ImVector@D@@QEAAXXZ		; ImVector<char>::clear

; 2718 : 	g.InputTextState.TempBuffer.clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7992				; 00001f38H
	mov	rcx, rax
	call	?clear@?$ImVector@D@@QEAAXXZ		; ImVector<char>::clear

; 2719 : 
; 2720 : 	/* for (int i = 0; i < g.SettingsWindows.Size; i++)
; 2721 : 		 IM_DELETE(g.SettingsWindows[i].Name);
; 2722 : 	 g.SettingsWindows.clear();
; 2723 : 	 g.SettingsHandlers.clear();
; 2724 : 
; 2725 : 	 if (g.LogFile && g.LogFile != stdout)
; 2726 : 	 {
; 2727 : 		 fclose(g.LogFile);
; 2728 : 		 g.LogFile = NULL;
; 2729 : 	 }
; 2730 : 	 g.LogClipboard.clear();*/
; 2731 : 
; 2732 : 	g.Initialized = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+1], 0
$LN1@Shutdown:

; 2733 : }

	add	rsp, 72					; 00000048H
	ret	0
?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z ENDP		; ImGui::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
context$ = 32
?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z PROC		; ImGui::Initialize

; 2654 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2655 : 	ImGuiContext& g = *context;

	mov	rax, QWORD PTR context$[rsp]
	mov	QWORD PTR g$[rsp], rax

; 2656 : 	IM_ASSERT(!g.Initialized /*&& !g.SettingsLoaded*/);
; 2657 : 
; 2658 : 	// Add .ini handle for ImGuiWindow type
; 2659 : 	/*ImGuiSettingsHandler ini_handler;
; 2660 : 	ini_handler.TypeName = ("Window");
; 2661 : 	ini_handler.TypeHash = ImHashStr(("Window"), 0);
; 2662 : 	ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
; 2663 : 	ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
; 2664 : 	ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
; 2665 : 	g.SettingsHandlers.push_back(ini_handler);*/
; 2666 : 
; 2667 : 	g.Initialized = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+1], 1

; 2668 : }

	add	rsp, 24
	ret	0
?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z ENDP		; ImGui::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ
_TEXT	SEGMENT
g$ = 32
tv77 = 40
tv75 = 48
?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ PROC		; ImGui::GetDefaultFont, COMDAT

; 1348 :     inline ImFont* GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }

$LN5:
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+200], 0
	je	SHORT $LN3@GetDefault
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+200]
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN4@GetDefault
$LN3@GetDefault:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+176]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv75[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv75[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv77[rsp], rax
$LN4@GetDefault:
	mov	rax, QWORD PTR tv77[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ ENDP		; ImGui::GetDefaultFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv83 = 32
g$ = 40
atlas$ = 48
font$ = 80
?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z PROC		; ImGui::SetCurrentFont

; 4784 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4785 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4786 : 	IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
; 4787 : 	IM_ASSERT(font->Scale > 0.0f);
; 4788 : 	g.Font = font;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 4789 : 	g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+172]
	mulss	xmm0, DWORD PTR [rax+20]
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR [rax+80]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+6412], xmm0

; 4790 : 	g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6584], 0
	je	SHORT $LN3@SetCurrent
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6584]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	movss	DWORD PTR tv83[rsp], xmm0
	jmp	SHORT $LN4@SetCurrent
$LN3@SetCurrent:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv83[rsp], xmm0
$LN4@SetCurrent:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv83[rsp]
	movss	DWORD PTR [rax+6408], xmm0

; 4791 : 
; 4792 : 	ImFontAtlas* atlas = g.Font->ContainerAtlas;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR atlas$[rsp], rax

; 4793 : 	g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6416], rax

; 4794 : 	g.DrawListSharedData.Font = g.Font;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+6424], rcx

; 4795 : 	g.DrawListSharedData.FontSize = g.FontSize;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+6408]
	movss	DWORD PTR [rax+6432], xmm0

; 4796 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z ENDP		; ImGui::SetCurrentFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 8
collapsed$ = 16
cond$ = 24
?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z PROC ; ImGui::SetWindowCollapsed

; 5240 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 5241 : 	// Test condition (NB: bit 0 is always true) and clear flags for next time
; 5242 : 	if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN2@SetWindowC
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR cond$[rsp]
	mov	eax, DWORD PTR [rax+176]
	and	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@SetWindowC

; 5243 : 		return;

	jmp	SHORT $LN1@SetWindowC
$LN2@SetWindowC:

; 5244 : 	window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+176]
	and	eax, -15
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+176], eax

; 5245 : 
; 5246 : 	// Set
; 5247 : 	window->Collapsed = collapsed;

	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR collapsed$[rsp]
	mov	BYTE PTR [rax+113], cl
$LN1@SetWindowC:

; 5248 : }

	ret	0
?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z ENDP ; ImGui::SetWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 48
size$ = 56
cond$ = 64
?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z PROC ; ImGui::SetWindowSize

; 5197 : {

$LN8:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5198 : 	// Test condition (NB: bit 0 is always true) and clear flags for next time
; 5199 : 	if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN2@SetWindowS
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR cond$[rsp]
	mov	eax, DWORD PTR [rax+144]
	and	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@SetWindowS

; 5200 : 		return;

	jmp	$LN1@SetWindowS
$LN2@SetWindowS:

; 5201 : 
; 5202 : 	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 5203 : 	window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+144]
	and	eax, -15
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+144], eax

; 5204 : 
; 5205 : 	// Set
; 5206 : 	if (size.x > 0.0f)

	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@SetWindowS

; 5207 : 	{
; 5208 : 		window->AutoFitFramesX = 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+156], 0

; 5209 : 		window->SizeFull.x = ImFloor(size.x);

	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+32], xmm0

; 5210 : 	}

	jmp	SHORT $LN4@SetWindowS
$LN3@SetWindowS:

; 5211 : 	else
; 5212 : 	{
; 5213 : 		window->AutoFitFramesX = 2;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+156], 2

; 5214 : 		window->AutoFitOnlyGrows = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+164], 0
$LN4@SetWindowS:

; 5215 : 	}
; 5216 : 	if (size.y > 0.0f)

	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@SetWindowS

; 5217 : 	{
; 5218 : 		window->AutoFitFramesY = 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+160], 0

; 5219 : 		window->SizeFull.y = ImFloor(size.y);

	mov	rax, QWORD PTR size$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+36], xmm0

; 5220 : 	}

	jmp	SHORT $LN6@SetWindowS
$LN5@SetWindowS:

; 5221 : 	else
; 5222 : 	{
; 5223 : 		window->AutoFitFramesY = 2;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+160], 2

; 5224 : 		window->AutoFitOnlyGrows = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+164], 0
$LN6@SetWindowS:
$LN1@SetWindowS:

; 5225 : 	}
; 5226 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ENDP ; ImGui::SetWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
old_pos$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
window$ = 96
pos$ = 104
cond$ = 112
?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z PROC ; ImGui::SetWindowPos

; 5162 : {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 5163 : 	// Test condition (NB: bit 0 is always true) and clear flags for next time
; 5164 : 	if (cond && (window->SetWindowPosAllowFlags & cond) == 0)

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN2@SetWindowP
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR cond$[rsp]
	mov	eax, DWORD PTR [rax+172]
	and	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@SetWindowP

; 5165 : 		return;

	jmp	$LN1@SetWindowP
$LN2@SetWindowP:

; 5166 : 
; 5167 : 	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 5168 : 	window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+172]
	and	eax, -15
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+172], eax

; 5169 : 	window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 5170 : 
; 5171 : 	// Set
; 5172 : 	const ImVec2 old_pos = window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR old_pos$[rsp], rax

; 5173 : 	window->Pos = ImFloor(pos);

	mov	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 5174 : 	window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	lea	r8, QWORD PTR old_pos$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	rdx, rax
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1

; 5175 : 	window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	lea	r8, QWORD PTR old_pos$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 312				; 00000138H
	mov	rdx, rax
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1
$LN1@SetWindowP:

; 5176 : }

	add	rsp, 88					; 00000058H
	ret	0
?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ENDP ; ImGui::SetWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv76 = 32
tv83 = 36
padding$ = 40
$T1 = 48
r_screen$ = 56
__$ReturnUdt$ = 112
__formal$ = 120
?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z PROC ; ImGui::GetWindowAllowedExtentRect

; 6132 : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 6133 : 	ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+5620]
	mov	QWORD PTR padding$[rsp], rax

; 6134 : 	ImRect r_screen = GetViewportRect();

	lea	rcx, QWORD PTR r_screen$[rsp]
	call	?GetViewportRect@@YA?AUImRect@@XZ	; GetViewportRect
	npad	1

; 6135 : 	r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));

	lea	rcx, QWORD PTR r_screen$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	xmm1, DWORD PTR padding$[rsp+4]
	mulss	xmm1, DWORD PTR __real@40000000
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@GetWindowA
	movss	xmm0, DWORD PTR padding$[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv76[rsp], xmm0
	jmp	SHORT $LN4@GetWindowA
$LN3@GetWindowA:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv76[rsp], xmm0
$LN4@GetWindowA:
	lea	rcx, QWORD PTR r_screen$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	xmm1, DWORD PTR padding$[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@GetWindowA
	movss	xmm0, DWORD PTR padding$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv83[rsp], xmm0
	jmp	SHORT $LN6@GetWindowA
$LN5@GetWindowA:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv83[rsp], xmm0
$LN6@GetWindowA:
	movss	xmm2, DWORD PTR tv76[rsp]
	movss	xmm1, DWORD PTR tv83[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR r_screen$[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1

; 6136 : 	return r_screen;

	lea	rax, QWORD PTR r_screen$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 6137 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z ENDP ; ImGui::GetWindowAllowedExtentRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 48
?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z PROC	; ImGui::GetWindowScrollMaxY

; 3723 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3724 : 	return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	subss	xmm0, DWORD PTR [rcx+128]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>

; 3725 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z ENDP	; ImGui::GetWindowScrollMaxY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 48
?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z PROC	; ImGui::GetWindowScrollMaxX

; 3718 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3719 : 	return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	subss	xmm0, DWORD PTR [rcx+124]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>

; 3720 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z ENDP	; ImGui::GetWindowScrollMaxX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 8
new_scroll_y$ = 16
?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z PROC	; ImGui::SetWindowScrollY

; 5155 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 5156 : 	window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	addss	xmm0, DWORD PTR [rcx+96]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+316], xmm0

; 5157 : 	window->Scroll.y = new_scroll_y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR new_scroll_y$[rsp]
	movss	DWORD PTR [rax+96], xmm0

; 5158 : 	window->DC.CursorMaxPos.y -= window->Scroll.y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	subss	xmm0, DWORD PTR [rcx+96]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+316], xmm0

; 5159 : }

	ret	0
?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ENDP	; ImGui::SetWindowScrollY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 8
new_scroll_x$ = 16
?SetWindowScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z PROC	; ImGui::SetWindowScrollX

; 5148 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 5149 : 	window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	addss	xmm0, DWORD PTR [rcx+92]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+312], xmm0

; 5150 : 	window->Scroll.x = new_scroll_x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR new_scroll_x$[rsp]
	movss	DWORD PTR [rax+92], xmm0

; 5151 : 	window->DC.CursorMaxPos.x -= window->Scroll.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	subss	xmm0, DWORD PTR [rcx+92]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+312], xmm0

; 5152 : }

	ret	0
?SetWindowScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z ENDP	; ImGui::SetWindowScrollX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv72 = 0
window$ = 32
?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z PROC ; ImGui::IsWindowNavFocusable

; 5124 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5125 : 	return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN3@IsWindowNa
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR window$[rsp], rax
	jne	SHORT $LN3@IsWindowNa
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 524288				; 00080000H
	test	eax, eax
	jne	SHORT $LN3@IsWindowNa
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@IsWindowNa
$LN3@IsWindowNa:
	mov	DWORD PTR tv72[rsp], 0
$LN4@IsWindowNa:
	movzx	eax, BYTE PTR tv72[rsp]

; 5126 : }

	add	rsp, 24
	ret	0
?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z ENDP ; ImGui::IsWindowNavFocusable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 8
potential_parent$ = 16
?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z PROC	; ImGui::IsWindowChildOf

; 5046 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 5047 : 	if (window->RootWindow == potential_parent)

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR potential_parent$[rsp]
	cmp	QWORD PTR [rax+688], rcx
	jne	SHORT $LN4@IsWindowCh

; 5048 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@IsWindowCh
$LN4@IsWindowCh:
$LN2@IsWindowCh:

; 5049 : 	while (window != NULL)

	cmp	QWORD PTR window$[rsp], 0
	je	SHORT $LN3@IsWindowCh

; 5050 : 	{
; 5051 : 		if (window == potential_parent)

	mov	rax, QWORD PTR potential_parent$[rsp]
	cmp	QWORD PTR window$[rsp], rax
	jne	SHORT $LN5@IsWindowCh

; 5052 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsWindowCh
$LN5@IsWindowCh:

; 5053 : 		window = window->ParentWindow;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR window$[rsp], rax

; 5054 : 	}

	jmp	SHORT $LN2@IsWindowCh
$LN3@IsWindowCh:

; 5055 : 	return false;

	xor	al, al
$LN1@IsWindowCh:

; 5056 : }

	ret	0
?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z ENDP	; ImGui::IsWindowChildOf
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
size_contents$ = 32
$T1 = 40
__$ReturnUdt$ = 64
window$ = 72
?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z PROC ; ImGui::CalcWindowExpectedSize

; 3712 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3713 : 	ImVec2 size_contents = CalcSizeContents(window);

	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR size_contents$[rsp]
	call	?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; CalcSizeContents
	npad	1

; 3714 : 	return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));

	lea	r8, QWORD PTR size_contents$[rsp]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z ; CalcSizeAutoFit
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ; CalcSizeAfterConstraint
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3715 : }

	add	rsp, 56					; 00000038H
	ret	0
?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ENDP ; ImGui::CalcWindowExpectedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 8
flags$ = 16
parent_window$ = 24
?UpdateWindowParentAndRootLinks@ImGui@@YAXPEAUImGuiWindow@@H0@Z PROC ; ImGui::UpdateWindowParentAndRootLinks

; 3955 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 3956 : 	window->ParentWindow = parent_window;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	QWORD PTR [rax+880], rcx

; 3957 : 	window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+888], rcx
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+704], rcx
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+688], rcx

; 3958 : 	if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN4@UpdateWind
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN4@UpdateWind
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	jne	SHORT $LN4@UpdateWind

; 3959 : 		window->RootWindow = parent_window->RootWindow;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	rcx, QWORD PTR [rcx+688]
	mov	QWORD PTR [rax+688], rcx
$LN4@UpdateWind:

; 3960 : 	if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN5@UpdateWind
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $LN5@UpdateWind
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 83886080				; 05000000H
	test	eax, eax
	je	SHORT $LN5@UpdateWind

; 3961 : 		window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	rcx, QWORD PTR [rcx+704]
	mov	QWORD PTR [rax+704], rcx
$LN5@UpdateWind:
$LN2@UpdateWind:

; 3962 : 	while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+888]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	je	SHORT $LN3@UpdateWind

; 3963 : 	{
; 3964 : 		IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
; 3965 : 		window->RootWindowForNav = window->RootWindowForNav->ParentWindow;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+888]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR [rcx+888], rax

; 3966 : 	}

	jmp	SHORT $LN2@UpdateWind
$LN3@UpdateWind:

; 3967 : }

	ret	0
?UpdateWindowParentAndRootLinks@ImGui@@YAXPEAUImGuiWindow@@H0@Z ENDP ; ImGui::UpdateWindowParentAndRootLinks
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
tv69 = 48
tv80 = 56
tv91 = 64
tv130 = 72
tv135 = 80
tv133 = 88
tv140 = 96
window$ = 128
?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::BringWindowToDisplayBack

; 4675 : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 4676 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4677 : 	if (g.Windows[0] == window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv69[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv69[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN5@BringWindo

; 4678 : 		return;

	jmp	$LN1@BringWindo
$LN5@BringWindo:

; 4679 : 	for (int i = 0; i < g.Windows.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@BringWindo
$LN2@BringWindo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@BringWindo:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@BringWindo

; 4680 : 		if (g.Windows[i] == window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv80[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	$LN6@BringWindo

; 4681 : 		{
; 4682 : 			memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv91[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv91[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	QWORD PTR tv135[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv130[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv130[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	QWORD PTR tv133[rsp], rax
	movsxd	rax, DWORD PTR i$1[rsp]
	shl	rax, 3
	mov	r8, rax
	mov	rdx, QWORD PTR tv135[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	memmove

; 4683 : 			g.Windows[0] = window;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv140[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv140[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax], rcx

; 4684 : 			break;

	jmp	SHORT $LN3@BringWindo
$LN6@BringWindo:

; 4685 : 		}

	jmp	$LN2@BringWindo
$LN3@BringWindo:
$LN1@BringWindo:

; 4686 : }

	add	rsp, 120				; 00000078H
	ret	0
?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::BringWindowToDisplayBack
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
current_front_window$ = 48
tv80 = 56
tv128 = 64
tv135 = 72
tv142 = 80
tv140 = 88
tv138 = 96
tv150 = 104
window$ = 128
?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::BringWindowToDisplayFront

; 4660 : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 4661 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4662 : 	ImGuiWindow* current_front_window = g.Windows.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current_front_window$[rsp], rax

; 4663 : 	if (current_front_window == window || current_front_window->RootWindow == window)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR current_front_window$[rsp], rax
	je	SHORT $LN6@BringWindo
	mov	rax, QWORD PTR current_front_window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+688], rcx
	jne	SHORT $LN5@BringWindo
$LN6@BringWindo:

; 4664 : 		return;

	jmp	$LN1@BringWindo
$LN5@BringWindo:

; 4665 : 	for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	sub	eax, 2
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@BringWindo
$LN2@BringWindo:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@BringWindo:
	cmp	DWORD PTR i$1[rsp], 0
	jl	$LN3@BringWindo

; 4666 : 		if (g.Windows[i] == window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv80[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	$LN7@BringWindo

; 4667 : 		{
; 4668 : 			memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR i$1[rsp]
	mov	eax, DWORD PTR [rax+6600]
	sub	eax, ecx
	dec	eax
	cdqe
	shl	rax, 3
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv128[rsp], rax
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv128[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	QWORD PTR tv140[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv135[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	QWORD PTR tv138[rsp], rax
	mov	r8, QWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	mov	rcx, QWORD PTR tv138[rsp]
	call	memmove

; 4669 : 			g.Windows[g.Windows.Size - 1] = window;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv150[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv150[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax], rcx

; 4670 : 			break;

	jmp	SHORT $LN3@BringWindo
$LN7@BringWindo:

; 4671 : 		}

	jmp	$LN2@BringWindo
$LN3@BringWindo:
$LN1@BringWindo:

; 4672 : }

	add	rsp, 120				; 00000078H
	ret	0
?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::BringWindowToDisplayFront
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
g$ = 40
tv78 = 48
tv94 = 56
tv133 = 64
tv140 = 72
tv138 = 80
tv136 = 88
tv148 = 96
window$ = 128
?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::BringWindowToFocusFront

; 4646 : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 4647 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4648 : 	if (g.WindowsFocusOrder.back() == window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::back
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN5@BringWindo

; 4649 : 		return;

	jmp	$LN1@BringWindo
$LN5@BringWindo:

; 4650 : 	for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	sub	eax, 2
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@BringWindo
$LN2@BringWindo:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@BringWindo:
	cmp	DWORD PTR i$1[rsp], 0
	jl	$LN3@BringWindo

; 4651 : 		if (g.WindowsFocusOrder[i] == window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv78[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	$LN6@BringWindo

; 4652 : 		{
; 4653 : 			memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(ImGuiWindow*));

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR i$1[rsp]
	mov	eax, DWORD PTR [rax+6656]
	sub	eax, ecx
	dec	eax
	cdqe
	shl	rax, 3
	mov	QWORD PTR tv140[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv94[rsp], rax
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv94[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv133[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	QWORD PTR tv136[rsp], rax
	mov	r8, QWORD PTR tv140[rsp]
	mov	rdx, QWORD PTR tv138[rsp]
	mov	rcx, QWORD PTR tv136[rsp]
	call	memmove

; 4654 : 			g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv148[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv148[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax], rcx

; 4655 : 			break;

	jmp	SHORT $LN3@BringWindo
$LN6@BringWindo:

; 4656 : 		}

	jmp	$LN2@BringWindo
$LN3@BringWindo:
$LN1@BringWindo:

; 4657 : }

	add	rsp, 120				; 00000078H
	ret	0
?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::BringWindowToFocusFront
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
window$2 = 40
g$ = 48
tv74 = 56
focus_window$3 = 64
ignore_window$ = 96
?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z PROC ; ImGui::FocusPreviousWindowIgnoringOne

; 4725 : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4726 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4727 : 	for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6656]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@FocusPrevi
$LN2@FocusPrevi:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FocusPrevi:
	cmp	DWORD PTR i$1[rsp], 0
	jl	$LN3@FocusPrevi

; 4728 : 	{
; 4729 : 		// We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
; 4730 : 		ImGuiWindow* window = g.WindowsFocusOrder[i];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6656				; 00001a00H
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$2[rsp], rax

; 4731 : 		if (window != ignore_window && window->WasActive && !(window->Flags & ImGuiWindowFlags_ChildWindow))

	mov	rax, QWORD PTR ignore_window$[rsp]
	cmp	QWORD PTR window$2[rsp], rax
	je	SHORT $LN5@FocusPrevi
	mov	rax, QWORD PTR window$2[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	je	SHORT $LN5@FocusPrevi
	mov	rax, QWORD PTR window$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN5@FocusPrevi

; 4732 : 			if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))

	mov	rax, QWORD PTR window$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262656				; 00040200H
	cmp	eax, 262656				; 00040200H
	je	SHORT $LN6@FocusPrevi

; 4733 : 			{
; 4734 : 				ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);

	mov	rcx, QWORD PTR window$2[rsp]
	call	?NavRestoreLastChildNavWindow@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z ; ImGui::NavRestoreLastChildNavWindow
	mov	QWORD PTR focus_window$3[rsp], rax

; 4735 : 				FocusWindow(focus_window);

	mov	rcx, QWORD PTR focus_window$3[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1

; 4736 : 				return;

	jmp	SHORT $LN1@FocusPrevi
$LN6@FocusPrevi:
$LN5@FocusPrevi:

; 4737 : 			}
; 4738 : 	}

	jmp	$LN2@FocusPrevi
$LN3@FocusPrevi:
$LN1@FocusPrevi:

; 4739 : }

	add	rsp, 88					; 00000058H
	ret	0
?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP ; ImGui::FocusPreviousWindowIgnoringOne
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv78 = 32
g$ = 40
window$ = 64
?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z PROC		; ImGui::FocusWindow

; 4690 : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4691 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4692 : 
; 4693 : 	if (g.NavWindow != window)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+7024], rcx
	je	$LN2@FocusWindo

; 4694 : 	{
; 4695 : 		g.NavWindow = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+7024], rcx

; 4696 : 		if (window && g.NavDisableMouseHover)

	cmp	QWORD PTR window$[rsp], 0
	je	SHORT $LN3@FocusWindo
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	SHORT $LN3@FocusWindo

; 4697 : 			g.NavMousePosDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7142], 1
$LN3@FocusWindo:

; 4698 : 		g.NavInitRequest = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 0

; 4699 : 		g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId

	cmp	QWORD PTR window$[rsp], 0
	je	SHORT $LN10@FocusWindo
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rcx+rax+904]
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN11@FocusWindo
$LN10@FocusWindo:
	mov	DWORD PTR tv78[rsp], 0
$LN11@FocusWindo:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv78[rsp]
	mov	DWORD PTR [rax+7040], ecx

; 4700 : 		g.NavIdIsAlive = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7141], 0

; 4701 : 		g.NavLayer = ImGuiNavLayer_Main;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7132], 0
$LN2@FocusWindo:

; 4702 : 		//IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);
; 4703 : 	}
; 4704 : 
; 4705 : 	// Passing NULL allow to disable keyboard focus
; 4706 : 	if (!window)

	cmp	QWORD PTR window$[rsp], 0
	jne	SHORT $LN4@FocusWindo

; 4707 : 		return;

	jmp	$LN1@FocusWindo
$LN4@FocusWindo:

; 4708 : 
; 4709 : 	// Move the root window to the top of the pile
; 4710 : 	if (window->RootWindow)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+688], 0
	je	SHORT $LN5@FocusWindo

; 4711 : 		window = window->RootWindow;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	mov	QWORD PTR window$[rsp], rax
$LN5@FocusWindo:

; 4712 : 
; 4713 : 	// Steal focus on active widgets
; 4714 : 	if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN6@FocusWindo

; 4715 : 		if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN7@FocusWindo
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6744], 0
	je	SHORT $LN7@FocusWindo
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6744]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+688], rcx
	je	SHORT $LN7@FocusWindo

; 4716 : 			ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN7@FocusWindo:
$LN6@FocusWindo:

; 4717 : 
; 4718 : 	// Bring to front
; 4719 : 	BringWindowToFocusFront(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::BringWindowToFocusFront
	npad	1

; 4720 : 	if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8192				; 00002000H
	test	eax, eax
	jne	SHORT $LN8@FocusWindo

; 4721 : 		BringWindowToDisplayFront(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::BringWindowToDisplayFront
	npad	1
$LN8@FocusWindo:
$LN1@FocusWindo:

; 4722 : }

	add	rsp, 56					; 00000038H
	ret	0
?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ENDP		; ImGui::FocusWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
name$ = 64
?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z PROC	; ImGui::FindWindowByName

; 3583 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3584 : 	ImGuiID id = ImHashStr(name, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR name$[rsp]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	DWORD PTR id$[rsp], eax

; 3585 : 	return FindWindowByID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z ; ImGui::FindWindowByID

; 3586 : }

	add	rsp, 56					; 00000038H
	ret	0
?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ENDP	; ImGui::FindWindowByName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv69 = 40
id$ = 64
?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z PROC	; ImGui::FindWindowByID

; 3577 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 3578 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3579 : 	return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6616				; 000019d8H
	mov	QWORD PTR tv69[rsp], rax
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z	; ImGuiStorage::GetVoidPtr

; 3580 : }

	add	rsp, 56					; 00000038H
	ret	0
?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z ENDP	; ImGui::FindWindowByID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
g$ = 0
?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindow, COMDAT

; 1326 :     inline    ImGuiWindow* GetCurrentWindow() { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

$LN3:
	sub	rsp, 24
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	BYTE PTR [rax+112], 1
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rsp, 24
	ret	0
?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
g$ = 0
?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindowRead, COMDAT

; 1325 :     inline    ImGuiWindow* GetCurrentWindowRead() { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

$LN3:
	sub	rsp, 24
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rsp, 24
	ret	0
?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindowRead
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImGuiTabBar@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImGuiTabBar@@QEAAPEAXI@Z PROC			; ImGuiTabBar::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImGuiTabBar@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImGuiTabBar@@QEAAPEAXI@Z ENDP			; ImGuiTabBar::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiTabBar@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiTabBar@@QEAA@XZ PROC				; ImGuiTabBar::~ImGuiTabBar, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??1ImGuiTextBuffer@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ	; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiTabBar@@QEAA@XZ ENDP				; ImGuiTabBar::~ImGuiTabBar
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA PROC		; `ImGuiTabBar::~ImGuiTabBar'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ	; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiTabBar@@QEAA@XZ@4HA ENDP		; `ImGuiTabBar::~ImGuiTabBar'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA PROC		; `ImGuiTabBar::~ImGuiTabBar'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1ImGuiTextBuffer@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImGuiTabBar@@QEAA@XZ@4HA ENDP		; `ImGuiTabBar::~ImGuiTabBar'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z PROC ; ImVector<ImGuiTabItem>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ENDP ; ImVector<ImGuiTabItem>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ PROC		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImGuiWindow@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImGuiWindow@@QEAAPEAXI@Z PROC			; ImGuiWindow::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImGuiWindow@@QEAA@XZ			; ImGuiWindow::~ImGuiWindow
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 968				; 000003c8H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImGuiWindow@@QEAAPEAXI@Z ENDP			; ImGuiWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
y1$ = 48
tv88 = 52
tv90 = 56
tv86 = 60
this$ = 80
__$ReturnUdt$ = 88
?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ PROC	; ImGuiWindow::MenuBarRect, COMDAT

; 1231 :     ImRect      MenuBarRect() const { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR this$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR y1$[rsp], xmm0
	mov	rcx, QWORD PTR this$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR y1$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv88[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+32]
	movss	DWORD PTR tv90[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv86[rsp], xmm0
	movss	xmm0, DWORD PTR tv88[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv90[rsp]
	movss	xmm2, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR tv86[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ENDP	; ImGuiWindow::MenuBarRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?MenuBarHeight@ImGuiWindow@@QEBAMXZ
_TEXT	SEGMENT
tv78 = 32
this$ = 64
?MenuBarHeight@ImGuiWindow@@QEBAMXZ PROC		; ImGuiWindow::MenuBarHeight, COMDAT

; 1230 :     float       MenuBarHeight() const { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN3@MenuBarHei
	mov	rcx, QWORD PTR this$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+464]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN4@MenuBarHei
$LN3@MenuBarHei:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv78[rsp], xmm0
$LN4@MenuBarHei:
	movss	xmm0, DWORD PTR tv78[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?MenuBarHeight@ImGuiWindow@@QEBAMXZ ENDP		; ImGuiWindow::MenuBarHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
tv83 = 32
tv81 = 36
$T1 = 40
this$ = 64
__$ReturnUdt$ = 72
?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ PROC	; ImGuiWindow::TitleBarRect, COMDAT

; 1229 :     ImRect      TitleBarRect() const { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR this$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv83[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+32]
	movss	DWORD PTR tv81[rsp], xmm0
	movss	xmm2, DWORD PTR tv83[rsp]
	movss	xmm1, DWORD PTR tv81[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ENDP	; ImGuiWindow::TitleBarRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?TitleBarHeight@ImGuiWindow@@QEBAMXZ
_TEXT	SEGMENT
tv74 = 32
this$ = 64
?TitleBarHeight@ImGuiWindow@@QEBAMXZ PROC		; ImGuiWindow::TitleBarHeight, COMDAT

; 1228 :     float       TitleBarHeight() const { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@TitleBarHe
	xorps	xmm0, xmm0
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN4@TitleBarHe
$LN3@TitleBarHe:
	mov	rcx, QWORD PTR this$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR tv74[rsp], xmm0
$LN4@TitleBarHe:
	movss	xmm0, DWORD PTR tv74[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?TitleBarHeight@ImGuiWindow@@QEBAMXZ ENDP		; ImGuiWindow::TitleBarHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?CalcFontSize@ImGuiWindow@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?CalcFontSize@ImGuiWindow@@QEBAMXZ PROC			; ImGuiWindow::CalcFontSize, COMDAT

; 1227 :     float       CalcFontSize() const { return GImGui->FontBaseSize * FontWindowScale; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+6412]
	mulss	xmm0, DWORD PTR [rcx+680]
	ret	0
?CalcFontSize@ImGuiWindow@@QEBAMXZ ENDP			; ImGuiWindow::CalcFontSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ PROC		; ImGuiWindow::Rect, COMDAT

; 1226 :     ImRect      Rect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	addss	xmm1, DWORD PTR [rcx]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ ENDP		; ImGuiWindow::Rect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
seed$ = 36
r_rel$ = 40
__$ArrayPad$ = 56
this$ = 80
r_abs$ = 88
?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z PROC ; ImGuiWindow::GetIDFromRectangle

; 1706 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1707 : 	ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR seed$[rsp], eax

; 1708 : 	const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };

	mov	rax, QWORD PTR r_abs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx+48]
	cvttss2si eax, xmm0
	mov	DWORD PTR r_rel$[rsp], eax
	mov	rax, QWORD PTR r_abs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+52]
	cvttss2si eax, xmm0
	mov	DWORD PTR r_rel$[rsp+4], eax
	mov	rax, QWORD PTR r_abs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx+48]
	cvttss2si eax, xmm0
	mov	DWORD PTR r_rel$[rsp+8], eax
	mov	rax, QWORD PTR r_abs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+52]
	cvttss2si eax, xmm0
	mov	DWORD PTR r_rel$[rsp+12], eax

; 1709 : 	ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);

	mov	r8d, DWORD PTR seed$[rsp]
	mov	edx, 16
	lea	rcx, QWORD PTR r_rel$[rsp]
	call	?ImHashData@@YAIPEBX_KI@Z		; ImHashData
	mov	DWORD PTR id$[rsp], eax

; 1710 : 	ImGui::KeepAliveID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID

; 1711 : 	return id;

	mov	eax, DWORD PTR id$[rsp]

; 1712 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	ret	0
?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z ENDP ; ImGuiWindow::GetIDFromRectangle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
seed$ = 32
this$ = 64
ptr$ = 72
?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z PROC		; ImGuiWindow::GetIDNoKeepAlive

; 1699 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1700 : 	ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR seed$[rsp], eax

; 1701 : 	return ImHashData(&ptr, sizeof(void*), seed);

	mov	r8d, DWORD PTR seed$[rsp]
	mov	edx, 8
	lea	rcx, QWORD PTR ptr$[rsp]
	call	?ImHashData@@YAIPEBX_KI@Z		; ImHashData

; 1702 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z ENDP		; ImGuiWindow::GetIDNoKeepAlive
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
seed$ = 32
tv75 = 36
tv71 = 40
this$ = 64
str$ = 72
str_end$ = 80
?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z PROC	; ImGuiWindow::GetIDNoKeepAlive

; 1693 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1694 : 	ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR seed$[rsp], eax

; 1695 : 	return ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR tv75[rsp], eax
	cmp	QWORD PTR str_end$[rsp], 0
	je	SHORT $LN3@GetIDNoKee
	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR str_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN4@GetIDNoKee
$LN3@GetIDNoKee:
	mov	QWORD PTR tv71[rsp], 0
$LN4@GetIDNoKee:
	mov	r8d, DWORD PTR tv75[rsp]
	mov	rdx, QWORD PTR tv71[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr

; 1696 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z ENDP	; ImGuiWindow::GetIDNoKeepAlive
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
seed$ = 36
this$ = 64
ptr$ = 72
?GetID@ImGuiWindow@@QEAAIPEBX@Z PROC			; ImGuiWindow::GetID

; 1685 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1686 : 	ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR seed$[rsp], eax

; 1687 : 	ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);

	mov	r8d, DWORD PTR seed$[rsp]
	mov	edx, 8
	lea	rcx, QWORD PTR ptr$[rsp]
	call	?ImHashData@@YAIPEBX_KI@Z		; ImHashData
	mov	DWORD PTR id$[rsp], eax

; 1688 : 	ImGui::KeepAliveID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID

; 1689 : 	return id;

	mov	eax, DWORD PTR id$[rsp]

; 1690 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetID@ImGuiWindow@@QEAAIPEBX@Z ENDP			; ImGuiWindow::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
seed$ = 36
tv75 = 40
tv71 = 48
this$ = 80
str$ = 88
str_end$ = 96
?GetID@ImGuiWindow@@QEAAIPEBD0@Z PROC			; ImGuiWindow::GetID

; 1677 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1678 : 	ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR seed$[rsp], eax

; 1679 : 	ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR tv75[rsp], eax
	cmp	QWORD PTR str_end$[rsp], 0
	je	SHORT $LN3@GetID
	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR str_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN4@GetID
$LN3@GetID:
	mov	QWORD PTR tv71[rsp], 0
$LN4@GetID:
	mov	r8d, DWORD PTR tv75[rsp]
	mov	rdx, QWORD PTR tv71[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	DWORD PTR id$[rsp], eax

; 1680 : 	ImGui::KeepAliveID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID

; 1681 : 	return id;

	mov	eax, DWORD PTR id$[rsp]

; 1682 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetID@ImGuiWindow@@QEAAIPEBD0@Z ENDP			; ImGuiWindow::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
tv83 = 40
tv88 = 48
this$ = 80
??1ImGuiWindow@@QEAA@XZ PROC				; ImGuiWindow::~ImGuiWindow

; 1669 : {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1670 : 	IM_ASSERT(DrawList == &DrawListInst);
; 1671 : 	//IM_DELETE(Name);
; 1672 : 	for (int i = 0; i != ColumnsStorage.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ImGuiWindo
$LN2@ImGuiWindo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ImGuiWindo:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+664]
	cmp	DWORD PTR i$1[rsp], eax
	je	SHORT $LN3@ImGuiWindo

; 1673 : 		ColumnsStorage[i].~ImGuiColumnsSet();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 664				; 00000298H
	mov	QWORD PTR tv83[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z ; ImVector<ImGuiColumnsSet>::operator[]
	mov	QWORD PTR tv88[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv88[rsp]
	call	??_GImGuiColumnsSet@@QEAAPEAXI@Z
	npad	1
	jmp	SHORT $LN2@ImGuiWindo
$LN3@ImGuiWindo:

; 1674 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 712				; 000002c8H
	mov	rcx, rax
	call	??1ImDrawList@@QEAA@XZ			; ImDrawList::~ImDrawList
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 664				; 00000298H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ ; ImVector<ImGuiColumnsSet>::~ImVector<ImGuiColumnsSet>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 304				; 00000130H
	mov	rcx, rax
	call	??1ImGuiWindowTempData@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 288				; 00000120H
	mov	rcx, rax
	call	??1ImGuiStorage@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	??1?$ImVector@I@@QEAA@XZ		; ImVector<unsigned int>::~ImVector<unsigned int>
	npad	1
	add	rsp, 72					; 00000048H
	ret	0
??1ImGuiWindow@@QEAA@XZ ENDP				; ImGuiWindow::~ImGuiWindow
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
tv83 = 40
tv88 = 48
this$ = 80
?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA PROC		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 232				; 000000e8H
	call	??1?$ImVector@I@@QEAA@XZ		; ImVector<unsigned int>::~ImVector<unsigned int>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiWindow@@QEAA@XZ@4HA ENDP		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
tv83 = 40
tv88 = 48
this$ = 80
?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA PROC		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 288				; 00000120H
	call	??1ImGuiStorage@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImGuiWindow@@QEAA@XZ@4HA ENDP		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
tv83 = 40
tv88 = 48
this$ = 80
?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA PROC		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 304				; 00000130H
	call	??1ImGuiWindowTempData@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImGuiWindow@@QEAA@XZ@4HA ENDP		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
tv83 = 40
tv88 = 48
this$ = 80
?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA PROC		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 664				; 00000298H
	call	??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ ; ImVector<ImGuiColumnsSet>::~ImVector<ImGuiColumnsSet>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???1ImGuiWindow@@QEAA@XZ@4HA ENDP		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
tv83 = 40
tv88 = 48
this$ = 80
?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA PROC		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 712				; 000002c8H
	call	??1ImDrawList@@QEAA@XZ			; ImDrawList::~ImDrawList
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???1ImGuiWindow@@QEAA@XZ@4HA ENDP		; `ImGuiWindow::~ImGuiWindow'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv160 = 32
tv181 = 40
tv475 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
context$ = 184
name$ = 192
??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z PROC	; ImGuiWindow::ImGuiWindow

; 1607 : {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 92					; 0000005cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 124				; 0000007cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 200				; 000000c8H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 208				; 000000d0H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	??0?$ImVector@I@@QEAA@XZ		; ImVector<unsigned int>::ImVector<unsigned int>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 248				; 000000f8H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 264				; 00000108H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 288				; 00000120H
	mov	rcx, rax
	call	??0ImGuiStorage@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 304				; 00000130H
	mov	rcx, rax
	call	??0ImGuiWindowTempData@@QEAA@XZ		; ImGuiWindowTempData::ImGuiWindowTempData
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 584				; 00000248H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 600				; 00000258H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 616				; 00000268H
	mov	rcx, rax
	call	??0ImGuiMenuColumns@@QEAA@XZ		; ImGuiMenuColumns::ImGuiMenuColumns
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 664				; 00000298H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ ; ImVector<ImGuiColumnsSet>::ImVector<ImGuiColumnsSet>
	npad	1

; 1606 : 	: DrawListInst(&context->DrawListSharedData)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 712				; 000002c8H
	mov	QWORD PTR tv160[rsp], rax
	mov	rax, QWORD PTR context$[rsp]
	add	rax, 6416				; 00001910H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv160[rsp]
	call	??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ; ImDrawList::ImDrawList
	npad	1

; 1607 : {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 912				; 00000390H
	lea	r9, OFFSET FLAT:??0ImRect@@QEAA@XZ	; ImRect::ImRect
	mov	r8d, 2
	mov	edx, 16
	mov	rcx, rax
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z

; 1608 : 	Name = hash_(name);

	mov	rcx, QWORD PTR name$[rsp]
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1609 : 	ID = ImHashStr(name, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR name$[rsp]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 1610 : 	IDStack.push_back(ID);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv181[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rdx, rax
	mov	rcx, QWORD PTR tv181[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back

; 1611 : 	Flags = ImGuiWindowFlags_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0

; 1612 : 	Pos = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1613 : 	Size = SizeFull = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 1614 : 	SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+72], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1615 : 	WindowPadding = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 1616 : 	WindowRounding = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+88], xmm0

; 1617 : 	WindowBorderSize = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+56], xmm0

; 1618 : 	NameBufLen = (int)strlen(name) + 1;

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 1619 : 	MoveId = GetID(("#MOVE"));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_05EJCOBEBF@?$CDMOVE@
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+68], eax

; 1620 : 	ChildId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1621 : 	Scroll = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+92], rax

; 1622 : 	ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 1623 : 	ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+116], rax

; 1624 : 	ScrollbarSizes = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+124], rax

; 1625 : 	ScrollbarX = ScrollbarY = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+101], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+100], 0

; 1626 : 	Active = WasActive = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+132], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+102], 0

; 1627 : 	WriteAccessed = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+112], 0

; 1628 : 	Collapsed = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+113], 0

; 1629 : 	WantCollapseToggle = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+114], 0

; 1630 : 	SkipItems = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+115], 0

; 1631 : 	Appearing = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+133], 0

; 1632 : 	Hidden = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+140], 0

; 1633 : 	HasCloseButton = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+148], 0

; 1634 : 	ResizeBorderHeld = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+134], -1

; 1635 : 	BeginCount = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+136], ax

; 1636 : 	BeginOrderWithinParent = -1;

	mov	eax, -1
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+138], ax

; 1637 : 	BeginOrderWithinContext = -1;

	mov	eax, -1
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+150], ax

; 1638 : 	PopupId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0

; 1639 : 	AutoFitFramesX = AutoFitFramesY = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+160], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+156], -1

; 1640 : 	AutoFitOnlyGrows = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+164], 0

; 1641 : 	AutoFitChildAxises = 0x00;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+180], 0

; 1642 : 	AutoPosLastDirection = ImGuiDir_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+184], -1

; 1643 : 	HiddenFramesRegular = HiddenFramesForResize = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+168], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+188], 0

; 1644 : 	SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+176], 15
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+144], 15
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+172], 15

; 1645 : 	SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+200], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+200]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 1646 : 
; 1647 : 	LastFrameActive = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+224], -1

; 1648 : 	ItemWidthDefault = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+280], xmm0

; 1649 : 	FontWindowScale = 1.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+680], xmm0

; 1650 : 	SettingsIdx = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+684], -1

; 1651 : 
; 1652 : 	DrawList = &DrawListInst;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 712				; 000002c8H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+696], rax

; 1653 : 	DrawList->_OwnerName = Name;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+56], rcx

; 1654 : 	ParentWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+880], 0

; 1655 : 	RootWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+688], 0

; 1656 : 	RootWindowForTitleBarHighlight = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+704], 0

; 1657 : 	RootWindowForNav = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+888], 0

; 1658 : 
; 1659 : 	NavLastIds[0] = NavLastIds[1] = 0;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+rax+904], 0
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+rax+904], 0

; 1660 : 	NavRectRel[0] = NavRectRel[1] = ImRect();

	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+912]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	eax, 16
	imul	rax, rax, 1
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	mov	QWORD PTR tv475[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx+912]
	mov	rcx, QWORD PTR tv475[rsp]
	lea	rsi, QWORD PTR [rcx+rax+912]
	mov	ecx, 16
	rep movsb

; 1661 : 	NavLastChildNavWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+896], 0

; 1662 : 
; 1663 : 	FocusIdxAllCounter = FocusIdxTabCounter = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+960], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+944], -1

; 1664 : 	FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+956], 2147483647		; 7fffffffH
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+948], 2147483647		; 7fffffffH

; 1665 : 	FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+964], 2147483647		; 7fffffffH
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+952], 2147483647		; 7fffffffH

; 1666 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
??0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z ENDP	; ImGuiWindow::ImGuiWindow
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv160 = 32
tv181 = 40
tv475 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
context$ = 184
name$ = 192
?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA PROC ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 232				; 000000e8H
	call	??1?$ImVector@I@@QEAA@XZ		; ImVector<unsigned int>::~ImVector<unsigned int>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA ENDP ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv160 = 32
tv181 = 40
tv475 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
context$ = 184
name$ = 192
?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA PROC ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 288				; 00000120H
	call	??1ImGuiStorage@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA ENDP ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv160 = 32
tv181 = 40
tv475 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
context$ = 184
name$ = 192
?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA PROC ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 304				; 00000130H
	call	??1ImGuiWindowTempData@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA ENDP ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv160 = 32
tv181 = 40
tv475 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
context$ = 184
name$ = 192
?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA PROC ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 664				; 00000298H
	call	??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ ; ImVector<ImGuiColumnsSet>::~ImVector<ImGuiColumnsSet>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA ENDP ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv160 = 32
tv181 = 40
tv475 = 48
$T1 = 56
$T2 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
context$ = 184
name$ = 192
?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA PROC ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 712				; 000002c8H
	call	??1ImDrawList@@QEAA@XZ			; ImDrawList::~ImDrawList
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ImGuiWindow@@QEAA@PEAUImGuiContext@@PEBD@Z@4HA ENDP ; `ImGuiWindow::ImGuiWindow'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z PROC ; ImVector<ImGuiColumnsSet>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z ; ImVector<ImGuiColumnsSet>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z ; ImVector<ImGuiColumnsSet>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 64					; 00000040H
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImGuiColumnsSet@@@@QEAAXAEBUImGuiColumnsSet@@@Z ENDP ; ImVector<ImGuiColumnsSet>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z PROC	; ImVector<ImGuiColumnsSet>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 64				; 00000040H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiColumnsSet@@@@QEAAXH@Z ENDP	; ImVector<ImGuiColumnsSet>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z PROC ; ImVector<ImGuiColumnsSet>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiColumnsSet@@@@QEBAHH@Z ENDP ; ImVector<ImGuiColumnsSet>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@XZ PROC ; ImVector<ImGuiColumnsSet>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@XZ ENDP ; ImVector<ImGuiColumnsSet>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z PROC ; ImVector<ImGuiColumnsSet>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiColumnsSet@@@@QEAAAEAUImGuiColumnsSet@@H@Z ENDP ; ImVector<ImGuiColumnsSet>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ PROC		; ImVector<ImGuiColumnsSet>::~ImVector<ImGuiColumnsSet>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ ENDP		; ImVector<ImGuiColumnsSet>::~ImVector<ImGuiColumnsSet>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ PROC		; ImVector<ImGuiColumnsSet>::ImVector<ImGuiColumnsSet>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiColumnsSet@@@@QEAA@XZ ENDP		; ImVector<ImGuiColumnsSet>::ImVector<ImGuiColumnsSet>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@I@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@I@@QEAAXXZ PROC			; ImVector<unsigned int>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@I@@QEAAXXZ ENDP			; ImVector<unsigned int>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@I@@QEAAXAEBI@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@I@@QEAAXAEBI@Z PROC		; ImVector<unsigned int>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@I@@QEBAHH@Z	; ImVector<unsigned int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	r8d, 4
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@I@@QEAAXAEBI@Z ENDP		; ImVector<unsigned int>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@I@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@I@@QEAAXH@Z PROC			; ImVector<unsigned int>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@I@@QEAAXH@Z ENDP			; ImVector<unsigned int>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@I@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@I@@QEAAXH@Z PROC			; ImVector<unsigned int>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@I@@QEBAHH@Z	; ImVector<unsigned int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@I@@QEAAXH@Z ENDP			; ImVector<unsigned int>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@I@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@I@@QEBAHH@Z PROC		; ImVector<unsigned int>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@I@@QEBAHH@Z ENDP		; ImVector<unsigned int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@I@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@I@@QEAAAEAIXZ PROC			; ImVector<unsigned int>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
?back@?$ImVector@I@@QEAAAEAIXZ ENDP			; ImVector<unsigned int>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@I@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@I@@QEAA@XZ PROC				; ImVector<unsigned int>::~ImVector<unsigned int>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@I@@QEAA@XZ ENDP				; ImVector<unsigned int>::~ImVector<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@I@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@I@@QEAA@XZ PROC				; ImVector<unsigned int>::ImVector<unsigned int>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@I@@QEAA@XZ ENDP				; ImVector<unsigned int>::ImVector<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiWindowTempData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiWindowTempData@@QEAA@XZ PROC			; ImGuiWindowTempData::~ImGuiWindowTempData, COMDAT
$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ ; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 216				; 000000d8H
	mov	rcx, rax
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	rcx, rax
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 176				; 000000b0H
	mov	rcx, rax
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiWindowTempData@@QEAA@XZ ENDP			; ImGuiWindowTempData::~ImGuiWindowTempData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 176				; 000000b0H
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 192				; 000000c0H
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 216				; 000000d8H
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 232				; 000000e8H
	call	??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ ; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???1ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::~ImGuiWindowTempData'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiWindowTempData@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 52
$T6 = 60
$T7 = 68
this$ = 128
??0ImGuiWindowTempData@@QEAA@XZ PROC			; ImGuiWindowTempData::ImGuiWindowTempData, COMDAT

; 1100 :     ImGuiWindowTempData()

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 1101 :     {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 44					; 0000002cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 156				; 0000009cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 176				; 000000b0H
	mov	rcx, rax
	call	??0?$ImVector@M@@QEAA@XZ		; ImVector<float>::ImVector<float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	rcx, rax
	call	??0?$ImVector@M@@QEAA@XZ		; ImVector<float>::ImVector<float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 216				; 000000d8H
	mov	rcx, rax
	call	??0?$ImVector@H@@QEAA@XZ		; ImVector<int>::ImVector<int>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiGroupData@@@@QEAA@XZ ; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 260				; 00000104H
	mov	rcx, rax
	call	??0ImVec1@@QEAA@XZ			; ImVec1::ImVec1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 272				; 00000110H
	mov	rcx, rax
	call	??0ImVec1@@QEAA@XZ			; ImVec1::ImVec1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 276				; 00000114H
	mov	rcx, rax
	call	??0ImVec1@@QEAA@XZ			; ImVec1::ImVec1
	npad	1

; 1102 :         CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+44], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+36], rax

; 1103 :         CurrentLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+28], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+28]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1104 :         CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+52], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+24], xmm0

; 1105 :         LogLinePosY = -1.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rax+56], xmm0

; 1106 :         TreeDepth = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1107 :         TreeDepthMayJumpToParentOnPop = 0x00;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+104], 0

; 1108 :         LastItemId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+108], 0

; 1109 :         LastItemStatusFlags = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+112], 0

; 1110 :         LastItemRect = LastItemDisplayRect = ImRect();

	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+80]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rax+64]
	lea	rsi, QWORD PTR [rcx+80]
	mov	ecx, 16
	rep movsb

; 1111 :         NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+120], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+116], 0

; 1112 :         NavLayerCurrent = ImGuiNavLayer_Main;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+96], 0

; 1113 :         NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+100], 1

; 1114 :         NavHideHighlightOneFrame = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+124], 0

; 1115 :         NavHasScroll = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+152], 0

; 1116 :         MenuBarAppending = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+153], 0

; 1117 :         MenuBarOffset = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+156], rax

; 1118 :         StateStorage = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+144], 0

; 1119 :         LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+168], 1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+164], 1

; 1120 :         ItemWidth = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+208], xmm0

; 1121 :         ItemFlags = ImGuiItemFlags_Default_;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+172], 0

; 1122 :         TextWrapPos = -1.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rax+212], xmm0

; 1123 :         memset(StackSizesBackup, 0, sizeof(StackSizesBackup));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 248				; 000000f8H
	mov	r8d, 12
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 1124 : 
; 1125 :         Indent = ImVec1(0.0f);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec1@@QEAA@M@Z			; ImVec1::ImVec1
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+272], eax

; 1126 :         GroupOffset = ImVec1(0.0f);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec1@@QEAA@M@Z			; ImVec1::ImVec1
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+276], eax

; 1127 :         ColumnsOffset = ImVec1(0.0f);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec1@@QEAA@M@Z			; ImVec1::ImVec1
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+260], eax

; 1128 :         ColumnsSet = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+264], 0

; 1129 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
??0ImGuiWindowTempData@@QEAA@XZ ENDP			; ImGuiWindowTempData::ImGuiWindowTempData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 52
$T6 = 60
$T7 = 68
this$ = 128
?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 52
$T6 = 60
$T7 = 68
this$ = 128
?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 176				; 000000b0H
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 52
$T6 = 60
$T7 = 68
this$ = 128
?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 192				; 000000c0H
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 52
$T6 = 60
$T7 = 68
this$ = 128
?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 216				; 000000d8H
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 52
$T6 = 60
$T7 = 68
this$ = 128
?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA PROC	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 232				; 000000e8H
	call	??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ ; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ImGuiWindowTempData@@QEAA@XZ@4HA ENDP	; `ImGuiWindowTempData::ImGuiWindowTempData'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiGroupData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImGuiGroupData@@@@QEAAXXZ PROC	; ImVector<ImGuiGroupData>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImGuiGroupData@@@@QEAAXXZ ENDP	; ImVector<ImGuiGroupData>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z PROC	; ImVector<ImGuiGroupData>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z ENDP	; ImVector<ImGuiGroupData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z PROC	; ImVector<ImGuiGroupData>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z ; ImVector<ImGuiGroupData>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z ; ImVector<ImGuiGroupData>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z ENDP	; ImVector<ImGuiGroupData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z PROC ; ImVector<ImGuiGroupData>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiGroupData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ PROC ; ImVector<ImGuiGroupData>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ENDP ; ImVector<ImGuiGroupData>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ PROC		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiGroupData@@@@QEAA@XZ ENDP		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiGroupData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiGroupData@@@@QEAA@XZ PROC		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiGroupData@@@@QEAA@XZ ENDP		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImGuiContext@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImGuiContext@@QEAAPEAXI@Z PROC			; ImGuiContext::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImGuiContext@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 15328				; 00003be0H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImGuiContext@@QEAAPEAXI@Z ENDP			; ImGuiContext::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiContext@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiContext@@QEAA@XZ PROC				; ImGuiContext::~ImGuiContext, COMDAT
$LN24:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11704				; 00002db8H
	mov	rcx, rax
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7936				; 00001f00H
	mov	rcx, rax
	call	??1ImGuiInputTextState@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7816				; 00001e88H
	mov	rcx, rax
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ ; ImVector<ImGuiTabBar *>::~ImVector<ImGuiTabBar *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7784				; 00001e68H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ ; ImVector<ImGuiTabBarSortItem>::~ImVector<ImGuiTabBarSortItem>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7744				; 00001e40H
	mov	rcx, rax
	call	??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ	; ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7712				; 00001e20H
	mov	rcx, rax
	call	??1?$ImVector@E@@QEAA@XZ		; ImVector<unsigned char>::~ImVector<unsigned char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7560				; 00001d88H
	mov	rcx, rax
	call	??1ImDrawDataBuilder@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7512				; 00001d58H
	mov	rcx, rax
	call	??1ImDrawData@@QEAA@XZ			; ImDrawData::~ImDrawData
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	rcx, rax
	call	??1ImDrawList@@QEAA@XZ			; ImDrawList::~ImDrawList
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6840				; 00001ab8H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ	; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6784				; 00001a80H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ	; ImVector<ImGuiColorMod>::~ImVector<ImGuiColorMod>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6656				; 00001a00H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6632				; 000019e8H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6616				; 000019d8H
	mov	rcx, rax
	call	??1ImGuiStorage@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6600				; 000019c8H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??1ImGuiIO@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiContext@@QEAA@XZ ENDP				; ImGuiContext::~ImGuiContext
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1ImGuiIO@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6600				; 000019c8H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6616				; 000019d8H
	call	??1ImGuiStorage@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6632				; 000019e8H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6656				; 00001a00H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6672				; 00001a10H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6784				; 00001a80H
	call	??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ	; ImVector<ImGuiColorMod>::~ImVector<ImGuiColorMod>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6840				; 00001ab8H
	call	??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ	; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6856				; 00001ac8H
	call	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6872				; 00001ad8H
	call	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6888				; 00001ae8H
	call	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$11
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7336				; 00001ca8H
	call	??1ImDrawList@@QEAA@XZ			; ImDrawList::~ImDrawList
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$11@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$12
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7512				; 00001d58H
	call	??1ImDrawData@@QEAA@XZ			; ImDrawData::~ImDrawData
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$12@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7560				; 00001d88H
	call	??1ImDrawDataBuilder@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$14
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7712				; 00001e20H
	call	??1?$ImVector@E@@QEAA@XZ		; ImVector<unsigned char>::~ImVector<unsigned char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$14@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$15
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7744				; 00001e40H
	call	??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ	; ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$15@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$16
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7784				; 00001e68H
	call	??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ ; ImVector<ImGuiTabBarSortItem>::~ImVector<ImGuiTabBarSortItem>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$16@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$17
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7800				; 00001e78H
	call	??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ ; ImVector<ImGuiTabBar *>::~ImVector<ImGuiTabBar *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$17@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$18
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7816				; 00001e88H
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$18@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$19
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7936				; 00001f00H
	call	??1ImGuiInputTextState@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$19@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA PROC		; `ImGuiContext::~ImGuiContext'::`1'::dtor$20
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 11704				; 00002db8H
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$20@?0???1ImGuiContext@@QEAA@XZ@4HA ENDP		; `ImGuiContext::~ImGuiContext'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z
_TEXT	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z PROC		; ImGuiContext::ImGuiContext, COMDAT

; 939  :     {

$LN31:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImGuiIO@@QEAA@XZ			; ImGuiIO::ImGuiIO
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 5472				; 00001560H
	mov	rcx, rax
	call	??0ImGuiStyle@@QEAA@XZ			; ImGuiStyle::ImGuiStyle
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6416				; 00001910H
	mov	rcx, rax
	call	??0ImDrawListSharedData@@QEAA@XZ	; ImDrawListSharedData::ImDrawListSharedData
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6600				; 000019c8H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6616				; 000019d8H
	mov	rcx, rax
	call	??0ImGuiStorage@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6632				; 000019e8H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6656				; 00001a00H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6784				; 00001a80H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiColorMod@@@@QEAA@XZ	; ImVector<ImGuiColorMod>::ImVector<ImGuiColorMod>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6812				; 00001a9cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6832				; 00001ab0H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6840				; 00001ab8H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiStyleMod@@@@QEAA@XZ	; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::ImVector<ImFont *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6912				; 00001b00H
	mov	rcx, rax
	call	??0ImGuiNextWindowData@@QEAA@XZ		; ImGuiNextWindowData::ImGuiNextWindowData
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7072				; 00001ba0H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7152				; 00001bf0H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7176				; 00001c08H
	mov	rcx, rax
	call	??0ImGuiNavMoveResult@@QEAA@XZ		; ImGuiNavMoveResult::ImGuiNavMoveResult
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7224				; 00001c38H
	mov	rcx, rax
	call	??0ImGuiNavMoveResult@@QEAA@XZ		; ImGuiNavMoveResult::ImGuiNavMoveResult
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7288				; 00001c78H
	mov	rcx, rax
	call	??0ImGuiNavMoveResult@@QEAA@XZ		; ImGuiNavMoveResult::ImGuiNavMoveResult

; 938  :     ImGuiContext(ImFontAtlas* shared_font_atlas) : OverlayDrawList(NULL)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	QWORD PTR tv176[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv176[rsp]
	call	??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ; ImDrawList::ImDrawList
	npad	1

; 939  :     {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7512				; 00001d58H
	mov	rcx, rax
	call	??0ImDrawData@@QEAA@XZ			; ImDrawData::ImDrawData
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7560				; 00001d88H
	mov	rcx, rax
	call	??0ImDrawDataBuilder@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7616				; 00001dc0H
	mov	rcx, rax
	call	??0ImGuiPayload@@QEAA@XZ		; ImGuiPayload::ImGuiPayload
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7680				; 00001e00H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7712				; 00001e20H
	mov	rcx, rax
	call	??0?$ImVector@E@@QEAA@XZ		; ImVector<unsigned char>::ImVector<unsigned char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7744				; 00001e40H
	mov	rcx, rax
	call	??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ	; ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7784				; 00001e68H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ ; ImVector<ImGuiTabBarSortItem>::ImVector<ImGuiTabBarSortItem>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ ; ImVector<ImGuiTabBar *>::ImVector<ImGuiTabBar *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7816				; 00001e88H
	mov	rcx, rax
	call	??0ImFont@@QEAA@XZ			; ImFont::ImFont
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7936				; 00001f00H
	mov	rcx, rax
	call	??0ImGuiInputTextState@@QEAA@XZ		; ImGuiInputTextState::ImGuiInputTextState
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11680				; 00002da0H
	mov	rcx, rax
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11704				; 00002db8H
	mov	rcx, rax
	call	??0?$ImVector@D@@QEAA@XZ		; ImVector<char>::ImVector<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11720				; 00002dc8H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11732				; 00002dd4H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11740				; 00002ddcH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 940  :         Initialized = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1], 0

; 941  :         FrameScopeActive = FrameScopePushedImplicitWindow = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+3], 0

; 942  :         Font = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 943  :         FontSize = FontBaseSize = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6412], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6408], xmm0

; 944  :         FontAtlasOwnedByContext = shared_font_atlas ? false : true;

	cmp	QWORD PTR shared_font_atlas$[rsp], 0
	je	SHORT $LN3@ImGuiConte
	mov	BYTE PTR tv244[rsp], 0
	jmp	SHORT $LN4@ImGuiConte
$LN3@ImGuiConte:
	mov	BYTE PTR tv244[rsp], 1
$LN4@ImGuiConte:
	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR tv244[rsp]
	mov	BYTE PTR [rax+2], cl

; 945  :         IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();

	cmp	QWORD PTR shared_font_atlas$[rsp], 0
	je	SHORT $LN7@ImGuiConte
	mov	rax, QWORD PTR shared_font_atlas$[rsp]
	mov	QWORD PTR tv264[rsp], rax
	jmp	SHORT $LN8@ImGuiConte
$LN7@ImGuiConte:
	mov	ecx, 128				; 00000080H
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	r8, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR $T4[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 128				; 00000080H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN5@ImGuiConte
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0ImFontAtlas@@QEAA@XZ			; ImFontAtlas::ImFontAtlas
	mov	QWORD PTR tv263[rsp], rax
	jmp	SHORT $LN6@ImGuiConte
$LN5@ImGuiConte:
	mov	QWORD PTR tv263[rsp], 0
$LN6@ImGuiConte:
	mov	rax, QWORD PTR tv263[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR tv264[rsp], rax
$LN8@ImGuiConte:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv264[rsp]
	mov	QWORD PTR [rax+176], rcx

; 946  : 
; 947  :         Time = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [rax+6576], xmm0

; 948  :         FrameCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6552], 0

; 949  :         FrameCountEnded = FrameCountRendered = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6592], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6568], -1

; 950  :         WindowsActiveCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6648], 0

; 951  :         CurrentWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+6584], 0

; 952  :         HoveredWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+6560], 0

; 953  :         HoveredRootWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+6688], 0

; 954  :         HoveredId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6696], 0

; 955  :         HoveredIdAllowOverlap = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6700], 0

; 956  :         HoveredIdPreviousFrame = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6724], 0

; 957  :         HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6712], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6728], xmm0

; 958  :         ActiveId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6704], 0

; 959  :         ActiveIdPreviousFrame = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6708], 0

; 960  :         ActiveIdIsAlive = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6720], 0

; 961  :         ActiveIdTimer = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6736], xmm0

; 962  :         ActiveIdIsJustActivated = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6752], 0

; 963  :         ActiveIdAllowOverlap = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6753], 0

; 964  :         ActiveIdHasBeenPressed = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6716], 0

; 965  :         ActiveIdHasBeenEdited = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6732], 0

; 966  :         ActiveIdPreviousFrameIsAlive = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6768], 0

; 967  :         ActiveIdPreviousFrameHasBeenEdited = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6800], 0

; 968  :         ActiveIdAllowNavDirFlags = 0x00;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6804], 0

; 969  :         ActiveIdBlockNavInputFlags = 0x00;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6808], 0

; 970  :         ActiveIdClickOffset = ImVec2(-1, -1);

	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+6812], rax

; 971  :         ActiveIdWindow = ActiveIdPreviousFrameWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+6760], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+6744], 0

; 972  :         ActiveIdSource = ImGuiInputSource_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6820], 0

; 973  :         LastActiveId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6824], 0

; 974  :         LastActiveIdTimer = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6828], xmm0

; 975  :         LastValidMousePos = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+6832], rax

; 976  :         MovingWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+6776], 0

; 977  :         NextTreeNodeOpenVal = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+6904], 0

; 978  :         NextTreeNodeOpenCond = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+6908], 0

; 979  : 
; 980  :         NavWindow = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+7024], 0

; 981  :         NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7048], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7036], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7032], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7044], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7040], 0

; 982  :         NavJustTabbedId = NavJustMovedToId = NavJustMovedToSelectScopeId = NavNextActivateId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7056], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7068], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7064], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7052], 0

; 983  :         NavInputSource = ImGuiInputSource_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7060], 0

; 984  :         NavScoringRectScreen = ImRect();

	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+7072]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 985  :         NavScoringCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7088], 0

; 986  :         NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+7120], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+7112], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+7104], 0

; 987  :         NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+7096], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+7092], xmm0

; 988  :         NavWindowingToggleLayer = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7128], 0

; 989  :         NavLayer = ImGuiNavLayer_Main;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7132], 0

; 990  :         NavIdTabCounter = INT_MAX;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7136], 2147483647	; 7fffffffH

; 991  :         NavIdIsAlive = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7141], 0

; 992  :         NavMousePosDirty = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7142], 0

; 993  :         NavDisableHighlight = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7140], 1

; 994  :         NavDisableMouseHover = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7143], 0

; 995  :         NavAnyRequest = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7144], 0

; 996  :         NavInitRequest = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7168], 0

; 997  :         NavInitRequestFromMove = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7169], 0

; 998  :         NavInitResultId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7148], 0

; 999  :         NavMoveFromClampedRefRect = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7170], 0

; 1000 :         NavMoveRequest = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7171], 0

; 1001 :         NavMoveRequestFlags = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7172], 0

; 1002 :         NavMoveRequestForward = ImGuiNavForward_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7272], 0

; 1003 :         NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7284], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7280], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7276], -1

; 1004 : 
; 1005 :         DimBgRatio = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+7592], xmm0

; 1006 :         OverlayDrawList._Data = &DrawListSharedData;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 6416				; 00001910H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+7408], rax

; 1007 :         OverlayDrawList._OwnerName = hash_(("##+-oly"))/*"##Overlay"*/; // Give it a name for debugging

	lea	rcx, OFFSET FLAT:??_C@_07JLDOGPMM@?$CD?$CD?$CL?9oly@
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+7392], rax

; 1008 :         MouseCursor = ImGuiMouseCursor_Arrow;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7504], 0

; 1009 : 
; 1010 :         DragDropActive = DragDropWithinSourceOrTarget = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7597], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+7596], 0

; 1011 :         DragDropSourceFlags = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7608], 0

; 1012 :         DragDropSourceFrameCount = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7600], -1

; 1013 :         DragDropMouseButton = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7604], -1

; 1014 :         DragDropTargetId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7700], 0

; 1015 :         DragDropAcceptFlags = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7704], 0

; 1016 :         DragDropAcceptIdCurrRectSurface = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+7696], xmm0

; 1017 :         DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7708], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7736], 0

; 1018 :         DragDropAcceptFrameCount = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+7740], -1

; 1019 :         memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 7728				; 00001e30H
	mov	r8d, 8
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1020 : 
; 1021 :         ScalarAsInputTextId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+11664], 0

; 1022 :         ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+11676], 42991616		; 02900000H

; 1023 :         DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 1024 :         DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 1025 :         DragSpeedDefaultRatio = 1.0f / 100.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [rax+11696], xmm0

; 1026 :         ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+11720], rax

; 1027 :         TooltipOverrideCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+11700], 0

; 1028 : 
; 1029 :         MultiSelectScopeId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+11728], 0

; 1030 : 
; 1031 :         PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+11732], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+11732]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+11740], rax

; 1032 : 
; 1033 :         /*SettingsLoaded = false;
; 1034 :         SettingsDirtyTimer = 0.0f;
; 1035 : 
; 1036 :         LogEnabled = false;
; 1037 :         LogFile = NULL;
; 1038 :         LogStartDepth = 0;
; 1039 :         LogAutoExpandMaxDepth = 2;*/
; 1040 : 
; 1041 :         memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 11748				; 00002de4H
	mov	r8d, 480				; 000001e0H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1042 :         FramerateSecPerFrameIdx = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12228], 0

; 1043 :         FramerateSecPerFrameAccum = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12232], xmm0

; 1044 :         WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12236], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+15320], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+15316], -1

; 1045 :         memset(TempBuffer, 0, sizeof(TempBuffer));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	r8d, 3073				; 00000c01H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 1046 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z ENDP		; ImGuiContext::ImGuiContext
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1ImGuiIO@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6600				; 000019c8H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6616				; 000019d8H
	call	??1ImGuiStorage@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6632				; 000019e8H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6656				; 00001a00H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6672				; 00001a10H
	call	??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6784				; 00001a80H
	call	??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ	; ImVector<ImGuiColorMod>::~ImVector<ImGuiColorMod>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6840				; 00001ab8H
	call	??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ	; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6856				; 00001ac8H
	call	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6872				; 00001ad8H
	call	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 6888				; 00001ae8H
	call	??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$11
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7336				; 00001ca8H
	call	??1ImDrawList@@QEAA@XZ			; ImDrawList::~ImDrawList
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$11@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$12
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7512				; 00001d58H
	call	??1ImDrawData@@QEAA@XZ			; ImDrawData::~ImDrawData
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$12@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7560				; 00001d88H
	call	??1ImDrawDataBuilder@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$14
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7712				; 00001e20H
	call	??1?$ImVector@E@@QEAA@XZ		; ImVector<unsigned char>::~ImVector<unsigned char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$14@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$15
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7744				; 00001e40H
	call	??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ	; ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$15@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$16
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7784				; 00001e68H
	call	??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ ; ImVector<ImGuiTabBarSortItem>::~ImVector<ImGuiTabBarSortItem>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$16@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$17
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7800				; 00001e78H
	call	??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ ; ImVector<ImGuiTabBar *>::~ImVector<ImGuiTabBar *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$17@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$18
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7816				; 00001e88H
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$18@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$19
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 7936				; 00001f00H
	call	??1ImGuiInputTextState@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$19@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$20
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 11704				; 00002db8H
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$20@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv244 = 32
$T1 = 33
$T2 = 40
tv263 = 48
tv264 = 56
tv176 = 64
$T3 = 72
$T4 = 80
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 176
shared_font_atlas$ = 184
?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGuiContext::ImGuiContext'::`1'::dtor$21
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$21@?0???0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGuiContext::ImGuiContext'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ PROC		; ImVector<ImGuiTabBar *>::~ImVector<ImGuiTabBar *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabBar *>::~ImVector<ImGuiTabBar *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ PROC		; ImVector<ImGuiTabBar *>::ImVector<ImGuiTabBar *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAUImGuiTabBar@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabBar *>::ImVector<ImGuiTabBar *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ PROC	; ImVector<ImGuiTabBarSortItem>::~ImVector<ImGuiTabBarSortItem>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ ENDP	; ImVector<ImGuiTabBarSortItem>::~ImVector<ImGuiTabBarSortItem>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ PROC	; ImVector<ImGuiTabBarSortItem>::ImVector<ImGuiTabBarSortItem>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiTabBarSortItem@@@@QEAA@XZ ENDP	; ImVector<ImGuiTabBarSortItem>::ImVector<ImGuiTabBarSortItem>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ
_TEXT	SEGMENT
n$1 = 32
idx$2 = 36
tv75 = 40
tv83 = 48
tv88 = 56
this$ = 80
?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ PROC		; ImPool<ImGuiTabBar>::Clear, COMDAT

; 278  :     void        Clear() { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); }  Map.Clear(); Data.clear(); FreeIdx = 0; }

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@Clear
$LN2@Clear:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@Clear:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@Clear
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv75[rsp], rax
	mov	edx, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??A?$ImVector@UPair@ImGuiStorage@@@@QEAAAEAUPair@ImGuiStorage@@H@Z ; ImVector<ImGuiStorage::Pair>::operator[]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR idx$2[rsp], eax
	cmp	DWORD PTR idx$2[rsp], -1
	je	SHORT $LN5@Clear
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	edx, DWORD PTR idx$2[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
	mov	QWORD PTR tv88[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv88[rsp]
	call	??_GImGuiTabBar@@QEAAPEAXI@Z
	npad	1
$LN5@Clear:
	jmp	SHORT $LN2@Clear
$LN3@Clear:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	?Clear@ImGuiStorage@@QEAAXXZ		; ImGuiStorage::Clear
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ ; ImVector<ImGuiTabBar>::clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0
	add	rsp, 72					; 00000048H
	ret	0
?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ ENDP		; ImPool<ImGuiTabBar>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
n$ = 72
?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z PROC ; ImPool<ImGuiTabBar>::GetByIndex, COMDAT

; 275  :     T* GetByIndex(ImPoolIdx n) { return &Data[n]; }

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	edx, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
	add	rsp, 56					; 00000038H
	ret	0
?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z ENDP ; ImPool<ImGuiTabBar>::GetByIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ PROC		; ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>, COMDAT

; 273  :     ~ImPool() { Clear(); }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@?$ImPool@UImGuiTabBar@@@@QEAAXXZ	; ImPool<ImGuiTabBar>::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??1ImGuiStorage@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ	; ImVector<ImGuiTabBar>::~ImVector<ImGuiTabBar>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImPool@UImGuiTabBar@@@@QEAA@XZ ENDP		; ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA PROC	; `ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ	; ImVector<ImGuiTabBar>::~ImVector<ImGuiTabBar>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA ENDP	; `ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA PROC	; `ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1ImGuiStorage@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA ENDP	; `ImPool<ImGuiTabBar>::~ImPool<ImGuiTabBar>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ PROC		; ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>, COMDAT

; 272  :     ImPool() { FreeIdx = 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@UImGuiTabBar@@@@QEAA@XZ	; ImVector<ImGuiTabBar>::ImVector<ImGuiTabBar>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImGuiStorage@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$ImPool@UImGuiTabBar@@@@QEAA@XZ ENDP		; ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA PROC	; `ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ	; ImVector<ImGuiTabBar>::~ImVector<ImGuiTabBar>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA ENDP	; `ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA PROC	; `ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1ImGuiStorage@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$ImPool@UImGuiTabBar@@@@QEAA@XZ@4HA ENDP	; `ImPool<ImGuiTabBar>::ImPool<ImGuiTabBar>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ PROC		; ImVector<ImGuiTabBar>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImGuiTabBar@@@@QEAAXXZ ENDP		; ImVector<ImGuiTabBar>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z PROC ; ImVector<ImGuiTabBar>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ENDP ; ImVector<ImGuiTabBar>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ PROC		; ImVector<ImGuiTabBar>::~ImVector<ImGuiTabBar>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiTabBar@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabBar>::~ImVector<ImGuiTabBar>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTabBar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiTabBar@@@@QEAA@XZ PROC		; ImVector<ImGuiTabBar>::ImVector<ImGuiTabBar>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiTabBar@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabBar>::ImVector<ImGuiTabBar>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@E@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@E@@QEAAXH@Z PROC			; ImVector<unsigned char>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@E@@QEAAXH@Z ENDP			; ImVector<unsigned char>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@E@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@E@@QEAAXH@Z PROC			; ImVector<unsigned char>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@E@@QEBAHH@Z	; ImVector<unsigned char>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@E@@QEAAXH@Z		; ImVector<unsigned char>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@E@@QEAAXH@Z ENDP			; ImVector<unsigned char>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@E@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@E@@QEBAHH@Z PROC		; ImVector<unsigned char>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@E@@QEBAHH@Z ENDP		; ImVector<unsigned char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@E@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@E@@QEAAXXZ PROC			; ImVector<unsigned char>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@E@@QEAAXXZ ENDP			; ImVector<unsigned char>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@E@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@E@@QEAA@XZ PROC				; ImVector<unsigned char>::~ImVector<unsigned char>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@E@@QEAA@XZ ENDP				; ImVector<unsigned char>::~ImVector<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@E@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@E@@QEAA@XZ PROC				; ImVector<unsigned char>::ImVector<unsigned char>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@E@@QEAA@XZ ENDP				; ImVector<unsigned char>::ImVector<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ PROC	; ImVector<ImGuiPopupRef>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ ENDP	; ImVector<ImGuiPopupRef>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z PROC ; ImVector<ImGuiPopupRef>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z ; ImVector<ImGuiPopupRef>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ; ImVector<ImGuiPopupRef>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 48					; 00000030H
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z ENDP ; ImVector<ImGuiPopupRef>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z PROC	; ImVector<ImGuiPopupRef>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ENDP	; ImVector<ImGuiPopupRef>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z PROC	; ImVector<ImGuiPopupRef>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z ; ImVector<ImGuiPopupRef>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ; ImVector<ImGuiPopupRef>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ENDP	; ImVector<ImGuiPopupRef>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z PROC ; ImVector<ImGuiPopupRef>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QEBAHH@Z ENDP ; ImVector<ImGuiPopupRef>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@XZ PROC ; ImVector<ImGuiPopupRef>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@XZ ENDP ; ImVector<ImGuiPopupRef>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ PROC	; ImVector<ImGuiPopupRef>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ ENDP	; ImVector<ImGuiPopupRef>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z PROC ; ImVector<ImGuiPopupRef>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ENDP ; ImVector<ImGuiPopupRef>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ PROC	; ImVector<ImGuiPopupRef>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@UImGuiPopupRef@@@@QEBA_NXZ ENDP	; ImVector<ImGuiPopupRef>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ PROC		; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiPopupRef@@@@QEAA@XZ ENDP		; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiPopupRef@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiPopupRef@@@@QEAA@XZ PROC		; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiPopupRef@@@@QEAA@XZ ENDP		; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ PROC	; ImVector<ImGuiStyleMod>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ ENDP	; ImVector<ImGuiStyleMod>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z PROC ; ImVector<ImGuiStyleMod>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z ; ImVector<ImGuiStyleMod>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z ; ImVector<ImGuiStyleMod>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 12
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 12
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ENDP ; ImVector<ImGuiStyleMod>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z PROC	; ImVector<ImGuiStyleMod>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 12
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 12
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiStyleMod@@@@QEAAXH@Z ENDP	; ImVector<ImGuiStyleMod>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z PROC ; ImVector<ImGuiStyleMod>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QEBAHH@Z ENDP ; ImVector<ImGuiStyleMod>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiStyleMod@@@@QEAAAEAUImGuiStyleMod@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiStyleMod@@@@QEAAAEAUImGuiStyleMod@@XZ PROC ; ImVector<ImGuiStyleMod>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 12
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiStyleMod@@@@QEAAAEAUImGuiStyleMod@@XZ ENDP ; ImVector<ImGuiStyleMod>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ PROC	; ImVector<ImGuiStyleMod>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ ENDP	; ImVector<ImGuiStyleMod>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ PROC		; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiStyleMod@@@@QEAA@XZ ENDP		; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiStyleMod@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiStyleMod@@@@QEAA@XZ PROC		; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiStyleMod@@@@QEAA@XZ ENDP		; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiColorMod@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImGuiColorMod@@@@QEAAXXZ PROC	; ImVector<ImGuiColorMod>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImGuiColorMod@@@@QEAAXXZ ENDP	; ImVector<ImGuiColorMod>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z PROC ; ImVector<ImGuiColorMod>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z ; ImVector<ImGuiColorMod>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z ; ImVector<ImGuiColorMod>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 20
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ENDP ; ImVector<ImGuiColorMod>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z PROC	; ImVector<ImGuiColorMod>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 20
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 20
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiColorMod@@@@QEAAXH@Z ENDP	; ImVector<ImGuiColorMod>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z PROC ; ImVector<ImGuiColorMod>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiColorMod@@@@QEBAHH@Z ENDP ; ImVector<ImGuiColorMod>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiColorMod@@@@QEAAAEAUImGuiColorMod@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiColorMod@@@@QEAAAEAUImGuiColorMod@@XZ PROC ; ImVector<ImGuiColorMod>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiColorMod@@@@QEAAAEAUImGuiColorMod@@XZ ENDP ; ImVector<ImGuiColorMod>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ PROC	; ImVector<ImGuiColorMod>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImGuiColorMod@@@@QEAAXXZ ENDP	; ImVector<ImGuiColorMod>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ PROC		; ImVector<ImGuiColorMod>::~ImVector<ImGuiColorMod>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiColorMod@@@@QEAA@XZ ENDP		; ImVector<ImGuiColorMod>::~ImVector<ImGuiColorMod>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColorMod@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiColorMod@@@@QEAA@XZ PROC		; ImVector<ImGuiColorMod>::ImVector<ImGuiColorMod>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiColorMod@@@@QEAA@XZ ENDP		; ImVector<ImGuiColorMod>::ImVector<ImGuiColorMod>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z
_TEXT	SEGMENT
off$ = 32
tv93 = 40
this$ = 64
it$ = 72
v$ = 80
?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z PROC ; ImVector<ImGuiWindow *>::insert, COMDAT

; 1254 : 	inline T* insert(const T* it, const T& v) { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR it$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 3
	mov	QWORD PTR off$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@insert
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z ; ImVector<ImGuiWindow *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::reserve
	npad	1
$LN2@insert:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	cmp	QWORD PTR off$[rsp], rax
	jge	SHORT $LN3@insert
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	sub	rax, QWORD PTR off$[rsp]
	shl	rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR off$[rsp]
	lea	rcx, QWORD PTR [rcx+rdx*8]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	r8, QWORD PTR off$[rsp]
	lea	rdx, QWORD PTR [rdx+r8*8+8]
	mov	QWORD PTR tv93[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv93[rsp]
	mov	rcx, rax
	call	memmove
	npad	1
$LN3@insert:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR off$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR off$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	add	rsp, 56					; 00000038H
	ret	0
?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z ENDP ; ImVector<ImGuiWindow *>::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z PROC ; ImVector<ImGuiWindow *>::push_front, COMDAT

; 1250 : 	inline void         push_front(const T& v) { if (Size == 0) push_back(v); else insert(Data, v); }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN2@push_front
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
	npad	1
	jmp	SHORT $LN3@push_front
$LN2@push_front:
	mov	r8, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?insert@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@PEBQEAU2@AEBQEAU2@@Z ; ImVector<ImGuiWindow *>::insert
	npad	1
$LN3@push_front:
	add	rsp, 40					; 00000028H
	ret	0
?push_front@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ENDP ; ImVector<ImGuiWindow *>::push_front
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ PROC	; ImVector<ImGuiWindow *>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ENDP	; ImVector<ImGuiWindow *>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z PROC ; ImVector<ImGuiWindow *>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z ; ImVector<ImGuiWindow *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ENDP ; ImVector<ImGuiWindow *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z PROC	; ImVector<ImGuiWindow *>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ENDP	; ImVector<ImGuiWindow *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z PROC	; ImVector<ImGuiWindow *>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z ; ImVector<ImGuiWindow *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ENDP	; ImVector<ImGuiWindow *>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z PROC ; ImVector<ImGuiWindow *>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@PEAUImGuiWindow@@@@QEBAHH@Z ENDP ; ImVector<ImGuiWindow *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z
_TEXT	SEGMENT
rhs_size$ = 0
rhs_cap$ = 4
rhs_data$ = 8
this$ = 32
rhs$ = 40
?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z PROC	; ImVector<ImGuiWindow *>::swap, COMDAT

; 1240 : 	inline void         swap(ImVector<T>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR rhs$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR rhs_size$[rsp], eax
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR rhs_size$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR rhs$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR rhs_cap$[rsp], eax
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+4], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR rhs_cap$[rsp]
	mov	DWORD PTR [rax+4], ecx
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR rhs_data$[rsp], rax
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR rhs_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	add	rsp, 24
	ret	0
?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z ENDP	; ImVector<ImGuiWindow *>::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ PROC ; ImVector<ImGuiWindow *>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ ENDP ; ImVector<ImGuiWindow *>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?begin@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
this$ = 8
?begin@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@XZ PROC ; ImVector<ImGuiWindow *>::begin, COMDAT

; 1232 : 	inline T* begin() { return Data; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?begin@?$ImVector@PEAUImGuiWindow@@@@QEAAPEAPEAUImGuiWindow@@XZ ENDP ; ImVector<ImGuiWindow *>::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ PROC	; ImVector<ImGuiWindow *>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ENDP	; ImVector<ImGuiWindow *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z PROC ; ImVector<ImGuiWindow *>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ENDP ; ImVector<ImGuiWindow *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ PROC	; ImVector<ImGuiWindow *>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ ENDP	; ImVector<ImGuiWindow *>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ PROC		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ENDP		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ PROC		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAUImGuiWindow@@@@QEAA@XZ ENDP		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Clear@ImGuiNextWindowData@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?Clear@ImGuiNextWindowData@@QEAAXXZ PROC		; ImGuiNextWindowData::Clear, COMDAT

; 741  :     {

	mov	QWORD PTR [rsp+8], rcx

; 742  :         PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 743  :     }

	ret	0
?Clear@ImGuiNextWindowData@@QEAAXXZ ENDP		; ImGuiNextWindowData::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiNextWindowData@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
$T4 = 56
this$ = 112
??0ImGuiNextWindowData@@QEAA@XZ PROC			; ImGuiNextWindowData::ImGuiNextWindowData, COMDAT

; 727  :     ImGuiNextWindowData()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 728  :     {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 20
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 44					; 0000002cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 52					; 00000034H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect

; 729  :         PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 730  :         PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+44], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+36], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+36]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+20], rax

; 731  :         ContentSizeVal = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+52], rax

; 732  :         CollapsedVal = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+80], 0

; 733  :         SizeConstraintRect = ImRect();

	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+96]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 734  :         SizeCallback = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 735  :         SizeCallbackUserData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 736  :         BgAlphaVal = FLT_MAX;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+84], xmm0

; 737  :         MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 738  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
??0ImGuiNextWindowData@@QEAA@XZ ENDP			; ImGuiNextWindowData::ImGuiNextWindowData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Clear@ImGuiNavMoveResult@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
?Clear@ImGuiNavMoveResult@@QEAAXXZ PROC			; ImGuiNavMoveResult::Clear, COMDAT

; 703  :     void Clear() { ID = SelectScopeId = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+24], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+16], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+4], xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+28]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?Clear@ImGuiNavMoveResult@@QEAAXXZ ENDP			; ImGuiNavMoveResult::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiNavMoveResult@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiNavMoveResult@@QEAA@XZ PROC			; ImGuiNavMoveResult::ImGuiNavMoveResult, COMDAT

; 702  :     ImGuiNavMoveResult() { Clear(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImGuiNavMoveResult@@QEAAXXZ	; ImGuiNavMoveResult::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiNavMoveResult@@QEAA@XZ ENDP			; ImGuiNavMoveResult::ImGuiNavMoveResult
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImDrawDataBuilder@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImDrawDataBuilder@@QEAA@XZ PROC			; ImDrawDataBuilder::~ImDrawDataBuilder, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	r9, OFFSET FLAT:??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	mov	r8d, 2
	mov	edx, 16
	mov	rcx, rax
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImDrawDataBuilder@@QEAA@XZ ENDP			; ImDrawDataBuilder::~ImDrawDataBuilder
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA PROC	; `ImDrawDataBuilder::~ImDrawDataBuilder'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	lea	r9, OFFSET FLAT:??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	mov	r8d, 2
	mov	edx, 16
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImDrawDataBuilder@@QEAA@XZ@4HA ENDP	; `ImDrawDataBuilder::~ImDrawDataBuilder'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImDrawDataBuilder@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??0ImDrawDataBuilder@@QEAA@XZ PROC			; ImDrawDataBuilder::ImDrawDataBuilder, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	mov	QWORD PTR [rsp+32], rcx
	lea	r9, OFFSET FLAT:??0?$ImVector@PEAUImDrawList@@@@QEAA@XZ ; ImVector<ImDrawList *>::ImVector<ImDrawList *>
	mov	r8d, 2
	mov	edx, 16
	mov	rcx, rax
	call	??_L@YAXPEAX_K1P6AX0@Z2@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImDrawDataBuilder@@QEAA@XZ ENDP			; ImDrawDataBuilder::ImDrawDataBuilder
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA PROC	; `ImDrawDataBuilder::ImDrawDataBuilder'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	lea	r9, OFFSET FLAT:??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	mov	r8d, 2
	mov	edx, 16
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImDrawDataBuilder@@QEAA@XZ@4HA ENDP	; `ImDrawDataBuilder::ImDrawDataBuilder'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
layer_n$2 = 36
n$ = 40
size$ = 44
layer$3 = 48
tv82 = 56
tv141 = 64
tv148 = 72
tv146 = 80
tv144 = 88
this$ = 112
?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ PROC	; ImDrawDataBuilder::FlattenIntoSingleLayer

; 2820 : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2821 : 	int n = Layers[0].Size;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR n$[rsp], eax

; 2822 : 	int size = n;

	mov	eax, DWORD PTR n$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 2823 : 	for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)

	mov	DWORD PTR i$1[rsp], 1
	jmp	SHORT $LN4@FlattenInt
$LN2@FlattenInt:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FlattenInt:
	cmp	DWORD PTR i$1[rsp], 2
	jge	SHORT $LN3@FlattenInt

; 2824 : 		size += Layers[i].Size;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, DWORD PTR size$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$[rsp], eax
	jmp	SHORT $LN2@FlattenInt
$LN3@FlattenInt:

; 2825 : 	Layers[0].resize(size);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv82[rsp], rax
	mov	edx, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::resize
	npad	1

; 2826 : 	for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)

	mov	DWORD PTR layer_n$2[rsp], 1
	jmp	SHORT $LN7@FlattenInt
$LN5@FlattenInt:
	mov	eax, DWORD PTR layer_n$2[rsp]
	inc	eax
	mov	DWORD PTR layer_n$2[rsp], eax
$LN7@FlattenInt:
	cmp	DWORD PTR layer_n$2[rsp], 2
	jge	$LN6@FlattenInt

; 2827 : 	{
; 2828 : 		ImVector<ImDrawList*>& layer = Layers[layer_n];

	movsxd	rax, DWORD PTR layer_n$2[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR layer$3[rsp], rax

; 2829 : 		if (layer.empty())

	mov	rcx, QWORD PTR layer$3[rsp]
	call	?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ ; ImVector<ImDrawList *>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@FlattenInt

; 2830 : 			continue;

	jmp	SHORT $LN5@FlattenInt
$LN8@FlattenInt:

; 2831 : 		memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));

	mov	rax, QWORD PTR layer$3[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	QWORD PTR tv148[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR layer$3[rsp]
	call	??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z ; ImVector<ImDrawList *>::operator[]
	mov	QWORD PTR tv146[rsp], rax
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv141[rsp], rax
	mov	edx, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR tv141[rsp]
	call	??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z ; ImVector<ImDrawList *>::operator[]
	mov	QWORD PTR tv144[rsp], rax
	mov	r8, QWORD PTR tv148[rsp]
	mov	rdx, QWORD PTR tv146[rsp]
	mov	rcx, QWORD PTR tv144[rsp]
	call	memcpy

; 2832 : 		n += layer.Size;

	mov	rax, QWORD PTR layer$3[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 2833 : 		layer.resize(0);

	xor	edx, edx
	mov	rcx, QWORD PTR layer$3[rsp]
	call	?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::resize
	npad	1

; 2834 : 	}

	jmp	$LN5@FlattenInt
$LN6@FlattenInt:

; 2835 : }

	add	rsp, 104				; 00000068H
	ret	0
?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ ENDP	; ImDrawDataBuilder::FlattenIntoSingleLayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ
_TEXT	SEGMENT
n$1 = 32
this$ = 64
?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ PROC	; ImDrawDataBuilder::ClearFreeMemory, COMDAT

; 688  :     void ClearFreeMemory() { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@ClearFreeM
$LN2@ClearFreeM:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@ClearFreeM:
	cmp	DWORD PTR n$1[rsp], 2
	jge	SHORT $LN3@ClearFreeM
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ ; ImVector<ImDrawList *>::clear
	npad	1
	jmp	SHORT $LN2@ClearFreeM
$LN3@ClearFreeM:
	add	rsp, 56					; 00000038H
	ret	0
?ClearFreeMemory@ImDrawDataBuilder@@QEAAXXZ ENDP	; ImDrawDataBuilder::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Clear@ImDrawDataBuilder@@QEAAXXZ
_TEXT	SEGMENT
n$1 = 32
tv73 = 40
this$ = 64
?Clear@ImDrawDataBuilder@@QEAAXXZ PROC			; ImDrawDataBuilder::Clear, COMDAT

; 687  :     void Clear() { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@Clear
$LN2@Clear:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@Clear:
	cmp	DWORD PTR n$1[rsp], 2
	jge	SHORT $LN3@Clear
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv73[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv73[rsp]
	call	?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::resize
	npad	1
	jmp	SHORT $LN2@Clear
$LN3@Clear:
	add	rsp, 56					; 00000038H
	ret	0
?Clear@ImDrawDataBuilder@@QEAAXXZ ENDP			; ImDrawDataBuilder::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z PROC ; ImVector<ImDrawList *>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z ; ImVector<ImDrawList *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z ENDP ; ImVector<ImDrawList *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z PROC	; ImVector<ImDrawList *>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ENDP	; ImVector<ImDrawList *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z PROC	; ImVector<ImDrawList *>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z ; ImVector<ImDrawList *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ENDP	; ImVector<ImDrawList *>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z PROC ; ImVector<ImDrawList *>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@PEAUImDrawList@@@@QEBAHH@Z ENDP ; ImVector<ImDrawList *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ PROC	; ImVector<ImDrawList *>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@PEAUImDrawList@@@@QEAAXXZ ENDP	; ImVector<ImDrawList *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z PROC ; ImVector<ImDrawList *>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z ENDP ; ImVector<ImDrawList *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ PROC	; ImVector<ImDrawList *>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@PEAUImDrawList@@@@QEBA_NXZ ENDP	; ImVector<ImDrawList *>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ PROC		; ImVector<ImDrawList *>::~ImVector<ImDrawList *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAUImDrawList@@@@QEAA@XZ ENDP		; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAUImDrawList@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAUImDrawList@@@@QEAA@XZ PROC		; ImVector<ImDrawList *>::ImVector<ImDrawList *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAUImDrawList@@@@QEAA@XZ ENDP		; ImVector<ImDrawList *>::ImVector<ImDrawList *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImGuiColumnsSet@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImGuiColumnsSet@@QEAAPEAXI@Z PROC			; ImGuiColumnsSet::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImGuiColumnsSet@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImGuiColumnsSet@@QEAAPEAXI@Z ENDP			; ImGuiColumnsSet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiColumnsSet@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiColumnsSet@@QEAA@XZ PROC			; ImGuiColumnsSet::~ImGuiColumnsSet, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ ; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiColumnsSet@@QEAA@XZ ENDP			; ImGuiColumnsSet::~ImGuiColumnsSet
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA PROC		; `ImGuiColumnsSet::~ImGuiColumnsSet'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 48					; 00000030H
	call	??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ ; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiColumnsSet@@QEAA@XZ@4HA ENDP		; `ImGuiColumnsSet::~ImGuiColumnsSet'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Clear@ImGuiColumnsSet@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImGuiColumnsSet@@QEAAXXZ PROC			; ImGuiColumnsSet::Clear, COMDAT

; 652  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 653  :         ID = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0

; 654  :         Flags = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0

; 655  :         IsFirstFrame = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 656  :         IsBeingResized = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+20], 0

; 657  :         Current = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 0

; 658  :         Count = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+36], 1

; 659  :         MinX = MaxX = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 660  :         LineMinY = LineMaxY = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0

; 661  :         StartPosY = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+40], xmm0

; 662  :         StartMaxPosX = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+44], xmm0

; 663  :         Columns.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ ; ImVector<ImGuiColumnData>::clear
	npad	1

; 664  :     }

	add	rsp, 40					; 00000028H
	ret	0
?Clear@ImGuiColumnsSet@@QEAAXXZ ENDP			; ImGuiColumnsSet::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiColumnsSet@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiColumnsSet@@QEAA@XZ PROC			; ImGuiColumnsSet::ImGuiColumnsSet, COMDAT

; 650  :     ImGuiColumnsSet() { Clear(); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	??0?$ImVector@UImGuiColumnData@@@@QEAA@XZ ; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
	npad	1
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImGuiColumnsSet@@QEAAXXZ		; ImGuiColumnsSet::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiColumnsSet@@QEAA@XZ ENDP			; ImGuiColumnsSet::ImGuiColumnsSet
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA PROC		; `ImGuiColumnsSet::ImGuiColumnsSet'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 48					; 00000030H
	call	??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ ; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiColumnsSet@@QEAA@XZ@4HA ENDP		; `ImGuiColumnsSet::ImGuiColumnsSet'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z PROC ; ImVector<ImGuiColumnData>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ; ImVector<ImGuiColumnData>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 28
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 28
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImGuiColumnData@@@@QEAAXAEBUImGuiColumnData@@@Z ENDP ; ImVector<ImGuiColumnData>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z PROC	; ImVector<ImGuiColumnData>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 28
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 28
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ENDP	; ImVector<ImGuiColumnData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z PROC	; ImVector<ImGuiColumnData>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ; ImVector<ImGuiColumnData>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImGuiColumnData@@@@QEAAXH@Z ENDP	; ImVector<ImGuiColumnData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z PROC ; ImVector<ImGuiColumnData>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiColumnData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ PROC	; ImVector<ImGuiColumnData>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImGuiColumnData@@@@QEAAXXZ ENDP	; ImVector<ImGuiColumnData>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiColumnData@@@@QEBAAEBUImGuiColumnData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiColumnData@@@@QEBAAEBUImGuiColumnData@@H@Z PROC ; ImVector<ImGuiColumnData>::operator[], COMDAT

; 1229 : 	inline const T& operator[](int i) const { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 28
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiColumnData@@@@QEBAAEBUImGuiColumnData@@H@Z ENDP ; ImVector<ImGuiColumnData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z PROC ; ImVector<ImGuiColumnData>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 28
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ENDP ; ImVector<ImGuiColumnData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ PROC		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiColumnData@@@@QEAA@XZ ENDP		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColumnData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiColumnData@@@@QEAA@XZ PROC		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiColumnData@@@@QEAA@XZ ENDP		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiColumnData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiColumnData@@QEAA@XZ PROC			; ImGuiColumnData::ImGuiColumnData, COMDAT

; 633  :     ImGuiColumnData() { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = 0; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+24], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiColumnData@@QEAA@XZ ENDP			; ImGuiColumnData::ImGuiColumnData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImGuiPopupRef@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiPopupRef@@QEAA@XZ PROC				; ImGuiPopupRef::ImGuiPopupRef, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiPopupRef@@QEAA@XZ ENDP				; ImGuiPopupRef::ImGuiPopupRef
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiInputTextState@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiInputTextState@@QEAA@XZ PROC			; ImGuiInputTextState::~ImGuiInputTextState, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiInputTextState@@QEAA@XZ ENDP			; ImGuiInputTextState::~ImGuiInputTextState
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA PROC	; `ImGuiInputTextState::~ImGuiInputTextState'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiInputTextState@@QEAA@XZ@4HA ENDP	; `ImGuiInputTextState::~ImGuiInputTextState'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA PROC	; `ImGuiInputTextState::~ImGuiInputTextState'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImGuiInputTextState@@QEAA@XZ@4HA ENDP	; `ImGuiInputTextState::~ImGuiInputTextState'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA PROC	; `ImGuiInputTextState::~ImGuiInputTextState'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImGuiInputTextState@@QEAA@XZ@4HA ENDP	; `ImGuiInputTextState::~ImGuiInputTextState'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiInputTextState@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiInputTextState@@QEAA@XZ PROC			; ImGuiInputTextState::ImGuiInputTextState, COMDAT

; 580  :     ImGuiInputTextState() { memset(this, 0, sizeof(*this)); }

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0?$ImVector@D@@QEAA@XZ		; ImVector<char>::ImVector<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??0?$ImVector@D@@QEAA@XZ		; ImVector<char>::ImVector<char>
	npad	1
	mov	r8d, 3728				; 00000e90H
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	memset
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiInputTextState@@QEAA@XZ ENDP			; ImGuiInputTextState::ImGuiInputTextState
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA PROC	; `ImGuiInputTextState::ImGuiInputTextState'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiInputTextState@@QEAA@XZ@4HA ENDP	; `ImGuiInputTextState::ImGuiInputTextState'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA PROC	; `ImGuiInputTextState::ImGuiInputTextState'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImGuiInputTextState@@QEAA@XZ@4HA ENDP	; `ImGuiInputTextState::ImGuiInputTextState'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA PROC	; `ImGuiInputTextState::ImGuiInputTextState'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImGuiInputTextState@@QEAA@XZ@4HA ENDP	; `ImGuiInputTextState::ImGuiInputTextState'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiStyleMod@@QEAA@HUImVec2@@@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
v$ = 24
??0ImGuiStyleMod@@QEAA@HUImVec2@@@Z PROC		; ImGuiStyleMod::ImGuiStyleMod, COMDAT

; 528  :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v) { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR idx$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR v$[rsp+4]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImGuiStyleMod@@QEAA@HUImVec2@@@Z ENDP		; ImGuiStyleMod::ImGuiStyleMod
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiStyleMod@@QEAA@HM@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
v$ = 24
??0ImGuiStyleMod@@QEAA@HM@Z PROC			; ImGuiStyleMod::ImGuiStyleMod, COMDAT

; 527  :     ImGuiStyleMod(ImGuiStyleVar idx, float v) { VarIdx = idx; BackupFloat[0] = v; }

	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR idx$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImGuiStyleMod@@QEAA@HM@Z ENDP			; ImGuiStyleMod::ImGuiStyleMod
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImGuiColorMod@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiColorMod@@QEAA@XZ PROC				; ImGuiColorMod::ImGuiColorMod, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 4
	mov	rcx, rax
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiColorMod@@QEAA@XZ ENDP				; ImGuiColorMod::ImGuiColorMod
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsInverted@ImRect@@QEBA_NXZ
_TEXT	SEGMENT
tv74 = 0
this$ = 32
?IsInverted@ImRect@@QEBA_NXZ PROC			; ImRect::IsInverted, COMDAT

; 511  :     bool        IsInverted() const { return Min.x > Max.x || Min.y > Max.y; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx+8]
	ja	SHORT $LN3@IsInverted
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+12]
	ja	SHORT $LN3@IsInverted
	mov	DWORD PTR tv74[rsp], 0
	jmp	SHORT $LN4@IsInverted
$LN3@IsInverted:
	mov	DWORD PTR tv74[rsp], 1
$LN4@IsInverted:
	movzx	eax, BYTE PTR tv74[rsp]
	add	rsp, 24
	ret	0
?IsInverted@ImRect@@QEBA_NXZ ENDP			; ImRect::IsInverted
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Floor@ImRect@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?Floor@ImRect@@QEAAXXZ PROC				; ImRect::Floor, COMDAT

; 510  :     void        Floor() { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	cvttss2si eax, DWORD PTR [rax]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	cvttss2si eax, DWORD PTR [rax+4]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	cvttss2si eax, DWORD PTR [rax+8]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	cvttss2si eax, DWORD PTR [rax+12]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Floor@ImRect@@QEAAXXZ ENDP				; ImRect::Floor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?ClipWithFull@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
r$ = 72
?ClipWithFull@ImRect@@QEAAXAEBU1@@Z PROC		; ImRect::ClipWithFull, COMDAT

; 509  :     void        ClipWithFull(const ImRect& r) { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR r$[rsp]
	mov	r9, QWORD PTR [rdx+8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z	; ImClamp
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, QWORD PTR r$[rsp]
	mov	r9, QWORD PTR [rdx+8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z	; ImClamp
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	add	rsp, 56					; 00000038H
	ret	0
?ClipWithFull@ImRect@@QEAAXAEBU1@@Z ENDP		; ImRect::ClipWithFull
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?ClipWith@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
r$ = 72
?ClipWith@ImRect@@QEAAXAEBU1@@Z PROC			; ImRect::ClipWith, COMDAT

; 508  :     void        ClipWith(const ImRect& r) { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR r$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	add	rsp, 56					; 00000038H
	ret	0
?ClipWith@ImRect@@QEAAXAEBU1@@Z ENDP			; ImRect::ClipWith
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?TranslateY@ImRect@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
dy$ = 16
?TranslateY@ImRect@@QEAAXM@Z PROC			; ImRect::TranslateY, COMDAT

; 507  :     void        TranslateY(float dy) { Min.y += dy; Max.y += dy; }

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR dy$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR dy$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?TranslateY@ImRect@@QEAAXM@Z ENDP			; ImRect::TranslateY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?TranslateX@ImRect@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
dx$ = 16
?TranslateX@ImRect@@QEAAXM@Z PROC			; ImRect::TranslateX, COMDAT

; 506  :     void        TranslateX(float dx) { Min.x += dx; Max.x += dx; }

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR dx$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR dx$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	ret	0
?TranslateX@ImRect@@QEAAXM@Z ENDP			; ImRect::TranslateX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Translate@ImRect@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 8
d$ = 16
?Translate@ImRect@@QEAAXAEBUImVec2@@@Z PROC		; ImRect::Translate, COMDAT

; 505  :     void        Translate(const ImVec2& d) { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Translate@ImRect@@QEAAXAEBUImVec2@@@Z ENDP		; ImRect::Translate
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 8
amount$ = 16
?Expand@ImRect@@QEAAXAEBUImVec2@@@Z PROC		; ImRect::Expand, COMDAT

; 504  :     void        Expand(const ImVec2& amount) { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Expand@ImRect@@QEAAXAEBUImVec2@@@Z ENDP		; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
amount$ = 16
?Expand@ImRect@@QEAAXM@Z PROC				; ImRect::Expand, COMDAT

; 503  :     void        Expand(const float amount) { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Expand@ImRect@@QEAAXM@Z ENDP				; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
this$ = 8
r$ = 16
?Add@ImRect@@QEAAXAEBU1@@Z PROC				; ImRect::Add, COMDAT

; 502  :     void        Add(const ImRect& r) { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN2@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax], xmm0
$LN2@Add:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [rax+4], xmm0
$LN3@Add:
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx+8]
	jbe	SHORT $LN4@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rcx+8]
	movss	DWORD PTR [rax+8], xmm0
$LN4@Add:
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+12]
	jbe	SHORT $LN5@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rcx+12]
	movss	DWORD PTR [rax+12], xmm0
$LN5@Add:
	ret	0
?Add@ImRect@@QEAAXAEBU1@@Z ENDP				; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?Add@ImRect@@QEAAXAEBUImVec2@@@Z PROC			; ImRect::Add, COMDAT

; 501  :     void        Add(const ImVec2& p) { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN2@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax], xmm0
$LN2@Add:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [rax+4], xmm0
$LN3@Add:
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx+8]
	jbe	SHORT $LN4@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax+8], xmm0
$LN4@Add:
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+12]
	jbe	SHORT $LN5@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [rax+12], xmm0
$LN5@Add:
	ret	0
?Add@ImRect@@QEAAXAEBUImVec2@@@Z ENDP			; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Overlaps@ImRect@@QEBA_NAEBU1@@Z
_TEXT	SEGMENT
tv84 = 0
this$ = 32
r$ = 40
?Overlaps@ImRect@@QEBA_NAEBU1@@Z PROC			; ImRect::Overlaps, COMDAT

; 500  :     bool        Overlaps(const ImRect& r) const { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Overlaps
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Overlaps
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN3@Overlaps
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN3@Overlaps
	mov	DWORD PTR tv84[rsp], 1
	jmp	SHORT $LN4@Overlaps
$LN3@Overlaps:
	mov	DWORD PTR tv84[rsp], 0
$LN4@Overlaps:
	movzx	eax, BYTE PTR tv84[rsp]
	add	rsp, 24
	ret	0
?Overlaps@ImRect@@QEBA_NAEBU1@@Z ENDP			; ImRect::Overlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QEBA_NAEBU1@@Z
_TEXT	SEGMENT
tv84 = 0
this$ = 32
r$ = 40
?Contains@ImRect@@QEBA_NAEBU1@@Z PROC			; ImRect::Contains, COMDAT

; 499  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx+8]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+12]
	jb	SHORT $LN3@Contains
	mov	DWORD PTR tv84[rsp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv84[rsp], 0
$LN4@Contains:
	movzx	eax, BYTE PTR tv84[rsp]
	add	rsp, 24
	ret	0
?Contains@ImRect@@QEBA_NAEBU1@@Z ENDP			; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z
_TEXT	SEGMENT
tv80 = 0
this$ = 32
p$ = 40
?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z PROC		; ImRect::Contains, COMDAT

; 498  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Contains
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv80[rsp], 0
$LN4@Contains:
	movzx	eax, BYTE PTR tv80[rsp]
	add	rsp, 24
	ret	0
?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z ENDP		; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetBR@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetBR@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetBR, COMDAT

; 497  :     ImVec2      GetBR() const { return Max; }                   // Bottom-right

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	ret	0
?GetBR@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetBR
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetBL@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetBL@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetBL, COMDAT

; 496  :     ImVec2      GetBL() const { return ImVec2(Min.x, Max.y); }  // Bottom-left

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetBL@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetBL
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetTR@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetTR@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetTR, COMDAT

; 495  :     ImVec2      GetTR() const { return ImVec2(Max.x, Min.y); }  // Top-right

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetTR@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetHeight@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?GetHeight@ImRect@@QEBAMXZ PROC				; ImRect::GetHeight, COMDAT

; 493  :     float       GetHeight() const { return Max.y - Min.y; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+4]
	ret	0
?GetHeight@ImRect@@QEBAMXZ ENDP				; ImRect::GetHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetWidth@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?GetWidth@ImRect@@QEBAMXZ PROC				; ImRect::GetWidth, COMDAT

; 492  :     float       GetWidth() const { return Max.x - Min.x; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx]
	ret	0
?GetWidth@ImRect@@QEBAMXZ ENDP				; ImRect::GetWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetSize@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetSize@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetSize, COMDAT

; 491  :     ImVec2      GetSize() const { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetSize@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@MMMM@Z
_TEXT	SEGMENT
tv70 = 32
tv76 = 40
this$ = 64
x1$ = 72
y1$ = 80
x2$ = 88
y2$ = 96
??0ImRect@@QEAA@MMMM@Z PROC				; ImRect::ImRect, COMDAT

; 488  :     ImRect(float x1, float y1, float x2, float y2) : Min(x1, y1), Max(x2, y2) {}

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	movss	xmm2, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR x1$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv76[rsp], rax
	movss	xmm2, DWORD PTR y2$[rsp]
	movss	xmm1, DWORD PTR x2$[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImRect@@QEAA@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec4@@@Z
_TEXT	SEGMENT
tv72 = 32
tv80 = 40
this$ = 64
v$ = 72
??0ImRect@@QEAA@AEBUImVec4@@@Z PROC			; ImRect::ImRect, COMDAT

; 487  :     ImRect(const ImVec4& v) : Min(v.x, v.y), Max(v.z, v.w) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImRect@@QEAA@AEBUImVec4@@@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec2@@0@Z
_TEXT	SEGMENT
this$ = 8
min$ = 16
max$ = 24
??0ImRect@@QEAA@AEBUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT

; 486  :     ImRect(const ImVec2& min, const ImVec2& max) : Min(min), Max(max) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR max$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImRect@@QEAA@AEBUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@XZ
_TEXT	SEGMENT
tv70 = 32
tv76 = 40
this$ = 64
??0ImRect@@QEAA@XZ PROC					; ImRect::ImRect, COMDAT

; 485  :     ImRect() : Min(FLT_MAX, FLT_MAX), Max(-FLT_MAX, -FLT_MAX) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv76[rsp], rax
	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR __real@ff7fffff
	mov	rcx, QWORD PTR tv76[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImRect@@QEAA@XZ ENDP					; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImVec1@@QEAA@M@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
??0ImVec1@@QEAA@M@Z PROC				; ImVec1::ImVec1, COMDAT

; 474  :     ImVec1(float _x) { x = _x; }

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec1@@QEAA@M@Z ENDP				; ImVec1::ImVec1
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImVec1@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec1@@QEAA@XZ PROC					; ImVec1::ImVec1, COMDAT

; 473  :     ImVec1() { x = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec1@@QEAA@XZ ENDP					; ImVec1::ImVec1
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR lhs$[rsp]
	comiss	xmm0, DWORD PTR rhs$[rsp]
	jb	SHORT $LN3@ImMax
	movss	xmm0, DWORD PTR lhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	movss	xmm0, DWORD PTR rhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@ImMax:
	movss	xmm0, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR rhs$[rsp]
	comiss	xmm0, DWORD PTR lhs$[rsp]
	jbe	SHORT $LN3@ImMin
	movss	xmm0, DWORD PTR lhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	movss	xmm0, DWORD PTR rhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@ImMin:
	movss	xmm0, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
v$ = 56
?ImFloor@@YA?AUImVec2@@AEBU1@@Z PROC			; ImFloor

; 244  : static inline ImVec2 ImFloor(const ImVec2& v) { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR v$[rsp]
	cvttss2si eax, DWORD PTR [rax+4]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR v$[rsp]
	cvttss2si eax, DWORD PTR [rax]
	cvtsi2ss xmm1, eax
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?ImFloor@@YA?AUImVec2@@AEBU1@@Z ENDP			; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor

; 243  : static inline float  ImFloor(float f) { return (float)(int)f; }

	movss	DWORD PTR [rsp+8], xmm0
	cvttss2si eax, DWORD PTR f$[rsp]
	cvtsi2ss xmm0, eax
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
?ImLengthSqr@@YAMAEBUImVec2@@@Z PROC			; ImLengthSqr

; 240  : static inline float  ImLengthSqr(const ImVec2& lhs) { return lhs.x * lhs.x + lhs.y * lhs.y; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	ret	0
?ImLengthSqr@@YAMAEBUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
f$ = 32
?ImSaturate@@YAMM@Z PROC				; ImSaturate

; 239  : static inline float  ImSaturate(float f) { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR f$[rsp]
	jbe	SHORT $LN5@ImSaturate
	xorps	xmm0, xmm0
	movss	DWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@ImSaturate
$LN5@ImSaturate:
	movss	xmm0, DWORD PTR f$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@ImSaturate
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@ImSaturate
$LN3@ImSaturate:
	movss	xmm0, DWORD PTR f$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@ImSaturate:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
$LN6@ImSaturate:
	movss	xmm0, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
?ImSaturate@@YAMM@Z ENDP				; ImSaturate
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
t$ = 72
?ImLerp@@YA?AUImVec2@@AEBU1@00@Z PROC			; ImLerp

; 237  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t) { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR t$[rsp]
	mulss	xmm0, DWORD PTR [rax+4]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	mov	rax, QWORD PTR t$[rsp]
	mulss	xmm1, DWORD PTR [rax]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?ImLerp@@YA?AUImVec2@@AEBU1@00@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv73 = 32
tv83 = 36
tv74 = 40
tv84 = 44
__$ReturnUdt$ = 64
v$ = 72
mn$ = 80
mx$ = 88
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z PROC		; ImClamp

; 235  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx) { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR mn$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN5@ImClamp
	mov	rax, QWORD PTR mn$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR mx$[rsp+4]
	jbe	SHORT $LN3@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp+4]
	movss	DWORD PTR tv73[rsp], xmm0
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv73[rsp], xmm0
$LN4@ImClamp:
	movss	xmm0, DWORD PTR tv73[rsp]
	movss	DWORD PTR tv74[rsp], xmm0
$LN6@ImClamp:
	mov	rax, QWORD PTR mn$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN9@ImClamp
	mov	rax, QWORD PTR mn$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv84[rsp], xmm0
	jmp	SHORT $LN10@ImClamp
$LN9@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR mx$[rsp]
	jbe	SHORT $LN7@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp]
	movss	DWORD PTR tv83[rsp], xmm0
	jmp	SHORT $LN8@ImClamp
$LN7@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv83[rsp], xmm0
$LN8@ImClamp:
	movss	xmm0, DWORD PTR tv83[rsp]
	movss	DWORD PTR tv84[rsp], xmm0
$LN10@ImClamp:
	movss	xmm2, DWORD PTR tv74[rsp]
	movss	xmm1, DWORD PTR tv84[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z ENDP		; ImClamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv71 = 32
tv78 = 36
__$ReturnUdt$ = 64
lhs$ = 72
rhs$ = 80
?ImMax@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMax

; 234  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@ImMax:
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN5@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN6@ImMax
$LN5@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
$LN6@ImMax:
	movss	xmm2, DWORD PTR tv71[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImMax@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv71 = 32
tv78 = 36
__$ReturnUdt$ = 64
lhs$ = 72
rhs$ = 80
?ImMin@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMin

; 233  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN5@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN6@ImMin
$LN5@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
$LN6@ImMin:
	movss	xmm2, DWORD PTR tv71[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImMin@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
y$ = 56
?ImFmod@@YAMMM@Z PROC					; ImFmod

; 216  : static inline float  ImFmod(float x, float y) { return fmodf(x, y); }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm1, DWORD PTR y$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	call	fmodf
	add	rsp, 40					; 00000028H
	ret	0
?ImFmod@@YAMMM@Z ENDP					; ImFmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImFabs@@YAMM@Z PROC					; ImFabs

; 212  : static inline float  ImFabs(float x) { return fabsf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	fabsf
	add	rsp, 40					; 00000028H
	ret	0
?ImFabs@@YAMM@Z ENDP					; ImFabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??X@YAAEAUImVec2@@AEAU0@M@Z PROC			; operator*=

; 202  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs) { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	ret	0
??X@YAAEAUImVec2@@AEAU0@M@Z ENDP			; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator-=

; 201  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	ret	0
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator+=

; 200  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs) { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	ret	0
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??K@YA?AUImVec2@@AEBU0@0@Z PROC				; operator/

; 199  : static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x / rhs.x, lhs.y / rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??K@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??D@YA?AUImVec2@@AEBU0@0@Z PROC				; operator*

; 198  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??D@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-

; 197  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+

; 196  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??K@YA?AUImVec2@@AEBU0@M@Z PROC				; operator/

; 195  : static inline ImVec2 operator/(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x / rhs, lhs.y / rhs); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR rhs$[rsp]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??K@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*

; 194  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR rhs$[rsp]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
w$ = 32
buf$ = 64
buf_size$ = 72
fmt$ = 80
args$ = 88
?ImFormatStringV@@YAHPEAD_KPEBD0@Z PROC			; ImFormatStringV

; 504  : {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 505  : #ifdef IMGUI_USE_STB_SPRINTF
; 506  : 	int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
; 507  : #else
; 508  : 	int w = vsnprintf(buf, buf_size, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	rdx, QWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	_vsnprintf
	mov	DWORD PTR w$[rsp], eax

; 509  : #endif
; 510  : 	if (buf == NULL)

	cmp	QWORD PTR buf$[rsp], 0
	jne	SHORT $LN2@ImFormatSt

; 511  : 		return w;

	mov	eax, DWORD PTR w$[rsp]
	jmp	SHORT $LN1@ImFormatSt
$LN2@ImFormatSt:

; 512  : 	if (w == -1 || w >= (int)buf_size)

	cmp	DWORD PTR w$[rsp], -1
	je	SHORT $LN4@ImFormatSt
	mov	eax, DWORD PTR buf_size$[rsp]
	cmp	DWORD PTR w$[rsp], eax
	jl	SHORT $LN3@ImFormatSt
$LN4@ImFormatSt:

; 513  : 		w = (int)buf_size - 1;

	mov	eax, DWORD PTR buf_size$[rsp]
	dec	eax
	mov	DWORD PTR w$[rsp], eax
$LN3@ImFormatSt:

; 514  : 	buf[w] = 0;

	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 515  : 	return w;

	mov	eax, DWORD PTR w$[rsp]
$LN1@ImFormatSt:

; 516  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImFormatStringV@@YAHPEAD_KPEBD0@Z ENDP			; ImFormatStringV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
w$ = 32
args$ = 40
buf$ = 64
buf_size$ = 72
fmt$ = 80
?ImFormatString@@YAHPEAD_KPEBDZZ PROC			; ImFormatString

; 486  : {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 487  : 	va_list args;
; 488  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 489  : #ifdef IMGUI_USE_STB_SPRINTF
; 490  : 	int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
; 491  : #else
; 492  : 	int w = vsnprintf(buf, buf_size, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	rdx, QWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	_vsnprintf
	mov	DWORD PTR w$[rsp], eax

; 493  : #endif
; 494  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 495  : 	if (buf == NULL)

	cmp	QWORD PTR buf$[rsp], 0
	jne	SHORT $LN2@ImFormatSt

; 496  : 		return w;

	mov	eax, DWORD PTR w$[rsp]
	jmp	SHORT $LN1@ImFormatSt
$LN2@ImFormatSt:

; 497  : 	if (w == -1 || w >= (int)buf_size)

	cmp	DWORD PTR w$[rsp], -1
	je	SHORT $LN4@ImFormatSt
	mov	eax, DWORD PTR buf_size$[rsp]
	cmp	DWORD PTR w$[rsp], eax
	jl	SHORT $LN3@ImFormatSt
$LN4@ImFormatSt:

; 498  : 		w = (int)buf_size - 1;

	mov	eax, DWORD PTR buf_size$[rsp]
	dec	eax
	mov	DWORD PTR w$[rsp], eax
$LN3@ImFormatSt:

; 499  : 	buf[w] = 0;

	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 500  : 	return w;

	mov	eax, DWORD PTR w$[rsp]
$LN1@ImFormatSt:

; 501  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImFormatString@@YAHPEAD_KPEBDZZ ENDP			; ImFormatString
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
p$ = 32
p_start$ = 40
buf$ = 64
?ImStrTrimBlanks@@YAXPEAD@Z PROC			; ImStrTrimBlanks

; 456  : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 457  : 	char* p = buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@ImStrTrimB:

; 458  : 	while (p[0] == ' ' || p[0] == '\t')     // Leading blanks

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@ImStrTrimB
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN3@ImStrTrimB
$LN8@ImStrTrimB:

; 459  : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@ImStrTrimB
$LN3@ImStrTrimB:

; 460  : 	char* p_start = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR p_start$[rsp], rax
$LN4@ImStrTrimB:

; 461  : 	while (*p != 0)                         // Find end of string

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@ImStrTrimB

; 462  : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@ImStrTrimB
$LN5@ImStrTrimB:
$LN6@ImStrTrimB:

; 463  : 	while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks

	mov	rax, QWORD PTR p_start$[rsp]
	cmp	QWORD PTR p$[rsp], rax
	jbe	SHORT $LN7@ImStrTrimB
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN9@ImStrTrimB
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN7@ImStrTrimB
$LN9@ImStrTrimB:

; 464  : 		p--;

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN6@ImStrTrimB
$LN7@ImStrTrimB:

; 465  : 	if (p_start != buf)                     // Copy memory if we had leading blanks

	mov	rax, QWORD PTR buf$[rsp]
	cmp	QWORD PTR p_start$[rsp], rax
	je	SHORT $LN10@ImStrTrimB

; 466  : 		memmove(buf, p_start, p - p_start);

	mov	rax, QWORD PTR p_start$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR p_start$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	memmove
	npad	1
$LN10@ImStrTrimB:

; 467  : 	buf[p - p_start] = 0;                   // Zero terminate

	mov	rax, QWORD PTR p_start$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 468  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImStrTrimBlanks@@YAXPEAD@Z ENDP			; ImStrTrimBlanks
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
un0$ = 32
tv87 = 36
b$1 = 40
a$2 = 48
haystack$ = 80
haystack_end$ = 88
needle$ = 96
needle_end$ = 104
?ImStristr@@YAPEBDPEBD000@Z PROC			; ImStristr

; 433  : {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 434  : 	if (!needle_end)

	cmp	QWORD PTR needle_end$[rsp], 0
	jne	SHORT $LN7@ImStristr

; 435  : 		needle_end = needle + strlen(needle);

	mov	rcx, QWORD PTR needle$[rsp]
	call	strlen
	mov	rcx, QWORD PTR needle$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR needle_end$[rsp], rax
$LN7@ImStristr:

; 436  : 
; 437  : 	const char un0 = (char)toupper(*needle);

	mov	rax, QWORD PTR needle$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	toupper
	mov	BYTE PTR un0$[rsp], al
$LN2@ImStristr:

; 438  : 	while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))

	cmp	QWORD PTR haystack_end$[rsp], 0
	jne	SHORT $LN9@ImStristr
	mov	rax, QWORD PTR haystack$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN8@ImStristr
$LN9@ImStristr:
	cmp	QWORD PTR haystack_end$[rsp], 0
	je	$LN3@ImStristr
	mov	rax, QWORD PTR haystack_end$[rsp]
	cmp	QWORD PTR haystack$[rsp], rax
	jae	$LN3@ImStristr
$LN8@ImStristr:

; 439  : 	{
; 440  : 		if (toupper(*haystack) == un0)

	mov	rax, QWORD PTR haystack$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	toupper
	movsx	ecx, BYTE PTR un0$[rsp]
	cmp	eax, ecx
	jne	$LN10@ImStristr

; 441  : 		{
; 442  : 			const char* b = needle + 1;

	mov	rax, QWORD PTR needle$[rsp]
	inc	rax
	mov	QWORD PTR b$1[rsp], rax

; 443  : 			for (const char* a = haystack + 1; b < needle_end; a++, b++)

	mov	rax, QWORD PTR haystack$[rsp]
	inc	rax
	mov	QWORD PTR a$2[rsp], rax
	jmp	SHORT $LN6@ImStristr
$LN4@ImStristr:
	mov	rax, QWORD PTR a$2[rsp]
	inc	rax
	mov	QWORD PTR a$2[rsp], rax
	mov	rax, QWORD PTR b$1[rsp]
	inc	rax
	mov	QWORD PTR b$1[rsp], rax
$LN6@ImStristr:
	mov	rax, QWORD PTR needle_end$[rsp]
	cmp	QWORD PTR b$1[rsp], rax
	jae	SHORT $LN5@ImStristr

; 444  : 				if (toupper(*a) != toupper(*b))

	mov	rax, QWORD PTR a$2[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	toupper
	mov	DWORD PTR tv87[rsp], eax
	mov	rcx, QWORD PTR b$1[rsp]
	movsx	ecx, BYTE PTR [rcx]
	call	toupper
	mov	ecx, DWORD PTR tv87[rsp]
	cmp	ecx, eax
	je	SHORT $LN11@ImStristr

; 445  : 					break;

	jmp	SHORT $LN5@ImStristr
$LN11@ImStristr:
	jmp	SHORT $LN4@ImStristr
$LN5@ImStristr:

; 446  : 			if (b == needle_end)

	mov	rax, QWORD PTR needle_end$[rsp]
	cmp	QWORD PTR b$1[rsp], rax
	jne	SHORT $LN12@ImStristr

; 447  : 				return haystack;

	mov	rax, QWORD PTR haystack$[rsp]
	jmp	SHORT $LN1@ImStristr
$LN12@ImStristr:
$LN10@ImStristr:

; 448  : 		}
; 449  : 		haystack++;

	mov	rax, QWORD PTR haystack$[rsp]
	inc	rax
	mov	QWORD PTR haystack$[rsp], rax

; 450  : 	}

	jmp	$LN2@ImStristr
$LN3@ImStristr:

; 451  : 	return NULL;

	xor	eax, eax
$LN1@ImStristr:

; 452  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImStristr@@YAPEBDPEBD000@Z ENDP			; ImStristr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
buf_mid_line$ = 8
buf_begin$ = 16
?ImStrbolW@@YAPEBGPEBG0@Z PROC				; ImStrbolW

; 426  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
$LN2@ImStrbolW:

; 427  : 	while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')

	mov	rax, QWORD PTR buf_begin$[rsp]
	cmp	QWORD PTR buf_mid_line$[rsp], rax
	jbe	SHORT $LN3@ImStrbolW
	mov	eax, 2
	imul	rax, rax, -1
	mov	rcx, QWORD PTR buf_mid_line$[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	cmp	eax, 10
	je	SHORT $LN3@ImStrbolW

; 428  : 		buf_mid_line--;

	mov	rax, QWORD PTR buf_mid_line$[rsp]
	sub	rax, 2
	mov	QWORD PTR buf_mid_line$[rsp], rax
	jmp	SHORT $LN2@ImStrbolW
$LN3@ImStrbolW:

; 429  : 	return buf_mid_line;

	mov	rax, QWORD PTR buf_mid_line$[rsp]

; 430  : }

	ret	0
?ImStrbolW@@YAPEBGPEBG0@Z ENDP				; ImStrbolW
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
p$ = 32
tv70 = 40
str$ = 64
str_end$ = 72
?ImStreolRange@@YAPEBDPEBD0@Z PROC			; ImStreolRange

; 420  : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 421  : 	const char* p = (const char*)memchr(str, '\n', str_end - str);

	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR str_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR str$[rsp]
	call	memchr
	mov	QWORD PTR p$[rsp], rax

; 422  : 	return p ? p : str_end;

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN3@ImStreolRa
	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN4@ImStreolRa
$LN3@ImStreolRa:
	mov	rax, QWORD PTR str_end$[rsp]
	mov	QWORD PTR tv70[rsp], rax
$LN4@ImStreolRa:
	mov	rax, QWORD PTR tv70[rsp]

; 423  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImStreolRange@@YAPEBDPEBD0@Z ENDP			; ImStreolRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
n$ = 0
tv67 = 4
str$ = 32
?ImStrlenW@@YAHPEBG@Z PROC				; ImStrlenW

; 411  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 412  : 	//return (int)wcslen((const wchar_t*)str);	// FIXME-OPT: Could use this when wchar_t are 16-bits
; 413  : 	int n = 0;

	mov	DWORD PTR n$[rsp], 0
$LN2@ImStrlenW:

; 414  : 	while (*str++) n++;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv67[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	add	rax, 2
	mov	QWORD PTR str$[rsp], rax
	cmp	DWORD PTR tv67[rsp], 0
	je	SHORT $LN3@ImStrlenW
	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
	jmp	SHORT $LN2@ImStrlenW
$LN3@ImStrlenW:

; 415  : 	return n;

	mov	eax, DWORD PTR n$[rsp]

; 416  : }

	add	rsp, 24
	ret	0
?ImStrlenW@@YAHPEBG@Z ENDP				; ImStrlenW
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
p$ = 32
str$ = 64
str_end$ = 72
c$ = 80
?ImStrchrRange@@YAPEBDPEBD0D@Z PROC			; ImStrchrRange

; 405  : {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 406  : 	const char* p = (const char*)memchr(str, (int)c, str_end - str);

	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR str_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movsx	ecx, BYTE PTR c$[rsp]
	mov	r8, rax
	mov	edx, ecx
	mov	rcx, QWORD PTR str$[rsp]
	call	memchr
	mov	QWORD PTR p$[rsp], rax

; 407  : 	return p;

	mov	rax, QWORD PTR p$[rsp]

; 408  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImStrchrRange@@YAPEBDPEBD0D@Z ENDP			; ImStrchrRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
src_size$ = 32
tv68 = 40
dst_buf_size$ = 48
dst$ = 80
p_dst_size$ = 88
src$ = 96
?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z PROC		; ImStrdupcpy

; 391  : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 392  : 	size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;

	cmp	QWORD PTR p_dst_size$[rsp], 0
	je	SHORT $LN5@ImStrdupcp
	mov	rax, QWORD PTR p_dst_size$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN6@ImStrdupcp
$LN5@ImStrdupcp:
	mov	rcx, QWORD PTR dst$[rsp]
	call	strlen
	inc	rax
	mov	QWORD PTR tv68[rsp], rax
$LN6@ImStrdupcp:
	mov	rax, QWORD PTR tv68[rsp]
	mov	QWORD PTR dst_buf_size$[rsp], rax

; 393  : 	size_t src_size = strlen(src) + 1;

	mov	rcx, QWORD PTR src$[rsp]
	call	strlen
	inc	rax
	mov	QWORD PTR src_size$[rsp], rax

; 394  : 	if (dst_buf_size < src_size)

	mov	rax, QWORD PTR src_size$[rsp]
	cmp	QWORD PTR dst_buf_size$[rsp], rax
	jae	SHORT $LN2@ImStrdupcp

; 395  : 	{
; 396  : 		ImGui::MemFree(dst);

	mov	rcx, QWORD PTR dst$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 397  : 		dst = (char*)ImGui::MemAlloc(src_size);

	mov	rcx, QWORD PTR src_size$[rsp]
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR dst$[rsp], rax

; 398  : 		if (p_dst_size)

	cmp	QWORD PTR p_dst_size$[rsp], 0
	je	SHORT $LN3@ImStrdupcp

; 399  : 			*p_dst_size = src_size;

	mov	rax, QWORD PTR p_dst_size$[rsp]
	mov	rcx, QWORD PTR src_size$[rsp]
	mov	QWORD PTR [rax], rcx
$LN3@ImStrdupcp:
$LN2@ImStrdupcp:

; 400  : 	}
; 401  : 	return (char*)memcpy(dst, (const void*)src, src_size);

	mov	r8, QWORD PTR src_size$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 402  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z ENDP		; ImStrdupcpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
len$ = 32
buf$ = 40
str$ = 64
?ImStrdup@@YAPEADPEBD@Z PROC				; ImStrdup

; 384  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 385  : 	size_t len = strlen(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	QWORD PTR len$[rsp], rax

; 386  : 	void* buf = ImGui::MemAlloc(len + 1);

	mov	rax, QWORD PTR len$[rsp]
	inc	rax
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR buf$[rsp], rax

; 387  : 	return (char*)memcpy(buf, (const void*)str, len + 1);

	mov	rax, QWORD PTR len$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	memcpy

; 388  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImStrdup@@YAPEADPEBD@Z ENDP				; ImStrdup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
dst$ = 48
src$ = 56
count$ = 64
?ImStrncpy@@YAXPEADPEBD_K@Z PROC			; ImStrncpy

; 375  : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 376  : 	if (count < 1)

	cmp	QWORD PTR count$[rsp], 1
	jae	SHORT $LN2@ImStrncpy

; 377  : 		return;

	jmp	SHORT $LN1@ImStrncpy
$LN2@ImStrncpy:

; 378  : 	if (count > 1)

	cmp	QWORD PTR count$[rsp], 1
	jbe	SHORT $LN3@ImStrncpy

; 379  : 		strncpy(dst, src, count - 1);

	mov	rax, QWORD PTR count$[rsp]
	dec	rax
	mov	r8, rax
	mov	rdx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	strncpy
	npad	1
$LN3@ImStrncpy:

; 380  : 	dst[count - 1] = 0;

	mov	rax, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax-1], 0
$LN1@ImStrncpy:

; 381  : }

	add	rsp, 40					; 00000028H
	ret	0
?ImStrncpy@@YAXPEADPEBD_K@Z ENDP			; ImStrncpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
d$ = 32
tv65 = 36
str1$ = 64
str2$ = 72
count$ = 80
?ImStrnicmp@@YAHPEBD0_K@Z PROC				; ImStrnicmp

; 368  : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 369  : 	int d = 0;

	mov	DWORD PTR d$[rsp], 0
$LN2@ImStrnicmp:

; 370  : 	while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }

	cmp	QWORD PTR count$[rsp], 0
	jbe	SHORT $LN3@ImStrnicmp
	mov	rax, QWORD PTR str2$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	toupper
	mov	DWORD PTR tv65[rsp], eax
	mov	rcx, QWORD PTR str1$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	call	toupper
	mov	ecx, DWORD PTR tv65[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR d$[rsp], eax
	cmp	DWORD PTR d$[rsp], 0
	jne	SHORT $LN3@ImStrnicmp
	mov	rax, QWORD PTR str1$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ImStrnicmp
	mov	rax, QWORD PTR str1$[rsp]
	inc	rax
	mov	QWORD PTR str1$[rsp], rax
	mov	rax, QWORD PTR str2$[rsp]
	inc	rax
	mov	QWORD PTR str2$[rsp], rax
	mov	rax, QWORD PTR count$[rsp]
	dec	rax
	mov	QWORD PTR count$[rsp], rax
	jmp	SHORT $LN2@ImStrnicmp
$LN3@ImStrnicmp:

; 371  : 	return d;

	mov	eax, DWORD PTR d$[rsp]

; 372  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImStrnicmp@@YAHPEBD0_K@Z ENDP				; ImStrnicmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
d$ = 32
tv64 = 36
str1$ = 64
str2$ = 72
?ImStricmp@@YAHPEBD0@Z PROC				; ImStricmp

; 361  : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@ImStricmp:

; 362  : 	int d;
; 363  : 	while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }

	mov	rax, QWORD PTR str2$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	toupper
	mov	DWORD PTR tv64[rsp], eax
	mov	rcx, QWORD PTR str1$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	call	toupper
	mov	ecx, DWORD PTR tv64[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR d$[rsp], eax
	cmp	DWORD PTR d$[rsp], 0
	jne	SHORT $LN3@ImStricmp
	mov	rax, QWORD PTR str1$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ImStricmp
	mov	rax, QWORD PTR str1$[rsp]
	inc	rax
	mov	QWORD PTR str1$[rsp], rax
	mov	rax, QWORD PTR str2$[rsp]
	inc	rax
	mov	QWORD PTR str2$[rsp], rax
	jmp	SHORT $LN2@ImStricmp
$LN3@ImStricmp:

; 364  : 	return d;

	mov	eax, DWORD PTR d$[rsp]

; 365  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImStricmp@@YAHPEBD0@Z ENDP				; ImStricmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv70 = 32
tv72 = 36
tv64 = 40
dx$ = 64
dy$ = 72
?ImGetDirQuadrantFromDelta@@YAHMM@Z PROC		; ImGetDirQuadrantFromDelta

; 6248 : {

$LN8:
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 6249 : 	if (ImFabs(dx) > ImFabs(dy))

	movss	xmm0, DWORD PTR dx$[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	DWORD PTR tv64[rsp], xmm0
	movss	xmm0, DWORD PTR dy$[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	xmm1, DWORD PTR tv64[rsp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@ImGetDirQu

; 6250 : 		return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;

	movss	xmm0, DWORD PTR dx$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@ImGetDirQu
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN5@ImGetDirQu
$LN4@ImGetDirQu:
	mov	DWORD PTR tv70[rsp], 0
$LN5@ImGetDirQu:
	mov	eax, DWORD PTR tv70[rsp]
	jmp	SHORT $LN1@ImGetDirQu
$LN2@ImGetDirQu:

; 6251 : 	return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;

	movss	xmm0, DWORD PTR dy$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@ImGetDirQu
	mov	DWORD PTR tv72[rsp], 3
	jmp	SHORT $LN7@ImGetDirQu
$LN6@ImGetDirQu:
	mov	DWORD PTR tv72[rsp], 2
$LN7@ImGetDirQu:
	mov	eax, DWORD PTR tv72[rsp]
$LN1@ImGetDirQu:

; 6252 : }

	add	rsp, 56					; 00000038H
	ret	0
?ImGetDirQuadrantFromDelta@@YAHMM@Z ENDP		; ImGetDirQuadrantFromDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
denom$ = 32
v1$ = 40
v2$ = 48
v0$ = 56
a$ = 80
b$ = 88
c$ = 96
p$ = 104
out_u$ = 112
out_v$ = 120
out_w$ = 128
?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z PROC ; ImTriangleBarycentricCoords

; 333  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 334  : 	ImVec2 v0 = b - a;

	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR v0$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 335  : 	ImVec2 v1 = c - a;

	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR c$[rsp]
	lea	rcx, QWORD PTR v1$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 336  : 	ImVec2 v2 = p - a;

	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR v2$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 337  : 	const float denom = v0.x * v1.y - v1.x * v0.y;

	movss	xmm0, DWORD PTR v0$[rsp]
	mulss	xmm0, DWORD PTR v1$[rsp+4]
	movss	xmm1, DWORD PTR v1$[rsp]
	mulss	xmm1, DWORD PTR v0$[rsp+4]
	subss	xmm0, xmm1
	movss	DWORD PTR denom$[rsp], xmm0

; 338  : 	out_v = (v2.x * v1.y - v1.x * v2.y) / denom;

	movss	xmm0, DWORD PTR v2$[rsp]
	mulss	xmm0, DWORD PTR v1$[rsp+4]
	movss	xmm1, DWORD PTR v1$[rsp]
	mulss	xmm1, DWORD PTR v2$[rsp+4]
	subss	xmm0, xmm1
	divss	xmm0, DWORD PTR denom$[rsp]
	mov	rax, QWORD PTR out_v$[rsp]
	movss	DWORD PTR [rax], xmm0

; 339  : 	out_w = (v0.x * v2.y - v2.x * v0.y) / denom;

	movss	xmm0, DWORD PTR v0$[rsp]
	mulss	xmm0, DWORD PTR v2$[rsp+4]
	movss	xmm1, DWORD PTR v2$[rsp]
	mulss	xmm1, DWORD PTR v0$[rsp+4]
	subss	xmm0, xmm1
	divss	xmm0, DWORD PTR denom$[rsp]
	mov	rax, QWORD PTR out_w$[rsp]
	movss	DWORD PTR [rax], xmm0

; 340  : 	out_u = 1.0f - out_v - out_w;

	mov	rax, QWORD PTR out_v$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR out_w$[rsp]
	subss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR out_u$[rsp]
	movss	DWORD PTR [rax], xmm0

; 341  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z ENDP ; ImTriangleBarycentricCoords
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
dist2_ab$ = 32
m$ = 36
dist2_bc$ = 40
dist2_ca$ = 44
proj_ab$ = 48
proj_bc$ = 56
proj_ca$ = 64
$T1 = 72
$T2 = 80
$T3 = 88
__$ReturnUdt$ = 112
a$ = 120
b$ = 128
c$ = 136
p$ = 144
?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z PROC	; ImTriangleClosestPoint

; 344  : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 345  : 	ImVec2 proj_ab = ImLineClosestPoint(a, b, p);

	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	lea	rcx, QWORD PTR proj_ab$[rsp]
	call	?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z ; ImLineClosestPoint

; 346  : 	ImVec2 proj_bc = ImLineClosestPoint(b, c, p);

	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR c$[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR proj_bc$[rsp]
	call	?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z ; ImLineClosestPoint

; 347  : 	ImVec2 proj_ca = ImLineClosestPoint(c, a, p);

	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR c$[rsp]
	lea	rcx, QWORD PTR proj_ca$[rsp]
	call	?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z ; ImLineClosestPoint
	npad	1

; 348  : 	float dist2_ab = ImLengthSqr(p - proj_ab);

	lea	r8, QWORD PTR proj_ab$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, rax
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	movss	DWORD PTR dist2_ab$[rsp], xmm0

; 349  : 	float dist2_bc = ImLengthSqr(p - proj_bc);

	lea	r8, QWORD PTR proj_bc$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, rax
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	movss	DWORD PTR dist2_bc$[rsp], xmm0

; 350  : 	float dist2_ca = ImLengthSqr(p - proj_ca);

	lea	r8, QWORD PTR proj_ca$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, rax
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	movss	DWORD PTR dist2_ca$[rsp], xmm0

; 351  : 	float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));

	movss	xmm1, DWORD PTR dist2_ca$[rsp]
	movss	xmm0, DWORD PTR dist2_bc$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR dist2_ab$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR m$[rsp], xmm0

; 352  : 	if (m == dist2_ab)

	movss	xmm0, DWORD PTR m$[rsp]
	ucomiss	xmm0, DWORD PTR dist2_ab$[rsp]
	jp	SHORT $LN2@ImTriangle
	jne	SHORT $LN2@ImTriangle

; 353  : 		return proj_ab;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR proj_ab$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@ImTriangle
$LN2@ImTriangle:

; 354  : 	if (m == dist2_bc)

	movss	xmm0, DWORD PTR m$[rsp]
	ucomiss	xmm0, DWORD PTR dist2_bc$[rsp]
	jp	SHORT $LN3@ImTriangle
	jne	SHORT $LN3@ImTriangle

; 355  : 		return proj_bc;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR proj_bc$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@ImTriangle
$LN3@ImTriangle:

; 356  : 	return proj_ca;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR proj_ca$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@ImTriangle:

; 357  : }

	add	rsp, 104				; 00000068H
	ret	0
?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z ENDP	; ImTriangleClosestPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
b2$ = 0
b1$ = 1
b3$ = 2
tv80 = 4
tv130 = 8
tv148 = 12
tv156 = 16
a$ = 48
b$ = 56
c$ = 64
p$ = 72
?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z PROC	; ImTriangleContainsPoint

; 325  : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 326  : 	bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mulss	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm2, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rcx]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@ImTriangle
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN4@ImTriangle
$LN3@ImTriangle:
	mov	DWORD PTR tv80[rsp], 0
$LN4@ImTriangle:
	movzx	eax, BYTE PTR tv80[rsp]
	mov	BYTE PTR b1$[rsp], al

; 327  : 	bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mulss	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	movss	xmm2, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rcx]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@ImTriangle
	mov	DWORD PTR tv130[rsp], 1
	jmp	SHORT $LN6@ImTriangle
$LN5@ImTriangle:
	mov	DWORD PTR tv130[rsp], 0
$LN6@ImTriangle:
	movzx	eax, BYTE PTR tv130[rsp]
	mov	BYTE PTR b2$[rsp], al

; 328  : 	bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mulss	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rcx]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@ImTriangle
	mov	DWORD PTR tv148[rsp], 1
	jmp	SHORT $LN8@ImTriangle
$LN7@ImTriangle:
	mov	DWORD PTR tv148[rsp], 0
$LN8@ImTriangle:
	movzx	eax, BYTE PTR tv148[rsp]
	mov	BYTE PTR b3$[rsp], al

; 329  : 	return ((b1 == b2) && (b2 == b3));

	movzx	eax, BYTE PTR b1$[rsp]
	movzx	ecx, BYTE PTR b2$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN9@ImTriangle
	movzx	eax, BYTE PTR b2$[rsp]
	movzx	ecx, BYTE PTR b3$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN9@ImTriangle
	mov	DWORD PTR tv156[rsp], 1
	jmp	SHORT $LN10@ImTriangle
$LN9@ImTriangle:
	mov	DWORD PTR tv156[rsp], 0
$LN10@ImTriangle:
	movzx	eax, BYTE PTR tv156[rsp]

; 330  : }

	add	rsp, 40					; 00000028H
	ret	0
?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z ENDP	; ImTriangleContainsPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
dot$ = 32
ab_len_sqr$ = 36
ab_dir$ = 40
ap$ = 48
$T1 = 56
$T2 = 64
__$ReturnUdt$ = 96
a$ = 104
b$ = 112
p$ = 120
?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z PROC	; ImLineClosestPoint

; 312  : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 313  : 	ImVec2 ap = p - a;

	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR ap$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 314  : 	ImVec2 ab_dir = b - a;

	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR ab_dir$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 315  : 	float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;

	movss	xmm0, DWORD PTR ap$[rsp]
	mulss	xmm0, DWORD PTR ab_dir$[rsp]
	movss	xmm1, DWORD PTR ap$[rsp+4]
	mulss	xmm1, DWORD PTR ab_dir$[rsp+4]
	addss	xmm0, xmm1
	movss	DWORD PTR dot$[rsp], xmm0

; 316  : 	if (dot < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR dot$[rsp]
	jbe	SHORT $LN2@ImLineClos

; 317  : 		return a;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@ImLineClos
$LN2@ImLineClos:

; 318  : 	float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;

	movss	xmm0, DWORD PTR ab_dir$[rsp]
	mulss	xmm0, DWORD PTR ab_dir$[rsp]
	movss	xmm1, DWORD PTR ab_dir$[rsp+4]
	mulss	xmm1, DWORD PTR ab_dir$[rsp+4]
	addss	xmm0, xmm1
	movss	DWORD PTR ab_len_sqr$[rsp], xmm0

; 319  : 	if (dot > ab_len_sqr)

	movss	xmm0, DWORD PTR dot$[rsp]
	comiss	xmm0, DWORD PTR ab_len_sqr$[rsp]
	jbe	SHORT $LN3@ImLineClos

; 320  : 		return b;

	mov	rax, QWORD PTR b$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@ImLineClos
$LN3@ImLineClos:

; 321  : 	return a + ab_dir * dot / ab_len_sqr;

	movss	xmm2, DWORD PTR dot$[rsp]
	lea	rdx, QWORD PTR ab_dir$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	movss	xmm2, DWORD PTR ab_len_sqr$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??K@YA?AUImVec2@@AEBU0@M@Z		; operator/
	mov	r8, rax
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@ImLineClos:

; 322  : }

	add	rsp, 88					; 00000058H
	ret	0
?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z ENDP	; ImLineClosestPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv68 = 0
c$ = 32
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA

; 155  : static inline bool      ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 9
	je	SHORT $LN3@ImCharIsBl
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
	mov	DWORD PTR tv68[rsp], 1
$LN4@ImCharIsBl:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
filename_wsize$ = 48
mode_wsize$ = 52
tv138 = 56
tv136 = 64
$T1 = 72
buf$ = 80
filename$ = 112
mode$ = 120
?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z PROC			; ImFileOpen

; 590  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 591  : #if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)
; 592  : 	// We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
; 593  : 	const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;

	xor	edx, edx
	mov	rcx, QWORD PTR filename$[rsp]
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	inc	eax
	mov	DWORD PTR filename_wsize$[rsp], eax

; 594  : 	const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;

	xor	edx, edx
	mov	rcx, QWORD PTR mode$[rsp]
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	inc	eax
	mov	DWORD PTR mode_wsize$[rsp], eax

; 595  : 	ImVector<ImWchar> buf;

	lea	rcx, QWORD PTR buf$[rsp]
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1

; 596  : 	buf.resize(filename_wsize + mode_wsize);

	mov	eax, DWORD PTR mode_wsize$[rsp]
	mov	ecx, DWORD PTR filename_wsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	lea	rcx, QWORD PTR buf$[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 597  : 	ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);

	xor	edx, edx
	lea	rcx, QWORD PTR buf$[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR filename$[rsp]
	mov	edx, DWORD PTR filename_wsize$[rsp]
	mov	rcx, rax
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8

; 598  : 	ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);

	mov	edx, DWORD PTR filename_wsize$[rsp]
	lea	rcx, QWORD PTR buf$[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR mode$[rsp]
	mov	edx, DWORD PTR mode_wsize$[rsp]
	mov	rcx, rax
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	npad	1

; 599  : 	return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);

	mov	edx, DWORD PTR filename_wsize$[rsp]
	lea	rcx, QWORD PTR buf$[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	mov	QWORD PTR tv138[rsp], rax
	xor	edx, edx
	lea	rcx, QWORD PTR buf$[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	mov	QWORD PTR tv136[rsp], rax
	mov	rdx, QWORD PTR tv138[rsp]
	mov	rcx, QWORD PTR tv136[rsp]
	call	_wfopen
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR buf$[rsp]
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	mov	rax, QWORD PTR $T1[rsp]

; 600  : #else
; 601  : 	return fopen(filename, mode);
; 602  : #endif
; 603  : }

	add	rsp, 104				; 00000068H
	ret	0
?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z ENDP			; ImFileOpen
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
filename_wsize$ = 48
mode_wsize$ = 52
tv138 = 56
tv136 = 64
$T1 = 72
buf$ = 80
filename$ = 112
mode$ = 120
?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA PROC	; `ImFileOpen'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR buf$[rbp]
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z@4HA ENDP	; `ImFileOpen'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
file_size_signed$ = 32
f$ = 40
file_size$ = 48
file_data$ = 56
filename$ = 80
file_open_mode$ = 88
out_file_size$ = 96
padding_bytes$ = 104
?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z PROC		; ImFileLoadToMemory

; 608  : {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 609  : 	IM_ASSERT(filename && file_open_mode);
; 610  : 	if (out_file_size)

	cmp	QWORD PTR out_file_size$[rsp], 0
	je	SHORT $LN2@ImFileLoad

; 611  : 		*out_file_size = 0;

	mov	rax, QWORD PTR out_file_size$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@ImFileLoad:

; 612  : 
; 613  : 	FILE* f;
; 614  : 	if ((f = ImFileOpen(filename, file_open_mode)) == NULL)

	mov	rdx, QWORD PTR file_open_mode$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z	; ImFileOpen
	mov	QWORD PTR f$[rsp], rax
	cmp	QWORD PTR f$[rsp], 0
	jne	SHORT $LN3@ImFileLoad

; 615  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@ImFileLoad
$LN3@ImFileLoad:

; 616  : 
; 617  : 	long file_size_signed;
; 618  : 	if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	fseek
	test	eax, eax
	jne	SHORT $LN5@ImFileLoad
	mov	rcx, QWORD PTR f$[rsp]
	call	ftell
	mov	DWORD PTR file_size_signed$[rsp], eax
	cmp	DWORD PTR file_size_signed$[rsp], -1
	je	SHORT $LN5@ImFileLoad
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	fseek
	test	eax, eax
	je	SHORT $LN4@ImFileLoad
$LN5@ImFileLoad:

; 619  : 	{
; 620  : 		fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 621  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@ImFileLoad
$LN4@ImFileLoad:

; 622  : 	}
; 623  : 
; 624  : 	size_t file_size = (size_t)file_size_signed;

	movsxd	rax, DWORD PTR file_size_signed$[rsp]
	mov	QWORD PTR file_size$[rsp], rax

; 625  : 	void* file_data = ImGui::MemAlloc(file_size + padding_bytes);

	movsxd	rax, DWORD PTR padding_bytes$[rsp]
	mov	rcx, QWORD PTR file_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR file_data$[rsp], rax

; 626  : 	if (file_data == NULL)

	cmp	QWORD PTR file_data$[rsp], 0
	jne	SHORT $LN6@ImFileLoad

; 627  : 	{
; 628  : 		fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 629  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@ImFileLoad
$LN6@ImFileLoad:

; 630  : 	}
; 631  : 	if (fread(file_data, 1, file_size, f) != file_size)

	mov	r9, QWORD PTR f$[rsp]
	mov	r8, QWORD PTR file_size$[rsp]
	mov	edx, 1
	mov	rcx, QWORD PTR file_data$[rsp]
	call	fread
	cmp	rax, QWORD PTR file_size$[rsp]
	je	SHORT $LN7@ImFileLoad

; 632  : 	{
; 633  : 		fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 634  : 		ImGui::MemFree(file_data);

	mov	rcx, QWORD PTR file_data$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 635  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@ImFileLoad
$LN7@ImFileLoad:

; 636  : 	}
; 637  : 	if (padding_bytes > 0)

	cmp	DWORD PTR padding_bytes$[rsp], 0
	jle	SHORT $LN8@ImFileLoad

; 638  : 		memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

	movsxd	rax, DWORD PTR padding_bytes$[rsp]
	mov	rcx, QWORD PTR file_size$[rsp]
	mov	rdx, QWORD PTR file_data$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	xor	edx, edx
	call	memset
	npad	1
$LN8@ImFileLoad:

; 639  : 
; 640  : 	fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose
	npad	1

; 641  : 	if (out_file_size)

	cmp	QWORD PTR out_file_size$[rsp], 0
	je	SHORT $LN9@ImFileLoad

; 642  : 		*out_file_size = file_size;

	mov	rax, QWORD PTR out_file_size$[rsp]
	mov	rcx, QWORD PTR file_size$[rsp]
	mov	QWORD PTR [rax], rcx
$LN9@ImFileLoad:

; 643  : 
; 644  : 	return file_data;

	mov	rax, QWORD PTR file_data$[rsp]
$LN1@ImFileLoad:

; 645  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z ENDP		; ImFileLoadToMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
c$1 = 0
c$2 = 1
tv71 = 2
tv92 = 3
crc$ = 4
src$ = 8
crc32_lut$ = 16
tv68 = 24
data$ = 48
data_size$ = 56
seed$ = 64
?ImHashStr@@YAIPEBD_KI@Z PROC				; ImHashStr

; 562  : {

$LN11:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 563  : 	seed = ~seed;

	mov	eax, DWORD PTR seed$[rsp]
	not	eax
	mov	DWORD PTR seed$[rsp], eax

; 564  : 	ImU32 crc = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR crc$[rsp], eax

; 565  : 	const unsigned char* src = (const unsigned char*)data;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR src$[rsp], rax

; 566  : 	const ImU32* crc32_lut = GCrc32LookupTable;

	lea	rax, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
	mov	QWORD PTR crc32_lut$[rsp], rax

; 567  : 	if (data_size != 0)

	cmp	QWORD PTR data_size$[rsp], 0
	je	$LN6@ImHashStr
$LN2@ImHashStr:

; 568  : 	{
; 569  : 		while (data_size-- != 0)

	mov	rax, QWORD PTR data_size$[rsp]
	mov	QWORD PTR tv68[rsp], rax
	mov	rax, QWORD PTR data_size$[rsp]
	dec	rax
	mov	QWORD PTR data_size$[rsp], rax
	cmp	QWORD PTR tv68[rsp], 0
	je	$LN3@ImHashStr

; 570  : 		{
; 571  : 			unsigned char c = *src++;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv71[rsp], al
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR c$2[rsp], al

; 572  : 			if (c == '#' && src[0] == '#' && src[1] == '#')

	movzx	eax, BYTE PTR c$2[rsp]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN8@ImHashStr
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN8@ImHashStr
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN8@ImHashStr

; 573  : 				crc = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR crc$[rsp], eax
$LN8@ImHashStr:

; 574  : 			crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	mov	eax, DWORD PTR crc$[rsp]
	shr	eax, 8
	mov	ecx, DWORD PTR crc$[rsp]
	and	ecx, 255				; 000000ffH
	movzx	edx, BYTE PTR c$2[rsp]
	xor	ecx, edx
	mov	ecx, ecx
	mov	rdx, QWORD PTR crc32_lut$[rsp]
	xor	eax, DWORD PTR [rdx+rcx*4]
	mov	DWORD PTR crc$[rsp], eax

; 575  : 		}

	jmp	$LN2@ImHashStr
$LN3@ImHashStr:

; 576  : 	}

	jmp	$LN7@ImHashStr
$LN6@ImHashStr:
$LN4@ImHashStr:

; 577  : 	else
; 578  : 	{
; 579  : 		while (unsigned char c = *src++)

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv92[rsp], al
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	movzx	eax, BYTE PTR tv92[rsp]
	mov	BYTE PTR c$1[rsp], al
	movzx	eax, BYTE PTR c$1[rsp]
	test	eax, eax
	je	SHORT $LN5@ImHashStr

; 580  : 		{
; 581  : 			if (c == '#' && src[0] == '#' && src[1] == '#')

	movzx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN9@ImHashStr
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN9@ImHashStr
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN9@ImHashStr

; 582  : 				crc = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR crc$[rsp], eax
$LN9@ImHashStr:

; 583  : 			crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	mov	eax, DWORD PTR crc$[rsp]
	shr	eax, 8
	mov	ecx, DWORD PTR crc$[rsp]
	and	ecx, 255				; 000000ffH
	movzx	edx, BYTE PTR c$1[rsp]
	xor	ecx, edx
	mov	ecx, ecx
	mov	rdx, QWORD PTR crc32_lut$[rsp]
	xor	eax, DWORD PTR [rdx+rcx*4]
	mov	DWORD PTR crc$[rsp], eax

; 584  : 		}

	jmp	$LN4@ImHashStr
$LN5@ImHashStr:
$LN7@ImHashStr:

; 585  : 	}
; 586  : 	return ~crc;

	mov	eax, DWORD PTR crc$[rsp]
	not	eax

; 587  : }

	add	rsp, 40					; 00000028H
	ret	0
?ImHashStr@@YAIPEBD_KI@Z ENDP				; ImHashStr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
crc$ = 0
tv78 = 4
data$ = 8
tv67 = 16
crc32_lut$ = 24
data_p$ = 48
data_size$ = 56
seed$ = 64
?ImHashData@@YAIPEBX_KI@Z PROC				; ImHashData

; 546  : {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 547  : 	ImU32 crc = ~seed;

	mov	eax, DWORD PTR seed$[rsp]
	not	eax
	mov	DWORD PTR crc$[rsp], eax

; 548  : 	const unsigned char* data = (const unsigned char*)data_p;

	mov	rax, QWORD PTR data_p$[rsp]
	mov	QWORD PTR data$[rsp], rax

; 549  : 	const ImU32* crc32_lut = GCrc32LookupTable;

	lea	rax, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
	mov	QWORD PTR crc32_lut$[rsp], rax
$LN2@ImHashData:

; 550  : 	while (data_size-- != 0)

	mov	rax, QWORD PTR data_size$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	rax, QWORD PTR data_size$[rsp]
	dec	rax
	mov	QWORD PTR data_size$[rsp], rax
	cmp	QWORD PTR tv67[rsp], 0
	je	SHORT $LN3@ImHashData

; 551  : 		crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];

	mov	eax, DWORD PTR crc$[rsp]
	shr	eax, 8
	mov	ecx, DWORD PTR crc$[rsp]
	and	ecx, 255				; 000000ffH
	mov	rdx, QWORD PTR data$[rsp]
	movzx	edx, BYTE PTR [rdx]
	xor	ecx, edx
	mov	ecx, ecx
	mov	rdx, QWORD PTR crc32_lut$[rsp]
	xor	eax, DWORD PTR [rdx+rcx*4]
	mov	DWORD PTR tv78[rsp], eax
	mov	rax, QWORD PTR data$[rsp]
	inc	rax
	mov	QWORD PTR data$[rsp], rax
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR crc$[rsp], eax
	jmp	SHORT $LN2@ImHashData
$LN3@ImHashData:

; 552  : 	return ~crc;

	mov	eax, DWORD PTR crc$[rsp]
	not	eax

; 553  : }

	add	rsp, 40					; 00000028H
	ret	0
?ImHashData@@YAIPEBX_KI@Z ENDP				; ImHashData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
bytes_count$ = 32
c$1 = 36
tv71 = 40
in_text$ = 64
in_text_end$ = 72
?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z PROC		; ImTextCountUtf8BytesFromStr

; 817  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 818  : 	int bytes_count = 0;

	mov	DWORD PTR bytes_count$[rsp], 0
$LN2@ImTextCoun:

; 819  : 	while ((!in_text_end || in_text < in_text_end) && *in_text)

	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN4@ImTextCoun
	mov	rax, QWORD PTR in_text_end$[rsp]
	cmp	QWORD PTR in_text$[rsp], rax
	jae	SHORT $LN3@ImTextCoun
$LN4@ImTextCoun:
	mov	rax, QWORD PTR in_text$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ImTextCoun

; 820  : 	{
; 821  : 		unsigned int c = (unsigned int)(*in_text++);

	mov	rax, QWORD PTR in_text$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv71[rsp], eax
	mov	rax, QWORD PTR in_text$[rsp]
	add	rax, 2
	mov	QWORD PTR in_text$[rsp], rax
	mov	eax, DWORD PTR tv71[rsp]
	mov	DWORD PTR c$1[rsp], eax

; 822  : 		if (c < 0x80)

	cmp	DWORD PTR c$1[rsp], 128			; 00000080H
	jae	SHORT $LN5@ImTextCoun

; 823  : 			bytes_count++;

	mov	eax, DWORD PTR bytes_count$[rsp]
	inc	eax
	mov	DWORD PTR bytes_count$[rsp], eax
	jmp	SHORT $LN6@ImTextCoun
$LN5@ImTextCoun:

; 824  : 		else
; 825  : 			bytes_count += ImTextCountUtf8BytesFromChar(c);

	mov	ecx, DWORD PTR c$1[rsp]
	call	?ImTextCountUtf8BytesFromChar@@YAHI@Z	; ImTextCountUtf8BytesFromChar
	mov	ecx, DWORD PTR bytes_count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR bytes_count$[rsp], eax
$LN6@ImTextCoun:

; 826  : 	}

	jmp	SHORT $LN2@ImTextCoun
$LN3@ImTextCoun:

; 827  : 	return bytes_count;

	mov	eax, DWORD PTR bytes_count$[rsp]

; 828  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ENDP		; ImTextCountUtf8BytesFromStr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
dummy$ = 32
in_text$ = 64
in_text_end$ = 72
?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z PROC		; ImTextCountUtf8BytesFromChar

; 786  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 787  : 	unsigned int dummy = 0;

	mov	DWORD PTR dummy$[rsp], 0

; 788  : 	return ImTextCharFromUtf8(&dummy, in_text, in_text_end);

	mov	r8, QWORD PTR in_text_end$[rsp]
	mov	rdx, QWORD PTR in_text$[rsp]
	lea	rcx, QWORD PTR dummy$[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8

; 789  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z ENDP		; ImTextCountUtf8BytesFromChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
char_count$ = 32
c$1 = 36
in_text$ = 64
in_text_end$ = 72
?ImTextCountCharsFromUtf8@@YAHPEBD0@Z PROC		; ImTextCountCharsFromUtf8

; 732  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 733  : 	int char_count = 0;

	mov	DWORD PTR char_count$[rsp], 0
$LN2@ImTextCoun:

; 734  : 	while ((!in_text_end || in_text < in_text_end) && *in_text)

	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN4@ImTextCoun
	mov	rax, QWORD PTR in_text_end$[rsp]
	cmp	QWORD PTR in_text$[rsp], rax
	jae	SHORT $LN3@ImTextCoun
$LN4@ImTextCoun:
	mov	rax, QWORD PTR in_text$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ImTextCoun

; 735  : 	{
; 736  : 		unsigned int c;
; 737  : 		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);

	mov	r8, QWORD PTR in_text_end$[rsp]
	mov	rdx, QWORD PTR in_text$[rsp]
	lea	rcx, QWORD PTR c$1[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR in_text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR in_text$[rsp], rax

; 738  : 		if (c == 0)

	cmp	DWORD PTR c$1[rsp], 0
	jne	SHORT $LN5@ImTextCoun

; 739  : 			break;

	jmp	SHORT $LN3@ImTextCoun
$LN5@ImTextCoun:

; 740  : 		if (c < 0x10000)

	cmp	DWORD PTR c$1[rsp], 65536		; 00010000H
	jae	SHORT $LN6@ImTextCoun

; 741  : 			char_count++;

	mov	eax, DWORD PTR char_count$[rsp]
	inc	eax
	mov	DWORD PTR char_count$[rsp], eax
$LN6@ImTextCoun:

; 742  : 	}

	jmp	SHORT $LN2@ImTextCoun
$LN3@ImTextCoun:

; 743  : 	return char_count;

	mov	eax, DWORD PTR char_count$[rsp]

; 744  : }

	add	rsp, 56					; 00000038H
	ret	0
?ImTextCountCharsFromUtf8@@YAHPEBD0@Z ENDP		; ImTextCountCharsFromUtf8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
c$1 = 32
buf_out$ = 40
buf_end$ = 48
buf$ = 80
buf_size$ = 88
in_text$ = 96
in_text_end$ = 104
in_text_remaining$ = 112
?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z PROC		; ImTextStrFromUtf8

; 713  : {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 714  : 	ImWchar* buf_out = buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR buf_out$[rsp], rax

; 715  : 	ImWchar* buf_end = buf + buf_size;

	movsxd	rax, DWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR buf_end$[rsp], rax
$LN2@ImTextStrF:

; 716  : 	while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)

	mov	rax, QWORD PTR buf_end$[rsp]
	sub	rax, 2
	cmp	QWORD PTR buf_out$[rsp], rax
	jae	SHORT $LN3@ImTextStrF
	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN4@ImTextStrF
	mov	rax, QWORD PTR in_text_end$[rsp]
	cmp	QWORD PTR in_text$[rsp], rax
	jae	SHORT $LN3@ImTextStrF
$LN4@ImTextStrF:
	mov	rax, QWORD PTR in_text$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ImTextStrF

; 717  : 	{
; 718  : 		unsigned int c;
; 719  : 		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);

	mov	r8, QWORD PTR in_text_end$[rsp]
	mov	rdx, QWORD PTR in_text$[rsp]
	lea	rcx, QWORD PTR c$1[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR in_text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR in_text$[rsp], rax

; 720  : 		if (c == 0)

	cmp	DWORD PTR c$1[rsp], 0
	jne	SHORT $LN5@ImTextStrF

; 721  : 			break;

	jmp	SHORT $LN3@ImTextStrF
$LN5@ImTextStrF:

; 722  : 		if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes

	cmp	DWORD PTR c$1[rsp], 65536		; 00010000H
	jae	SHORT $LN6@ImTextStrF

; 723  : 			*buf_out++ = (ImWchar)c;

	mov	rax, QWORD PTR buf_out$[rsp]
	movzx	ecx, WORD PTR c$1[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR buf_out$[rsp]
	add	rax, 2
	mov	QWORD PTR buf_out$[rsp], rax
$LN6@ImTextStrF:

; 724  : 	}

	jmp	$LN2@ImTextStrF
$LN3@ImTextStrF:

; 725  : 	*buf_out = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR buf_out$[rsp]
	mov	WORD PTR [rcx], ax

; 726  : 	if (in_text_remaining)

	cmp	QWORD PTR in_text_remaining$[rsp], 0
	je	SHORT $LN7@ImTextStrF

; 727  : 		*in_text_remaining = in_text;

	mov	rax, QWORD PTR in_text_remaining$[rsp]
	mov	rcx, QWORD PTR in_text$[rsp]
	mov	QWORD PTR [rax], rcx
$LN7@ImTextStrF:

; 728  : 	return (int)(buf_out - buf);

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR buf_out$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1

; 729  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ENDP		; ImTextStrFromUtf8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
str$ = 0
c$ = 8
tv70 = 12
tv82 = 16
tv91 = 20
tv151 = 24
tv160 = 28
tv170 = 32
tv200 = 36
tv209 = 40
tv219 = 44
tv229 = 48
out_char$ = 80
in_text$ = 88
in_text_end$ = 96
?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z PROC		; ImTextCharFromUtf8

; 655  : {

$LN25:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 656  : 	unsigned int c = (unsigned int)-1;

	mov	DWORD PTR c$[rsp], -1			; ffffffffH

; 657  : 	const unsigned char* str = (const unsigned char*)in_text;

	mov	rax, QWORD PTR in_text$[rsp]
	mov	QWORD PTR str$[rsp], rax

; 658  : 	if (!(*str & 0x80))

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN2@ImTextChar

; 659  : 	{
; 660  : 		c = (unsigned int)(*str++);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv70[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR c$[rsp], eax

; 661  : 		*out_char = c;

	mov	rax, QWORD PTR out_char$[rsp]
	mov	ecx, DWORD PTR c$[rsp]
	mov	DWORD PTR [rax], ecx

; 662  : 		return 1;

	mov	eax, 1
	jmp	$LN1@ImTextChar
$LN2@ImTextChar:

; 663  : 	}
; 664  : 	if ((*str & 0xe0) == 0xc0)

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 224				; 000000e0H
	cmp	eax, 192				; 000000c0H
	jne	$LN3@ImTextChar

; 665  : 	{
; 666  : 		*out_char = 0xFFFD; // will be invalid but not end of string

	mov	rax, QWORD PTR out_char$[rsp]
	mov	DWORD PTR [rax], 65533			; 0000fffdH

; 667  : 		if (in_text_end && in_text_end - (const char*)str < 2) return 1;

	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN4@ImTextChar
	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR in_text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 2
	jge	SHORT $LN4@ImTextChar
	mov	eax, 1
	jmp	$LN1@ImTextChar
$LN4@ImTextChar:

; 668  : 		if (*str < 0xc2) return 2;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 194				; 000000c2H
	jge	SHORT $LN5@ImTextChar
	mov	eax, 2
	jmp	$LN1@ImTextChar
$LN5@ImTextChar:

; 669  : 		c = (unsigned int)((*str++ & 0x1f) << 6);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv82[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv82[rsp]
	and	eax, 31
	shl	eax, 6
	mov	DWORD PTR c$[rsp], eax

; 670  : 		if ((*str & 0xc0) != 0x80) return 2;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN6@ImTextChar
	mov	eax, 2
	jmp	$LN1@ImTextChar
$LN6@ImTextChar:

; 671  : 		c += (*str++ & 0x3f);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv91[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv91[rsp]
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR c$[rsp], eax

; 672  : 		*out_char = c;

	mov	rax, QWORD PTR out_char$[rsp]
	mov	ecx, DWORD PTR c$[rsp]
	mov	DWORD PTR [rax], ecx

; 673  : 		return 2;

	mov	eax, 2
	jmp	$LN1@ImTextChar
$LN3@ImTextChar:

; 674  : 	}
; 675  : 	if ((*str & 0xf0) == 0xe0)

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 240				; 000000f0H
	cmp	eax, 224				; 000000e0H
	jne	$LN7@ImTextChar

; 676  : 	{
; 677  : 		*out_char = 0xFFFD; // will be invalid but not end of string

	mov	rax, QWORD PTR out_char$[rsp]
	mov	DWORD PTR [rax], 65533			; 0000fffdH

; 678  : 		if (in_text_end && in_text_end - (const char*)str < 3) return 1;

	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN8@ImTextChar
	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR in_text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 3
	jge	SHORT $LN8@ImTextChar
	mov	eax, 1
	jmp	$LN1@ImTextChar
$LN8@ImTextChar:

; 679  : 		if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 224				; 000000e0H
	jne	SHORT $LN9@ImTextChar
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 160				; 000000a0H
	jl	SHORT $LN10@ImTextChar
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 191				; 000000bfH
	jle	SHORT $LN9@ImTextChar
$LN10@ImTextChar:
	mov	eax, 3
	jmp	$LN1@ImTextChar
$LN9@ImTextChar:

; 680  : 		if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 237				; 000000edH
	jne	SHORT $LN11@ImTextChar
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 159				; 0000009fH
	jle	SHORT $LN11@ImTextChar
	mov	eax, 3
	jmp	$LN1@ImTextChar
$LN11@ImTextChar:

; 681  : 		c = (unsigned int)((*str++ & 0x0f) << 12);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv151[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv151[rsp]
	and	eax, 15
	shl	eax, 12
	mov	DWORD PTR c$[rsp], eax

; 682  : 		if ((*str & 0xc0) != 0x80) return 3;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN12@ImTextChar
	mov	eax, 3
	jmp	$LN1@ImTextChar
$LN12@ImTextChar:

; 683  : 		c += (unsigned int)((*str++ & 0x3f) << 6);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv160[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv160[rsp]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR c$[rsp], eax

; 684  : 		if ((*str & 0xc0) != 0x80) return 3;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN13@ImTextChar
	mov	eax, 3
	jmp	$LN1@ImTextChar
$LN13@ImTextChar:

; 685  : 		c += (*str++ & 0x3f);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv170[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv170[rsp]
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR c$[rsp], eax

; 686  : 		*out_char = c;

	mov	rax, QWORD PTR out_char$[rsp]
	mov	ecx, DWORD PTR c$[rsp]
	mov	DWORD PTR [rax], ecx

; 687  : 		return 3;

	mov	eax, 3
	jmp	$LN1@ImTextChar
$LN7@ImTextChar:

; 688  : 	}
; 689  : 	if ((*str & 0xf8) == 0xf0)

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 248				; 000000f8H
	cmp	eax, 240				; 000000f0H
	jne	$LN14@ImTextChar

; 690  : 	{
; 691  : 		*out_char = 0xFFFD; // will be invalid but not end of string

	mov	rax, QWORD PTR out_char$[rsp]
	mov	DWORD PTR [rax], 65533			; 0000fffdH

; 692  : 		if (in_text_end && in_text_end - (const char*)str < 4) return 1;

	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN15@ImTextChar
	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR in_text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 4
	jge	SHORT $LN15@ImTextChar
	mov	eax, 1
	jmp	$LN1@ImTextChar
$LN15@ImTextChar:

; 693  : 		if (*str > 0xf4) return 4;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 244				; 000000f4H
	jle	SHORT $LN16@ImTextChar
	mov	eax, 4
	jmp	$LN1@ImTextChar
$LN16@ImTextChar:

; 694  : 		if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 240				; 000000f0H
	jne	SHORT $LN17@ImTextChar
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 144				; 00000090H
	jl	SHORT $LN18@ImTextChar
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 191				; 000000bfH
	jle	SHORT $LN17@ImTextChar
$LN18@ImTextChar:
	mov	eax, 4
	jmp	$LN1@ImTextChar
$LN17@ImTextChar:

; 695  : 		if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 244				; 000000f4H
	jne	SHORT $LN19@ImTextChar
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 143				; 0000008fH
	jle	SHORT $LN19@ImTextChar
	mov	eax, 4
	jmp	$LN1@ImTextChar
$LN19@ImTextChar:

; 696  : 		c = (unsigned int)((*str++ & 0x07) << 18);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv200[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv200[rsp]
	and	eax, 7
	shl	eax, 18
	mov	DWORD PTR c$[rsp], eax

; 697  : 		if ((*str & 0xc0) != 0x80) return 4;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN20@ImTextChar
	mov	eax, 4
	jmp	$LN1@ImTextChar
$LN20@ImTextChar:

; 698  : 		c += (unsigned int)((*str++ & 0x3f) << 12);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv209[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv209[rsp]
	and	eax, 63					; 0000003fH
	shl	eax, 12
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR c$[rsp], eax

; 699  : 		if ((*str & 0xc0) != 0x80) return 4;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN21@ImTextChar
	mov	eax, 4
	jmp	$LN1@ImTextChar
$LN21@ImTextChar:

; 700  : 		c += (unsigned int)((*str++ & 0x3f) << 6);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv219[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv219[rsp]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR c$[rsp], eax

; 701  : 		if ((*str & 0xc0) != 0x80) return 4;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN22@ImTextChar
	mov	eax, 4
	jmp	SHORT $LN1@ImTextChar
$LN22@ImTextChar:

; 702  : 		c += (*str++ & 0x3f);

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv229[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR tv229[rsp]
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR c$[rsp], eax

; 703  : 		// utf-8 encodings of values used in surrogate pairs are invalid
; 704  : 		if ((c & 0xFFFFF800) == 0xD800) return 4;

	mov	eax, DWORD PTR c$[rsp]
	and	eax, -2048				; fffff800H
	cmp	eax, 55296				; 0000d800H
	jne	SHORT $LN23@ImTextChar
	mov	eax, 4
	jmp	SHORT $LN1@ImTextChar
$LN23@ImTextChar:

; 705  : 		*out_char = c;

	mov	rax, QWORD PTR out_char$[rsp]
	mov	ecx, DWORD PTR c$[rsp]
	mov	DWORD PTR [rax], ecx

; 706  : 		return 4;

	mov	eax, 4
	jmp	SHORT $LN1@ImTextChar
$LN14@ImTextChar:

; 707  : 	}
; 708  : 	*out_char = 0;

	mov	rax, QWORD PTR out_char$[rsp]
	mov	DWORD PTR [rax], 0

; 709  : 	return 0;

	xor	eax, eax
$LN1@ImTextChar:

; 710  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z ENDP		; ImTextCharFromUtf8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
c$1 = 32
tv75 = 36
buf_out$ = 40
buf_end$ = 48
buf$ = 80
buf_size$ = 88
in_text$ = 96
in_text_end$ = 104
?ImTextStrToUtf8@@YAHPEADHPEBG1@Z PROC			; ImTextStrToUtf8

; 801  : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 802  : 	char* buf_out = buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR buf_out$[rsp], rax

; 803  : 	const char* buf_end = buf + buf_size;

	movsxd	rax, DWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR buf_end$[rsp], rax
$LN2@ImTextStrT:

; 804  : 	while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)

	mov	rax, QWORD PTR buf_end$[rsp]
	dec	rax
	cmp	QWORD PTR buf_out$[rsp], rax
	jae	$LN3@ImTextStrT
	cmp	QWORD PTR in_text_end$[rsp], 0
	je	SHORT $LN4@ImTextStrT
	mov	rax, QWORD PTR in_text_end$[rsp]
	cmp	QWORD PTR in_text$[rsp], rax
	jae	$LN3@ImTextStrT
$LN4@ImTextStrT:
	mov	rax, QWORD PTR in_text$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	$LN3@ImTextStrT

; 805  : 	{
; 806  : 		unsigned int c = (unsigned int)(*in_text++);

	mov	rax, QWORD PTR in_text$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR in_text$[rsp]
	add	rax, 2
	mov	QWORD PTR in_text$[rsp], rax
	mov	eax, DWORD PTR tv75[rsp]
	mov	DWORD PTR c$1[rsp], eax

; 807  : 		if (c < 0x80)

	cmp	DWORD PTR c$1[rsp], 128			; 00000080H
	jae	SHORT $LN5@ImTextStrT

; 808  : 			*buf_out++ = (char)c;

	mov	rax, QWORD PTR buf_out$[rsp]
	movzx	ecx, BYTE PTR c$1[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR buf_out$[rsp]
	inc	rax
	mov	QWORD PTR buf_out$[rsp], rax
	jmp	SHORT $LN6@ImTextStrT
$LN5@ImTextStrT:

; 809  : 		else
; 810  : 			buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end - buf_out - 1), c);

	mov	rax, QWORD PTR buf_out$[rsp]
	mov	rcx, QWORD PTR buf_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	dec	rax
	mov	r8d, DWORD PTR c$1[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR buf_out$[rsp]
	call	?ImTextCharToUtf8@@YAHPEADHI@Z		; ImTextCharToUtf8
	cdqe
	mov	rcx, QWORD PTR buf_out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR buf_out$[rsp], rax
$LN6@ImTextStrT:

; 811  : 	}

	jmp	$LN2@ImTextStrT
$LN3@ImTextStrT:

; 812  : 	*buf_out = 0;

	mov	rax, QWORD PTR buf_out$[rsp]
	mov	BYTE PTR [rax], 0

; 813  : 	return (int)(buf_out - buf);

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR buf_out$[rsp]
	sub	rcx, rax
	mov	rax, rcx

; 814  : }

	add	rsp, 72					; 00000048H
	ret	0
?ImTextStrToUtf8@@YAHPEADHPEBG1@Z ENDP			; ImTextStrToUtf8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@M@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@M@@QEAAXXZ PROC			; ImVector<float>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@M@@QEAAXXZ ENDP			; ImVector<float>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@M@@QEAAXAEBM@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@M@@QEAAXAEBM@Z PROC		; ImVector<float>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@M@@QEBAHH@Z	; ImVector<float>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	r8d, 4
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@M@@QEAAXAEBM@Z ENDP		; ImVector<float>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@M@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@M@@QEAAXH@Z PROC			; ImVector<float>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@M@@QEAAXH@Z ENDP			; ImVector<float>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@M@@QEAAXH@Z PROC			; ImVector<float>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@M@@QEBAHH@Z	; ImVector<float>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@M@@QEAAXH@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@M@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@M@@QEBAHH@Z PROC		; ImVector<float>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@M@@QEBAHH@Z ENDP		; ImVector<float>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@M@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@M@@QEAAAEAMXZ PROC			; ImVector<float>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
?back@?$ImVector@M@@QEAAAEAMXZ ENDP			; ImVector<float>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@M@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@M@@QEBA_NXZ PROC			; ImVector<float>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@M@@QEBA_NXZ ENDP			; ImVector<float>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@M@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@M@@QEAA@XZ PROC				; ImVector<float>::~ImVector<float>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@M@@QEAA@XZ ENDP				; ImVector<float>::~ImVector<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@M@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@M@@QEAA@XZ PROC				; ImVector<float>::ImVector<float>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@M@@QEAA@XZ ENDP				; ImVector<float>::ImVector<float>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImFontAtlas@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImFontAtlas@@QEAAPEAXI@Z PROC			; ImFontAtlas::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImFontAtlas@@QEAA@XZ			; ImFontAtlas::~ImFontAtlas
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImFontAtlas@@QEAAPEAXI@Z ENDP			; ImFontAtlas::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PEAUImFont@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@PEAUImFont@@@@QEAAXXZ PROC		; ImVector<ImFont *>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@PEAUImFont@@@@QEAAXXZ ENDP		; ImVector<ImFont *>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z PROC ; ImVector<ImFont *>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z ; ImVector<ImFont *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z ; ImVector<ImFont *>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ENDP ; ImVector<ImFont *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z PROC		; ImVector<ImFont *>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z ENDP		; ImVector<ImFont *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z PROC	; ImVector<ImFont *>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z ENDP	; ImVector<ImFont *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ PROC ; ImVector<ImFont *>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ ENDP ; ImVector<ImFont *>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ PROC		; ImVector<ImFont *>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ ENDP		; ImVector<ImFont *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z PROC	; ImVector<ImFont *>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ENDP	; ImVector<ImFont *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ PROC		; ImVector<ImFont *>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ ENDP		; ImVector<ImFont *>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAUImFont@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAUImFont@@@@QEAA@XZ PROC		; ImVector<ImFont *>::~ImVector<ImFont *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAUImFont@@@@QEAA@XZ ENDP		; ImVector<ImFont *>::~ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAUImFont@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAUImFont@@@@QEAA@XZ PROC		; ImVector<ImFont *>::ImVector<ImFont *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAUImFont@@@@QEAA@XZ ENDP		; ImVector<ImFont *>::ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@H@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@H@@QEAAXXZ PROC			; ImVector<int>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@H@@QEAAXXZ ENDP			; ImVector<int>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@H@@QEAAXAEBH@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@H@@QEAAXAEBH@Z PROC		; ImVector<int>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@H@@QEBAHH@Z	; ImVector<int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	r8d, 4
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@H@@QEAAXAEBH@Z ENDP		; ImVector<int>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@H@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@H@@QEAAXH@Z PROC			; ImVector<int>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@H@@QEAAXH@Z ENDP			; ImVector<int>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@H@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@H@@QEAAXH@Z PROC			; ImVector<int>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@H@@QEBAHH@Z	; ImVector<int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@H@@QEAAXH@Z ENDP			; ImVector<int>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@H@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@H@@QEBAHH@Z PROC		; ImVector<int>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@H@@QEBAHH@Z ENDP		; ImVector<int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@H@@QEAAAEAHXZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@H@@QEAAAEAHXZ PROC			; ImVector<int>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
?back@?$ImVector@H@@QEAAAEAHXZ ENDP			; ImVector<int>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@H@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@H@@QEBA_NXZ PROC			; ImVector<int>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@H@@QEBA_NXZ ENDP			; ImVector<int>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@H@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@H@@QEAA@XZ PROC				; ImVector<int>::~ImVector<int>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@H@@QEAA@XZ ENDP				; ImVector<int>::~ImVector<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@H@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@H@@QEAA@XZ PROC				; ImVector<int>::ImVector<int>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@H@@QEAA@XZ ENDP				; ImVector<int>::ImVector<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?Clear@ImDrawData@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?Clear@ImDrawData@@QEAAXXZ PROC				; ImDrawData::Clear, COMDAT

; 1943 : 	void Clear() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+40], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	add	rsp, 56					; 00000038H
	ret	0
?Clear@ImDrawData@@QEAAXXZ ENDP				; ImDrawData::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1ImDrawData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImDrawData@@QEAA@XZ PROC				; ImDrawData::~ImDrawData, COMDAT

; 1942 : 	~ImDrawData() { Clear(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImDrawData@@QEAAXXZ		; ImDrawData::Clear
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImDrawData@@QEAA@XZ ENDP				; ImDrawData::~ImDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImDrawData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImDrawData@@QEAA@XZ PROC				; ImDrawData::ImDrawData, COMDAT

; 1941 : 	ImDrawData() { Valid = false; Clear(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImDrawData@@QEAAXXZ		; ImDrawData::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImDrawData@@QEAA@XZ ENDP				; ImDrawData::ImDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QEAAXI_NM@Z
_TEXT	SEGMENT
this$ = 64
col$ = 72
closed$ = 80
thickness$ = 88
?PathStroke@ImDrawList@@QEAAXI_NM@Z PROC		; ImDrawList::PathStroke, COMDAT

; 1894 : 	inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movss	xmm0, DWORD PTR thickness$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movzx	eax, BYTE PTR closed$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR col$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rax+152]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+160]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	add	rsp, 56					; 00000038H
	ret	0
?PathStroke@ImDrawList@@QEAAXI_NM@Z ENDP		; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathFillConvex@ImDrawList@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 48
col$ = 56
?PathFillConvex@ImDrawList@@QEAAXI@Z PROC		; ImDrawList::PathFillConvex, COMDAT

; 1893 : 	inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9d, DWORD PTR col$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rax+152]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+160]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	add	rsp, 40					; 00000028H
	ret	0
?PathFillConvex@ImDrawList@@QEAAXI@Z ENDP		; ImDrawList::PathFillConvex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
tv68 = 32
this$ = 64
pos$ = 72
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z PROC	; ImDrawList::PathLineTo, COMDAT

; 1891 : 	inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv68[rsp], rax
	mov	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ENDP	; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1ImDrawList@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImDrawList@@QEAA@XZ PROC				; ImDrawList::~ImDrawList, COMDAT

; 1856 : 	~ImDrawList() { ClearFreeMemory(); }

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearFreeMemory@ImDrawList@@QEAAXXZ	; ImDrawList::ClearFreeMemory
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	??1?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::~ImVector<ImVec2>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	??1?$ImVector@PEAX@@QEAA@XZ		; ImVector<void *>::~ImVector<void *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	??1?$ImVector@UImVec4@@@@QEAA@XZ	; ImVector<ImVec4>::~ImVector<ImVec4>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ	; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImDrawList@@QEAA@XZ ENDP				; ImDrawList::~ImDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ	; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 120				; 00000078H
	call	??1?$ImVector@UImVec4@@@@QEAA@XZ	; ImVector<ImVec4>::~ImVector<ImVec4>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 136				; 00000088H
	call	??1?$ImVector@PEAX@@QEAA@XZ		; ImVector<void *>::~ImVector<void *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA PROC		; `ImDrawList::~ImDrawList'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	??1?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::~ImVector<ImVec2>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???1ImDrawList@@QEAA@XZ@4HA ENDP		; `ImDrawList::~ImDrawList'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
_TEXT	SEGMENT
this$ = 48
shared_data$ = 56
??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z PROC	; ImDrawList::ImDrawList, COMDAT

; 1855 : 	ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::ImVector<ImDrawVert>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??0?$ImVector@UImDrawChannel@@@@QEAA@XZ	; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	??0?$ImVector@UImVec4@@@@QEAA@XZ	; ImVector<ImVec4>::ImVector<ImVec4>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	??0?$ImVector@PEAX@@QEAA@XZ		; ImVector<void *>::ImVector<void *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	??0?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::ImVector<ImVec2>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR shared_data$[rsp]
	mov	QWORD PTR [rax+72], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImDrawList@@QEAAXXZ		; ImDrawList::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ENDP	; ImDrawList::ImDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ	; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 120				; 00000078H
	call	??1?$ImVector@UImVec4@@@@QEAA@XZ	; ImVector<ImVec4>::~ImVector<ImVec4>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 136				; 00000088H
	call	??1?$ImVector@PEAX@@QEAA@XZ		; ImVector<void *>::~ImVector<void *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	??1?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::~ImVector<ImVec2>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z PROC ; ImVector<ImVec2>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ; ImVector<ImVec2>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ENDP ; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec2@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImVec2@@@@QEAA@XZ PROC			; ImVector<ImVec2>::~ImVector<ImVec2>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImVec2@@@@QEAA@XZ ENDP			; ImVector<ImVec2>::~ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec2@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImVec2@@@@QEAA@XZ PROC			; ImVector<ImVec2>::ImVector<ImVec2>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImVec2@@@@QEAA@XZ ENDP			; ImVector<ImVec2>::ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAX@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAX@@QEAA@XZ PROC			; ImVector<void *>::~ImVector<void *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAX@@QEAA@XZ ENDP			; ImVector<void *>::~ImVector<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAX@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAX@@QEAA@XZ PROC			; ImVector<void *>::ImVector<void *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAX@@QEAA@XZ ENDP			; ImVector<void *>::ImVector<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ PROC	; ImVector<ImVec4>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ENDP	; ImVector<ImVec4>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec4@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImVec4@@@@QEAA@XZ PROC			; ImVector<ImVec4>::~ImVector<ImVec4>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImVec4@@@@QEAA@XZ ENDP			; ImVector<ImVec4>::~ImVector<ImVec4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec4@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImVec4@@@@QEAA@XZ PROC			; ImVector<ImVec4>::ImVector<ImVec4>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImVec4@@@@QEAA@XZ ENDP			; ImVector<ImVec4>::ImVector<ImVec4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImDrawChannel@@@@QEAA@XZ PROC		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImDrawChannel@@@@QEAA@XZ ENDP		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawChannel@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImDrawChannel@@@@QEAA@XZ PROC		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImDrawChannel@@@@QEAA@XZ ENDP		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z PROC ; ImVector<ImDrawVert>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ENDP ; ImVector<ImDrawVert>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ PROC		; ImVector<ImDrawVert>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ ENDP		; ImVector<ImDrawVert>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawVert@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImDrawVert@@@@QEAA@XZ PROC		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImDrawVert@@@@QEAA@XZ ENDP		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawVert@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImDrawVert@@@@QEAA@XZ PROC		; ImVector<ImDrawVert>::ImVector<ImDrawVert>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImDrawVert@@@@QEAA@XZ ENDP		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ PROC		; ImVector<ImDrawCmd>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ENDP		; ImVector<ImDrawCmd>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ PROC ; ImVector<ImDrawCmd>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ENDP ; ImVector<ImDrawCmd>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?end@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ
_TEXT	SEGMENT
this$ = 8
?end@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ PROC ; ImVector<ImDrawCmd>::end, COMDAT

; 1234 : 	inline T* end() { return Data + Size; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?end@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ENDP ; ImVector<ImDrawCmd>::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?begin@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ
_TEXT	SEGMENT
this$ = 8
?begin@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ PROC ; ImVector<ImDrawCmd>::begin, COMDAT

; 1232 : 	inline T* begin() { return Data; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?begin@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@XZ ENDP ; ImVector<ImDrawCmd>::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ PROC		; ImVector<ImDrawCmd>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@UImDrawCmd@@@@QEBA_NXZ ENDP		; ImVector<ImDrawCmd>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImDrawCmd@@@@QEAA@XZ PROC		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImDrawCmd@@@@QEAA@XZ ENDP		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawCmd@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImDrawCmd@@@@QEAA@XZ PROC		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImDrawCmd@@@@QEAA@XZ ENDP		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
this$ = 48
?End@ImGuiListClipper@@QEAAXXZ PROC			; ImGuiListClipper::End

; 1321 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1322 : 	if (ItemsCount < 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jge	SHORT $LN2@End

; 1323 : 		return;

	jmp	SHORT $LN1@End
$LN2@End:

; 1324 : 	// In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
; 1325 : 	if (ItemsCount < INT_MAX)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+8], 2147483647		; 7fffffffH
	jge	SHORT $LN3@End

; 1326 : 		SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor

	mov	rax, QWORD PTR this$[rsp]
	cvtsi2ss xmm0, DWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	call	?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z ; SetCursorPosYAndSetupDummyPrevLine
	npad	1
$LN3@End:

; 1327 : 	ItemsCount = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], -1

; 1328 : 	StepNo = 3;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 3
$LN1@End:

; 1329 : }

	add	rsp, 40					; 00000028H
	ret	0
?End@ImGuiListClipper@@QEAAXXZ ENDP			; ImGuiListClipper::End
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
this$ = 48
count$ = 56
items_height$ = 64
?Begin@ImGuiListClipper@@QEAAXHM@Z PROC			; ImGuiListClipper::Begin

; 1305 : {

$LN5:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1306 : 	StartPosY = ImGui::GetCursorPosY();

	call	?GetCursorPosY@ImGui@@YAMXZ		; ImGui::GetCursorPosY
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 1307 : 	ItemsHeight = items_height;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR items_height$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1308 : 	ItemsCount = count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 1309 : 	StepNo = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 0

; 1310 : 	DisplayEnd = DisplayStart = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], -1

; 1311 : 	if (ItemsHeight > 0.0f)

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@Begin

; 1312 : 	{
; 1313 : 		ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 16
	mov	r9, rax
	mov	r8, rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+8]
	call	?CalcListClipping@ImGui@@YAXHMPEAH0@Z	; ImGui::CalcListClipping
	npad	1

; 1314 : 		if (DisplayStart > 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jle	SHORT $LN3@Begin

; 1315 : 			SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor

	mov	rax, QWORD PTR this$[rsp]
	cvtsi2ss xmm0, DWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	call	?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z ; SetCursorPosYAndSetupDummyPrevLine
	npad	1
$LN3@Begin:

; 1316 : 		StepNo = 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 2
$LN2@Begin:

; 1317 : 	}
; 1318 : }

	add	rsp, 40					; 00000028H
	ret	0
?Begin@ImGuiListClipper@@QEAAXHM@Z ENDP			; ImGuiListClipper::Begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
items_height$1 = 32
this$ = 64
?Step@ImGuiListClipper@@QEAA_NXZ PROC			; ImGuiListClipper::Step

; 1332 : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1333 : 	if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN3@Step
	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Step
$LN3@Step:

; 1334 : 	{
; 1335 : 		ItemsCount = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], -1

; 1336 : 		return false;

	xor	al, al
	jmp	$LN1@Step
$LN2@Step:

; 1337 : 	}
; 1338 : 	if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+12], 0
	jne	SHORT $LN4@Step

; 1339 : 	{
; 1340 : 		DisplayStart = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], 0

; 1341 : 		DisplayEnd = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], 1

; 1342 : 		StartPosY = ImGui::GetCursorPosY();

	call	?GetCursorPosY@ImGui@@YAMXZ		; ImGui::GetCursorPosY
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 1343 : 		StepNo = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 1

; 1344 : 		return true;

	mov	al, 1
	jmp	$LN1@Step
$LN4@Step:

; 1345 : 	}
; 1346 : 	if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+12], 1
	jne	$LN5@Step

; 1347 : 	{
; 1348 : 		if (ItemsCount == 1) { ItemsCount = -1; return false; }

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+8], 1
	jne	SHORT $LN6@Step
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], -1
	xor	al, al
	jmp	$LN1@Step
$LN6@Step:

; 1349 : 		float items_height = ImGui::GetCursorPosY() - StartPosY;

	call	?GetCursorPosY@ImGui@@YAMXZ		; ImGui::GetCursorPosY
	mov	rax, QWORD PTR this$[rsp]
	subss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR items_height$1[rsp], xmm0

; 1350 : 		IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
; 1351 : 		Begin(ItemsCount - 1, items_height);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	dec	eax
	movss	xmm2, DWORD PTR items_height$1[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?Begin@ImGuiListClipper@@QEAAXHM@Z	; ImGuiListClipper::Begin

; 1352 : 		DisplayStart++;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 1353 : 		DisplayEnd++;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 1354 : 		StepNo = 3;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 3

; 1355 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@Step
$LN5@Step:

; 1356 : 	}
; 1357 : 	if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+12], 2
	jne	SHORT $LN7@Step

; 1358 : 	{
; 1359 : 		IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
; 1360 : 		StepNo = 3;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 3

; 1361 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@Step
$LN7@Step:

; 1362 : 	}
; 1363 : 	if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+12], 3
	jne	SHORT $LN8@Step

; 1364 : 		End();

	mov	rcx, QWORD PTR this$[rsp]
	call	?End@ImGuiListClipper@@QEAAXXZ		; ImGuiListClipper::End
	npad	1
$LN8@Step:

; 1365 : 	return false;

	xor	al, al
$LN1@Step:

; 1366 : }

	add	rsp, 56					; 00000038H
	ret	0
?Step@ImGuiListClipper@@QEAA_NXZ ENDP			; ImGuiListClipper::Step
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1ImGuiListClipper@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1ImGuiListClipper@@QEAA@XZ PROC			; ImGuiListClipper::~ImGuiListClipper, COMDAT

; 1703 : 	~ImGuiListClipper() { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1ImGuiListClipper@@QEAA@XZ ENDP			; ImGuiListClipper::~ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImGuiListClipper@@QEAA@HM@Z
_TEXT	SEGMENT
this$ = 48
items_count$ = 56
items_height$ = 64
??0ImGuiListClipper@@QEAA@HM@Z PROC			; ImGuiListClipper::ImGuiListClipper, COMDAT

; 1702 : 	ImGuiListClipper(int items_count = -1, float items_height = -1.0f) { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	movss	xmm2, DWORD PTR items_height$[rsp]
	mov	edx, DWORD PTR items_count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Begin@ImGuiListClipper@@QEAAXHM@Z	; ImGuiListClipper::Begin
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiListClipper@@QEAA@HM@Z ENDP			; ImGuiListClipper::ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiStorage@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiStorage@@QEAA@XZ PROC				; ImGuiStorage::~ImGuiStorage, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ ; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiStorage@@QEAA@XZ ENDP				; ImGuiStorage::~ImGuiStorage
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA PROC		; `ImGuiStorage::~ImGuiStorage'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ ; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiStorage@@QEAA@XZ@4HA ENDP		; `ImGuiStorage::~ImGuiStorage'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImGuiStorage@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiStorage@@QEAA@XZ PROC				; ImGuiStorage::ImGuiStorage, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ ; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiStorage@@QEAA@XZ ENDP				; ImGuiStorage::ImGuiStorage
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA PROC		; `ImGuiStorage::ImGuiStorage'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ ; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiStorage@@QEAA@XZ@4HA ENDP		; `ImGuiStorage::ImGuiStorage'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
this$ = 48
?BuildSortByKey@ImGuiStorage@@QEAAXXZ PROC		; ImGuiStorage::BuildSortByKey

; 991  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 992  : 	struct StaticFunc
; 993  : 	{
; 994  : 		static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
; 995  : 		{
; 996  : 			// We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
; 997  : 			if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
; 998  : 			if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
; 999  : 			return 0;
; 1000 : 		}
; 1001 : 	};
; 1002 : 	if (Data.Size > 1)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 1
	jle	SHORT $LN2@BuildSortB

; 1003 : 		ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	r9, OFFSET FLAT:?PairCompareByID@StaticFunc@?1??BuildSortByKey@ImGuiStorage@@QEAAXXZ@SAHPEBX0@Z ; `ImGuiStorage::BuildSortByKey'::`2'::StaticFunc::PairCompareByID
	mov	r8d, 16
	mov	rdx, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	qsort
	npad	1
$LN2@BuildSortB:

; 1004 : }

	add	rsp, 40					; 00000028H
	ret	0
?BuildSortByKey@ImGuiStorage@@QEAAXXZ ENDP		; ImGuiStorage::BuildSortByKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
tv73 = 40
this$ = 64
v$ = 72
?SetAllInt@ImGuiStorage@@QEAAXH@Z PROC			; ImGuiStorage::SetAllInt

; 1105 : {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1106 : 	for (int i = 0; i < Data.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@SetAllInt
$LN2@SetAllInt:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@SetAllInt:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@SetAllInt

; 1107 : 		Data[i].val_i = v;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??A?$ImVector@UPair@ImGuiStorage@@@@QEAAAEAUPair@ImGuiStorage@@H@Z ; ImVector<ImGuiStorage::Pair>::operator[]
	mov	ecx, DWORD PTR v$[rsp]
	mov	DWORD PTR [rax+8], ecx
	jmp	SHORT $LN2@SetAllInt
$LN3@SetAllInt:

; 1108 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetAllInt@ImGuiStorage@@QEAAXH@Z ENDP			; ImGuiStorage::SetAllInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
tv84 = 40
$T1 = 48
this$ = 80
key$ = 88
default_val$ = 96
?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z PROC	; ImGuiStorage::GetVoidPtrRef

; 1058 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1059 : 	ImGuiStorage::Pair* it = LowerBound(Data, key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1060 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@GetVoidPtr
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@GetVoidPtr
$LN3@GetVoidPtr:

; 1061 : 		it = Data.insert(it, Pair(key, default_val));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	mov	r8, QWORD PTR default_val$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Pair@ImGuiStorage@@QEAA@IPEAX@Z	; ImGuiStorage::Pair::Pair
	mov	r8, rax
	mov	rdx, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	mov	QWORD PTR it$[rsp], rax
$LN2@GetVoidPtr:

; 1062 : 	return &it->val_p;

	mov	rax, QWORD PTR it$[rsp]
	add	rax, 8

; 1063 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z ENDP	; ImGuiStorage::GetVoidPtrRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
tv84 = 40
$T1 = 48
this$ = 80
key$ = 88
default_val$ = 96
?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z PROC		; ImGuiStorage::GetFloatRef

; 1050 : {

$LN5:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1051 : 	ImGuiStorage::Pair* it = LowerBound(Data, key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1052 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@GetFloatRe
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@GetFloatRe
$LN3@GetFloatRe:

; 1053 : 		it = Data.insert(it, Pair(key, default_val));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	movss	xmm2, DWORD PTR default_val$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Pair@ImGuiStorage@@QEAA@IM@Z		; ImGuiStorage::Pair::Pair
	mov	r8, rax
	mov	rdx, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	mov	QWORD PTR it$[rsp], rax
$LN2@GetFloatRe:

; 1054 : 	return &it->val_f;

	mov	rax, QWORD PTR it$[rsp]
	add	rax, 8

; 1055 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z ENDP		; ImGuiStorage::GetFloatRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv68 = 32
this$ = 64
key$ = 72
default_val$ = 80
?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z PROC		; ImGuiStorage::GetBoolRef

; 1045 : {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1046 : 	return (bool*)GetIntRef(key, default_val ? 1 : 0);

	movzx	eax, BYTE PTR default_val$[rsp]
	test	eax, eax
	je	SHORT $LN3@GetBoolRef
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@GetBoolRef
$LN3@GetBoolRef:
	mov	DWORD PTR tv68[rsp], 0
$LN4@GetBoolRef:
	mov	r8d, DWORD PTR tv68[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z	; ImGuiStorage::GetIntRef

; 1047 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z ENDP		; ImGuiStorage::GetBoolRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
tv84 = 40
$T1 = 48
this$ = 80
key$ = 88
default_val$ = 96
?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z PROC		; ImGuiStorage::GetIntRef

; 1037 : {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1038 : 	ImGuiStorage::Pair* it = LowerBound(Data, key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1039 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@GetIntRef
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@GetIntRef
$LN3@GetIntRef:

; 1040 : 		it = Data.insert(it, Pair(key, default_val));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	mov	r8d, DWORD PTR default_val$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Pair@ImGuiStorage@@QEAA@IH@Z		; ImGuiStorage::Pair::Pair
	mov	r8, rax
	mov	rdx, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	mov	QWORD PTR it$[rsp], rax
$LN2@GetIntRef:

; 1041 : 	return &it->val_i;

	mov	rax, QWORD PTR it$[rsp]
	add	rax, 8

; 1042 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z ENDP		; ImGuiStorage::GetIntRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
tv84 = 40
$T1 = 48
this$ = 80
key$ = 88
val$ = 96
?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z PROC		; ImGuiStorage::SetVoidPtr

; 1094 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1095 : 	ImGuiStorage::Pair* it = LowerBound(Data, key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1096 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@SetVoidPtr
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@SetVoidPtr
$LN3@SetVoidPtr:

; 1097 : 	{
; 1098 : 		Data.insert(it, Pair(key, val));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	mov	r8, QWORD PTR val$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Pair@ImGuiStorage@@QEAA@IPEAX@Z	; ImGuiStorage::Pair::Pair
	mov	r8, rax
	mov	rdx, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	npad	1

; 1099 : 		return;

	jmp	SHORT $LN1@SetVoidPtr
$LN2@SetVoidPtr:

; 1100 : 	}
; 1101 : 	it->val_p = val;

	mov	rax, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR val$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN1@SetVoidPtr:

; 1102 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z ENDP		; ImGuiStorage::SetVoidPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
this$ = 64
key$ = 72
?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z PROC		; ImGuiStorage::GetVoidPtr

; 1028 : {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1029 : 	ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1030 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@GetVoidPtr
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@GetVoidPtr
$LN3@GetVoidPtr:

; 1031 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@GetVoidPtr
$LN2@GetVoidPtr:

; 1032 : 	return it->val_p;

	mov	rax, QWORD PTR it$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@GetVoidPtr:

; 1033 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z ENDP		; ImGuiStorage::GetVoidPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
tv84 = 40
$T1 = 48
this$ = 80
key$ = 88
val$ = 96
?SetFloat@ImGuiStorage@@QEAAXIM@Z PROC			; ImGuiStorage::SetFloat

; 1083 : {

$LN5:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1084 : 	ImGuiStorage::Pair* it = LowerBound(Data, key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1085 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@SetFloat
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@SetFloat
$LN3@SetFloat:

; 1086 : 	{
; 1087 : 		Data.insert(it, Pair(key, val));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	movss	xmm2, DWORD PTR val$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Pair@ImGuiStorage@@QEAA@IM@Z		; ImGuiStorage::Pair::Pair
	mov	r8, rax
	mov	rdx, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	npad	1

; 1088 : 		return;

	jmp	SHORT $LN1@SetFloat
$LN2@SetFloat:

; 1089 : 	}
; 1090 : 	it->val_f = val;

	mov	rax, QWORD PTR it$[rsp]
	movss	xmm0, DWORD PTR val$[rsp]
	movss	DWORD PTR [rax+8], xmm0
$LN1@SetFloat:

; 1091 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetFloat@ImGuiStorage@@QEAAXIM@Z ENDP			; ImGuiStorage::SetFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
this$ = 64
key$ = 72
default_val$ = 80
?GetFloat@ImGuiStorage@@QEBAMIM@Z PROC			; ImGuiStorage::GetFloat

; 1020 : {

$LN5:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1021 : 	ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1022 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@GetFloat
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@GetFloat
$LN3@GetFloat:

; 1023 : 		return default_val;

	movss	xmm0, DWORD PTR default_val$[rsp]
	jmp	SHORT $LN1@GetFloat
$LN2@GetFloat:

; 1024 : 	return it->val_f;

	mov	rax, QWORD PTR it$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
$LN1@GetFloat:

; 1025 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetFloat@ImGuiStorage@@QEBAMIM@Z ENDP			; ImGuiStorage::GetFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv67 = 32
this$ = 64
key$ = 72
val$ = 80
?SetBool@ImGuiStorage@@QEAAXI_N@Z PROC			; ImGuiStorage::SetBool

; 1078 : {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1079 : 	SetInt(key, val ? 1 : 0);

	movzx	eax, BYTE PTR val$[rsp]
	test	eax, eax
	je	SHORT $LN3@SetBool
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@SetBool
$LN3@SetBool:
	mov	DWORD PTR tv67[rsp], 0
$LN4@SetBool:
	mov	r8d, DWORD PTR tv67[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt
	npad	1

; 1080 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetBool@ImGuiStorage@@QEAAXI_N@Z ENDP			; ImGuiStorage::SetBool
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv68 = 32
tv72 = 36
this$ = 64
key$ = 72
default_val$ = 80
?GetBool@ImGuiStorage@@QEBA_NI_N@Z PROC			; ImGuiStorage::GetBool

; 1015 : {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1016 : 	return GetInt(key, default_val ? 1 : 0) != 0;

	movzx	eax, BYTE PTR default_val$[rsp]
	test	eax, eax
	je	SHORT $LN3@GetBool
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@GetBool
$LN3@GetBool:
	mov	DWORD PTR tv68[rsp], 0
$LN4@GetBool:
	mov	r8d, DWORD PTR tv68[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt
	test	eax, eax
	je	SHORT $LN5@GetBool
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN6@GetBool
$LN5@GetBool:
	mov	DWORD PTR tv72[rsp], 0
$LN6@GetBool:
	movzx	eax, BYTE PTR tv72[rsp]

; 1017 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetBool@ImGuiStorage@@QEBA_NI_N@Z ENDP			; ImGuiStorage::GetBool
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
tv84 = 40
$T1 = 48
this$ = 80
key$ = 88
val$ = 96
?SetInt@ImGuiStorage@@QEAAXIH@Z PROC			; ImGuiStorage::SetInt

; 1067 : {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1068 : 	ImGuiStorage::Pair* it = LowerBound(Data, key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1069 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@SetInt
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@SetInt
$LN3@SetInt:

; 1070 : 	{
; 1071 : 		Data.insert(it, Pair(key, val));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	mov	r8d, DWORD PTR val$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Pair@ImGuiStorage@@QEAA@IH@Z		; ImGuiStorage::Pair::Pair
	mov	r8, rax
	mov	rdx, QWORD PTR it$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	npad	1

; 1072 : 		return;

	jmp	SHORT $LN1@SetInt
$LN2@SetInt:

; 1073 : 	}
; 1074 : 	it->val_i = val;

	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR val$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN1@SetInt:

; 1075 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetInt@ImGuiStorage@@QEAAXIH@Z ENDP			; ImGuiStorage::SetInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
it$ = 32
this$ = 64
key$ = 72
default_val$ = 80
?GetInt@ImGuiStorage@@QEBAHIH@Z PROC			; ImGuiStorage::GetInt

; 1007 : {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1008 : 	ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, rax
	call	?LowerBound@@YAPEAUPair@ImGuiStorage@@AEAU?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
	mov	QWORD PTR it$[rsp], rax

; 1009 : 	if (it == Data.end() || it->key != key)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
	cmp	QWORD PTR it$[rsp], rax
	je	SHORT $LN3@GetInt
	mov	rax, QWORD PTR it$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN2@GetInt
$LN3@GetInt:

; 1010 : 		return default_val;

	mov	eax, DWORD PTR default_val$[rsp]
	jmp	SHORT $LN1@GetInt
$LN2@GetInt:

; 1011 : 	return it->val_i;

	mov	rax, QWORD PTR it$[rsp]
	mov	eax, DWORD PTR [rax+8]
$LN1@GetInt:

; 1012 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetInt@ImGuiStorage@@QEBAHIH@Z ENDP			; ImGuiStorage::GetInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?Clear@ImGuiStorage@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImGuiStorage@@QEAAXXZ PROC			; ImGuiStorage::Clear, COMDAT

; 1654 : 	void                Clear() { Data.clear(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ ; ImVector<ImGuiStorage::Pair>::clear
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?Clear@ImGuiStorage@@QEAAXXZ ENDP			; ImGuiStorage::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z
_TEXT	SEGMENT
off$ = 32
tv93 = 40
this$ = 64
it$ = 72
v$ = 80
?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z PROC ; ImVector<ImGuiStorage::Pair>::insert, COMDAT

; 1254 : 	inline T* insert(const T* it, const T& v) { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR it$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 4
	mov	QWORD PTR off$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@insert
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z ; ImVector<ImGuiStorage::Pair>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z ; ImVector<ImGuiStorage::Pair>::reserve
	npad	1
$LN2@insert:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	cmp	QWORD PTR off$[rsp], rax
	jge	SHORT $LN3@insert
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	sub	rax, QWORD PTR off$[rsp]
	imul	rax, rax, 16
	imul	rcx, QWORD PTR off$[rsp], 16
	mov	rdx, QWORD PTR this$[rsp]
	add	rcx, QWORD PTR [rdx+8]
	imul	rdx, QWORD PTR off$[rsp], 16
	mov	r8, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [r8+8]
	lea	rdx, QWORD PTR [r8+rdx+16]
	mov	QWORD PTR tv93[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv93[rsp]
	mov	rcx, rax
	call	memmove
	npad	1
$LN3@insert:
	imul	rax, QWORD PTR off$[rsp], 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 16
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	imul	rax, QWORD PTR off$[rsp], 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	add	rsp, 56					; 00000038H
	ret	0
?insert@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@PEBU23@AEBU23@@Z ENDP ; ImVector<ImGuiStorage::Pair>::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z PROC	; ImVector<ImGuiStorage::Pair>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 16
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UPair@ImGuiStorage@@@@QEAAXH@Z ENDP	; ImVector<ImGuiStorage::Pair>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z PROC ; ImVector<ImGuiStorage::Pair>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UPair@ImGuiStorage@@@@QEBAHH@Z ENDP ; ImVector<ImGuiStorage::Pair>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ
_TEXT	SEGMENT
this$ = 8
?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ PROC ; ImVector<ImGuiStorage::Pair>::end, COMDAT

; 1235 : 	inline const T* end() const { return Data + Size; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?end@?$ImVector@UPair@ImGuiStorage@@@@QEBAPEBUPair@ImGuiStorage@@XZ ENDP ; ImVector<ImGuiStorage::Pair>::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ
_TEXT	SEGMENT
this$ = 8
?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ PROC ; ImVector<ImGuiStorage::Pair>::end, COMDAT

; 1234 : 	inline T* end() { return Data + Size; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?end@?$ImVector@UPair@ImGuiStorage@@@@QEAAPEAUPair@ImGuiStorage@@XZ ENDP ; ImVector<ImGuiStorage::Pair>::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ PROC	; ImVector<ImGuiStorage::Pair>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UPair@ImGuiStorage@@@@QEAAXXZ ENDP	; ImVector<ImGuiStorage::Pair>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UPair@ImGuiStorage@@@@QEAAAEAUPair@ImGuiStorage@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UPair@ImGuiStorage@@@@QEAAAEAUPair@ImGuiStorage@@H@Z PROC ; ImVector<ImGuiStorage::Pair>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UPair@ImGuiStorage@@@@QEAAAEAUPair@ImGuiStorage@@H@Z ENDP ; ImVector<ImGuiStorage::Pair>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ PROC	; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ ENDP	; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ PROC	; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UPair@ImGuiStorage@@@@QEAA@XZ ENDP	; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0Pair@ImGuiStorage@@QEAA@IPEAX@Z
_TEXT	SEGMENT
this$ = 8
_key$ = 16
_val_p$ = 24
??0Pair@ImGuiStorage@@QEAA@IPEAX@Z PROC			; ImGuiStorage::Pair::Pair, COMDAT

; 1647 : 		Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _key$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _val_p$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Pair@ImGuiStorage@@QEAA@IPEAX@Z ENDP			; ImGuiStorage::Pair::Pair
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0Pair@ImGuiStorage@@QEAA@IM@Z
_TEXT	SEGMENT
this$ = 8
_key$ = 16
_val_f$ = 24
??0Pair@ImGuiStorage@@QEAA@IM@Z PROC			; ImGuiStorage::Pair::Pair, COMDAT

; 1646 : 		Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }

	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _key$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _val_f$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Pair@ImGuiStorage@@QEAA@IM@Z ENDP			; ImGuiStorage::Pair::Pair
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0Pair@ImGuiStorage@@QEAA@IH@Z
_TEXT	SEGMENT
this$ = 8
_key$ = 16
_val_i$ = 24
??0Pair@ImGuiStorage@@QEAA@IH@Z PROC			; ImGuiStorage::Pair::Pair, COMDAT

; 1645 : 		Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _key$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _val_i$[rsp]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Pair@ImGuiStorage@@QEAA@IH@Z ENDP			; ImGuiStorage::Pair::Pair
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiTextBuffer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiTextBuffer@@QEAA@XZ PROC			; ImGuiTextBuffer::~ImGuiTextBuffer, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiTextBuffer@@QEAA@XZ ENDP			; ImGuiTextBuffer::~ImGuiTextBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA PROC		; `ImGuiTextBuffer::~ImGuiTextBuffer'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA ENDP		; `ImGuiTextBuffer::~ImGuiTextBuffer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
len$ = 32
needed_sz$ = 36
write_off$ = 40
tv75 = 44
new_capacity$1 = 48
tv87 = 52
args_copy$ = 56
tv90 = 64
tv95 = 72
tv140 = 80
tv132 = 88
this$ = 112
fmt$ = 120
args$ = 128
?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z PROC		; ImGuiTextBuffer::appendfv

; 1258 : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1259 : 	va_list args_copy;
; 1260 : 	va_copy(args_copy, args);

	mov	rax, QWORD PTR args$[rsp]
	mov	QWORD PTR args_copy$[rsp], rax

; 1261 : 
; 1262 : 	int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	xor	edx, edx
	xor	ecx, ecx
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV
	mov	DWORD PTR len$[rsp], eax

; 1263 : 	if (len <= 0)

	cmp	DWORD PTR len$[rsp], 0
	jg	SHORT $LN2@appendfv

; 1264 : 	{
; 1265 : 		va_end(args_copy);

	mov	QWORD PTR args_copy$[rsp], 0

; 1266 : 		return;

	jmp	$LN1@appendfv
$LN2@appendfv:

; 1267 : 	}
; 1268 : 
; 1269 : 	// Add zero-terminator the first time
; 1270 : 	const int write_off = (Buf.Size != 0) ? Buf.Size : 1;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN5@appendfv
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv75[rsp], eax
	jmp	SHORT $LN6@appendfv
$LN5@appendfv:
	mov	DWORD PTR tv75[rsp], 1
$LN6@appendfv:
	mov	eax, DWORD PTR tv75[rsp]
	mov	DWORD PTR write_off$[rsp], eax

; 1271 : 	const int needed_sz = write_off + len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR write_off$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR needed_sz$[rsp], eax

; 1272 : 	if (write_off + len >= Buf.Capacity)

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR write_off$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jl	SHORT $LN3@appendfv

; 1273 : 	{
; 1274 : 		int new_capacity = Buf.Capacity * 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	shl	eax, 1
	mov	DWORD PTR new_capacity$1[rsp], eax

; 1275 : 		Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv90[rsp], rax
	mov	eax, DWORD PTR new_capacity$1[rsp]
	cmp	DWORD PTR needed_sz$[rsp], eax
	jle	SHORT $LN7@appendfv
	mov	eax, DWORD PTR needed_sz$[rsp]
	mov	DWORD PTR tv87[rsp], eax
	jmp	SHORT $LN8@appendfv
$LN7@appendfv:
	mov	eax, DWORD PTR new_capacity$1[rsp]
	mov	DWORD PTR tv87[rsp], eax
$LN8@appendfv:
	mov	edx, DWORD PTR tv87[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
	npad	1
$LN3@appendfv:

; 1276 : 	}
; 1277 : 
; 1278 : 	Buf.resize(needed_sz);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv95[rsp], rax
	mov	edx, DWORD PTR needed_sz$[rsp]
	mov	rcx, QWORD PTR tv95[rsp]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 1279 : 	ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv140[rsp], rax
	movsxd	rax, DWORD PTR len$[rsp]
	inc	rax
	mov	QWORD PTR tv132[rsp], rax
	mov	ecx, DWORD PTR write_off$[rsp]
	dec	ecx
	mov	edx, ecx
	mov	rcx, QWORD PTR tv140[rsp]
	call	??A?$ImVector@D@@QEAAAEADH@Z		; ImVector<char>::operator[]
	mov	r9, QWORD PTR args_copy$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV

; 1280 : 	va_end(args_copy);

	mov	QWORD PTR args_copy$[rsp], 0
$LN1@appendfv:

; 1281 : }

	add	rsp, 104				; 00000068H
	ret	0
?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z ENDP		; ImGuiTextBuffer::appendfv
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
args$ = 32
this$ = 64
fmt$ = 72
?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ PROC		; ImGuiTextBuffer::appendf

; 1249 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1250 : 	va_list args;
; 1251 : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 1252 : 	appendfv(fmt, args);

	mov	r8, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z ; ImGuiTextBuffer::appendfv

; 1253 : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 1254 : }

	add	rsp, 56					; 00000038H
	ret	0
?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ENDP		; ImGuiTextBuffer::appendf
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
write_off$ = 32
len$ = 36
needed_sz$ = 40
tv70 = 44
tv76 = 48
new_capacity$1 = 52
tv88 = 56
tv91 = 64
tv128 = 72
tv139 = 80
tv130 = 88
tv147 = 96
this$ = 128
str$ = 136
str_end$ = 144
?append@ImGuiTextBuffer@@QEAAXPEBD0@Z PROC		; ImGuiTextBuffer::append

; 1231 : {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1232 : 	int len = str_end ? (int)(str_end - str) : (int)strlen(str);

	cmp	QWORD PTR str_end$[rsp], 0
	je	SHORT $LN4@append
	mov	rax, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR str_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN5@append
$LN4@append:
	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	DWORD PTR tv70[rsp], eax
$LN5@append:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR len$[rsp], eax

; 1233 : 
; 1234 : 	// Add zero-terminator the first time
; 1235 : 	const int write_off = (Buf.Size != 0) ? Buf.Size : 1;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN6@append
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv76[rsp], eax
	jmp	SHORT $LN7@append
$LN6@append:
	mov	DWORD PTR tv76[rsp], 1
$LN7@append:
	mov	eax, DWORD PTR tv76[rsp]
	mov	DWORD PTR write_off$[rsp], eax

; 1236 : 	const int needed_sz = write_off + len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR write_off$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR needed_sz$[rsp], eax

; 1237 : 	if (write_off + len >= Buf.Capacity)

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR write_off$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jl	SHORT $LN2@append

; 1238 : 	{
; 1239 : 		int new_capacity = Buf.Capacity * 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	shl	eax, 1
	mov	DWORD PTR new_capacity$1[rsp], eax

; 1240 : 		Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv91[rsp], rax
	mov	eax, DWORD PTR new_capacity$1[rsp]
	cmp	DWORD PTR needed_sz$[rsp], eax
	jle	SHORT $LN8@append
	mov	eax, DWORD PTR needed_sz$[rsp]
	mov	DWORD PTR tv88[rsp], eax
	jmp	SHORT $LN9@append
$LN8@append:
	mov	eax, DWORD PTR new_capacity$1[rsp]
	mov	DWORD PTR tv88[rsp], eax
$LN9@append:
	mov	edx, DWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
	npad	1
$LN2@append:

; 1241 : 	}
; 1242 : 
; 1243 : 	Buf.resize(needed_sz);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	edx, DWORD PTR needed_sz$[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 1244 : 	memcpy(&Buf[write_off - 1], str, (size_t)len);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv139[rsp], rax
	movsxd	rax, DWORD PTR len$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	mov	ecx, DWORD PTR write_off$[rsp]
	dec	ecx
	mov	edx, ecx
	mov	rcx, QWORD PTR tv139[rsp]
	call	??A?$ImVector@D@@QEAAAEADH@Z		; ImVector<char>::operator[]
	mov	rcx, QWORD PTR tv130[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, rax
	call	memcpy

; 1245 : 	Buf[write_off - 1 + len] = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv147[rsp], rax
	mov	eax, DWORD PTR write_off$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	edx, eax
	mov	rcx, QWORD PTR tv147[rsp]
	call	??A?$ImVector@D@@QEAAAEADH@Z		; ImVector<char>::operator[]
	mov	BYTE PTR [rax], 0

; 1246 : }

	add	rsp, 120				; 00000078H
	ret	0
?append@ImGuiTextBuffer@@QEAAXPEBD0@Z ENDP		; ImGuiTextBuffer::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@D@@QEAAXH@Z PROC			; ImVector<char>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@D@@QEAAXH@Z ENDP			; ImVector<char>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@D@@QEAAXH@Z PROC			; ImVector<char>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@D@@QEBAHH@Z	; ImVector<char>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@D@@QEAAXH@Z ENDP			; ImVector<char>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@D@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@D@@QEBAHH@Z PROC		; ImVector<char>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@D@@QEBAHH@Z ENDP		; ImVector<char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@D@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@D@@QEAAXXZ PROC			; ImVector<char>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@D@@QEAAXXZ ENDP			; ImVector<char>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@D@@QEAAAEADH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@D@@QEAAAEADH@Z PROC			; ImVector<char>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	ret	0
??A?$ImVector@D@@QEAAAEADH@Z ENDP			; ImVector<char>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@D@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@D@@QEAA@XZ PROC				; ImVector<char>::~ImVector<char>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@D@@QEAA@XZ ENDP				; ImVector<char>::~ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@D@@QEAA@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@D@@QEAA@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ; ImVector<ImGuiTextFilter::TextRange>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 16
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 16
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ; ImVector<ImGuiTextFilter::TextRange>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAAEBUTextRange@ImGuiTextFilter@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAAEBUTextRange@ImGuiTextFilter@@H@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::operator[], COMDAT

; 1229 : 	inline const T& operator[](int i) const { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAAEBUTextRange@ImGuiTextFilter@@H@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAAEAUTextRange@ImGuiTextFilter@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAAEAUTextRange@ImGuiTextFilter@@H@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAAEAUTextRange@ImGuiTextFilter@@H@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ PROC ; ImVector<ImGuiTextFilter::TextRange>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ ENDP ; ImVector<ImGuiTextFilter::TextRange>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ PROC ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ ENDP ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ PROC ; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ ENDP ; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
we$ = 32
wb$ = 40
$T1 = 48
$T2 = 64
this$ = 96
separator$ = 104
out$ = 112
?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z PROC ; ImGuiTextFilter::TextRange::split

; 1142 : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1143 : 	out->resize(0);

	xor	edx, edx
	mov	rcx, QWORD PTR out$[rsp]
	call	?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ; ImVector<ImGuiTextFilter::TextRange>::resize

; 1144 : 	const char* wb = b;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR wb$[rsp], rax

; 1145 : 	const char* we = wb;

	mov	rax, QWORD PTR wb$[rsp]
	mov	QWORD PTR we$[rsp], rax
$LN2@split:

; 1146 : 	while (we < e)

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR we$[rsp], rax
	jae	SHORT $LN3@split

; 1147 : 	{
; 1148 : 		if (*we == separator)

	mov	rax, QWORD PTR we$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR separator$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN4@split

; 1149 : 		{
; 1150 : 			out->push_back(TextRange(wb, we));

	mov	r8, QWORD PTR we$[rsp]
	mov	rdx, QWORD PTR wb$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z ; ImGuiTextFilter::TextRange::TextRange
	mov	rdx, rax
	mov	rcx, QWORD PTR out$[rsp]
	call	?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z ; ImVector<ImGuiTextFilter::TextRange>::push_back
	npad	1

; 1151 : 			wb = we + 1;

	mov	rax, QWORD PTR we$[rsp]
	inc	rax
	mov	QWORD PTR wb$[rsp], rax
$LN4@split:

; 1152 : 		}
; 1153 : 		we++;

	mov	rax, QWORD PTR we$[rsp]
	inc	rax
	mov	QWORD PTR we$[rsp], rax

; 1154 : 	}

	jmp	SHORT $LN2@split
$LN3@split:

; 1155 : 	if (wb != we)

	mov	rax, QWORD PTR we$[rsp]
	cmp	QWORD PTR wb$[rsp], rax
	je	SHORT $LN5@split

; 1156 : 		out->push_back(TextRange(wb, we));

	mov	r8, QWORD PTR we$[rsp]
	mov	rdx, QWORD PTR wb$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z ; ImGuiTextFilter::TextRange::TextRange
	mov	rdx, rax
	mov	rcx, QWORD PTR out$[rsp]
	call	?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXAEBUTextRange@ImGuiTextFilter@@@Z ; ImVector<ImGuiTextFilter::TextRange>::push_back
	npad	1
$LN5@split:

; 1157 : }

	add	rsp, 88					; 00000058H
	ret	0
?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z ENDP ; ImGuiTextFilter::TextRange::split
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 0
this$ = 32
?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ PROC		; ImGuiTextFilter::TextRange::empty, COMDAT

; 1602 : 		bool            empty() const { return b == e; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv67[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv67[rsp]
	add	rsp, 24
	ret	0
?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ ENDP		; ImGuiTextFilter::TextRange::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?end@TextRange@ImGuiTextFilter@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?end@TextRange@ImGuiTextFilter@@QEBAPEBDXZ PROC		; ImGuiTextFilter::TextRange::end, COMDAT

; 1601 : 		const char* end() const { return e; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?end@TextRange@ImGuiTextFilter@@QEBAPEBDXZ ENDP		; ImGuiTextFilter::TextRange::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?begin@TextRange@ImGuiTextFilter@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?begin@TextRange@ImGuiTextFilter@@QEBAPEBDXZ PROC	; ImGuiTextFilter::TextRange::begin, COMDAT

; 1600 : 		const char* begin() const { return b; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	ret	0
?begin@TextRange@ImGuiTextFilter@@QEBAPEBDXZ ENDP	; ImGuiTextFilter::TextRange::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z
_TEXT	SEGMENT
this$ = 8
_b$ = 16
_e$ = 24
??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z PROC		; ImGuiTextFilter::TextRange::TextRange, COMDAT

; 1599 : 		TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _b$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _e$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z ENDP		; ImGuiTextFilter::TextRange::TextRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
f$2 = 40
tv68 = 48
tv92 = 56
tv162 = 64
input_range$ = 72
this$ = 112
?Build@ImGuiTextFilter@@QEAAXXZ PROC			; ImGuiTextFilter::Build

; 1160 : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1161 : 	Filters.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv68[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv68[rsp]
	call	?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAXH@Z ; ImVector<ImGuiTextFilter::TextRange>::resize

; 1162 : 	TextRange input_range(InputBuf, InputBuf + strlen(InputBuf));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	strlen
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR input_range$[rsp]
	call	??0TextRange@ImGuiTextFilter@@QEAA@PEBD0@Z ; ImGuiTextFilter::TextRange::TextRange

; 1163 : 	input_range.split(',', &Filters);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	r8, rax
	mov	dl, 44					; 0000002cH
	lea	rcx, QWORD PTR input_range$[rsp]
	call	?split@TextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z ; ImGuiTextFilter::TextRange::split

; 1164 : 
; 1165 : 	CountGrep = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+272], 0

; 1166 : 	for (int i = 0; i != Filters.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@Build
$LN2@Build:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@Build:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+256]
	cmp	DWORD PTR i$1[rsp], eax
	je	$LN3@Build

; 1167 : 	{
; 1168 : 		TextRange& f = Filters[i];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv92[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAAEAUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
	mov	QWORD PTR f$2[rsp], rax
$LN5@Build:

; 1169 : 		while (f.b < f.e && ImCharIsBlankA(f.b[0]))

	mov	rax, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN6@Build
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR [rcx]
	movzx	ecx, BYTE PTR [rcx+rax]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@Build

; 1170 : 			f.b++;

	mov	rax, QWORD PTR f$2[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR f$2[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN5@Build
$LN6@Build:
$LN7@Build:

; 1171 : 		while (f.e > f.b && ImCharIsBlankA(f.e[-1]))

	mov	rax, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rcx
	jbe	SHORT $LN8@Build
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	ecx, BYTE PTR [rcx+rax]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Build

; 1172 : 			f.e--;

	mov	rax, QWORD PTR f$2[rsp]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR f$2[rsp]
	mov	QWORD PTR [rcx+8], rax
	jmp	SHORT $LN7@Build
$LN8@Build:

; 1173 : 		if (f.empty())

	mov	rcx, QWORD PTR f$2[rsp]
	call	?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ ; ImGuiTextFilter::TextRange::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Build

; 1174 : 			continue;

	jmp	$LN2@Build
$LN9@Build:

; 1175 : 		if (Filters[i].b[0] != '-')

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv162[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv162[rsp]
	call	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAAAEAUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN10@Build

; 1176 : 			CountGrep += 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+272]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+272], eax
$LN10@Build:

; 1177 : 	}

	jmp	$LN2@Build
$LN3@Build:

; 1178 : }

	add	rsp, 104				; 00000068H
	ret	0
?Build@ImGuiTextFilter@@QEAAXXZ ENDP			; ImGuiTextFilter::Build
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
f$2 = 40
tv79 = 48
tv134 = 56
tv132 = 64
tv148 = 72
tv146 = 80
this$ = 112
text$ = 120
text_end$ = 128
?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z PROC		; ImGuiTextFilter::PassFilter

; 1181 : {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1182 : 	if (Filters.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	rcx, rax
	call	?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBA_NXZ ; ImVector<ImGuiTextFilter::TextRange>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@PassFilter

; 1183 : 		return true;

	mov	al, 1
	jmp	$LN1@PassFilter
$LN5@PassFilter:

; 1184 : 
; 1185 : 	if (text == NULL)

	cmp	QWORD PTR text$[rsp], 0
	jne	SHORT $LN6@PassFilter

; 1186 : 		text = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR text$[rsp], rax
$LN6@PassFilter:

; 1187 : 
; 1188 : 	for (int i = 0; i != Filters.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@PassFilter
$LN2@PassFilter:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@PassFilter:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+256]
	cmp	DWORD PTR i$1[rsp], eax
	je	$LN3@PassFilter

; 1189 : 	{
; 1190 : 		const TextRange& f = Filters[i];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv79[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QEBAAEBUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
	mov	QWORD PTR f$2[rsp], rax

; 1191 : 		if (f.empty())

	mov	rcx, QWORD PTR f$2[rsp]
	call	?empty@TextRange@ImGuiTextFilter@@QEBA_NXZ ; ImGuiTextFilter::TextRange::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@PassFilter

; 1192 : 			continue;

	jmp	SHORT $LN2@PassFilter
$LN7@PassFilter:

; 1193 : 		if (f.b[0] == '-')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$2[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN8@PassFilter

; 1194 : 		{
; 1195 : 			// Subtract
; 1196 : 			if (ImStristr(text, text_end, f.begin() + 1, f.end()) != NULL)

	mov	rcx, QWORD PTR f$2[rsp]
	call	?end@TextRange@ImGuiTextFilter@@QEBAPEBDXZ ; ImGuiTextFilter::TextRange::end
	mov	QWORD PTR tv134[rsp], rax
	mov	rcx, QWORD PTR f$2[rsp]
	call	?begin@TextRange@ImGuiTextFilter@@QEBAPEBDXZ ; ImGuiTextFilter::TextRange::begin
	inc	rax
	mov	QWORD PTR tv132[rsp], rax
	mov	r9, QWORD PTR tv134[rsp]
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?ImStristr@@YAPEBDPEBD000@Z		; ImStristr
	test	rax, rax
	je	SHORT $LN10@PassFilter

; 1197 : 				return false;

	xor	al, al
	jmp	SHORT $LN1@PassFilter
$LN10@PassFilter:

; 1198 : 		}

	jmp	SHORT $LN9@PassFilter
$LN8@PassFilter:

; 1199 : 		else
; 1200 : 		{
; 1201 : 			// Grep
; 1202 : 			if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)

	mov	rcx, QWORD PTR f$2[rsp]
	call	?end@TextRange@ImGuiTextFilter@@QEBAPEBDXZ ; ImGuiTextFilter::TextRange::end
	mov	QWORD PTR tv148[rsp], rax
	mov	rcx, QWORD PTR f$2[rsp]
	call	?begin@TextRange@ImGuiTextFilter@@QEBAPEBDXZ ; ImGuiTextFilter::TextRange::begin
	mov	QWORD PTR tv146[rsp], rax
	mov	r9, QWORD PTR tv148[rsp]
	mov	r8, QWORD PTR tv146[rsp]
	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?ImStristr@@YAPEBDPEBD000@Z		; ImStristr
	test	rax, rax
	je	SHORT $LN11@PassFilter

; 1203 : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@PassFilter
$LN11@PassFilter:
$LN9@PassFilter:

; 1204 : 		}
; 1205 : 	}

	jmp	$LN2@PassFilter
$LN3@PassFilter:

; 1206 : 
; 1207 : 	// Implicit * grep
; 1208 : 	if (CountGrep == 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+272], 0
	jne	SHORT $LN12@PassFilter

; 1209 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@PassFilter
$LN12@PassFilter:

; 1210 : 
; 1211 : 	return false;

	xor	al, al
$LN1@PassFilter:

; 1212 : }

	add	rsp, 104				; 00000068H
	ret	0
?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z ENDP		; ImGuiTextFilter::PassFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
value_changed$ = 48
this$ = 80
label$ = 88
width$ = 96
?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z PROC		; ImGuiTextFilter::Draw

; 1130 : {

$LN8:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1131 : 	if (width != 0.0f)

	movss	xmm0, DWORD PTR width$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN7@Draw
	je	SHORT $LN2@Draw
$LN7@Draw:

; 1132 : 		ImGui::PushItemWidth(width);

	movss	xmm0, DWORD PTR width$[rsp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1
$LN2@Draw:

; 1133 : 	bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 256				; 00000100H
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
	mov	BYTE PTR value_changed$[rsp], al

; 1134 : 	if (width != 0.0f)

	movss	xmm0, DWORD PTR width$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN6@Draw
	je	SHORT $LN3@Draw
$LN6@Draw:

; 1135 : 		ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	npad	1
$LN3@Draw:

; 1136 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN4@Draw

; 1137 : 		Build();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Build@ImGuiTextFilter@@QEAAXXZ		; ImGuiTextFilter::Build
	npad	1
$LN4@Draw:

; 1138 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 1139 : }

	add	rsp, 72					; 00000048H
	ret	0
?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z ENDP		; ImGuiTextFilter::Draw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
this$ = 48
default_filter$ = 56
??0ImGuiTextFilter@@QEAA@PEBD@Z PROC			; ImGuiTextFilter::ImGuiTextFilter

; 1116 : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	rcx, rax
	call	??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ ; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>
	npad	1

; 1117 : 	if (default_filter)

	cmp	QWORD PTR default_filter$[rsp], 0
	je	SHORT $LN2@ImGuiTextF

; 1118 : 	{
; 1119 : 		ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));

	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, 256				; 00000100H
	mov	rdx, QWORD PTR default_filter$[rsp]
	mov	rcx, rax
	call	?ImStrncpy@@YAXPEADPEBD_K@Z		; ImStrncpy

; 1120 : 		Build();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Build@ImGuiTextFilter@@QEAAXXZ		; ImGuiTextFilter::Build
	npad	1

; 1121 : 	}

	jmp	SHORT $LN3@ImGuiTextF
$LN2@ImGuiTextF:

; 1122 : 	else
; 1123 : 	{
; 1124 : 		InputBuf[0] = 0;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1125 : 		CountGrep = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+272], 0
$LN3@ImGuiTextF:

; 1126 : 	}
; 1127 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiTextFilter@@QEAA@PEBD@Z ENDP			; ImGuiTextFilter::ImGuiTextFilter
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
default_filter$ = 56
?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA PROC	; `ImGuiTextFilter::ImGuiTextFilter'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 256				; 00000100H
	call	??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QEAA@XZ ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiTextFilter@@QEAA@PEBD@Z@4HA ENDP	; `ImGuiTextFilter::ImGuiTextFilter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??3@YAXPEAXUImNewDummy@@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
__formal$ = 24
??3@YAXPEAXUImNewDummy@@0@Z PROC			; operator delete, COMDAT

; 1563 : inline void  operator delete(void*, ImNewDummy, void*) {} // This is only required so we can use the symetrical new()

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	ret	0
??3@YAXPEAXUImNewDummy@@0@Z ENDP			; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??2@YAPEAX_KUImNewDummy@@PEAX@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
ptr$ = 24
??2@YAPEAX_KUImNewDummy@@PEAX@Z PROC			; operator new, COMDAT

; 1562 : inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR ptr$[rsp]
	ret	0
??2@YAPEAX_KUImNewDummy@@PEAX@Z ENDP			; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
name$ = 48
p_open$ = 56
size_first_use$ = 64
bg_alpha_override$ = 72
flags$ = 80
?Begin@ImGui@@YA_NPEBDPEA_NAEBUImVec2@@MH@Z PROC	; ImGui::Begin

; 4603 : {

$LN7:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4604 : 	// Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
; 4605 : 	if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)

	mov	rax, QWORD PTR size_first_use$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@Begin
	jne	SHORT $LN3@Begin
	mov	rax, QWORD PTR size_first_use$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN6@Begin
	je	SHORT $LN2@Begin
$LN6@Begin:
$LN3@Begin:

; 4606 : 		SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);

	mov	edx, 4
	mov	rcx, QWORD PTR size_first_use$[rsp]
	call	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ; ImGui::SetNextWindowSize
	npad	1
$LN2@Begin:

; 4607 : 
; 4608 : 	// Old API feature: override the window background alpha with a parameter.
; 4609 : 	if (bg_alpha_override >= 0.0f)

	movss	xmm0, DWORD PTR bg_alpha_override$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN4@Begin

; 4610 : 		SetNextWindowBgAlpha(bg_alpha_override);

	movss	xmm0, DWORD PTR bg_alpha_override$[rsp]
	call	?SetNextWindowBgAlpha@ImGui@@YAXM@Z	; ImGui::SetNextWindowBgAlpha
	npad	1
$LN4@Begin:

; 4611 : 
; 4612 : 	return Begin(name, p_open, flags);

	mov	r8d, DWORD PTR flags$[rsp]
	mov	rdx, QWORD PTR p_open$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin

; 4613 : }

	add	rsp, 40					; 00000028H
	ret	0
?Begin@ImGui@@YA_NPEBDPEA_NAEBUImVec2@@MH@Z ENDP	; ImGui::Begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?Clear@ImGuiPayload@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImGuiPayload@@QEAAXXZ PROC			; ImGuiPayload::Clear, COMDAT

; 1507 : 	void Clear() { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	r8d, 33					; 00000021H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+58], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+57], 0
	add	rsp, 40					; 00000028H
	ret	0
?Clear@ImGuiPayload@@QEAAXXZ ENDP			; ImGuiPayload::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImGuiPayload@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiPayload@@QEAA@XZ PROC				; ImGuiPayload::ImGuiPayload, COMDAT

; 1506 : 	ImGuiPayload() { Clear(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImGuiPayload@@QEAAXXZ		; ImGuiPayload::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiPayload@@QEAA@XZ ENDP				; ImGuiPayload::ImGuiPayload
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z
_TEXT	SEGMENT
tv71 = 32
this$ = 64
type$ = 72
?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z PROC		; ImGuiPayload::IsDataType, COMDAT

; 1505 : 	bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], -1
	je	SHORT $LN3@IsDataType
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rdx, rax
	mov	rcx, QWORD PTR type$[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN3@IsDataType
	mov	DWORD PTR tv71[rsp], 1
	jmp	SHORT $LN4@IsDataType
$LN3@IsDataType:
	mov	DWORD PTR tv71[rsp], 0
$LN4@IsDataType:
	movzx	eax, BYTE PTR tv71[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z ENDP		; ImGuiPayload::IsDataType
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImGuiSizeCallbackData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiSizeCallbackData@@QEAA@XZ PROC			; ImGuiSizeCallbackData::ImGuiSizeCallbackData, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiSizeCallbackData@@QEAA@XZ ENDP			; ImGuiSizeCallbackData::ImGuiSizeCallbackData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiIO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiIO@@QEAA@XZ PROC				; ImGuiIO::~ImGuiIO, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 5440				; 00001540H
	mov	rcx, rax
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiIO@@QEAA@XZ ENDP				; ImGuiIO::~ImGuiIO
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA PROC			; `ImGuiIO::~ImGuiIO'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 5440				; 00001540H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiIO@@QEAA@XZ@4HA ENDP			; `ImGuiIO::~ImGuiIO'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
i$3 = 40
i$4 = 44
$T5 = 48
$T6 = 56
$T7 = 64
$T8 = 72
this$ = 96
??0ImGuiIO@@QEAA@XZ PROC				; ImGuiIO::ImGuiIO

; 224  : {

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 4
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 172				; 000000acH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 300				; 0000012cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 952				; 000003b8H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1012				; 000003f4H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 1020				; 000003fcH
	lea	r9, OFFSET FLAT:??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
	mov	r8d, 5
	mov	edx, 8
	mov	rcx, rax
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 3164				; 00000c5cH
	lea	r9, OFFSET FLAT:??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
	mov	r8d, 5
	mov	edx, 8
	mov	rcx, rax
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 5440				; 00001540H
	mov	rcx, rax
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1

; 225  : 	// Most fields are initialized with zero
; 226  : 	memset(this, 0, sizeof(*this));

	mov	r8d, 5456				; 00001550H
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	memset

; 227  : 
; 228  : 	// Settings
; 229  : 	ConfigFlags = ImGuiConfigFlags_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 0

; 230  : 	BackendFlags = ImGuiBackendFlags_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 231  : 	DisplaySize = ImVec2(-1.0f, -1.0f);

	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+4], rax

; 232  : 	DeltaTime = 1.0f / 60.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3c888889
	movss	DWORD PTR [rax+32], xmm0

; 233  : 	IniSavingRate = 5.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [rax+40], xmm0

; 234  : 	IniFilename = nullptr;// "imgui.ini";

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 235  : 	LogFilename = nullptr;//"imgui_log.txt";

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 236  : 	MouseDoubleClickTime = 0.30f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [rax+128], xmm0

; 237  : 	MouseDoubleClickMaxDist = 6.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR [rax+36], xmm0

; 238  : 	for (int i = 0; i < ImGuiKey_COUNT; i++)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN4@ImGuiIO
$LN2@ImGuiIO:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN4@ImGuiIO:
	cmp	DWORD PTR i$3[rsp], 21
	jge	SHORT $LN3@ImGuiIO

; 239  : 		KeyMap[i] = -1;

	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+rax*4+44], -1
	jmp	SHORT $LN2@ImGuiIO
$LN3@ImGuiIO:

; 240  : 	KeyRepeatDelay = 0.250f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [rax+136], xmm0

; 241  : 	KeyRepeatRate = 0.050f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [rax+152], xmm0

; 242  : 	UserData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+144], 0

; 243  : 
; 244  : 	Fonts = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+160], 0

; 245  : 	FontGlobalScale = 1.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+156], xmm0

; 246  : 	FontDefault = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+184], 0

; 247  : 	FontAllowUserScaling = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+168], 0

; 248  : 	DisplayFramebufferScale = ImVec2(1.0f, 1.0f);

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+172], rax

; 249  : 
; 250  : 	// Miscellaneous options
; 251  : 	MouseDrawCursor = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+194], 0

; 252  : #ifdef __APPLE__
; 253  : 	ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
; 254  : #else
; 255  : 	ConfigMacOSXBehaviors = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+192], 0

; 256  : #endif
; 257  : 	ConfigInputTextCursorBlink = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+193], 1

; 258  : 	ConfigWindowsResizeFromEdges = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+196], 1

; 259  : 	ConfigWindowsMoveFromTitleBarOnly = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+195], 0

; 260  : 
; 261  : 	// Platform Functions
; 262  : 	BackendPlatformName = BackendRendererName = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+216], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+200], 0

; 263  : 	BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+232], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+224], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+208], 0

; 264  : 	GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?GetClipboardTextFn_DefaultImpl@@YAPEBDPEAX@Z ; GetClipboardTextFn_DefaultImpl
	mov	QWORD PTR [rax+248], rcx

; 265  : 	SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?SetClipboardTextFn_DefaultImpl@@YAXPEAXPEBD@Z ; SetClipboardTextFn_DefaultImpl
	mov	QWORD PTR [rax+240], rcx

; 266  : 	ClipboardUserData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+256], 0

; 267  : 	ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z ; ImeSetInputScreenPosFn_DefaultImpl
	mov	QWORD PTR [rax+264], rcx

; 268  : 	ImeWindowHandle = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+272], 0

; 269  : 
; 270  : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 271  : 	RenderDrawListsFn = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+280], 0

; 272  : #endif
; 273  : 
; 274  : 	// Input (NB: we already have memset zero the entire structure!)
; 275  : 	MousePos = ImVec2(-FLT_MAX, -FLT_MAX);

	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR __real@ff7fffff
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+300], rax

; 276  : 	MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);

	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR __real@ff7fffff
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+1012], rax

; 277  : 	MouseDragThreshold = 6.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR [rax+132], xmm0

; 278  : 	for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ImGuiIO
$LN5@ImGuiIO:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@ImGuiIO:
	cmp	DWORD PTR i$1[rsp], 5
	jge	SHORT $LN6@ImGuiIO
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rcx+rax*4+1096], xmm0
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rcx+rax*4+1068], xmm0
	jmp	SHORT $LN5@ImGuiIO
$LN6@ImGuiIO:

; 279  : 	for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i] = KeysDownDurationPrev[i] = -1.0f;

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN10@ImGuiIO
$LN8@ImGuiIO:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN10@ImGuiIO:
	cmp	DWORD PTR i$2[rsp], 512			; 00000200H
	jge	SHORT $LN9@ImGuiIO
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rcx+rax*4+3308], xmm0
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rcx+rax*4+1116], xmm0
	jmp	SHORT $LN8@ImGuiIO
$LN9@ImGuiIO:

; 280  : 	for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN13@ImGuiIO
$LN11@ImGuiIO:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN13@ImGuiIO:
	cmp	DWORD PTR i$4[rsp], 21
	jge	SHORT $LN12@ImGuiIO
	movsxd	rax, DWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rcx+rax*4+3204], xmm0
	jmp	SHORT $LN11@ImGuiIO
$LN12@ImGuiIO:

; 281  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0ImGuiIO@@QEAA@XZ ENDP				; ImGuiIO::ImGuiIO
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
i$2 = 36
i$3 = 40
i$4 = 44
$T5 = 48
$T6 = 56
$T7 = 64
$T8 = 72
this$ = 96
?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA PROC			; `ImGuiIO::ImGuiIO'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 5440				; 00001540H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiIO@@QEAA@XZ@4HA ENDP			; `ImGuiIO::ImGuiIO'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@G@@QEAAXAEBG@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@G@@QEAAXAEBG@Z PROC		; ImVector<unsigned short>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@G@@QEBAHH@Z	; ImVector<unsigned short>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	r8d, 2
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@G@@QEAAXAEBG@Z ENDP		; ImVector<unsigned short>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 1
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@G@@QEBAHH@Z	; ImVector<unsigned short>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@G@@QEBAHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@G@@QEBAHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@G@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@G@@QEAAXXZ PROC			; ImVector<unsigned short>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@G@@QEAAXXZ ENDP			; ImVector<unsigned short>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QEAAAEAGH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@G@@QEAAAEAGH@Z PROC			; ImVector<unsigned short>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	ret	0
??A?$ImVector@G@@QEAAAEAGH@Z ENDP			; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@G@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@G@@QEAA@XZ PROC				; ImVector<unsigned short>::~ImVector<unsigned short>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@G@@QEAA@XZ ENDP				; ImVector<unsigned short>::~ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@G@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@G@@QEAA@XZ PROC				; ImVector<unsigned short>::ImVector<unsigned short>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@G@@QEAA@XZ ENDP				; ImVector<unsigned short>::ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?ClearInputCharacters@ImGuiIO@@QEAAXXZ PROC		; ImGuiIO::ClearInputCharacters

; 303  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 304  : 	InputQueueCharacters.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 5440				; 00001540H
	mov	QWORD PTR tv68[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv68[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
	npad	1

; 305  : }

	add	rsp, 56					; 00000038H
	ret	0
?ClearInputCharacters@ImGuiIO@@QEAAXXZ ENDP		; ImGuiIO::ClearInputCharacters
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv68 = 32
this$ = 64
c$ = 72
?AddInputCharacter@ImGuiIO@@QEAAXG@Z PROC		; ImGuiIO::AddInputCharacter

; 287  : {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 288  : 	InputQueueCharacters.push_back(c);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 5440				; 00001540H
	mov	QWORD PTR tv68[rsp], rax
	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	call	?push_back@?$ImVector@G@@QEAAXAEBG@Z	; ImVector<unsigned short>::push_back
	npad	1

; 289  : }

	add	rsp, 56					; 00000038H
	ret	0
?AddInputCharacter@ImGuiIO@@QEAAXG@Z ENDP		; ImGuiIO::AddInputCharacter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
c$2 = 36
tv78 = 40
this$ = 64
utf8_chars$ = 72
?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z PROC	; ImGuiIO::AddInputCharactersUTF8

; 292  : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@AddInputCh:

; 293  : 	while (*utf8_chars != 0)

	mov	rax, QWORD PTR utf8_chars$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@AddInputCh

; 294  : 	{
; 295  : 		unsigned int c = 0;

	mov	DWORD PTR c$2[rsp], 0

; 296  : 		utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);

	xor	r8d, r8d
	mov	rdx, QWORD PTR utf8_chars$[rsp]
	lea	rcx, QWORD PTR c$2[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR utf8_chars$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR utf8_chars$[rsp], rax

; 297  : 		if (c > 0 && c <= 0xFFFF)

	cmp	DWORD PTR c$2[rsp], 0
	jbe	SHORT $LN4@AddInputCh
	cmp	DWORD PTR c$2[rsp], 65535		; 0000ffffH
	ja	SHORT $LN4@AddInputCh

; 298  : 			InputQueueCharacters.push_back((ImWchar)c);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 5440				; 00001540H
	mov	QWORD PTR tv78[rsp], rax
	movzx	eax, WORD PTR c$2[rsp]
	mov	WORD PTR $T1[rsp], ax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?push_back@?$ImVector@G@@QEAAXAEBG@Z	; ImVector<unsigned short>::push_back
	npad	1
$LN4@AddInputCh:

; 299  : 	}

	jmp	SHORT $LN2@AddInputCh
$LN3@AddInputCh:

; 300  : }

	add	rsp, 56					; 00000038H
	ret	0
?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z ENDP	; ImGuiIO::AddInputCharactersUTF8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
$T4 = 56
$T5 = 64
$T6 = 72
$T7 = 80
$T8 = 88
$T9 = 96
$T10 = 104
$T11 = 112
$T12 = 120
$T13 = 128
$T14 = 136
$T15 = 144
$T16 = 152
this$ = 176
scale_factor$ = 184
?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z PROC		; ImGuiStyle::ScaleAllSizes

; 200  : {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 201  : 	WindowPadding = ImFloor(WindowPadding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 4
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+4], rax

; 202  : 	WindowRounding = ImFloor(WindowRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 203  : 	WindowMinSize = ImFloor(WindowMinSize * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 20
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+20], rax

; 204  : 	ChildRounding = ImFloor(ChildRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+36], xmm0

; 205  : 	PopupRounding = ImFloor(PopupRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+44]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+44], xmm0

; 206  : 	FramePadding = ImFloor(FramePadding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 52					; 00000034H
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T6[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+52], rax

; 207  : 	FrameRounding = ImFloor(FrameRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+60], xmm0

; 208  : 	ItemSpacing = ImFloor(ItemSpacing * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 68					; 00000044H
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+68], rax

; 209  : 	ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 76					; 0000004cH
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T10[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+76], rax

; 210  : 	TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 84					; 00000054H
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T12[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+84], rax

; 211  : 	IndentSpacing = ImFloor(IndentSpacing * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+92]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+92], xmm0

; 212  : 	ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+96], xmm0

; 213  : 	ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+100]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+100], xmm0

; 214  : 	ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+104]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+104], xmm0

; 215  : 	GrabMinSize = ImFloor(GrabMinSize * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+108], xmm0

; 216  : 	GrabRounding = ImFloor(GrabRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+112]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+112], xmm0

; 217  : 	TabRounding = ImFloor(TabRounding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+116]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+116], xmm0

; 218  : 	DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 140				; 0000008cH
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T13[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T14[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+140], rax

; 219  : 	DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 148				; 00000094H
	movss	xmm2, DWORD PTR scale_factor$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T15[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	lea	rcx, QWORD PTR $T16[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+148], rax

; 220  : 	MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+156]
	mulss	xmm0, DWORD PTR scale_factor$[rsp]
	call	?ImFloor@@YAMM@Z			; ImFloor
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+156], xmm0

; 221  : }

	add	rsp, 168				; 000000a8H
	ret	0
?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z ENDP		; ImGuiStyle::ScaleAllSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
$T4 = 56
$T5 = 64
$T6 = 72
$T7 = 80
$T8 = 88
$T9 = 96
$T10 = 104
$T11 = 112
this$ = 144
??0ImGuiStyle@@QEAA@XZ PROC				; ImGuiStyle::ImGuiStyle

; 159  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 4
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 20
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 28
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 52					; 00000034H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 68					; 00000044H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 76					; 0000004cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 84					; 00000054H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 124				; 0000007cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 132				; 00000084H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 140				; 0000008cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 148				; 00000094H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 168				; 000000a8H
	lea	r9, OFFSET FLAT:??0ImVec4@@QEAA@XZ	; ImVec4::ImVec4
	mov	r8d, 48					; 00000030H
	mov	edx, 16
	mov	rcx, rax
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z

; 160  : 	Alpha = 1.0f;             // Global alpha applies to everything in ImGui

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 161  : 	WindowPadding = ImVec2(8, 8);      // Padding within a window

	movss	xmm2, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR __real@41000000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+4], rax

; 162  : 	WindowRounding = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [rax+12], xmm0

; 163  : 	WindowBorderSize = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+16], xmm0

; 164  : 	WindowMinSize = ImVec2(32, 32);    // Minimum window size

	movss	xmm2, DWORD PTR __real@42000000
	movss	xmm1, DWORD PTR __real@42000000
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+20], rax

; 165  : 	WindowTitleAlign = ImVec2(0.0f, 0.5f);// Alignment for title bar text

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+28], rax

; 166  : 	ChildRounding = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+36], xmm0

; 167  : 	ChildBorderSize = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+40], xmm0

; 168  : 	PopupRounding = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+44], xmm0

; 169  : 	PopupBorderSize = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+48], xmm0

; 170  : 	FramePadding = ImVec2(4, 3);      // Padding within a framed rectangle (used by most widgets)

	movss	xmm2, DWORD PTR __real@40400000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+52], rax

; 171  : 	FrameRounding = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+60], xmm0

; 172  : 	FrameBorderSize = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+64], xmm0

; 173  : 	ItemSpacing = ImVec2(8, 4);      // Horizontal and vertical spacing between widgets/lines

	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@41000000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+68], rax

; 174  : 	ItemInnerSpacing = ImVec2(4, 4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)

	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+76], rax

; 175  : 	TouchExtraPadding = ImVec2(0, 0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+84], rax

; 176  : 	IndentSpacing = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@41a80000
	movss	DWORD PTR [rax+92], xmm0

; 177  : 	ColumnsMinSpacing = 6.0f;             // Minimum horizontal spacing between two columns

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR [rax+96], xmm0

; 178  : 	ScrollbarSize = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [rax+100], xmm0

; 179  : 	ScrollbarRounding = 9.0f;             // Radius of grab corners rounding for scrollbar

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@41100000
	movss	DWORD PTR [rax+104], xmm0

; 180  : 	GrabMinSize = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rax+108], xmm0

; 181  : 	GrabRounding = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+112], xmm0

; 182  : 	TabRounding = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [rax+116], xmm0

; 183  : 	TabBorderSize = 0.0f;             // Thickness of border around tabs.

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+120], xmm0

; 184  : 	ButtonTextAlign = ImVec2(0.5f, 0.5f);// Alignment of button text when button is larger than text.

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+124], rax

; 185  : 	SelectableTextAlign = ImVec2(0.0f, 0.0f);// Alignment of selectable text when button is larger than text.

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+132], rax

; 186  : 	DisplayWindowPadding = ImVec2(19, 19);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.

	movss	xmm2, DWORD PTR __real@41980000
	movss	xmm1, DWORD PTR __real@41980000
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+140], rax

; 187  : 	DisplaySafeAreaPadding = ImVec2(3, 3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.

	movss	xmm2, DWORD PTR __real@40400000
	movss	xmm1, DWORD PTR __real@40400000
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+148], rax

; 188  : 	MouseCursorScale = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+156], xmm0

; 189  : 	AntiAliasedLines = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+160], 1

; 190  : 	AntiAliasedFill = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+161], 1

; 191  : 	CurveTessellationTol = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3fa00000
	movss	DWORD PTR [rax+164], xmm0

; 192  : 
; 193  : 	// Default theme
; 194  : 	ImGui::StyleColorsDark(this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z ; ImGui::StyleColorsDark
	npad	1

; 195  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 136				; 00000088H
	ret	0
??0ImGuiStyle@@QEAA@XZ ENDP				; ImGuiStyle::ImGuiStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ctx$1 = 32
tv76 = 40
ptr$ = 64
?MemFree@ImGui@@YAXPEAX@Z PROC				; ImGui::MemFree

; 2071 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2072 : 	if (ptr)

	cmp	QWORD PTR ptr$[rsp], 0
	je	SHORT $LN2@MemFree

; 2073 : 		if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR ctx$1[rsp], rax
	cmp	QWORD PTR ctx$1[rsp], 0
	je	SHORT $LN3@MemFree

; 2074 : 			ctx->IO.MetricsActiveAllocations--;

	mov	rax, QWORD PTR ctx$1[rsp]
	mov	eax, DWORD PTR [rax+960]
	dec	eax
	mov	rcx, QWORD PTR ctx$1[rsp]
	mov	DWORD PTR [rcx+960], eax
$LN3@MemFree:
$LN2@MemFree:

; 2075 : 	return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);

	mov	rax, QWORD PTR ?GImAllocatorFreeFunc@@3P6AXPEAX0@ZEA
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR ?GImAllocatorUserData@@3PEAXEA
	mov	rcx, QWORD PTR ptr$[rsp]
	call	QWORD PTR tv76[rsp]
	npad	1

; 2076 : }

	add	rsp, 56					; 00000038H
	ret	0
?MemFree@ImGui@@YAXPEAX@Z ENDP				; ImGui::MemFree
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ctx$1 = 32
tv76 = 40
size$ = 64
?MemAlloc@ImGui@@YAPEAX_K@Z PROC			; ImGui::MemAlloc

; 2064 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2065 : 	if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR ctx$1[rsp], rax
	cmp	QWORD PTR ctx$1[rsp], 0
	je	SHORT $LN2@MemAlloc

; 2066 : 		ctx->IO.MetricsActiveAllocations++;

	mov	rax, QWORD PTR ctx$1[rsp]
	mov	eax, DWORD PTR [rax+960]
	inc	eax
	mov	rcx, QWORD PTR ctx$1[rsp]
	mov	DWORD PTR [rcx+960], eax
$LN2@MemAlloc:

; 2067 : 	return GImAllocatorAllocFunc(size, GImAllocatorUserData);

	mov	rax, QWORD PTR ?GImAllocatorAllocFunc@@3P6APEAX_KPEAX@ZEA
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR ?GImAllocatorUserData@@3PEAXEA
	mov	rcx, QWORD PTR size$[rsp]
	call	QWORD PTR tv76[rsp]

; 2068 : }

	add	rsp, 56					; 00000038H
	ret	0
?MemAlloc@ImGui@@YAPEAX_K@Z ENDP			; ImGui::MemAlloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
alloc_func$ = 8
free_func$ = 16
user_data$ = 24
?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z PROC ; ImGui::SetAllocatorFunctions

; 2125 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2126 : 	GImAllocatorAllocFunc = alloc_func;

	mov	rax, QWORD PTR alloc_func$[rsp]
	mov	QWORD PTR ?GImAllocatorAllocFunc@@3P6APEAX_KPEAX@ZEA, rax

; 2127 : 	GImAllocatorFreeFunc = free_func;

	mov	rax, QWORD PTR free_func$[rsp]
	mov	QWORD PTR ?GImAllocatorFreeFunc@@3P6AXPEAX0@ZEA, rax

; 2128 : 	GImAllocatorUserData = user_data;

	mov	rax, QWORD PTR user_data$[rsp]
	mov	QWORD PTR ?GImAllocatorUserData@@3PEAXEA, rax

; 2129 : }

	ret	0
?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z ENDP ; ImGui::SetAllocatorFunctions
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv74 = 32
text$ = 64
?SetClipboardText@ImGui@@YAXPEBD@Z PROC			; ImGui::SetClipboardText

; 2084 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2085 : 	if (GImGui->IO.SetClipboardTextFn)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	QWORD PTR [rax+256], 0
	je	SHORT $LN2@SetClipboa

; 2086 : 		GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+256]
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR text$[rsp]
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+272]
	call	QWORD PTR tv74[rsp]
	npad	1
$LN2@SetClipboa:

; 2087 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetClipboardText@ImGui@@YAXPEBD@Z ENDP			; ImGui::SetClipboardText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv75 = 32
tv73 = 40
?GetClipboardText@ImGui@@YAPEBDXZ PROC			; ImGui::GetClipboardText

; 2079 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 2080 : 	return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	QWORD PTR [rax+264], 0
	je	SHORT $LN3@GetClipboa
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+264]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+272]
	call	QWORD PTR tv73[rsp]
	mov	QWORD PTR tv75[rsp], rax
	jmp	SHORT $LN4@GetClipboa
$LN3@GetClipboa:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv75[rsp], rax
$LN4@GetClipboa:
	mov	rax, QWORD PTR tv75[rsp]

; 2081 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetClipboardText@ImGui@@YAPEBDXZ ENDP			; ImGui::GetClipboardText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv67 = 0
capture$ = 32
?CaptureMouseFromApp@ImGui@@YAX_N@Z PROC		; ImGui::CaptureMouseFromApp

; 3312 : {

$LN5:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 3313 : 	GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;

	movzx	eax, BYTE PTR capture$[rsp]
	test	eax, eax
	je	SHORT $LN3@CaptureMou
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@CaptureMou
$LN3@CaptureMou:
	mov	DWORD PTR tv67[rsp], 0
$LN4@CaptureMou:
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ecx, DWORD PTR tv67[rsp]
	mov	DWORD PTR [rax+15316], ecx

; 3314 : }

	add	rsp, 24
	ret	0
?CaptureMouseFromApp@ImGui@@YAX_N@Z ENDP		; ImGui::CaptureMouseFromApp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv67 = 0
capture$ = 32
?CaptureKeyboardFromApp@ImGui@@YAX_N@Z PROC		; ImGui::CaptureKeyboardFromApp

; 3307 : {

$LN5:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 3308 : 	GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;

	movzx	eax, BYTE PTR capture$[rsp]
	test	eax, eax
	je	SHORT $LN3@CaptureKey
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@CaptureKey
$LN3@CaptureKey:
	mov	DWORD PTR tv67[rsp], 0
$LN4@CaptureKey:
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ecx, DWORD PTR tv67[rsp]
	mov	DWORD PTR [rax+15320], ecx

; 3309 : }

	add	rsp, 24
	ret	0
?CaptureKeyboardFromApp@ImGui@@YAX_N@Z ENDP		; ImGui::CaptureKeyboardFromApp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
cursor_type$ = 8
?SetMouseCursor@ImGui@@YAXH@Z PROC			; ImGui::SetMouseCursor

; 3302 : {

	mov	DWORD PTR [rsp+8], ecx

; 3303 : 	GImGui->MouseCursor = cursor_type;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ecx, DWORD PTR cursor_type$[rsp]
	mov	DWORD PTR [rax+7504], ecx

; 3304 : }

	ret	0
?SetMouseCursor@ImGui@@YAXH@Z ENDP			; ImGui::SetMouseCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetMouseCursor@ImGui@@YAHXZ PROC			; ImGui::GetMouseCursor

; 3298 : 	return GImGui->MouseCursor;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	eax, DWORD PTR [rax+7504]

; 3299 : }

	ret	0
?GetMouseCursor@ImGui@@YAHXZ ENDP			; ImGui::GetMouseCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
button$ = 32
?ResetMouseDragDelta@ImGui@@YAXH@Z PROC			; ImGui::ResetMouseDragDelta

; 3289 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 3290 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3291 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3292 : 	// NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
; 3293 : 	g.IO.MouseClickedPos[button] = g.IO.MousePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+316]
	movsxd	rcx, DWORD PTR button$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rdx+rcx*8+1036], rax

; 3294 : }

	add	rsp, 24
	ret	0
?ResetMouseDragDelta@ImGui@@YAXH@Z ENDP			; ImGui::ResetMouseDragDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
__$ReturnUdt$ = 64
button$ = 72
lock_threshold$ = 80
?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z PROC	; ImGui::GetMouseDragDelta

; 3277 : {

$LN6:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3278 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3279 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3280 : 	if (lock_threshold < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR lock_threshold$[rsp]
	jbe	SHORT $LN2@GetMouseDr

; 3281 : 		lock_threshold = g.IO.MouseDragThreshold;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+148]
	movss	DWORD PTR lock_threshold$[rsp], xmm0
$LN2@GetMouseDr:

; 3282 : 	if (g.IO.MouseDown[button])

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	SHORT $LN3@GetMouseDr

; 3283 : 		if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)

	movsxd	rax, DWORD PTR button$[rsp]
	movss	xmm0, DWORD PTR lock_threshold$[rsp]
	mulss	xmm0, DWORD PTR lock_threshold$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4+3304]
	comiss	xmm1, xmm0
	jb	SHORT $LN4@GetMouseDr

; 3284 : 			return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+1036]
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetMouseDr
$LN4@GetMouseDr:
$LN3@GetMouseDr:

; 3285 : 	return ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetMouseDr:

; 3286 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z ENDP	; ImGui::GetMouseDragDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv75 = 40
__$ReturnUdt$ = 64
?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ PROC ; ImGui::GetMousePosOnOpeningCurrentPopup

; 3255 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3256 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3257 : 	if (g.BeginPopupStack.Size > 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6888], 0
	jle	SHORT $LN2@GetMousePo

; 3258 : 		return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv75[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6888]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv75[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+28]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetMousePo
$LN2@GetMousePo:

; 3259 : 	return g.IO.MousePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+316]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetMousePo:

; 3260 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ ENDP ; ImGui::GetMousePosOnOpeningCurrentPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
__$ReturnUdt$ = 8
?GetMousePos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetMousePos

; 3249 : {

	mov	QWORD PTR [rsp+8], rcx

; 3250 : 	return GImGui->IO.MousePos;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+316]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3251 : }

	ret	0
?GetMousePos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetMousePos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 0
MOUSE_INVALID$ = 4
tv67 = 8
p$ = 16
$T1 = 24
mouse_pos$ = 48
?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z PROC		; ImGui::IsMousePosValid

; 3264 : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3265 : 	// The assert is only to silence a false-positive in XCode Static Analysis.
; 3266 : 	// Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
; 3267 : 	IM_ASSERT(GImGui != NULL);
; 3268 : 	const float MOUSE_INVALID = -256000.0f;

	movss	xmm0, DWORD PTR __real@c87a0000
	movss	DWORD PTR MOUSE_INVALID$[rsp], xmm0

; 3269 : 	ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	cmp	QWORD PTR mouse_pos$[rsp], 0
	je	SHORT $LN3@IsMousePos
	mov	rax, QWORD PTR mouse_pos$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	jmp	SHORT $LN4@IsMousePos
$LN3@IsMousePos:
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv67[rsp], rax
$LN4@IsMousePos:
	mov	rax, QWORD PTR tv67[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax

; 3270 : 	return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm0, DWORD PTR p$[rsp]
	comiss	xmm0, DWORD PTR __real@c87a0000
	jb	SHORT $LN5@IsMousePos
	movss	xmm0, DWORD PTR p$[rsp+4]
	comiss	xmm0, DWORD PTR __real@c87a0000
	jb	SHORT $LN5@IsMousePos
	mov	DWORD PTR tv71[rsp], 1
	jmp	SHORT $LN6@IsMousePos
$LN5@IsMousePos:
	mov	DWORD PTR tv71[rsp], 0
$LN6@IsMousePos:
	movzx	eax, BYTE PTR tv71[rsp]

; 3271 : }

	add	rsp, 40					; 00000028H
	ret	0
?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ENDP		; ImGui::IsMousePosValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv92 = 40
tv90 = 48
$T1 = 56
$T2 = 64
rect_clipped$ = 72
rect_for_touch$ = 88
r_min$ = 128
r_max$ = 136
clip$ = 144
?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z PROC	; ImGui::IsMouseHoveringRect

; 3118 : {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3119 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3120 : 
; 3121 : 	// Clip
; 3122 : 	ImRect rect_clipped(r_min, r_max);

	mov	r8, QWORD PTR r_max$[rsp]
	mov	rdx, QWORD PTR r_min$[rsp]
	lea	rcx, QWORD PTR rect_clipped$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 3123 : 	if (clip)

	movzx	eax, BYTE PTR clip$[rsp]
	test	eax, eax
	je	SHORT $LN2@IsMouseHov

; 3124 : 		rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rax, 248				; 000000f8H
	mov	rdx, rax
	lea	rcx, QWORD PTR rect_clipped$[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith
	npad	1
$LN2@IsMouseHov:

; 3125 : 
; 3126 : 	// Expand for touch input
; 3127 : 	const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5556				; 000015b4H
	mov	r8, rax
	lea	rdx, QWORD PTR rect_clipped$[rsp+8]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv92[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5556				; 000015b4H
	mov	r8, rax
	lea	rdx, QWORD PTR rect_clipped$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv90[rsp], rax
	mov	r8, QWORD PTR tv92[rsp]
	mov	rdx, QWORD PTR tv90[rsp]
	lea	rcx, QWORD PTR rect_for_touch$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 3128 : 	if (!rect_for_touch.Contains(g.IO.MousePos))

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rdx, rax
	lea	rcx, QWORD PTR rect_for_touch$[rsp]
	call	?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsMouseHov

; 3129 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsMouseHov
$LN3@IsMouseHov:

; 3130 : 	return true;

	mov	al, 1
$LN1@IsMouseHov:

; 3131 : }

	add	rsp, 120				; 00000078H
	ret	0
?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ENDP	; ImGui::IsMouseHoveringRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv81 = 0
g$ = 8
button$ = 32
lock_threshold$ = 40
?IsMouseDragging@ImGui@@YA_NHM@Z PROC			; ImGui::IsMouseDragging

; 3238 : {

$LN7:
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 3239 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3240 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3241 : 	if (!g.IO.MouseDown[button])

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN2@IsMouseDra

; 3242 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsMouseDra
$LN2@IsMouseDra:

; 3243 : 	if (lock_threshold < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR lock_threshold$[rsp]
	jbe	SHORT $LN3@IsMouseDra

; 3244 : 		lock_threshold = g.IO.MouseDragThreshold;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+148]
	movss	DWORD PTR lock_threshold$[rsp], xmm0
$LN3@IsMouseDra:

; 3245 : 	return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movsxd	rax, DWORD PTR button$[rsp]
	movss	xmm0, DWORD PTR lock_threshold$[rsp]
	mulss	xmm0, DWORD PTR lock_threshold$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4+3304]
	comiss	xmm1, xmm0
	jb	SHORT $LN5@IsMouseDra
	mov	DWORD PTR tv81[rsp], 1
	jmp	SHORT $LN6@IsMouseDra
$LN5@IsMouseDra:
	mov	DWORD PTR tv81[rsp], 0
$LN6@IsMouseDra:
	movzx	eax, BYTE PTR tv81[rsp]
$LN1@IsMouseDra:

; 3246 : }

	add	rsp, 24
	ret	0
?IsMouseDragging@ImGui@@YA_NHM@Z ENDP			; ImGui::IsMouseDragging
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
button$ = 32
?IsMouseReleased@ImGui@@YA_NH@Z PROC			; ImGui::IsMouseReleased

; 3224 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 3225 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3226 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3227 : 	return g.IO.MouseReleased[button];

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1076]

; 3228 : }

	add	rsp, 24
	ret	0
?IsMouseReleased@ImGui@@YA_NH@Z ENDP			; ImGui::IsMouseReleased
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
button$ = 32
?IsMouseDoubleClicked@ImGui@@YA_NH@Z PROC		; ImGui::IsMouseDoubleClicked

; 3231 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 3232 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3233 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3234 : 	return g.IO.MouseDoubleClicked[button];

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1021]

; 3235 : }

	add	rsp, 24
	ret	0
?IsMouseDoubleClicked@ImGui@@YA_NH@Z ENDP		; ImGui::IsMouseDoubleClicked
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
t$ = 32
rate$1 = 36
delay$2 = 40
tv95 = 44
tv85 = 48
g$ = 56
button$ = 80
repeat$ = 88
?IsMouseClicked@ImGui@@YA_NH_N@Z PROC			; ImGui::IsMouseClicked

; 3206 : {

$LN10:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 3207 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3208 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3209 : 	const float t = g.IO.MouseDownDuration[button];

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+1084]
	movss	DWORD PTR t$[rsp], xmm0

; 3210 : 	if (t == 0.0f)

	movss	xmm0, DWORD PTR t$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@IsMouseCli
	jne	SHORT $LN2@IsMouseCli

; 3211 : 		return true;

	mov	al, 1
	jmp	$LN1@IsMouseCli
$LN2@IsMouseCli:

; 3212 : 
; 3213 : 	if (repeat && t > g.IO.KeyRepeatDelay)

	movzx	eax, BYTE PTR repeat$[rsp]
	test	eax, eax
	je	$LN3@IsMouseCli
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR t$[rsp]
	comiss	xmm0, DWORD PTR [rax+152]
	jbe	$LN3@IsMouseCli

; 3214 : 	{
; 3215 : 		float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+152]
	movss	DWORD PTR delay$2[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+168]
	movss	DWORD PTR rate$1[rsp], xmm0

; 3216 : 		if ((ImFmod(t - delay, rate) > rate * 0.5f) != (ImFmod(t - delay - g.IO.DeltaTime, rate) > rate * 0.5f))

	movss	xmm0, DWORD PTR t$[rsp]
	subss	xmm0, DWORD PTR delay$2[rsp]
	movss	xmm1, DWORD PTR rate$1[rsp]
	call	?ImFmod@@YAMMM@Z			; ImFmod
	movss	xmm1, DWORD PTR rate$1[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	comiss	xmm0, xmm1
	jbe	SHORT $LN6@IsMouseCli
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN7@IsMouseCli
$LN6@IsMouseCli:
	mov	DWORD PTR tv85[rsp], 0
$LN7@IsMouseCli:
	movss	xmm0, DWORD PTR t$[rsp]
	subss	xmm0, DWORD PTR delay$2[rsp]
	mov	rax, QWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR [rax+48]
	movss	xmm1, DWORD PTR rate$1[rsp]
	call	?ImFmod@@YAMMM@Z			; ImFmod
	movss	xmm1, DWORD PTR rate$1[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	comiss	xmm0, xmm1
	jbe	SHORT $LN8@IsMouseCli
	mov	DWORD PTR tv95[rsp], 1
	jmp	SHORT $LN9@IsMouseCli
$LN8@IsMouseCli:
	mov	DWORD PTR tv95[rsp], 0
$LN9@IsMouseCli:
	mov	eax, DWORD PTR tv95[rsp]
	cmp	DWORD PTR tv85[rsp], eax
	je	SHORT $LN4@IsMouseCli

; 3217 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsMouseCli
$LN4@IsMouseCli:
$LN3@IsMouseCli:

; 3218 : 	}
; 3219 : 
; 3220 : 	return false;

	xor	al, al
$LN1@IsMouseCli:

; 3221 : }

	add	rsp, 72					; 00000048H
	ret	0
?IsMouseClicked@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsMouseClicked
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
n$1 = 0
g$ = 8
?IsAnyMouseDown@ImGui@@YA_NXZ PROC			; ImGui::IsAnyMouseDown

; 3197 : {

$LN7:
	sub	rsp, 24

; 3198 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3199 : 	for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@IsAnyMouse
$LN2@IsAnyMouse:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@IsAnyMouse:
	cmp	DWORD PTR n$1[rsp], 5
	jge	SHORT $LN3@IsAnyMouse

; 3200 : 		if (g.IO.MouseDown[n])

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	SHORT $LN5@IsAnyMouse

; 3201 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsAnyMouse
$LN5@IsAnyMouse:
	jmp	SHORT $LN2@IsAnyMouse
$LN3@IsAnyMouse:

; 3202 : 	return false;

	xor	al, al
$LN1@IsAnyMouse:

; 3203 : }

	add	rsp, 24
	ret	0
?IsAnyMouseDown@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyMouseDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
button$ = 32
?IsMouseDown@ImGui@@YA_NH@Z PROC			; ImGui::IsMouseDown

; 3190 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 3191 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3192 : 	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3193 : 	return g.IO.MouseDown[button];

	movsxd	rax, DWORD PTR button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]

; 3194 : }

	add	rsp, 24
	ret	0
?IsMouseDown@ImGui@@YA_NH@Z ENDP			; ImGui::IsMouseDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
t$ = 32
g$ = 40
key_index$ = 64
repeat_delay$ = 72
repeat_rate$ = 80
?GetKeyPressedAmount@ImGui@@YAHHMM@Z PROC		; ImGui::GetKeyPressedAmount

; 3158 : {

$LN4:
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 3159 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3160 : 	if (key_index < 0)

	cmp	DWORD PTR key_index$[rsp], 0
	jge	SHORT $LN2@GetKeyPres

; 3161 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetKeyPres
$LN2@GetKeyPres:

; 3162 : 	IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
; 3163 : 	const float t = g.IO.KeysDownDuration[key_index];

	movsxd	rax, DWORD PTR key_index$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+1132]
	movss	DWORD PTR t$[rsp], xmm0

; 3164 : 	return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR t$[rsp]
	subss	xmm0, DWORD PTR [rax+48]
	movss	xmm3, DWORD PTR repeat_rate$[rsp]
	movss	xmm2, DWORD PTR repeat_delay$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR t$[rsp]
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
$LN1@GetKeyPres:

; 3165 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetKeyPressedAmount@ImGui@@YAHHMM@Z ENDP		; ImGui::GetKeyPressedAmount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv78 = 0
g$ = 8
user_key_index$ = 32
?IsKeyReleased@ImGui@@YA_NH@Z PROC			; ImGui::IsKeyReleased

; 3182 : {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 3183 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3184 : 	if (user_key_index < 0) return false;

	cmp	DWORD PTR user_key_index$[rsp], 0
	jge	SHORT $LN2@IsKeyRelea
	xor	al, al
	jmp	SHORT $LN1@IsKeyRelea
$LN2@IsKeyRelea:

; 3185 : 	IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
; 3186 : 	return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];

	movsxd	rax, DWORD PTR user_key_index$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+3324]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN4@IsKeyRelea
	movsxd	rax, DWORD PTR user_key_index$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+333]
	test	eax, eax
	jne	SHORT $LN4@IsKeyRelea
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN5@IsKeyRelea
$LN4@IsKeyRelea:
	mov	DWORD PTR tv78[rsp], 0
$LN5@IsKeyRelea:
	movzx	eax, BYTE PTR tv78[rsp]
$LN1@IsKeyRelea:

; 3187 : }

	add	rsp, 24
	ret	0
?IsKeyReleased@ImGui@@YA_NH@Z ENDP			; ImGui::IsKeyReleased
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
t$ = 32
tv85 = 36
g$ = 40
user_key_index$ = 64
repeat$ = 72
?IsKeyPressed@ImGui@@YA_NH_N@Z PROC			; ImGui::IsKeyPressed

; 3168 : {

$LN8:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 3169 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3170 : 	if (user_key_index < 0)

	cmp	DWORD PTR user_key_index$[rsp], 0
	jge	SHORT $LN2@IsKeyPress

; 3171 : 		return false;

	xor	al, al
	jmp	$LN1@IsKeyPress
$LN2@IsKeyPress:

; 3172 : 	IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
; 3173 : 	const float t = g.IO.KeysDownDuration[user_key_index];

	movsxd	rax, DWORD PTR user_key_index$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+1132]
	movss	DWORD PTR t$[rsp], xmm0

; 3174 : 	if (t == 0.0f)

	movss	xmm0, DWORD PTR t$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@IsKeyPress
	jne	SHORT $LN3@IsKeyPress

; 3175 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@IsKeyPress
$LN3@IsKeyPress:

; 3176 : 	if (repeat && t > g.IO.KeyRepeatDelay)

	movzx	eax, BYTE PTR repeat$[rsp]
	test	eax, eax
	je	SHORT $LN4@IsKeyPress
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR t$[rsp]
	comiss	xmm0, DWORD PTR [rax+152]
	jbe	SHORT $LN4@IsKeyPress

; 3177 : 		return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+168]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+152]
	mov	ecx, DWORD PTR user_key_index$[rsp]
	call	?GetKeyPressedAmount@ImGui@@YAHHMM@Z	; ImGui::GetKeyPressedAmount
	test	eax, eax
	jle	SHORT $LN6@IsKeyPress
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN7@IsKeyPress
$LN6@IsKeyPress:
	mov	DWORD PTR tv85[rsp], 0
$LN7@IsKeyPress:
	movzx	eax, BYTE PTR tv85[rsp]
	jmp	SHORT $LN1@IsKeyPress
$LN4@IsKeyPress:

; 3178 : 	return false;

	xor	al, al
$LN1@IsKeyPress:

; 3179 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsKeyPressed@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsKeyPressed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
user_key_index$ = 8
?IsKeyDown@ImGui@@YA_NH@Z PROC				; ImGui::IsKeyDown

; 3141 : {

	mov	DWORD PTR [rsp+8], ecx

; 3142 : 	if (user_key_index < 0) return false;

	cmp	DWORD PTR user_key_index$[rsp], 0
	jge	SHORT $LN2@IsKeyDown
	xor	al, al
	jmp	SHORT $LN1@IsKeyDown
$LN2@IsKeyDown:

; 3143 : 	IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
; 3144 : 	return GImGui->IO.KeysDown[user_key_index];

	movsxd	rax, DWORD PTR user_key_index$[rsp]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movzx	eax, BYTE PTR [rcx+rax+333]
$LN1@IsKeyDown:

; 3145 : }

	ret	0
?IsKeyDown@ImGui@@YA_NH@Z ENDP				; ImGui::IsKeyDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
imgui_key$ = 8
?GetKeyIndex@ImGui@@YAHH@Z PROC				; ImGui::GetKeyIndex

; 3134 : {

	mov	DWORD PTR [rsp+8], ecx

; 3135 : 	IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
; 3136 : 	return GImGui->IO.KeyMap[imgui_key];

	movsxd	rax, DWORD PTR imgui_key$[rsp]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	eax, DWORD PTR [rcx+rax*4+60]

; 3137 : }

	ret	0
?GetKeyIndex@ImGui@@YAHH@Z ENDP				; ImGui::GetKeyIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
p$ = 32
t$ = 36
q$ = 40
f$ = 44
i$ = 48
tv81 = 52
h$ = 80
s$ = 88
v$ = 96
out_r$ = 104
out_g$ = 112
out_b$ = 120
?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z PROC	; ImGui::ColorConvertHSVtoRGB

; 885  : {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H

; 886  : 	if (s == 0.0f)

	movss	xmm0, DWORD PTR s$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN4@ColorConve
	jne	SHORT $LN4@ColorConve

; 887  : 	{
; 888  : 		// gray
; 889  : 		out_r = out_g = out_b = v;

	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0

; 890  : 		return;

	jmp	$LN1@ColorConve
$LN4@ColorConve:

; 891  : 	}
; 892  : 
; 893  : 	h = ImFmod(h, 1.0f) / (60.0f / 360.0f);

	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR h$[rsp]
	call	?ImFmod@@YAMMM@Z			; ImFmod
	divss	xmm0, DWORD PTR __real@3e2aaaab
	movss	DWORD PTR h$[rsp], xmm0

; 894  : 	int   i = (int)h;

	cvttss2si eax, DWORD PTR h$[rsp]
	mov	DWORD PTR i$[rsp], eax

; 895  : 	float f = h - (float)i;

	cvtsi2ss xmm0, DWORD PTR i$[rsp]
	movss	xmm1, DWORD PTR h$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$[rsp], xmm0

; 896  : 	float p = v * (1.0f - s);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR s$[rsp]
	movss	xmm1, DWORD PTR v$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR p$[rsp], xmm0

; 897  : 	float q = v * (1.0f - s * f);

	movss	xmm0, DWORD PTR s$[rsp]
	mulss	xmm0, DWORD PTR f$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR v$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR q$[rsp], xmm0

; 898  : 	float t = v * (1.0f - s * (1.0f - f));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR f$[rsp]
	movss	xmm1, DWORD PTR s$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR v$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR t$[rsp], xmm0

; 899  : 
; 900  : 	switch (i)

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tv81[rsp], eax
	cmp	DWORD PTR tv81[rsp], 5
	ja	$LN11@ColorConve
	movsxd	rax, DWORD PTR tv81[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN13@ColorConve[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN5@ColorConve:

; 901  : 	{
; 902  : 	case 0: out_r = v; out_g = t; out_b = p; break;

	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR t$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	$LN2@ColorConve
$LN6@ColorConve:

; 903  : 	case 1: out_r = q; out_g = v; out_b = p; break;

	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR q$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	$LN2@ColorConve
$LN7@ColorConve:

; 904  : 	case 2: out_r = p; out_g = v; out_b = t; break;

	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR t$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	$LN2@ColorConve
$LN8@ColorConve:

; 905  : 	case 3: out_r = p; out_g = q; out_b = v; break;

	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR q$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN2@ColorConve
$LN9@ColorConve:

; 906  : 	case 4: out_r = t; out_g = p; out_b = v; break;

	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR t$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN2@ColorConve
$LN10@ColorConve:
$LN11@ColorConve:

; 907  : 	case 5: default: out_r = v; out_g = p; out_b = q; break;

	mov	rax, QWORD PTR out_r$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_g$[rsp]
	movss	xmm0, DWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR out_b$[rsp]
	movss	xmm0, DWORD PTR q$[rsp]
	movss	DWORD PTR [rax], xmm0
$LN2@ColorConve:
$LN1@ColorConve:

; 908  : 	}
; 909  : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	1
$LN13@ColorConve:
	DD	$LN5@ColorConve
	DD	$LN6@ColorConve
	DD	$LN7@ColorConve
	DD	$LN8@ColorConve
	DD	$LN9@ColorConve
	DD	$LN10@ColorConve
?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ENDP	; ImGui::ColorConvertHSVtoRGB
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
K$ = 32
tv72 = 36
chroma$ = 40
r$ = 64
g$ = 72
b$ = 80
out_h$ = 88
out_s$ = 96
out_v$ = 104
?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z PROC	; ImGui::ColorConvertRGBtoHSV

; 863  : {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 864  : 	float K = 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR K$[rsp], xmm0

; 865  : 	if (g < b)

	movss	xmm0, DWORD PTR b$[rsp]
	comiss	xmm0, DWORD PTR g$[rsp]
	jbe	SHORT $LN2@ColorConve

; 866  : 	{
; 867  : 		ImSwap(g, b);

	lea	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR g$[rsp]
	call	??$ImSwap@M@@YAXAEAM0@Z			; ImSwap<float>

; 868  : 		K = -1.f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR K$[rsp], xmm0
$LN2@ColorConve:

; 869  : 	}
; 870  : 	if (r < g)

	movss	xmm0, DWORD PTR g$[rsp]
	comiss	xmm0, DWORD PTR r$[rsp]
	jbe	SHORT $LN3@ColorConve

; 871  : 	{
; 872  : 		ImSwap(r, g);

	lea	rdx, QWORD PTR g$[rsp]
	lea	rcx, QWORD PTR r$[rsp]
	call	??$ImSwap@M@@YAXAEAM0@Z			; ImSwap<float>

; 873  : 		K = -2.f / 6.f - K;

	movss	xmm0, DWORD PTR __real@beaaaaab
	subss	xmm0, DWORD PTR K$[rsp]
	movss	DWORD PTR K$[rsp], xmm0
$LN3@ColorConve:

; 874  : 	}
; 875  : 
; 876  : 	const float chroma = r - (g < b ? g : b);

	movss	xmm0, DWORD PTR b$[rsp]
	comiss	xmm0, DWORD PTR g$[rsp]
	jbe	SHORT $LN5@ColorConve
	movss	xmm0, DWORD PTR g$[rsp]
	movss	DWORD PTR tv72[rsp], xmm0
	jmp	SHORT $LN6@ColorConve
$LN5@ColorConve:
	movss	xmm0, DWORD PTR b$[rsp]
	movss	DWORD PTR tv72[rsp], xmm0
$LN6@ColorConve:
	movss	xmm0, DWORD PTR r$[rsp]
	subss	xmm0, DWORD PTR tv72[rsp]
	movss	DWORD PTR chroma$[rsp], xmm0

; 877  : 	out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));

	movss	xmm0, DWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR __real@40c00000
	mulss	xmm1, DWORD PTR chroma$[rsp]
	addss	xmm1, DWORD PTR __real@1e3ce508
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR K$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFabs@@YAMM@Z				; ImFabs
	mov	rax, QWORD PTR out_h$[rsp]
	movss	DWORD PTR [rax], xmm0

; 878  : 	out_s = chroma / (r + 1e-20f);

	movss	xmm0, DWORD PTR r$[rsp]
	addss	xmm0, DWORD PTR __real@1e3ce508
	movss	xmm1, DWORD PTR chroma$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR out_s$[rsp]
	movss	DWORD PTR [rax], xmm0

; 879  : 	out_v = r;

	mov	rax, QWORD PTR out_v$[rsp]
	movss	xmm0, DWORD PTR r$[rsp]
	movss	DWORD PTR [rax], xmm0

; 880  : }

	add	rsp, 56					; 00000038H
	ret	0
?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ENDP	; ImGui::ColorConvertRGBtoHSV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
in$ = 48
out_r$ = 56
out_g$ = 64
out_b$ = 72
?ColorConvertFloat4ToRGB@ImGui@@YAXAEBUImVec4@@AEAM11@Z PROC ; ImGui::ColorConvertFloat4ToRGB

; 855  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 856  : 	out_r = (float)((IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT);

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR out_r$[rsp]
	movss	DWORD PTR [rax], xmm0

; 857  : 	out_g = (float)((IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT);

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	shl	eax, 8
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR out_g$[rsp]
	movss	DWORD PTR [rax], xmm0

; 858  : 	out_b = (float)((IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT);

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	shl	eax, 16
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR out_b$[rsp]
	movss	DWORD PTR [rax], xmm0

; 859  : }

	add	rsp, 40					; 00000028H
	ret	0
?ColorConvertFloat4ToRGB@ImGui@@YAXAEBUImVec4@@AEAM11@Z ENDP ; ImGui::ColorConvertFloat4ToRGB
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
out$ = 32
in$ = 64
?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z PROC	; ImGui::ColorConvertFloat4ToU32

; 846  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 847  : 	ImU32 out;
; 848  : 	out = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR out$[rsp], eax

; 849  : 	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	shl	eax, 8
	mov	ecx, DWORD PTR out$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR out$[rsp], eax

; 850  : 	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	shl	eax, 16
	mov	ecx, DWORD PTR out$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR out$[rsp], eax

; 851  : 	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;

	mov	rax, QWORD PTR in$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	shl	eax, 24
	mov	ecx, DWORD PTR out$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR out$[rsp], eax

; 852  : 	return out;

	mov	eax, DWORD PTR out$[rsp]

; 853  : }

	add	rsp, 56					; 00000038H
	ret	0
?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ENDP	; ImGui::ColorConvertFloat4ToU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
s$ = 48
tv83 = 52
__$ReturnUdt$ = 80
in$ = 88
?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z PROC	; ImGui::ColorConvertU32ToFloat4

; 836  : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 837  : 	float s = 1.0f / 255.0f;

	movss	xmm0, DWORD PTR __real@3b808081
	movss	DWORD PTR s$[rsp], xmm0

; 838  : 	return ImVec4(

	mov	eax, DWORD PTR in$[rsp]
	shr	eax, 24
	and	eax, 255				; 000000ffH
	mov	eax, eax
	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR s$[rsp]
	mov	eax, DWORD PTR in$[rsp]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	eax, eax
	cvtsi2ss xmm1, rax
	mulss	xmm1, DWORD PTR s$[rsp]
	mov	eax, DWORD PTR in$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	eax, eax
	cvtsi2ss xmm2, rax
	mulss	xmm2, DWORD PTR s$[rsp]
	mov	eax, DWORD PTR in$[rsp]
	and	eax, 255				; 000000ffH
	mov	eax, eax
	cvtsi2ss xmm3, rax
	mulss	xmm3, DWORD PTR s$[rsp]
	movss	DWORD PTR tv83[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv83[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 839  : 		((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
; 840  : 		((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
; 841  : 		((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
; 842  : 		((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
; 843  : }

	add	rsp, 72					; 00000048H
	ret	0
?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z ENDP	; ImGui::ColorConvertU32ToFloat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?EndChildFrame@ImGui@@YAXXZ PROC			; ImGui::EndChildFrame

; 3549 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 3550 : 	EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild
	npad	1

; 3551 : }

	add	rsp, 40					; 00000028H
	ret	0
?EndChildFrame@ImGui@@YAXXZ ENDP			; ImGui::EndChildFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ret$ = 32
style$ = 40
g$ = 48
id$ = 80
size$ = 88
extra_flags$ = 96
?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z PROC	; ImGui::BeginChildFrame

; 3535 : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 3536 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3537 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 3538 : 	PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);

	mov	eax, 16
	imul	rax, rax, 7
	mov	rcx, QWORD PTR style$[rsp]
	lea	rax, QWORD PTR [rcx+rax+168]
	mov	rdx, rax
	mov	ecx, 3
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 3539 : 	PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+60]
	mov	ecx, 6
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 3540 : 	PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+64]
	mov	ecx, 7
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 3541 : 	PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	rdx, rax
	mov	ecx, 1
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar

; 3542 : 	bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);

	mov	eax, DWORD PTR extra_flags$[rsp]
	or	eax, 65540				; 00010004H
	mov	r9d, eax
	mov	r8b, 1
	mov	rdx, QWORD PTR size$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z ; ImGui::BeginChild
	mov	BYTE PTR ret$[rsp], al

; 3543 : 	PopStyleVar(3);

	mov	ecx, 3
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 3544 : 	PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor

; 3545 : 	return ret;

	movzx	eax, BYTE PTR ret$[rsp]

; 3546 : }

	add	rsp, 72					; 00000048H
	ret	0
?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z ENDP	; ImGui::BeginChildFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
start$ = 32
end$ = 36
g$ = 40
window$ = 48
pos$ = 56
unclipped_rect$ = 64
items_count$ = 112
items_height$ = 120
out_items_display_start$ = 128
out_items_display_end$ = 136
?CalcListClipping@ImGui@@YAXHMPEAH0@Z PROC		; ImGui::CalcListClipping

; 3034 : {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 3035 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3036 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 3037 : 	//if (g.LogEnabled)
; 3038 : 	//{
; 3039 : 	//    // If logging is active, do not perform any clipping
; 3040 : 	//    *out_items_display_start = 0;
; 3041 : 	//    *out_items_display_end = items_count;
; 3042 : 	//    return;
; 3043 : 	//}
; 3044 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@CalcListCl

; 3045 : 	{
; 3046 : 		*out_items_display_start = *out_items_display_end = 0;

	mov	rax, QWORD PTR out_items_display_end$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR out_items_display_start$[rsp]
	mov	DWORD PTR [rax], 0

; 3047 : 		return;

	jmp	$LN1@CalcListCl
$LN2@CalcListCl:

; 3048 : 	}
; 3049 : 
; 3050 : 	// We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
; 3051 : 	ImRect unclipped_rect = window->ClipRect;

	lea	rax, QWORD PTR unclipped_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+248]
	mov	ecx, 16
	rep movsb

; 3052 : 	if (g.NavMoveRequest)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN3@CalcListCl

; 3053 : 		unclipped_rect.Add(g.NavScoringRectScreen);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7072				; 00001ba0H
	mov	rdx, rax
	lea	rcx, QWORD PTR unclipped_rect$[rsp]
	call	?Add@ImRect@@QEAAXAEBU1@@Z		; ImRect::Add
	npad	1
$LN3@CalcListCl:

; 3054 : 
; 3055 : 	const ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 3056 : 	int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);

	movss	xmm0, DWORD PTR unclipped_rect$[rsp+4]
	subss	xmm0, DWORD PTR pos$[rsp+4]
	divss	xmm0, DWORD PTR items_height$[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR start$[rsp], eax

; 3057 : 	int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

	movss	xmm0, DWORD PTR unclipped_rect$[rsp+12]
	subss	xmm0, DWORD PTR pos$[rsp+4]
	divss	xmm0, DWORD PTR items_height$[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR end$[rsp], eax

; 3058 : 
; 3059 : 	// When performing a navigation request, ensure we have one item extra in the direction we are moving to
; 3060 : 	if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN4@CalcListCl
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7284], 2
	jne	SHORT $LN4@CalcListCl

; 3061 : 		start--;

	mov	eax, DWORD PTR start$[rsp]
	dec	eax
	mov	DWORD PTR start$[rsp], eax
$LN4@CalcListCl:

; 3062 : 	if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN5@CalcListCl
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7284], 3
	jne	SHORT $LN5@CalcListCl

; 3063 : 		end++;

	mov	eax, DWORD PTR end$[rsp]
	inc	eax
	mov	DWORD PTR end$[rsp], eax
$LN5@CalcListCl:

; 3064 : 
; 3065 : 	start = ImClamp(start, 0, items_count);

	mov	r8d, DWORD PTR items_count$[rsp]
	xor	edx, edx
	mov	ecx, DWORD PTR start$[rsp]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR start$[rsp], eax

; 3066 : 	end = ImClamp(end + 1, start, items_count);

	mov	eax, DWORD PTR end$[rsp]
	inc	eax
	mov	r8d, DWORD PTR items_count$[rsp]
	mov	edx, DWORD PTR start$[rsp]
	mov	ecx, eax
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR end$[rsp], eax

; 3067 : 	*out_items_display_start = start;

	mov	rax, QWORD PTR out_items_display_start$[rsp]
	mov	ecx, DWORD PTR start$[rsp]
	mov	DWORD PTR [rax], ecx

; 3068 : 	*out_items_display_end = end;

	mov	rax, QWORD PTR out_items_display_end$[rsp]
	mov	ecx, DWORD PTR end$[rsp]
	mov	DWORD PTR [rax], ecx
$LN1@CalcListCl:

; 3069 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?CalcListClipping@ImGui@@YAXHMPEAH0@Z ENDP		; ImGui::CalcListClipping
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
font_size$ = 64
text_display_end$ = 72
text_size$ = 80
g$ = 88
font$ = 96
__$ReturnUdt$ = 128
text$ = 136
text_end$ = 144
hide_text_after_double_hash$ = 152
wrap_width$ = 160
?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z PROC	; ImGui::CalcTextSize

; 3009 : {

$LN6:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3010 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3011 : 
; 3012 : 	const char* text_display_end;
; 3013 : 	if (hide_text_after_double_hash)

	movzx	eax, BYTE PTR hide_text_after_double_hash$[rsp]
	test	eax, eax
	je	SHORT $LN2@CalcTextSi

; 3014 : 		text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string

	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR text_display_end$[rsp], rax
	jmp	SHORT $LN3@CalcTextSi
$LN2@CalcTextSi:

; 3015 : 	else
; 3016 : 		text_display_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR text_display_end$[rsp], rax
$LN3@CalcTextSi:

; 3017 : 
; 3018 : 	ImFont* font = g.Font;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR font$[rsp], rax

; 3019 : 	const float font_size = g.FontSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR font_size$[rsp], xmm0

; 3020 : 	if (text == text_display_end)

	mov	rax, QWORD PTR text_display_end$[rsp]
	cmp	QWORD PTR text$[rsp], rax
	jne	SHORT $LN4@CalcTextSi

; 3021 : 		return ImVec2(0.0f, font_size);

	movss	xmm2, DWORD PTR font_size$[rsp]
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@CalcTextSi
$LN4@CalcTextSi:

; 3022 : 	ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], 0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@7f7fffff
	movss	xmm2, DWORD PTR font_size$[rsp]
	lea	rdx, QWORD PTR text_size$[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 3023 : 
; 3024 : 	// Round
; 3025 : 	text_size.x = (float)(int)(text_size.x + 0.95f);

	movss	xmm0, DWORD PTR text_size$[rsp]
	addss	xmm0, DWORD PTR __real@3f733333
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR text_size$[rsp], xmm0

; 3026 : 
; 3027 : 	return text_size;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR text_size$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@CalcTextSi:

; 3028 : }

	add	rsp, 120				; 00000078H
	ret	0
?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ENDP	; ImGui::CalcTextSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 0
?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ PROC	; ImGui::GetStateStorage

; 5594 : {

$LN3:
	sub	rsp, 24

; 5595 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5596 : 	return window->DC.StateStorage;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+448]

; 5597 : }

	add	rsp, 24
	ret	0
?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ ENDP	; ImGui::GetStateStorage
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 0
tv69 = 8
tree$ = 32
?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z PROC	; ImGui::SetStateStorage

; 5588 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5589 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5590 : 	window->DC.StateStorage = tree ? tree : &window->StateStorage;

	cmp	QWORD PTR tree$[rsp], 0
	je	SHORT $LN3@SetStateSt
	mov	rax, QWORD PTR tree$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@SetStateSt
$LN3@SetStateSt:
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 288				; 00000120H
	mov	QWORD PTR tv69[rsp], rax
$LN4@SetStateSt:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	mov	QWORD PTR [rax+448], rcx

; 5591 : }

	add	rsp, 24
	ret	0
?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z ENDP	; ImGui::SetStateStorage
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv64 = 0
idx$ = 32
?GetStyleColorName@ImGui@@YAPEBDH@Z PROC		; ImGui::GetStyleColorName

; 4988 : {

$LN54:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 4989 : 	// Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
; 4990 : 	switch (idx)

	mov	eax, DWORD PTR idx$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 47			; 0000002fH
	ja	$LN2@GetStyleCo
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN53@GetStyleCo[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@GetStyleCo:

; 4991 : 	{
; 4992 : 	case ImGuiCol_Text: return ("Text");

	lea	rax, OFFSET FLAT:??_C@_04OJAHODMC@Text@
	jmp	$LN1@GetStyleCo
$LN5@GetStyleCo:

; 4993 : 	case ImGuiCol_TextDisabled: return ("TextDisabled");

	lea	rax, OFFSET FLAT:??_C@_0N@LNHHFNPK@TextDisabled@
	jmp	$LN1@GetStyleCo
$LN6@GetStyleCo:

; 4994 : 	case ImGuiCol_WindowBg: return ("WindowBg");

	lea	rax, OFFSET FLAT:??_C@_08DMKFNKPN@WindowBg@
	jmp	$LN1@GetStyleCo
$LN7@GetStyleCo:

; 4995 : 	case ImGuiCol_ChildBg: return ("ChildBg");

	lea	rax, OFFSET FLAT:??_C@_07BLEJOHFO@ChildBg@
	jmp	$LN1@GetStyleCo
$LN8@GetStyleCo:

; 4996 : 	case ImGuiCol_PopupBg: return ("PopupBg");

	lea	rax, OFFSET FLAT:??_C@_07LKIIIJHA@PopupBg@
	jmp	$LN1@GetStyleCo
$LN9@GetStyleCo:

; 4997 : 	case ImGuiCol_Border: return ("Border");

	lea	rax, OFFSET FLAT:??_C@_06CMOGDIBK@Border@
	jmp	$LN1@GetStyleCo
$LN10@GetStyleCo:

; 4998 : 	case ImGuiCol_BorderShadow: return ("BorderShadow");

	lea	rax, OFFSET FLAT:??_C@_0N@DECGFAEC@BorderShadow@
	jmp	$LN1@GetStyleCo
$LN11@GetStyleCo:

; 4999 : 	case ImGuiCol_FrameBg: return ("FrameBg");

	lea	rax, OFFSET FLAT:??_C@_07PJIIOGAC@FrameBg@
	jmp	$LN1@GetStyleCo
$LN12@GetStyleCo:

; 5000 : 	case ImGuiCol_FrameBgHovered: return ("FrameBgHovered");

	lea	rax, OFFSET FLAT:??_C@_0P@KIOOHHAC@FrameBgHovered@
	jmp	$LN1@GetStyleCo
$LN13@GetStyleCo:

; 5001 : 	case ImGuiCol_FrameBgActive: return ("FrameBgActive");

	lea	rax, OFFSET FLAT:??_C@_0O@BGDCDDEA@FrameBgActive@
	jmp	$LN1@GetStyleCo
$LN14@GetStyleCo:

; 5002 : 	case ImGuiCol_TitleBg: return ("TitleBg");

	lea	rax, OFFSET FLAT:??_C@_07MMLEKCPI@TitleBg@
	jmp	$LN1@GetStyleCo
$LN15@GetStyleCo:

; 5003 : 	case ImGuiCol_TitleBgActive: return ("TitleBgActive");

	lea	rax, OFFSET FLAT:??_C@_0O@JHBFJHNE@TitleBgActive@
	jmp	$LN1@GetStyleCo
$LN16@GetStyleCo:

; 5004 : 	case ImGuiCol_TitleBgCollapsed: return ("TitleBgCollapsed");

	lea	rax, OFFSET FLAT:??_C@_0BB@EGCOMBJG@TitleBgCollapsed@
	jmp	$LN1@GetStyleCo
$LN17@GetStyleCo:

; 5005 : 	case ImGuiCol_MenuBarBg: return ("MenuBarBg");

	lea	rax, OFFSET FLAT:??_C@_09GEKCKLDE@MenuBarBg@
	jmp	$LN1@GetStyleCo
$LN18@GetStyleCo:

; 5006 : 	case ImGuiCol_ScrollbarBg: return ("ScrollbarBg");

	lea	rax, OFFSET FLAT:??_C@_0M@MFDHPFJF@ScrollbarBg@
	jmp	$LN1@GetStyleCo
$LN19@GetStyleCo:

; 5007 : 	case ImGuiCol_ScrollbarGrab: return ("ScrollbarGrab");

	lea	rax, OFFSET FLAT:??_C@_0O@HABIDNBE@ScrollbarGrab@
	jmp	$LN1@GetStyleCo
$LN20@GetStyleCo:

; 5008 : 	case ImGuiCol_ScrollbarGrabHovered: return ("ScrollbarGrabHovered");

	lea	rax, OFFSET FLAT:??_C@_0BF@JFEOOMLL@ScrollbarGrabHovered@
	jmp	$LN1@GetStyleCo
$LN21@GetStyleCo:

; 5009 : 	case ImGuiCol_ScrollbarGrabActive: return ("ScrollbarGrabActive");

	lea	rax, OFFSET FLAT:??_C@_0BE@GODMFNCF@ScrollbarGrabActive@
	jmp	$LN1@GetStyleCo
$LN22@GetStyleCo:

; 5010 : 	case ImGuiCol_CheckMark: return ("CheckMark");

	lea	rax, OFFSET FLAT:??_C@_09DMKAANGE@CheckMark@
	jmp	$LN1@GetStyleCo
$LN23@GetStyleCo:

; 5011 : 	case ImGuiCol_SliderGrab: return ("SliderGrab");

	lea	rax, OFFSET FLAT:??_C@_0L@LAMBADIC@SliderGrab@
	jmp	$LN1@GetStyleCo
$LN24@GetStyleCo:

; 5012 : 	case ImGuiCol_SliderGrabActive: return ("SliderGrabActive");

	lea	rax, OFFSET FLAT:??_C@_0BB@HBOBMOMP@SliderGrabActive@
	jmp	$LN1@GetStyleCo
$LN25@GetStyleCo:

; 5013 : 	case ImGuiCol_Button: return ("Button");

	lea	rax, OFFSET FLAT:??_C@_06LKBCGDFD@Button@
	jmp	$LN1@GetStyleCo
$LN26@GetStyleCo:

; 5014 : 	case ImGuiCol_ButtonHovered: return ("ButtonHovered");

	lea	rax, OFFSET FLAT:??_C@_0O@HBCGNIAI@ButtonHovered@
	jmp	$LN1@GetStyleCo
$LN27@GetStyleCo:

; 5015 : 	case ImGuiCol_ButtonActive: return ("ButtonActive");

	lea	rax, OFFSET FLAT:??_C@_0N@IMHOFKJ@ButtonActive@
	jmp	$LN1@GetStyleCo
$LN28@GetStyleCo:

; 5016 : 	case ImGuiCol_Header: return ("Header");

	lea	rax, OFFSET FLAT:??_C@_06OENKJGA@Header@
	jmp	$LN1@GetStyleCo
$LN29@GetStyleCo:

; 5017 : 	case ImGuiCol_HeaderHovered: return ("HeaderHovered");

	lea	rax, OFFSET FLAT:??_C@_0O@HAINNLMC@HeaderHovered@
	jmp	$LN1@GetStyleCo
$LN30@GetStyleCo:

; 5018 : 	case ImGuiCol_HeaderActive: return ("HeaderActive");

	lea	rax, OFFSET FLAT:??_C@_0N@HILFCJOI@HeaderActive@
	jmp	$LN1@GetStyleCo
$LN31@GetStyleCo:

; 5019 : 	case ImGuiCol_Separator: return ("Separator");

	lea	rax, OFFSET FLAT:??_C@_09IBFEOKHN@Separator@
	jmp	$LN1@GetStyleCo
$LN32@GetStyleCo:

; 5020 : 	case ImGuiCol_SeparatorHovered: return ("SeparatorHovered");

	lea	rax, OFFSET FLAT:??_C@_0BB@CHICANJA@SeparatorHovered@
	jmp	$LN1@GetStyleCo
$LN33@GetStyleCo:

; 5021 : 	case ImGuiCol_SeparatorActive: return ("SeparatorActive");

	lea	rax, OFFSET FLAT:??_C@_0BA@BPNGFOJM@SeparatorActive@
	jmp	$LN1@GetStyleCo
$LN34@GetStyleCo:

; 5022 : 	case ImGuiCol_ResizeGrip: return ("ResizeGrip");

	lea	rax, OFFSET FLAT:??_C@_0L@NGBDNFNJ@ResizeGrip@
	jmp	$LN1@GetStyleCo
$LN35@GetStyleCo:

; 5023 : 	case ImGuiCol_ResizeGripHovered: return ("ResizeGripHovered");

	lea	rax, OFFSET FLAT:??_C@_0BC@NNEDPMNH@ResizeGripHovered@
	jmp	$LN1@GetStyleCo
$LN36@GetStyleCo:

; 5024 : 	case ImGuiCol_ResizeGripActive: return ("ResizeGripActive");

	lea	rax, OFFSET FLAT:??_C@_0BB@NBBKHKIC@ResizeGripActive@
	jmp	$LN1@GetStyleCo
$LN37@GetStyleCo:

; 5025 : 	case ImGuiCol_Tab: return ("Tab");

	lea	rax, OFFSET FLAT:??_C@_03IEAKBACE@Tab@
	jmp	$LN1@GetStyleCo
$LN38@GetStyleCo:

; 5026 : 	case ImGuiCol_TabHovered: return ("TabHovered");

	lea	rax, OFFSET FLAT:??_C@_0L@JFDLBKBD@TabHovered@
	jmp	SHORT $LN1@GetStyleCo
$LN39@GetStyleCo:

; 5027 : 	case ImGuiCol_TabActive: return ("TabActive");

	lea	rax, OFFSET FLAT:??_C@_09BLMKPFCF@TabActive@
	jmp	SHORT $LN1@GetStyleCo
$LN40@GetStyleCo:

; 5028 : 	case ImGuiCol_TabUnfocused: return ("TabUnfocused");

	lea	rax, OFFSET FLAT:??_C@_0N@KLEENDFP@TabUnfocused@
	jmp	SHORT $LN1@GetStyleCo
$LN41@GetStyleCo:

; 5029 : 	case ImGuiCol_TabUnfocusedActive: return ("TabUnfocusedActive");

	lea	rax, OFFSET FLAT:??_C@_0BD@JMEALEPP@TabUnfocusedActive@
	jmp	SHORT $LN1@GetStyleCo
$LN42@GetStyleCo:

; 5030 : 	case ImGuiCol_PlotLines: return ("PlotLines");

	lea	rax, OFFSET FLAT:??_C@_09HDJFFJLL@PlotLines@
	jmp	SHORT $LN1@GetStyleCo
$LN43@GetStyleCo:

; 5031 : 	case ImGuiCol_PlotLinesHovered: return ("PlotLinesHovered");

	lea	rax, OFFSET FLAT:??_C@_0BB@OMALNJLN@PlotLinesHovered@
	jmp	SHORT $LN1@GetStyleCo
$LN44@GetStyleCo:

; 5032 : 	case ImGuiCol_PlotHistogram: return ("PlotHistogram");

	lea	rax, OFFSET FLAT:??_C@_0O@EEKOCENA@PlotHistogram@
	jmp	SHORT $LN1@GetStyleCo
$LN45@GetStyleCo:

; 5033 : 	case ImGuiCol_PlotHistogramHovered: return ("PlotHistogramHovered");

	lea	rax, OFFSET FLAT:??_C@_0BF@GJALJGDC@PlotHistogramHovered@
	jmp	SHORT $LN1@GetStyleCo
$LN46@GetStyleCo:

; 5034 : 	case ImGuiCol_TextSelectedBg: return ("TextSelectedBg");

	lea	rax, OFFSET FLAT:??_C@_0P@IBBLAEBJ@TextSelectedBg@
	jmp	SHORT $LN1@GetStyleCo
$LN47@GetStyleCo:

; 5035 : 	case ImGuiCol_DragDropTarget: return ("DragDropTarget");

	lea	rax, OFFSET FLAT:??_C@_0P@GDDMCLOI@DragDropTarget@
	jmp	SHORT $LN1@GetStyleCo
$LN48@GetStyleCo:

; 5036 : 	case ImGuiCol_NavHighlight: return ("NavHighlight");

	lea	rax, OFFSET FLAT:??_C@_0N@ENCIHEPH@NavHighlight@
	jmp	SHORT $LN1@GetStyleCo
$LN49@GetStyleCo:

; 5037 : 	case ImGuiCol_NavWindowingHighlight: return ("NavWindowingHighlight");

	lea	rax, OFFSET FLAT:??_C@_0BG@MCGDEFOI@NavWindowingHighlight@
	jmp	SHORT $LN1@GetStyleCo
$LN50@GetStyleCo:

; 5038 : 	case ImGuiCol_NavWindowingDimBg: return ("NavWindowingDimBg");

	lea	rax, OFFSET FLAT:??_C@_0BC@JHKONDGH@NavWindowingDimBg@
	jmp	SHORT $LN1@GetStyleCo
$LN51@GetStyleCo:

; 5039 : 	case ImGuiCol_ModalWindowDimBg: return ("ModalWindowDimBg");

	lea	rax, OFFSET FLAT:??_C@_0BB@JOEAHKNC@ModalWindowDimBg@
	jmp	SHORT $LN1@GetStyleCo
$LN2@GetStyleCo:

; 5040 : 	}
; 5041 : 	IM_ASSERT(0);
; 5042 : 	return ("Unknown");

	lea	rax, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
$LN1@GetStyleCo:

; 5043 : }

	add	rsp, 24
	ret	0
	npad	2
$LN53@GetStyleCo:
	DD	$LN4@GetStyleCo
	DD	$LN5@GetStyleCo
	DD	$LN6@GetStyleCo
	DD	$LN7@GetStyleCo
	DD	$LN8@GetStyleCo
	DD	$LN9@GetStyleCo
	DD	$LN10@GetStyleCo
	DD	$LN11@GetStyleCo
	DD	$LN12@GetStyleCo
	DD	$LN13@GetStyleCo
	DD	$LN14@GetStyleCo
	DD	$LN15@GetStyleCo
	DD	$LN16@GetStyleCo
	DD	$LN17@GetStyleCo
	DD	$LN18@GetStyleCo
	DD	$LN19@GetStyleCo
	DD	$LN20@GetStyleCo
	DD	$LN21@GetStyleCo
	DD	$LN22@GetStyleCo
	DD	$LN23@GetStyleCo
	DD	$LN24@GetStyleCo
	DD	$LN25@GetStyleCo
	DD	$LN26@GetStyleCo
	DD	$LN27@GetStyleCo
	DD	$LN28@GetStyleCo
	DD	$LN29@GetStyleCo
	DD	$LN30@GetStyleCo
	DD	$LN31@GetStyleCo
	DD	$LN32@GetStyleCo
	DD	$LN33@GetStyleCo
	DD	$LN34@GetStyleCo
	DD	$LN35@GetStyleCo
	DD	$LN36@GetStyleCo
	DD	$LN37@GetStyleCo
	DD	$LN38@GetStyleCo
	DD	$LN39@GetStyleCo
	DD	$LN40@GetStyleCo
	DD	$LN41@GetStyleCo
	DD	$LN42@GetStyleCo
	DD	$LN43@GetStyleCo
	DD	$LN44@GetStyleCo
	DD	$LN45@GetStyleCo
	DD	$LN46@GetStyleCo
	DD	$LN47@GetStyleCo
	DD	$LN48@GetStyleCo
	DD	$LN49@GetStyleCo
	DD	$LN50@GetStyleCo
	DD	$LN51@GetStyleCo
?GetStyleColorName@ImGui@@YAPEBDH@Z ENDP		; ImGui::GetStyleColorName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ PROC ; ImGui::GetDrawListSharedData

; 2192 : 	return &GImGui->DrawListSharedData;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 6416				; 00001910H

; 2193 : }

	ret	0
?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ ENDP ; ImGui::GetDrawListSharedData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetOverlayDrawList@ImGui@@YAPEAUImDrawList@@XZ PROC	; ImGui::GetOverlayDrawList

; 2187 : 	return &GImGui->OverlayDrawList;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 7336				; 00001ca8H

; 2188 : }

	ret	0
?GetOverlayDrawList@ImGui@@YAPEAUImDrawList@@XZ ENDP	; ImGui::GetOverlayDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetFrameCount@ImGui@@YAHXZ PROC			; ImGui::GetFrameCount

; 2176 : 	return GImGui->FrameCount;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	eax, DWORD PTR [rax+6552]

; 2177 : }

	ret	0
?GetFrameCount@ImGui@@YAHXZ ENDP			; ImGui::GetFrameCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetTime@ImGui@@YANXZ PROC				; ImGui::GetTime

; 2171 : 	return GImGui->Time;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movsd	xmm0, QWORD PTR [rax+6576]

; 2172 : }

	ret	0
?GetTime@ImGui@@YANXZ ENDP				; ImGui::GetTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv74 = 40
$T1 = 48
rect_min$ = 80
rect_max$ = 88
?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z PROC		; ImGui::IsRectVisible

; 5655 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5656 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5657 : 	return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR rect_max$[rsp]
	mov	rdx, QWORD PTR rect_min$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	rdx, rax
	mov	rcx, QWORD PTR tv74[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps

; 5658 : }

	add	rsp, 72					; 00000048H
	ret	0
?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z ENDP		; ImGui::IsRectVisible
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv82 = 40
$T1 = 48
$T2 = 56
size$ = 96
?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z PROC		; ImGui::IsRectVisible

; 5649 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 5650 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5651 : 	return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	rdx, rax
	mov	rcx, QWORD PTR tv82[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps

; 5652 : }

	add	rsp, 88					; 00000058H
	ret	0
?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z ENDP		; ImGui::IsRectVisible
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?SetItemAllowOverlap@ImGui@@YAXXZ PROC			; ImGui::SetItemAllowOverlap

; 3399 : {

$LN5:
	sub	rsp, 24

; 3400 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3401 : 	if (g.HoveredId == g.CurrentWindow->DC.LastItemId)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rcx, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+412]
	cmp	DWORD PTR [rcx+6696], eax
	jne	SHORT $LN2@SetItemAll

; 3402 : 		g.HoveredIdAllowOverlap = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6700], 1
$LN2@SetItemAll:

; 3403 : 	if (g.ActiveId == g.CurrentWindow->DC.LastItemId)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rcx, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+412]
	cmp	DWORD PTR [rcx+6704], eax
	jne	SHORT $LN3@SetItemAll

; 3404 : 		g.ActiveIdAllowOverlap = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6753], 1
$LN3@SetItemAll:

; 3405 : }

	add	rsp, 24
	ret	0
?SetItemAllowOverlap@ImGui@@YAXXZ ENDP			; ImGui::SetItemAllowOverlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv71 = 40
__$ReturnUdt$ = 64
?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetItemRectSize

; 3420 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3421 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 3422 : 	return window->DC.LastItemRect.GetSize();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	QWORD PTR tv71[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3423 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetItemRectSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetItemRectMax

; 3414 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3415 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 3416 : 	return window->DC.LastItemRect.Max;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+376]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3417 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetItemRectMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetItemRectMin

; 3408 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3409 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 3410 : 	return window->DC.LastItemRect.Min;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+368]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3411 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetItemRectMin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 0
g$ = 8
?IsAnyItemFocused@ImGui@@YA_NXZ PROC			; ImGui::IsAnyItemFocused

; 3380 : {

$LN5:
	sub	rsp, 24

; 3381 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3382 : 	return g.NavId != 0 && !g.NavDisableHighlight;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	je	SHORT $LN3@IsAnyItemF
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN3@IsAnyItemF
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@IsAnyItemF
$LN3@IsAnyItemF:
	mov	DWORD PTR tv69[rsp], 0
$LN4@IsAnyItemF:
	movzx	eax, BYTE PTR tv69[rsp]

; 3383 : }

	add	rsp, 24
	ret	0
?IsAnyItemFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyItemFocused
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv66 = 0
g$ = 8
?IsAnyItemActive@ImGui@@YA_NXZ PROC			; ImGui::IsAnyItemActive

; 3374 : {

$LN5:
	sub	rsp, 24

; 3375 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3376 : 	return g.ActiveId != 0;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN3@IsAnyItemA
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@IsAnyItemA
$LN3@IsAnyItemA:
	mov	DWORD PTR tv66[rsp], 0
$LN4@IsAnyItemA:
	movzx	eax, BYTE PTR tv66[rsp]

; 3377 : }

	add	rsp, 24
	ret	0
?IsAnyItemActive@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyItemActive
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv68 = 0
g$ = 8
?IsAnyItemHovered@ImGui@@YA_NXZ PROC			; ImGui::IsAnyItemHovered

; 3368 : {

$LN5:
	sub	rsp, 24

; 3369 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3370 : 	return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	jne	SHORT $LN3@IsAnyItemH
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6724], 0
	jne	SHORT $LN3@IsAnyItemH
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN4@IsAnyItemH
$LN3@IsAnyItemH:
	mov	DWORD PTR tv68[rsp], 1
$LN4@IsAnyItemH:
	movzx	eax, BYTE PTR tv68[rsp]

; 3371 : }

	add	rsp, 24
	ret	0
?IsAnyItemHovered@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyItemHovered
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv75 = 32
g$ = 40
?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ PROC		; ImGui::IsItemDeactivatedAfterEdit

; 3347 : {

$LN7:
	sub	rsp, 56					; 00000038H

; 3348 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3349 : 	return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));

	call	?IsItemDeactivated@ImGui@@YA_NXZ	; ImGui::IsItemDeactivated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@IsItemDeac
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6800]
	test	eax, eax
	jne	SHORT $LN4@IsItemDeac
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	SHORT $LN3@IsItemDeac
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6732]
	test	eax, eax
	je	SHORT $LN5@IsItemDeac
$LN4@IsItemDeac:
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN6@IsItemDeac
$LN5@IsItemDeac:
$LN3@IsItemDeac:
	mov	DWORD PTR tv75[rsp], 0
$LN6@IsItemDeac:
	movzx	eax, BYTE PTR tv75[rsp]

; 3350 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ ENDP		; ImGui::IsItemDeactivatedAfterEdit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv75 = 0
g$ = 8
window$ = 16
?IsItemDeactivated@ImGui@@YA_NXZ PROC			; ImGui::IsItemDeactivated

; 3340 : {

$LN5:
	sub	rsp, 40					; 00000028H

; 3341 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3342 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 3343 : 	return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+6708], ecx
	jne	SHORT $LN3@IsItemDeac
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6708], 0
	je	SHORT $LN3@IsItemDeac
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN3@IsItemDeac
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@IsItemDeac
$LN3@IsItemDeac:
	mov	DWORD PTR tv75[rsp], 0
$LN4@IsItemDeac:
	movzx	eax, BYTE PTR tv75[rsp]

; 3344 : }

	add	rsp, 40					; 00000028H
	ret	0
?IsItemDeactivated@ImGui@@YA_NXZ ENDP			; ImGui::IsItemDeactivated
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
window$1 = 8
?IsItemActivated@ImGui@@YA_NXZ PROC			; ImGui::IsItemActivated

; 3328 : {

$LN5:
	sub	rsp, 24

; 3329 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3330 : 	if (g.ActiveId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN2@IsItemActi

; 3331 : 	{
; 3332 : 		ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$1[rsp], rax

; 3333 : 		if (g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$1[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN3@IsItemActi
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$1[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+6708], ecx
	je	SHORT $LN3@IsItemActi

; 3334 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsItemActi
$LN3@IsItemActi:
$LN2@IsItemActi:

; 3335 : 	}
; 3336 : 	return false;

	xor	al, al
$LN1@IsItemActi:

; 3337 : }

	add	rsp, 24
	ret	0
?IsItemActivated@ImGui@@YA_NXZ ENDP			; ImGui::IsItemActivated
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 32
window$ = 40
?IsItemEdited@ImGui@@YA_NXZ PROC			; ImGui::IsItemEdited

; 3392 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 3393 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 3394 : 	return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN3@IsItemEdit
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@IsItemEdit
$LN3@IsItemEdit:
	mov	DWORD PTR tv69[rsp], 0
$LN4@IsItemEdit:
	movzx	eax, BYTE PTR tv69[rsp]

; 3395 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsItemEdited@ImGui@@YA_NXZ ENDP			; ImGui::IsItemEdited
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv72 = 40
?IsItemVisible@ImGui@@YA_NXZ PROC			; ImGui::IsItemVisible

; 3386 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 3387 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 3388 : 	return window->ClipRect.Overlaps(window->DC.LastItemRect);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv72[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps

; 3389 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsItemVisible@ImGui@@YA_NXZ ENDP			; ImGui::IsItemVisible
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv73 = 32
mouse_button$ = 64
?IsItemClicked@ImGui@@YA_NH@Z PROC			; ImGui::IsItemClicked

; 3363 : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 3364 : 	return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);

	xor	edx, edx
	mov	ecx, DWORD PTR mouse_button$[rsp]
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@IsItemClic
	xor	ecx, ecx
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@IsItemClic
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN4@IsItemClic
$LN3@IsItemClic:
	mov	DWORD PTR tv73[rsp], 0
$LN4@IsItemClic:
	movzx	eax, BYTE PTR tv73[rsp]

; 3365 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsItemClicked@ImGui@@YA_NH@Z ENDP			; ImGui::IsItemClicked
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
window$ = 8
?IsItemFocused@ImGui@@YA_NXZ PROC			; ImGui::IsItemFocused

; 3353 : {

$LN5:
	sub	rsp, 24

; 3354 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3355 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 3356 : 
; 3357 : 	if (g.NavId == 0 || g.NavDisableHighlight || g.NavId != window->DC.LastItemId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	je	SHORT $LN3@IsItemFocu
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN3@IsItemFocu
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+7040], ecx
	je	SHORT $LN2@IsItemFocu
$LN3@IsItemFocu:

; 3358 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsItemFocu
$LN2@IsItemFocu:

; 3359 : 	return true;

	mov	al, 1
$LN1@IsItemFocu:

; 3360 : }

	add	rsp, 24
	ret	0
?IsItemFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsItemFocused
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 0
g$ = 8
window$1 = 16
?IsItemActive@ImGui@@YA_NXZ PROC			; ImGui::IsItemActive

; 3317 : {

$LN6:
	sub	rsp, 40					; 00000028H

; 3318 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3319 : 	if (g.ActiveId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN2@IsItemActi

; 3320 : 	{
; 3321 : 		ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$1[rsp], rax

; 3322 : 		return g.ActiveId == window->DC.LastItemId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$1[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN4@IsItemActi
	mov	DWORD PTR tv71[rsp], 1
	jmp	SHORT $LN5@IsItemActi
$LN4@IsItemActi:
	mov	DWORD PTR tv71[rsp], 0
$LN5@IsItemActi:
	movzx	eax, BYTE PTR tv71[rsp]
	jmp	SHORT $LN1@IsItemActi
$LN2@IsItemActi:

; 3323 : 	}
; 3324 : 	return false;

	xor	al, al
$LN1@IsItemActi:

; 3325 : }

	add	rsp, 40					; 00000028H
	ret	0
?IsItemActive@ImGui@@YA_NXZ ENDP			; ImGui::IsItemActive
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
g$ = 40
flags$ = 64
?IsItemHovered@ImGui@@YA_NH@Z PROC			; ImGui::IsItemHovered

; 1932 : {

$LN11:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 1933 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1934 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1935 : 	if (g.NavDisableMouseHover && !g.NavDisableHighlight)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	SHORT $LN2@IsItemHove
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN2@IsItemHove

; 1936 : 		return IsItemFocused();

	call	?IsItemFocused@ImGui@@YA_NXZ		; ImGui::IsItemFocused
	jmp	$LN1@IsItemHove
$LN2@IsItemHove:

; 1937 : 
; 1938 : 	// Test for bounding box overlap, as updated as ItemAdd()
; 1939 : 	if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN3@IsItemHove

; 1940 : 		return false;

	xor	al, al
	jmp	$LN1@IsItemHove
$LN3@IsItemHove:

; 1941 : 	IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function
; 1942 : 
; 1943 : 	// Test if we are hovering the right window (our window could be behind another window)
; 1944 : 	// [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
; 1945 : 	// Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
; 1946 : 	//if (g.HoveredWindow != window)
; 1947 : 	//    return false;
; 1948 : 	if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rcx+688]
	cmp	QWORD PTR [rax+6688], rcx
	je	SHORT $LN4@IsItemHove
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN4@IsItemHove

; 1949 : 		return false;

	xor	al, al
	jmp	$LN1@IsItemHove
$LN4@IsItemHove:

; 1950 : 
; 1951 : 	// Test if another item is active (e.g. being dragged)
; 1952 : 	if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN5@IsItemHove

; 1953 : 		if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN6@IsItemHove
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN6@IsItemHove
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6753]
	test	eax, eax
	jne	SHORT $LN6@IsItemHove
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+68]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN6@IsItemHove

; 1954 : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsItemHove
$LN6@IsItemHove:
$LN5@IsItemHove:

; 1955 : 
; 1956 : 	// Test if interactions on this window are blocked by an active popup or modal
; 1957 : 	if (!IsWindowContentHoverable(window, flags))

	mov	edx, DWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z ; IsWindowContentHoverable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@IsItemHove

; 1958 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsItemHove
$LN7@IsItemHove:

; 1959 : 
; 1960 : 	// Test if the item is disabled
; 1961 : 	if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN8@IsItemHove
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN8@IsItemHove

; 1962 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsItemHove
$LN8@IsItemHove:

; 1963 : 
; 1964 : 	// Special handling for the dummy item after Begin() which represent the title bar or tab. 
; 1965 : 	// When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
; 1966 : 	if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+68]
	cmp	DWORD PTR [rax+412], ecx
	jne	SHORT $LN9@IsItemHove
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	test	eax, eax
	je	SHORT $LN9@IsItemHove

; 1967 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsItemHove
$LN9@IsItemHove:

; 1968 : 	return true;

	mov	al, 1
$LN1@IsItemHove:

; 1969 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsItemHovered@ImGui@@YA_NH@Z ENDP			; ImGui::IsItemHovered
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
offset$ = 64
?SetKeyboardFocusHere@ImGui@@YAXH@Z PROC		; ImGui::SetKeyboardFocusHere

; 5563 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 5564 : 	IM_ASSERT(offset >= -1);    // -1 is allowed but not below
; 5565 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5566 : 	window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+944]
	mov	ecx, DWORD PTR offset$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+952], eax

; 5567 : 	window->FocusIdxTabRequestNext = INT_MAX;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+964], 2147483647		; 7fffffffH

; 5568 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetKeyboardFocusHere@ImGui@@YAXH@Z ENDP		; ImGui::SetKeyboardFocusHere
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
tv146 = 48
tv144 = 56
$T1 = 64
$T2 = 72
$T3 = 80
?SetItemDefaultFocus@ImGui@@YAXXZ PROC			; ImGui::SetItemDefaultFocus

; 5571 : {

$LN7:
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 5572 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5573 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5574 : 	if (!window->Appearing)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+133]
	test	eax, eax
	jne	SHORT $LN2@SetItemDef

; 5575 : 		return;

	jmp	$LN1@SetItemDef
$LN2@SetItemDef:

; 5576 : 	if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rcx+888]
	cmp	QWORD PTR [rax+7024], rcx
	jne	$LN3@SetItemDef
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7168]
	test	eax, eax
	jne	SHORT $LN4@SetItemDef
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7148], 0
	je	$LN3@SetItemDef
$LN4@SetItemDef:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+400]
	cmp	DWORD PTR [rcx+7132], eax
	jne	$LN3@SetItemDef

; 5577 : 	{
; 5578 : 		g.NavInitRequest = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7168], 0

; 5579 : 		g.NavInitResultId = g.NavWindow->DC.LastItemId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+412]
	mov	DWORD PTR [rcx+7148], eax

; 5580 : 		g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	add	rcx, 376				; 00000178H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv146[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	add	rcx, 368				; 00000170H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv144[rsp], rax
	mov	r8, QWORD PTR tv146[rsp]
	mov	rdx, QWORD PTR tv144[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	rcx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rcx+7152]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 5581 : 		NavUpdateAnyRequestFlag();

	call	?NavUpdateAnyRequestFlag@ImGui@@YAXXZ	; ImGui::NavUpdateAnyRequestFlag
	npad	1

; 5582 : 		if (!IsItemVisible())

	call	?IsItemVisible@ImGui@@YA_NXZ		; ImGui::IsItemVisible
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@SetItemDef

; 5583 : 			SetScrollHereY();

	movss	xmm0, DWORD PTR __real@3f000000
	call	?SetScrollHereY@ImGui@@YAXM@Z		; ImGui::SetScrollHereY
	npad	1
$LN5@SetItemDef:
$LN3@SetItemDef:
$LN1@SetItemDef:

; 5584 : 	}
; 5585 : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?SetItemDefaultFocus@ImGui@@YAXXZ ENDP			; ImGui::SetItemDefaultFocus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
?PopClipRect@ImGui@@YAXXZ PROC				; ImGui::PopClipRect

; 2863 : {

$LN3:
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 2864 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2865 : 	window->DrawList->PopClipRect();

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?PopClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::PopClipRect
	npad	1

; 2866 : 	window->ClipRect = window->DrawList->_ClipRectStack.back();

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ; ImVector<ImVec4>::back
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect
	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	lea	rdi, QWORD PTR [rax+248]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 2867 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?PopClipRect@ImGui@@YAXXZ ENDP				; ImGui::PopClipRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv71 = 40
$T1 = 48
clip_rect_min$ = 96
clip_rect_max$ = 104
intersect_with_current_clip_rect$ = 112
?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z PROC		; ImGui::PushClipRect

; 2856 : {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 2857 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2858 : 	window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv71[rsp], rax
	movzx	r9d, BYTE PTR intersect_with_current_clip_rect$[rsp]
	mov	rax, QWORD PTR clip_rect_max$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR clip_rect_min$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z ; ImDrawList::PushClipRect
	npad	1

; 2859 : 	window->ClipRect = window->DrawList->_ClipRectStack.back();

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ; ImVector<ImVec4>::back
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect
	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	lea	rdi, QWORD PTR [rax+248]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 2860 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ENDP		; ImGui::PushClipRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
tv68 = 8
?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ PROC	; ImGui::GetDragDropPayload

; 7869 : {

$LN5:
	sub	rsp, 24

; 7870 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7871 : 	return g.DragDropActive ? &g.DragDropPayload : NULL;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN3@GetDragDro
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7616				; 00001dc0H
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN4@GetDragDro
$LN3@GetDragDro:
	mov	QWORD PTR tv68[rsp], 0
$LN4@GetDragDro:
	mov	rax, QWORD PTR tv68[rsp]

; 7872 : }

	add	rsp, 24
	ret	0
?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ ENDP	; ImGui::GetDragDropPayload
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?EndDragDropTarget@ImGui@@YAXXZ PROC			; ImGui::EndDragDropTarget

; 7876 : {

$LN3:
	sub	rsp, 24

; 7877 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7878 : 	IM_ASSERT(g.DragDropActive);
; 7879 : 	IM_ASSERT(g.DragDropWithinSourceOrTarget);
; 7880 : 	g.DragDropWithinSourceOrTarget = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 0

; 7881 : }

	add	rsp, 24
	ret	0
?EndDragDropTarget@ImGui@@YAXXZ ENDP			; ImGui::EndDragDropTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv75 = 64
push_clip_rect$1 = 65
was_accepted_previously$ = 66
g$ = 72
payload$ = 80
r_surface$ = 88
tv140 = 92
tv200 = 96
window$ = 104
r$ = 112
tv79 = 128
tv183 = 132
tv137 = 136
$T2 = 144
$T3 = 152
$T4 = 160
$T5 = 168
tv170 = 176
tv185 = 184
$T6 = 192
$T7 = 200
$T8 = 208
$T9 = 216
type$ = 256
flags$ = 264
?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z PROC ; ImGui::AcceptDragDropPayload

; 7826 : {

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 7827 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7828 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 7829 : 	ImGuiPayload& payload = g.DragDropPayload;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7616				; 00001dc0H
	mov	QWORD PTR payload$[rsp], rax

; 7830 : 	IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
; 7831 : 	IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
; 7832 : 	if (type != NULL && !payload.IsDataType(type))

	cmp	QWORD PTR type$[rsp], 0
	je	SHORT $LN2@AcceptDrag
	mov	rdx, QWORD PTR type$[rsp]
	mov	rcx, QWORD PTR payload$[rsp]
	call	?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z	; ImGuiPayload::IsDataType
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@AcceptDrag

; 7833 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@AcceptDrag
$LN2@AcceptDrag:

; 7834 : 
; 7835 : 	// Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
; 7836 : 	// NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
; 7837 : 	const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7700]
	cmp	DWORD PTR [rax+7736], ecx
	jne	SHORT $LN9@AcceptDrag
	mov	BYTE PTR tv75[rsp], 1
	jmp	SHORT $LN10@AcceptDrag
$LN9@AcceptDrag:
	mov	BYTE PTR tv75[rsp], 0
$LN10@AcceptDrag:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR was_accepted_previously$[rsp], al

; 7838 : 	ImRect r = g.DragDropTargetRect;

	lea	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+7680]
	mov	ecx, 16
	rep movsb

; 7839 : 	float r_surface = r.GetWidth() * r.GetHeight();

	lea	rcx, QWORD PTR r$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv79[rsp], xmm0
	lea	rcx, QWORD PTR r$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	xmm1, DWORD PTR tv79[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR r_surface$[rsp], xmm0

; 7840 : 	if (r_surface < g.DragDropAcceptIdCurrRectSurface)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7696]
	comiss	xmm0, DWORD PTR r_surface$[rsp]
	jbe	SHORT $LN3@AcceptDrag

; 7841 : 	{
; 7842 : 		g.DragDropAcceptFlags = flags;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+7704], ecx

; 7843 : 		g.DragDropAcceptIdCurr = g.DragDropTargetId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7700]
	mov	DWORD PTR [rax+7708], ecx

; 7844 : 		g.DragDropAcceptIdCurrRectSurface = r_surface;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR r_surface$[rsp]
	movss	DWORD PTR [rax+7696], xmm0
$LN3@AcceptDrag:

; 7845 : 	}
; 7846 : 
; 7847 : 	// Render default drop visuals
; 7848 : 	payload.Preview = was_accepted_previously;

	mov	rax, QWORD PTR payload$[rsp]
	movzx	ecx, BYTE PTR was_accepted_previously$[rsp]
	mov	BYTE PTR [rax+57], cl

; 7849 : 	flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7608]
	and	eax, 2048				; 00000800H
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 7850 : 	if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	jne	$LN4@AcceptDrag
	mov	rax, QWORD PTR payload$[rsp]
	movzx	eax, BYTE PTR [rax+57]
	test	eax, eax
	je	$LN4@AcceptDrag

; 7851 : 	{
; 7852 : 		// FIXME-DRAG: Settle on a proper default visuals for drop target.
; 7853 : 		r.Expand(3.5f);

	movss	xmm1, DWORD PTR __real@40600000
	lea	rcx, QWORD PTR r$[rsp]
	call	?Expand@ImRect@@QEAAXM@Z		; ImRect::Expand

; 7854 : 		bool push_clip_rect = !window->ClipRect.Contains(r);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	QWORD PTR tv137[rsp], rax
	lea	rdx, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR tv137[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@AcceptDrag
	mov	DWORD PTR tv140[rsp], 1
	jmp	SHORT $LN12@AcceptDrag
$LN11@AcceptDrag:
	mov	DWORD PTR tv140[rsp], 0
$LN12@AcceptDrag:
	movzx	eax, BYTE PTR tv140[rsp]
	mov	BYTE PTR push_clip_rect$1[rsp], al

; 7855 : 		if (push_clip_rect) window->DrawList->PushClipRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1));

	movzx	eax, BYTE PTR push_clip_rect$1[rsp]
	test	eax, eax
	je	$LN5@AcceptDrag
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv170[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR r$[rsp+8]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T4[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR r$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T5[rsp], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR $T4[rsp]
	mov	rdx, QWORD PTR $T5[rsp]
	mov	rcx, QWORD PTR tv170[rsp]
	call	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z ; ImDrawList::PushClipRect
	npad	1
$LN5@AcceptDrag:

; 7856 : 		window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv185[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 43					; 0000002bH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv183[rsp], eax
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], -1
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv183[rsp]
	lea	r8, QWORD PTR r$[rsp+8]
	lea	rdx, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1

; 7857 : 		if (push_clip_rect) window->DrawList->PopClipRect();

	movzx	eax, BYTE PTR push_clip_rect$1[rsp]
	test	eax, eax
	je	SHORT $LN6@AcceptDrag
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?PopClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::PopClipRect
	npad	1
$LN6@AcceptDrag:
$LN4@AcceptDrag:

; 7858 : 	}
; 7859 : 
; 7860 : 	g.DragDropAcceptFrameCount = g.FrameCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+7740], ecx

; 7861 : 	payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()

	movzx	eax, BYTE PTR was_accepted_previously$[rsp]
	test	eax, eax
	je	SHORT $LN13@AcceptDrag
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7604]
	call	?IsMouseDown@ImGui@@YA_NH@Z		; ImGui::IsMouseDown
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@AcceptDrag
	mov	DWORD PTR tv200[rsp], 1
	jmp	SHORT $LN14@AcceptDrag
$LN13@AcceptDrag:
	mov	DWORD PTR tv200[rsp], 0
$LN14@AcceptDrag:
	mov	rax, QWORD PTR payload$[rsp]
	movzx	ecx, BYTE PTR tv200[rsp]
	mov	BYTE PTR [rax+58], cl

; 7862 : 	if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))

	mov	rax, QWORD PTR payload$[rsp]
	movzx	eax, BYTE PTR [rax+58]
	test	eax, eax
	jne	SHORT $LN7@AcceptDrag
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $LN7@AcceptDrag

; 7863 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AcceptDrag
$LN7@AcceptDrag:

; 7864 : 
; 7865 : 	return &payload;

	mov	rax, QWORD PTR payload$[rsp]
$LN1@AcceptDrag:

; 7866 : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z ENDP ; ImGui::AcceptDragDropPayload
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
g$ = 40
window$ = 48
tv86 = 56
display_rect$ = 64
$T1 = 72
?BeginDragDropTarget@ImGui@@YA_NXZ PROC			; ImGui::BeginDragDropTarget

; 7794 : {

$LN11:
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 7795 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7796 : 	if (!g.DragDropActive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	jne	SHORT $LN2@BeginDragD

; 7797 : 		return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN2@BeginDragD:

; 7798 : 
; 7799 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 7800 : 	if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN3@BeginDragD

; 7801 : 		return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN3@BeginDragD:

; 7802 : 	if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	je	SHORT $LN5@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR [rcx+688], rax
	je	SHORT $LN4@BeginDragD
$LN5@BeginDragD:

; 7803 : 		return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN4@BeginDragD:

; 7804 : 
; 7805 : 	const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN9@BeginDragD
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 384				; 00000180H
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN10@BeginDragD
$LN9@BeginDragD:
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	QWORD PTR tv86[rsp], rax
$LN10@BeginDragD:
	mov	rax, QWORD PTR tv86[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR display_rect$[rsp], rax

; 7806 : 	ImGuiID id = window->DC.LastItemId;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+412]
	mov	DWORD PTR id$[rsp], eax

; 7807 : 	if (id == 0)

	cmp	DWORD PTR id$[rsp], 0
	jne	SHORT $LN6@BeginDragD

; 7808 : 		id = window->GetIDFromRectangle(display_rect);

	mov	rdx, QWORD PTR display_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z ; ImGuiWindow::GetIDFromRectangle
	mov	DWORD PTR id$[rsp], eax
$LN6@BeginDragD:

; 7809 : 	if (g.DragDropPayload.SourceId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7628], ecx
	jne	SHORT $LN7@BeginDragD

; 7810 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginDragD
$LN7@BeginDragD:

; 7811 : 
; 7812 : 	IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
; 7813 : 	g.DragDropTargetRect = display_rect;

	mov	rax, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rax+7680]
	mov	rsi, QWORD PTR display_rect$[rsp]
	mov	ecx, 16
	rep movsb

; 7814 : 	g.DragDropTargetId = id;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7700], ecx

; 7815 : 	g.DragDropWithinSourceOrTarget = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 1

; 7816 : 	return true;

	mov	al, 1
$LN1@BeginDragD:

; 7817 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?BeginDragDropTarget@ImGui@@YA_NXZ ENDP			; ImGui::BeginDragDropTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
?EndDragDropSource@ImGui@@YAXXZ PROC			; ImGui::EndDragDropSource

; 7709 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 7710 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7711 : 	IM_ASSERT(g.DragDropActive);
; 7712 : 	IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");
; 7713 : 
; 7714 : 	if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7608]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@EndDragDro

; 7715 : 		EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
	npad	1
$LN2@EndDragDro:

; 7716 : 
; 7717 : 	// Discard the drag if have not called SetDragDropPayload()
; 7718 : 	if (g.DragDropPayload.DataFrameCount == -1)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7632], -1
	jne	SHORT $LN3@EndDragDro

; 7719 : 		ClearDragDrop();

	call	?ClearDragDrop@ImGui@@YAXXZ		; ImGui::ClearDragDrop
	npad	1
$LN3@EndDragDro:

; 7720 : 	g.DragDropWithinSourceOrTarget = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 0

; 7721 : }

	add	rsp, 56					; 00000038H
	ret	0
?EndDragDropSource@ImGui@@YAXXZ ENDP			; ImGui::EndDragDropSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv145 = 32
g$ = 40
payload$ = 48
tv77 = 56
tv83 = 64
type$ = 96
data$ = 104
data_size$ = 112
cond$ = 120
?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z PROC	; ImGui::SetDragDropPayload

; 7725 : {

$LN12:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 7726 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7727 : 	ImGuiPayload& payload = g.DragDropPayload;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7616				; 00001dc0H
	mov	QWORD PTR payload$[rsp], rax

; 7728 : 	if (cond == 0)

	cmp	DWORD PTR cond$[rsp], 0
	jne	SHORT $LN2@SetDragDro

; 7729 : 		cond = ImGuiCond_Always;

	mov	DWORD PTR cond$[rsp], 1
$LN2@SetDragDro:

; 7730 : 
; 7731 : 	IM_ASSERT(type != NULL);
; 7732 : 	IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
; 7733 : 	IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
; 7734 : 	IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
; 7735 : 	IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()
; 7736 : 
; 7737 : 	if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)

	cmp	DWORD PTR cond$[rsp], 1
	je	SHORT $LN4@SetDragDro
	mov	rax, QWORD PTR payload$[rsp]
	cmp	DWORD PTR [rax+16], -1
	jne	$LN3@SetDragDro
$LN4@SetDragDro:

; 7738 : 	{
; 7739 : 		// Copy payload
; 7740 : 		ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));

	mov	rax, QWORD PTR payload$[rsp]
	add	rax, 24
	mov	r8d, 33					; 00000021H
	mov	rdx, QWORD PTR type$[rsp]
	mov	rcx, rax
	call	?ImStrncpy@@YAXPEADPEBD_K@Z		; ImStrncpy

; 7741 : 		g.DragDropPayloadBufHeap.resize(0);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7712				; 00001e20H
	mov	QWORD PTR tv77[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv77[rsp]
	call	?resize@?$ImVector@E@@QEAAXH@Z		; ImVector<unsigned char>::resize
	npad	1

; 7742 : 		if (data_size > sizeof(g.DragDropPayloadBufLocal))

	cmp	QWORD PTR data_size$[rsp], 8
	jbe	SHORT $LN5@SetDragDro

; 7743 : 		{
; 7744 : 			// Store in heap
; 7745 : 			g.DragDropPayloadBufHeap.resize((int)data_size);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7712				; 00001e20H
	mov	QWORD PTR tv83[rsp], rax
	mov	edx, DWORD PTR data_size$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	?resize@?$ImVector@E@@QEAAXH@Z		; ImVector<unsigned char>::resize

; 7746 : 			payload.Data = g.DragDropPayloadBufHeap.Data;

	mov	rax, QWORD PTR payload$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7720]
	mov	QWORD PTR [rax], rcx

; 7747 : 			memcpy(payload.Data, data, data_size);

	mov	r8, QWORD PTR data_size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR payload$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy
	npad	1

; 7748 : 		}

	jmp	SHORT $LN6@SetDragDro
$LN5@SetDragDro:

; 7749 : 		else if (data_size > 0)

	cmp	QWORD PTR data_size$[rsp], 0
	jbe	SHORT $LN7@SetDragDro

; 7750 : 		{
; 7751 : 			// Store locally
; 7752 : 			memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7728				; 00001e30H
	mov	r8d, 8
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 7753 : 			payload.Data = g.DragDropPayloadBufLocal;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7728				; 00001e30H
	mov	rcx, QWORD PTR payload$[rsp]
	mov	QWORD PTR [rcx], rax

; 7754 : 			memcpy(payload.Data, data, data_size);

	mov	r8, QWORD PTR data_size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR payload$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy
	npad	1

; 7755 : 		}

	jmp	SHORT $LN8@SetDragDro
$LN7@SetDragDro:

; 7756 : 		else
; 7757 : 		{
; 7758 : 			payload.Data = NULL;

	mov	rax, QWORD PTR payload$[rsp]
	mov	QWORD PTR [rax], 0
$LN8@SetDragDro:
$LN6@SetDragDro:

; 7759 : 		}
; 7760 : 		payload.DataSize = (int)data_size;

	mov	rax, QWORD PTR payload$[rsp]
	mov	ecx, DWORD PTR data_size$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN3@SetDragDro:

; 7761 : 	}
; 7762 : 	payload.DataFrameCount = g.FrameCount;

	mov	rax, QWORD PTR payload$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+16], ecx

; 7763 : 
; 7764 : 	return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	cmp	DWORD PTR [rax+7740], ecx
	je	SHORT $LN10@SetDragDro
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6552]
	dec	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rcx+7740], eax
	je	SHORT $LN10@SetDragDro
	mov	DWORD PTR tv145[rsp], 0
	jmp	SHORT $LN11@SetDragDro
$LN10@SetDragDro:
	mov	DWORD PTR tv145[rsp], 1
$LN11@SetDragDro:
	movzx	eax, BYTE PTR tv145[rsp]

; 7765 : }

	add	rsp, 88					; 00000058H
	ret	0
?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z ENDP	; ImGui::SetDragDropPayload
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
is_hovered$1 = 32
source_drag_active$ = 33
source_id$ = 36
g$ = 40
window$ = 48
mouse_button$ = 56
tv86 = 60
tv129 = 64
source_parent_id$ = 68
payload$2 = 72
tooltip_window$3 = 80
flags$ = 112
?BeginDragDropSource@ImGui@@YA_NH@Z PROC		; ImGui::BeginDragDropSource

; 7611 : {

$LN23:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 7612 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7613 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 7614 : 
; 7615 : 	bool source_drag_active = false;

	mov	BYTE PTR source_drag_active$[rsp], 0

; 7616 : 	ImGuiID source_id = 0;

	mov	DWORD PTR source_id$[rsp], 0

; 7617 : 	ImGuiID source_parent_id = 0;

	mov	DWORD PTR source_parent_id$[rsp], 0

; 7618 : 	int mouse_button = 0;

	mov	DWORD PTR mouse_button$[rsp], 0

; 7619 : 	if (!(flags & ImGuiDragDropFlags_SourceExtern))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16
	test	eax, eax
	jne	$LN2@BeginDragD

; 7620 : 	{
; 7621 : 		source_id = window->DC.LastItemId;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+412]
	mov	DWORD PTR source_id$[rsp], eax

; 7622 : 		if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case

	cmp	DWORD PTR source_id$[rsp], 0
	je	SHORT $LN4@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR source_id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN4@BeginDragD

; 7623 : 			return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN4@BeginDragD:

; 7624 : 		if (g.IO.MouseDown[mouse_button] == false)

	movsxd	rax, DWORD PTR mouse_button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN5@BeginDragD

; 7625 : 			return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN5@BeginDragD:

; 7626 : 
; 7627 : 		if (source_id == 0)

	cmp	DWORD PTR source_id$[rsp], 0
	jne	$LN6@BeginDragD

; 7628 : 		{
; 7629 : 			// If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
; 7630 : 			// A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
; 7631 : 			if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN8@BeginDragD

; 7632 : 			{
; 7633 : 				IM_ASSERT(0);
; 7634 : 				return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN8@BeginDragD:

; 7635 : 			}
; 7636 : 
; 7637 : 			// Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
; 7638 : 			// We build a throwaway ID based on current ID stack + relative AABB of items in window.
; 7639 : 			// THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
; 7640 : 			// We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
; 7641 : 			bool is_hovered = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) != 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@BeginDragD
	mov	DWORD PTR tv86[rsp], 1
	jmp	SHORT $LN22@BeginDragD
$LN21@BeginDragD:
	mov	DWORD PTR tv86[rsp], 0
$LN22@BeginDragD:
	movzx	eax, BYTE PTR tv86[rsp]
	mov	BYTE PTR is_hovered$1[rsp], al

; 7642 : 			if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))

	movzx	eax, BYTE PTR is_hovered$1[rsp]
	test	eax, eax
	jne	SHORT $LN9@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN10@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6744], rcx
	je	SHORT $LN9@BeginDragD
$LN10@BeginDragD:

; 7643 : 				return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN9@BeginDragD:

; 7644 : 			source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z ; ImGuiWindow::GetIDFromRectangle
	mov	DWORD PTR tv129[rsp], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv129[rsp]
	mov	DWORD PTR [rax+412], ecx
	mov	eax, DWORD PTR tv129[rsp]
	mov	DWORD PTR source_id$[rsp], eax

; 7645 : 			if (is_hovered)

	movzx	eax, BYTE PTR is_hovered$1[rsp]
	test	eax, eax
	je	SHORT $LN11@BeginDragD

; 7646 : 				SetHoveredID(source_id);

	mov	ecx, DWORD PTR source_id$[rsp]
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	npad	1
$LN11@BeginDragD:

; 7647 : 			if (is_hovered && g.IO.MouseClicked[mouse_button])

	movzx	eax, BYTE PTR is_hovered$1[rsp]
	test	eax, eax
	je	SHORT $LN12@BeginDragD
	movsxd	rax, DWORD PTR mouse_button$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	SHORT $LN12@BeginDragD

; 7648 : 			{
; 7649 : 				SetActiveID(source_id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR source_id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 7650 : 				FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN12@BeginDragD:

; 7651 : 			}
; 7652 : 			if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR source_id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN13@BeginDragD

; 7653 : 				g.ActiveIdAllowOverlap = is_hovered;

	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR is_hovered$1[rsp]
	mov	BYTE PTR [rax+6753], cl
$LN13@BeginDragD:

; 7654 : 		}

	jmp	SHORT $LN7@BeginDragD
$LN6@BeginDragD:

; 7655 : 		else
; 7656 : 		{
; 7657 : 			g.ActiveIdAllowOverlap = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6753], 0
$LN7@BeginDragD:

; 7658 : 		}
; 7659 : 		if (g.ActiveId != source_id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR source_id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN14@BeginDragD

; 7660 : 			return false;

	xor	al, al
	jmp	$LN1@BeginDragD
$LN14@BeginDragD:

; 7661 : 		source_parent_id = window->IDStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR source_parent_id$[rsp], eax

; 7662 : 		source_drag_active = IsMouseDragging(mouse_button);

	movss	xmm1, DWORD PTR __real@bf800000
	mov	ecx, DWORD PTR mouse_button$[rsp]
	call	?IsMouseDragging@ImGui@@YA_NHM@Z	; ImGui::IsMouseDragging
	mov	BYTE PTR source_drag_active$[rsp], al

; 7663 : 	}

	jmp	SHORT $LN3@BeginDragD
$LN2@BeginDragD:

; 7664 : 	else
; 7665 : 	{
; 7666 : 		window = NULL;

	mov	QWORD PTR window$[rsp], 0

; 7667 : 		source_id = ImHashStr(("#SourceExtern"), 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_0O@KMAIKFAM@?$CDSourceExtern@
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	DWORD PTR source_id$[rsp], eax

; 7668 : 		source_drag_active = true;

	mov	BYTE PTR source_drag_active$[rsp], 1
$LN3@BeginDragD:

; 7669 : 	}
; 7670 : 
; 7671 : 	if (source_drag_active)

	movzx	eax, BYTE PTR source_drag_active$[rsp]
	test	eax, eax
	je	$LN15@BeginDragD

; 7672 : 	{
; 7673 : 		if (!g.DragDropActive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	jne	SHORT $LN16@BeginDragD

; 7674 : 		{
; 7675 : 			IM_ASSERT(source_id != 0);
; 7676 : 			ClearDragDrop();

	call	?ClearDragDrop@ImGui@@YAXXZ		; ImGui::ClearDragDrop

; 7677 : 			ImGuiPayload& payload = g.DragDropPayload;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7616				; 00001dc0H
	mov	QWORD PTR payload$2[rsp], rax

; 7678 : 			payload.SourceId = source_id;

	mov	rax, QWORD PTR payload$2[rsp]
	mov	ecx, DWORD PTR source_id$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 7679 : 			payload.SourceParentId = source_parent_id;

	mov	rax, QWORD PTR payload$2[rsp]
	mov	ecx, DWORD PTR source_parent_id$[rsp]
	mov	DWORD PTR [rax+20], ecx

; 7680 : 			g.DragDropActive = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7596], 1

; 7681 : 			g.DragDropSourceFlags = flags;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+7608], ecx

; 7682 : 			g.DragDropMouseButton = mouse_button;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR mouse_button$[rsp]
	mov	DWORD PTR [rax+7604], ecx
$LN16@BeginDragD:

; 7683 : 		}
; 7684 : 		g.DragDropSourceFrameCount = g.FrameCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+7600], ecx

; 7685 : 		g.DragDropWithinSourceOrTarget = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 1

; 7686 : 
; 7687 : 		if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN17@BeginDragD

; 7688 : 		{
; 7689 : 			// Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
; 7690 : 			// We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
; 7691 : 			BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip
	npad	1

; 7692 : 			if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7736], 0
	je	SHORT $LN18@BeginDragD
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7704]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $LN18@BeginDragD

; 7693 : 			{
; 7694 : 				ImGuiWindow* tooltip_window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR tooltip_window$3[rsp], rax

; 7695 : 				tooltip_window->SkipItems = true;

	mov	rax, QWORD PTR tooltip_window$3[rsp]
	mov	BYTE PTR [rax+115], 1

; 7696 : 				tooltip_window->HiddenFramesRegular = 1;

	mov	rax, QWORD PTR tooltip_window$3[rsp]
	mov	DWORD PTR [rax+188], 1
$LN18@BeginDragD:
$LN17@BeginDragD:

; 7697 : 			}
; 7698 : 		}
; 7699 : 
; 7700 : 		if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN19@BeginDragD
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN19@BeginDragD

; 7701 : 			window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, -2
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+416], eax
$LN19@BeginDragD:

; 7702 : 
; 7703 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@BeginDragD
$LN15@BeginDragD:

; 7704 : 	}
; 7705 : 	return false;

	xor	al, al
$LN1@BeginDragD:

; 7706 : }

	add	rsp, 104				; 00000068H
	ret	0
?BeginDragDropSource@ImGui@@YA_NH@Z ENDP		; ImGui::BeginDragDropSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 32
window$ = 40
?GetColumnsCount@ImGui@@YAHXZ PROC			; ImGui::GetColumnsCount

; 7313 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 7314 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 7315 : 	return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN3@GetColumns
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv71[rsp], eax
	jmp	SHORT $LN4@GetColumns
$LN3@GetColumns:
	mov	DWORD PTR tv71[rsp], 1
$LN4@GetColumns:
	mov	eax, DWORD PTR tv71[rsp]

; 7316 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetColumnsCount@ImGui@@YAHXZ ENDP			; ImGui::GetColumnsCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv75 = 32
preserve_width$ = 33
columns$ = 40
tv83 = 48
tv143 = 52
width$ = 56
g$ = 64
window$ = 72
tv135 = 80
column_index$ = 112
offset$ = 120
?SetColumnOffset@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnOffset

; 7387 : {

$LN10:
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 7388 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7389 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 7390 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7391 : 	IM_ASSERT(columns != NULL);
; 7392 : 
; 7393 : 	if (column_index < 0)

	cmp	DWORD PTR column_index$[rsp], 0
	jge	SHORT $LN2@SetColumnO

; 7394 : 		column_index = columns->Current;

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR column_index$[rsp], eax
$LN2@SetColumnO:

; 7395 : 	IM_ASSERT(column_index < columns->Columns.Size);
; 7396 : 
; 7397 : 	const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count - 1);

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN6@SetColumnO
	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+36]
	dec	eax
	cmp	DWORD PTR column_index$[rsp], eax
	jge	SHORT $LN6@SetColumnO
	mov	BYTE PTR tv75[rsp], 1
	jmp	SHORT $LN7@SetColumnO
$LN6@SetColumnO:
	mov	BYTE PTR tv75[rsp], 0
$LN7@SetColumnO:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR preserve_width$[rsp], al

; 7398 : 	const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

	movzx	eax, BYTE PTR preserve_width$[rsp]
	test	eax, eax
	je	SHORT $LN8@SetColumnO
	mov	rax, QWORD PTR columns$[rsp]
	movzx	r8d, BYTE PTR [rax+20]
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	call	?GetColumnWidthEx@@YAMPEAUImGuiColumnsSet@@H_N@Z ; GetColumnWidthEx
	movss	DWORD PTR tv83[rsp], xmm0
	jmp	SHORT $LN9@SetColumnO
$LN8@SetColumnO:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv83[rsp], xmm0
$LN9@SetColumnO:
	movss	xmm0, DWORD PTR tv83[rsp]
	movss	DWORD PTR width$[rsp], xmm0

; 7399 : 
; 7400 : 	if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN3@SetColumnO

; 7401 : 		offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));

	mov	rax, QWORD PTR columns$[rsp]
	mov	ecx, DWORD PTR column_index$[rsp]
	mov	eax, DWORD PTR [rax+36]
	sub	eax, ecx
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5568]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR offset$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR offset$[rsp], xmm0
$LN3@SetColumnO:

; 7402 : 	columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR offset$[rsp]
	subss	xmm0, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR columns$[rsp]
	call	?PixelsToOffsetNorm@@YAMPEBUImGuiColumnsSet@@M@Z ; PixelsToOffsetNorm
	movss	DWORD PTR tv143[rsp], xmm0
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv135[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR tv143[rsp]
	movss	DWORD PTR [rax], xmm0

; 7403 : 
; 7404 : 	if (preserve_width)

	movzx	eax, BYTE PTR preserve_width$[rsp]
	test	eax, eax
	je	SHORT $LN4@SetColumnO

; 7405 : 		SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));

	movss	xmm1, DWORD PTR width$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5568]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR offset$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, DWORD PTR column_index$[rsp]
	inc	eax
	movaps	xmm1, xmm0
	mov	ecx, eax
	call	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
	npad	1
$LN4@SetColumnO:

; 7406 : }

	add	rsp, 104				; 00000068H
	ret	0
?SetColumnOffset@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
t$ = 32
x_offset$ = 36
columns$ = 40
window$ = 48
tv74 = 56
column_index$ = 80
?GetColumnOffset@ImGui@@YAMH@Z PROC			; ImGui::GetColumnOffset

; 7348 : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 7349 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 7350 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7351 : 	IM_ASSERT(columns != NULL);
; 7352 : 
; 7353 : 	if (column_index < 0)

	cmp	DWORD PTR column_index$[rsp], 0
	jge	SHORT $LN2@GetColumnO

; 7354 : 		column_index = columns->Current;

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR column_index$[rsp], eax
$LN2@GetColumnO:

; 7355 : 	IM_ASSERT(column_index < columns->Columns.Size);
; 7356 : 
; 7357 : 	const float t = columns->Columns[column_index].OffsetNorm;

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR t$[rsp], xmm0

; 7358 : 	const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);

	movss	xmm2, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR x_offset$[rsp], xmm0

; 7359 : 	return x_offset;

	movss	xmm0, DWORD PTR x_offset$[rsp]

; 7360 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetColumnOffset@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
columns$ = 40
column_index$ = 64
width$ = 72
?SetColumnWidth@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnWidth

; 7409 : {

$LN4:
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 7410 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 7411 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7412 : 	IM_ASSERT(columns != NULL);
; 7413 : 
; 7414 : 	if (column_index < 0)

	cmp	DWORD PTR column_index$[rsp], 0
	jge	SHORT $LN2@SetColumnW

; 7415 : 		column_index = columns->Current;

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR column_index$[rsp], eax
$LN2@SetColumnW:

; 7416 : 	SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);

	mov	ecx, DWORD PTR column_index$[rsp]
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	addss	xmm0, DWORD PTR width$[rsp]
	mov	eax, DWORD PTR column_index$[rsp]
	inc	eax
	movaps	xmm1, xmm0
	mov	ecx, eax
	call	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
	npad	1

; 7417 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetColumnWidth@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
columns$ = 32
window$ = 40
tv83 = 48
tv76 = 56
tv80 = 64
column_index$ = 96
?GetColumnWidth@ImGui@@YAMH@Z PROC			; ImGui::GetColumnWidth

; 7376 : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 7377 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 7378 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7379 : 	IM_ASSERT(columns != NULL);
; 7380 : 
; 7381 : 	if (column_index < 0)

	cmp	DWORD PTR column_index$[rsp], 0
	jge	SHORT $LN2@GetColumnW

; 7382 : 		column_index = columns->Current;

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR column_index$[rsp], eax
$LN2@GetColumnW:

; 7383 : 	return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR columns$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv83[rsp], rax
	mov	edx, DWORD PTR column_index$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	mov	QWORD PTR tv80[rsp], rax
	mov	ecx, DWORD PTR column_index$[rsp]
	inc	ecx
	mov	edx, ecx
	mov	rcx, QWORD PTR tv76[rsp]
	call	??A?$ImVector@UImGuiColumnData@@@@QEAAAEAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
	movss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR tv80[rsp]
	subss	xmm0, DWORD PTR [rax]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR columns$[rsp]
	call	?OffsetNormToPixels@@YAMPEBUImGuiColumnsSet@@M@Z ; OffsetNormToPixels

; 7384 : }

	add	rsp, 88					; 00000058H
	ret	0
?GetColumnWidth@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 32
window$ = 40
?GetColumnIndex@ImGui@@YAHXZ PROC			; ImGui::GetColumnIndex

; 7307 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 7308 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 7309 : 	return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN3@GetColumnI
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv71[rsp], eax
	jmp	SHORT $LN4@GetColumnI
$LN3@GetColumnI:
	mov	DWORD PTR tv71[rsp], 0
$LN4@GetColumnI:
	mov	eax, DWORD PTR tv71[rsp]

; 7310 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetColumnIndex@ImGui@@YAHXZ ENDP			; ImGui::GetColumnIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv83 = 32
window$ = 40
columns$ = 48
g$ = 56
tv137 = 64
tv145 = 72
$T1 = 80
?NextColumn@ImGui@@YAXXZ PROC				; ImGui::NextColumn

; 7273 : {

$LN7:
	sub	rsp, 104				; 00000068H

; 7274 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 7275 : 	if (window->SkipItems || window->DC.ColumnsSet == NULL)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	jne	SHORT $LN3@NextColumn
	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	jne	SHORT $LN2@NextColumn
$LN3@NextColumn:

; 7276 : 		return;

	jmp	$LN1@NextColumn
$LN2@NextColumn:

; 7277 : 
; 7278 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7279 : 	PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 7280 : 	PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 7281 : 
; 7282 : 	ImGuiColumnsSet* columns = window->DC.ColumnsSet;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	QWORD PTR columns$[rsp], rax

; 7283 : 	columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+344]
	mov	rax, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR columns$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 7284 : 	if (++columns->Current < columns->Count)

	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	DWORD PTR tv83[rsp], eax
	mov	rax, QWORD PTR columns$[rsp]
	mov	ecx, DWORD PTR tv83[rsp]
	mov	DWORD PTR [rax+24], ecx
	mov	rax, QWORD PTR columns$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR tv83[rsp], eax
	jge	SHORT $LN4@NextColumn

; 7285 : 	{
; 7286 : 		// Columns 1+ cancel out IndentX
; 7287 : 		window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;

	mov	rax, QWORD PTR columns$[rsp]
	mov	ecx, DWORD PTR [rax+24]
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+576]
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5540]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+564], xmm0

; 7288 : 		window->DrawList->ChannelsSetCurrent(columns->Current);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR columns$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR tv137[rsp]
	call	?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z ; ImDrawList::ChannelsSetCurrent
	npad	1

; 7289 : 	}

	jmp	SHORT $LN5@NextColumn
$LN4@NextColumn:

; 7290 : 	else
; 7291 : 	{
; 7292 : 		window->DC.ColumnsOffset.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+564], xmm0

; 7293 : 		window->DrawList->ChannelsSetCurrent(0);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv145[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv145[rsp]
	call	?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z ; ImDrawList::ChannelsSetCurrent

; 7294 : 		columns->Current = 0;

	mov	rax, QWORD PTR columns$[rsp]
	mov	DWORD PTR [rax+24], 0

; 7295 : 		columns->LineMinY = columns->LineMaxY;

	mov	rax, QWORD PTR columns$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rcx+16]
	movss	DWORD PTR [rax+12], xmm0
$LN5@NextColumn:

; 7296 : 	}
; 7297 : 	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+576]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 7298 : 	window->DC.CursorPos.y = columns->LineMinY;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR columns$[rsp]
	movss	xmm0, DWORD PTR [rcx+12]
	movss	DWORD PTR [rax+344], xmm0

; 7299 : 	window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+320], rax

; 7300 : 	window->DC.CurrentLineTextBaseOffset = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+328], xmm0

; 7301 : 
; 7302 : 	PushColumnClipRect();

	mov	ecx, -1
	call	?PushColumnClipRect@ImGui@@YAXH@Z	; ImGui::PushColumnClipRect

; 7303 : 	PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup

	mov	ecx, -1
	call	?GetColumnWidth@ImGui@@YAMH@Z		; ImGui::GetColumnWidth
	mulss	xmm0, DWORD PTR __real@3f266666
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1
$LN1@NextColumn:

; 7304 : }

	add	rsp, 104				; 00000068H
	ret	0
?NextColumn@ImGui@@YAXXZ ENDP				; ImGui::NextColumn
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv67 = 32
flags$ = 36
window$ = 40
columns_count$ = 64
id$ = 72
border$ = 80
?Columns@ImGui@@YAXHPEBD_N@Z PROC			; ImGui::Columns

; 7574 : {

$LN8:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 7575 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 7576 : 	IM_ASSERT(columns_count >= 1);
; 7577 : 
; 7578 : 	ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);

	movzx	eax, BYTE PTR border$[rsp]
	test	eax, eax
	je	SHORT $LN6@Columns
	mov	DWORD PTR tv67[rsp], 0
	jmp	SHORT $LN7@Columns
$LN6@Columns:
	mov	DWORD PTR tv67[rsp], 1
$LN7@Columns:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR flags$[rsp], eax

; 7579 : 	//flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
; 7580 : 	if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count == columns_count && window->DC.ColumnsSet->Flags == flags)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN2@Columns
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	ecx, DWORD PTR columns_count$[rsp]
	cmp	DWORD PTR [rax+36], ecx
	jne	SHORT $LN2@Columns
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	ecx, DWORD PTR flags$[rsp]
	cmp	DWORD PTR [rax+32], ecx
	jne	SHORT $LN2@Columns

; 7581 : 		return;

	jmp	SHORT $LN1@Columns
$LN2@Columns:

; 7582 : 
; 7583 : 	if (window->DC.ColumnsSet != NULL)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN3@Columns

; 7584 : 		EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
	npad	1
$LN3@Columns:

; 7585 : 
; 7586 : 	if (columns_count != 1)

	cmp	DWORD PTR columns_count$[rsp], 1
	je	SHORT $LN4@Columns

; 7587 : 		BeginColumns(id, columns_count, flags);

	mov	r8d, DWORD PTR flags$[rsp]
	mov	edx, DWORD PTR columns_count$[rsp]
	mov	rcx, QWORD PTR id$[rsp]
	call	?BeginColumns@ImGui@@YAXPEBDHH@Z	; ImGui::BeginColumns
	npad	1
$LN4@Columns:
$LN1@Columns:

; 7588 : }

	add	rsp, 56					; 00000038H
	ret	0
?Columns@ImGui@@YAXHPEBD_N@Z ENDP			; ImGui::Columns
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
close_parent$1 = 32
popup_idx$ = 36
g$ = 40
popup_window$2 = 48
parent_popup_window$3 = 56
window$4 = 64
tv83 = 72
tv76 = 80
tv80 = 88
tv92 = 96
tv132 = 104
?CloseCurrentPopup@ImGui@@YAXXZ PROC			; ImGui::CloseCurrentPopup

; 5992 : {

$LN12:
	sub	rsp, 120				; 00000078H

; 5993 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5994 : 	int popup_idx = g.BeginPopupStack.Size - 1;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6888]
	dec	eax
	mov	DWORD PTR popup_idx$[rsp], eax

; 5995 : 	if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)

	cmp	DWORD PTR popup_idx$[rsp], 0
	jl	SHORT $LN5@CloseCurre
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	cmp	DWORD PTR popup_idx$[rsp], eax
	jge	SHORT $LN5@CloseCurre
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv83[rsp], rax
	mov	edx, DWORD PTR popup_idx$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	QWORD PTR tv80[rsp], rax
	mov	edx, DWORD PTR popup_idx$[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rcx, QWORD PTR tv80[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN4@CloseCurre
$LN5@CloseCurre:

; 5996 : 		return;

	jmp	$LN1@CloseCurre
$LN4@CloseCurre:
$LN2@CloseCurre:

; 5997 : 
; 5998 : 	// Closing a menu closes its top-most parent popup (unless a modal)
; 5999 : 	while (popup_idx > 0)

	cmp	DWORD PTR popup_idx$[rsp], 0
	jle	$LN3@CloseCurre

; 6000 : 	{
; 6001 : 		ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv92[rsp], rax
	mov	edx, DWORD PTR popup_idx$[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR popup_window$2[rsp], rax

; 6002 : 		ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv132[rsp], rax
	mov	eax, DWORD PTR popup_idx$[rsp]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv132[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR parent_popup_window$3[rsp], rax

; 6003 : 		bool close_parent = false;

	mov	BYTE PTR close_parent$1[rsp], 0

; 6004 : 		if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))

	cmp	QWORD PTR popup_window$2[rsp], 0
	je	SHORT $LN6@CloseCurre
	mov	rax, QWORD PTR popup_window$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN6@CloseCurre

; 6005 : 			if (parent_popup_window == NULL || !(parent_popup_window->Flags & ImGuiWindowFlags_Modal))

	cmp	QWORD PTR parent_popup_window$3[rsp], 0
	je	SHORT $LN8@CloseCurre
	mov	rax, QWORD PTR parent_popup_window$3[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $LN7@CloseCurre
$LN8@CloseCurre:

; 6006 : 				close_parent = true;

	mov	BYTE PTR close_parent$1[rsp], 1
$LN7@CloseCurre:
$LN6@CloseCurre:

; 6007 : 		if (!close_parent)

	movzx	eax, BYTE PTR close_parent$1[rsp]
	test	eax, eax
	jne	SHORT $LN9@CloseCurre

; 6008 : 			break;

	jmp	SHORT $LN3@CloseCurre
$LN9@CloseCurre:

; 6009 : 		popup_idx--;

	mov	eax, DWORD PTR popup_idx$[rsp]
	dec	eax
	mov	DWORD PTR popup_idx$[rsp], eax

; 6010 : 	}

	jmp	$LN2@CloseCurre
$LN3@CloseCurre:

; 6011 : 	//IMGUI_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
; 6012 : 	ClosePopupToLevel(popup_idx, true);

	mov	dl, 1
	mov	ecx, DWORD PTR popup_idx$[rsp]
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
	npad	1

; 6013 : 
; 6014 : 	// A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
; 6015 : 	// To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
; 6016 : 	// Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
; 6017 : 	if (ImGuiWindow* window = g.NavWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR window$4[rsp], rax
	cmp	QWORD PTR window$4[rsp], 0
	je	SHORT $LN10@CloseCurre

; 6018 : 		window->DC.NavHideHighlightOneFrame = true;

	mov	rax, QWORD PTR window$4[rsp]
	mov	BYTE PTR [rax+428], 1
$LN10@CloseCurre:
$LN1@CloseCurre:

; 6019 : }

	add	rsp, 120				; 00000078H
	ret	0
?CloseCurrentPopup@ImGui@@YAXXZ ENDP			; ImGui::CloseCurrentPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv86 = 32
tv80 = 36
g$ = 40
tv84 = 48
tv76 = 56
str_id$ = 80
?IsPopupOpen@ImGui@@YA_NPEBD@Z PROC			; ImGui::IsPopupOpen

; 5850 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5851 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5852 : 	return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6888]
	cmp	DWORD PTR [rax+6872], ecx
	jle	SHORT $LN3@IsPopupOpe
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR tv84[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR tv80[rsp], eax
	mov	rcx, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rcx+6888]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	ecx, DWORD PTR tv80[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN3@IsPopupOpe
	mov	DWORD PTR tv86[rsp], 1
	jmp	SHORT $LN4@IsPopupOpe
$LN3@IsPopupOpe:
	mov	DWORD PTR tv86[rsp], 0
$LN4@IsPopupOpe:
	movzx	eax, BYTE PTR tv86[rsp]

; 5853 : }

	add	rsp, 72					; 00000048H
	ret	0
?IsPopupOpen@ImGui@@YA_NPEBD@Z ENDP			; ImGui::IsPopupOpen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv80 = 32
id$1 = 36
window$ = 40
str_id$ = 64
mouse_button$ = 72
?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z PROC		; ImGui::OpenPopupOnItemClick

; 5918 : {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5919 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5920 : 	if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, DWORD PTR mouse_button$[rsp]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@OpenPopupO
	mov	ecx, 8
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@OpenPopupO

; 5921 : 	{
; 5922 : 		ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	cmp	QWORD PTR str_id$[rsp], 0
	je	SHORT $LN4@OpenPopupO
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR tv80[rsp], eax
	jmp	SHORT $LN5@OpenPopupO
$LN4@OpenPopupO:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+412]
	mov	DWORD PTR tv80[rsp], eax
$LN5@OpenPopupO:
	mov	eax, DWORD PTR tv80[rsp]
	mov	DWORD PTR id$1[rsp], eax

; 5923 : 		IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 5924 : 		OpenPopupEx(id);

	mov	ecx, DWORD PTR id$1[rsp]
	call	?OpenPopupEx@ImGui@@YAXI@Z		; ImGui::OpenPopupEx

; 5925 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@OpenPopupO
$LN2@OpenPopupO:

; 5926 : 	}
; 5927 : 	return false;

	xor	al, al
$LN1@OpenPopupO:

; 5928 : }

	add	rsp, 56					; 00000038H
	ret	0
?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z ENDP		; ImGui::OpenPopupOnItemClick
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
?EndPopup@ImGui@@YAXXZ PROC				; ImGui::EndPopup

; 6086 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 6087 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6088 : 	IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
; 6089 : 	IM_ASSERT(g.BeginPopupStack.Size > 0);
; 6090 : 
; 6091 : 	// Make all menus and popups wrap around for now, may need to expose that policy.
; 6092 : 	NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);

	mov	edx, 2
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6584]
	call	?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::NavMoveRequestTryWrapping

; 6093 : 
; 6094 : 	End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1

; 6095 : }

	add	rsp, 56					; 00000038H
	ret	0
?EndPopup@ImGui@@YAXXZ ENDP				; ImGui::EndPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
is_open$ = 32
id$ = 36
g$ = 40
window$ = 48
tv94 = 56
tv92 = 64
$T1 = 72
$T2 = 80
name$ = 112
p_open$ = 120
flags$ = 128
?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z PROC		; ImGui::BeginPopupModal

; 6058 : {

$LN8:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 6059 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6060 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6061 : 	const ImGuiID id = window->GetID(name);

	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 6062 : 	if (!IsPopupOpen(id))

	mov	ecx, DWORD PTR id$[rsp]
	call	?IsPopupOpen@ImGui@@YA_NI@Z		; ImGui::IsPopupOpen
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@BeginPopup

; 6063 : 	{
; 6064 : 		g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6912				; 00001b00H
	mov	rcx, rax
	call	?Clear@ImGuiNextWindowData@@QEAAXXZ	; ImGuiNextWindowData::Clear

; 6065 : 		return false;

	xor	al, al
	jmp	$LN1@BeginPopup
$LN2@BeginPopup:

; 6066 : 	}
; 6067 : 
; 6068 : 	// Center modal windows by default
; 6069 : 	// FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
; 6070 : 	if (g.NextWindowData.PosCond == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6912], 0
	jne	SHORT $LN3@BeginPopup

; 6071 : 		SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 20
	movss	xmm2, DWORD PTR __real@3f000000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	mov	edx, 8
	mov	rcx, QWORD PTR tv92[rsp]
	call	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos
	npad	1
$LN3@BeginPopup:

; 6072 : 
; 6073 : 	flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse/* | ImGuiWindowFlags_NoSavedSettings*/;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 201326624				; 0c000020H
	mov	DWORD PTR flags$[rsp], eax

; 6074 : 	const bool is_open = Begin(name, p_open, flags);

	mov	r8d, DWORD PTR flags$[rsp]
	mov	rdx, QWORD PTR p_open$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	mov	BYTE PTR is_open$[rsp], al

; 6075 : 	if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN5@BeginPopup
	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN4@BeginPopup
	mov	rax, QWORD PTR p_open$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN4@BeginPopup
$LN5@BeginPopup:

; 6076 : 	{
; 6077 : 		EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1

; 6078 : 		if (is_open)

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN6@BeginPopup

; 6079 : 			ClosePopupToLevel(g.BeginPopupStack.Size, true);

	mov	dl, 1
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+6888]
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
	npad	1
$LN6@BeginPopup:

; 6080 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginPopup
$LN4@BeginPopup:

; 6081 : 	}
; 6082 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
$LN1@BeginPopup:

; 6083 : }

	add	rsp, 104				; 00000068H
	ret	0
?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z ENDP		; ImGui::BeginPopupModal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
tv71 = 40
str_id$ = 64
mouse_button$ = 72
?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z PROC		; ImGui::BeginPopupContextVoid

; 6122 : {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6123 : 	if (!str_id)

	cmp	QWORD PTR str_id$[rsp], 0
	jne	SHORT $LN2@BeginPopup

; 6124 : 		str_id = ("void_context");

	lea	rax, OFFSET FLAT:??_C@_0N@OOFNFKBH@void_context@
	mov	QWORD PTR str_id$[rsp], rax
$LN2@BeginPopup:

; 6125 : 	ImGuiID id = GImGui->CurrentWindow->GetID(str_id);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR tv71[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 6126 : 	if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))

	mov	ecx, DWORD PTR mouse_button$[rsp]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@BeginPopup
	mov	ecx, 4
	call	?IsWindowHovered@ImGui@@YA_NH@Z		; ImGui::IsWindowHovered
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@BeginPopup

; 6127 : 		OpenPopupEx(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?OpenPopupEx@ImGui@@YAXI@Z		; ImGui::OpenPopupEx
	npad	1
$LN3@BeginPopup:

; 6128 : 	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar/*|ImGuiWindowFlags_NoSavedSettings*/);

	mov	edx, 65					; 00000041H
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx

; 6129 : }

	add	rsp, 56					; 00000038H
	ret	0
?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z ENDP		; ImGui::BeginPopupContextVoid
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 32
tv71 = 40
str_id$ = 64
mouse_button$ = 72
also_over_items$ = 80
?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z PROC	; ImGui::BeginPopupContextWindow

; 6111 : {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6112 : 	if (!str_id)

	cmp	QWORD PTR str_id$[rsp], 0
	jne	SHORT $LN2@BeginPopup

; 6113 : 		str_id = ("window_context");

	lea	rax, OFFSET FLAT:??_C@_0P@DCJGJLLM@window_context@
	mov	QWORD PTR str_id$[rsp], rax
$LN2@BeginPopup:

; 6114 : 	ImGuiID id = GImGui->CurrentWindow->GetID(str_id);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR tv71[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 6115 : 	if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, DWORD PTR mouse_button$[rsp]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@BeginPopup
	mov	ecx, 8
	call	?IsWindowHovered@ImGui@@YA_NH@Z		; ImGui::IsWindowHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@BeginPopup

; 6116 : 		if (also_over_items || !IsAnyItemHovered())

	movzx	eax, BYTE PTR also_over_items$[rsp]
	test	eax, eax
	jne	SHORT $LN5@BeginPopup
	call	?IsAnyItemHovered@ImGui@@YA_NXZ		; ImGui::IsAnyItemHovered
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@BeginPopup
$LN5@BeginPopup:

; 6117 : 			OpenPopupEx(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?OpenPopupEx@ImGui@@YAXI@Z		; ImGui::OpenPopupEx
	npad	1
$LN4@BeginPopup:
$LN3@BeginPopup:

; 6118 : 	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar/*|ImGuiWindowFlags_NoSavedSettings*/);

	mov	edx, 65					; 00000041H
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx

; 6119 : }

	add	rsp, 56					; 00000038H
	ret	0
?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z ENDP	; ImGui::BeginPopupContextWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv72 = 32
id$ = 36
window$ = 40
str_id$ = 64
mouse_button$ = 72
?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z PROC		; ImGui::BeginPopupContextItem

; 6101 : {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6102 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6103 : 	ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	cmp	QWORD PTR str_id$[rsp], 0
	je	SHORT $LN4@BeginPopup
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN5@BeginPopup
$LN4@BeginPopup:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+412]
	mov	DWORD PTR tv72[rsp], eax
$LN5@BeginPopup:
	mov	eax, DWORD PTR tv72[rsp]
	mov	DWORD PTR id$[rsp], eax

; 6104 : 	IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 6105 : 	if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, DWORD PTR mouse_button$[rsp]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@BeginPopup
	mov	ecx, 8
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@BeginPopup

; 6106 : 		OpenPopupEx(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?OpenPopupEx@ImGui@@YAXI@Z		; ImGui::OpenPopupEx
	npad	1
$LN2@BeginPopup:

; 6107 : 	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar/*|ImGuiWindowFlags_NoSavedSettings*/);

	mov	edx, 65					; 00000041H
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx

; 6108 : }

	add	rsp, 56					; 00000038H
	ret	0
?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z ENDP		; ImGui::BeginPopupContextItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv80 = 40
str_id$ = 64
flags$ = 72
?BeginPopup@ImGui@@YA_NPEBDH@Z PROC			; ImGui::BeginPopup

; 6044 : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6045 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6046 : 	if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6888]
	cmp	DWORD PTR [rax+6872], ecx
	jg	SHORT $LN2@BeginPopup

; 6047 : 	{
; 6048 : 		g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6912				; 00001b00H
	mov	rcx, rax
	call	?Clear@ImGuiNextWindowData@@QEAAXXZ	; ImGuiNextWindowData::Clear

; 6049 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginPopup
$LN2@BeginPopup:

; 6050 : 	}
; 6051 : 	flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar/* | ImGuiWindowFlags_NoSavedSettings*/;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 65					; 00000041H
	mov	DWORD PTR flags$[rsp], eax

; 6052 : 	return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR tv80[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	edx, DWORD PTR flags$[rsp]
	mov	ecx, eax
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
$LN1@BeginPopup:

; 6053 : }

	add	rsp, 56					; 00000038H
	ret	0
?BeginPopup@ImGui@@YA_NPEBDH@Z ENDP			; ImGui::BeginPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv70 = 40
str_id$ = 64
?OpenPopup@ImGui@@YAXPEBD@Z PROC			; ImGui::OpenPopup

; 5866 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5867 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5868 : 	OpenPopupEx(g.CurrentWindow->GetID(str_id));

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR tv70[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXI@Z		; ImGui::OpenPopupEx
	npad	1

; 5869 : }

	add	rsp, 56					; 00000038H
	ret	0
?OpenPopup@ImGui@@YAXPEBD@Z ENDP			; ImGui::OpenPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
fmt$ = 64
args$ = 72
?SetTooltipV@ImGui@@YAXPEBDPEAD@Z PROC			; ImGui::SetTooltipV

; 5821 : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5822 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5823 : 	if (g.DragDropWithinSourceOrTarget)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7597]
	test	eax, eax
	je	SHORT $LN2@SetTooltip

; 5824 : 		BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip
	npad	1
	jmp	SHORT $LN3@SetTooltip
$LN2@SetTooltip:

; 5825 : 	else
; 5826 : 		BeginTooltipEx(0, true);

	mov	dl, 1
	xor	ecx, ecx
	call	?BeginTooltipEx@ImGui@@YAXH_N@Z		; ImGui::BeginTooltipEx
	npad	1
$LN3@SetTooltip:

; 5827 : 	TextV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV

; 5828 : 	EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
	npad	1

; 5829 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetTooltipV@ImGui@@YAXPEBDPEAD@Z ENDP			; ImGui::SetTooltipV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
args$ = 32
fmt$ = 64
?SetTooltip@ImGui@@YAXPEBDZZ PROC			; ImGui::SetTooltip

; 5832 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 5833 : 	va_list args;
; 5834 : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 5835 : 	SetTooltipV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?SetTooltipV@ImGui@@YAXPEBDPEAD@Z	; ImGui::SetTooltipV

; 5836 : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 5837 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetTooltip@ImGui@@YAXPEBDZZ ENDP			; ImGui::SetTooltip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?EndTooltip@ImGui@@YAXXZ PROC				; ImGui::EndTooltip

; 5815 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 5816 : 	IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
; 5817 : 	End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1

; 5818 : }

	add	rsp, 40					; 00000028H
	ret	0
?EndTooltip@ImGui@@YAXXZ ENDP				; ImGui::EndTooltip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tooltip_pos$1 = 40
$T2 = 48
$T3 = 56
?BeginTooltip@ImGui@@YAXXZ PROC				; ImGui::BeginTooltip

; 5775 : {

$LN5:
	sub	rsp, 72					; 00000048H

; 5776 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5777 : 	if (g.DragDropWithinSourceOrTarget)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7597]
	test	eax, eax
	je	$LN2@BeginToolt

; 5778 : 	{
; 5779 : 		// The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
; 5780 : 		// In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
; 5781 : 		// Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
; 5782 : 		//ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
; 5783 : 		ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@41000000
	mulss	xmm0, DWORD PTR [rax+5628]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR __real@41800000
	mulss	xmm1, DWORD PTR [rax+5628]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR tooltip_pos$1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 5784 : 		SetNextWindowPos(tooltip_pos);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	xor	edx, edx
	lea	rcx, QWORD PTR tooltip_pos$1[rsp]
	call	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos
	npad	1

; 5785 : 		SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);

	mov	eax, 16
	imul	rax, rax, 4
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+5652]
	mulss	xmm0, DWORD PTR __real@3f19999a
	call	?SetNextWindowBgAlpha@ImGui@@YAXM@Z	; ImGui::SetNextWindowBgAlpha

; 5786 : 		//PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
; 5787 : 		BeginTooltipEx(0, true);

	mov	dl, 1
	xor	ecx, ecx
	call	?BeginTooltipEx@ImGui@@YAXH_N@Z		; ImGui::BeginTooltipEx
	npad	1

; 5788 : 	}

	jmp	SHORT $LN3@BeginToolt
$LN2@BeginToolt:

; 5789 : 	else
; 5790 : 	{
; 5791 : 		BeginTooltipEx(0, false);

	xor	edx, edx
	xor	ecx, ecx
	call	?BeginTooltipEx@ImGui@@YAXH_N@Z		; ImGui::BeginTooltipEx
	npad	1
$LN3@BeginToolt:

; 5792 : 	}
; 5793 : }

	add	rsp, 72					; 00000048H
	ret	0
?BeginTooltip@ImGui@@YAXXZ ENDP				; ImGui::BeginTooltip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
ptr_id$ = 64
?GetID@ImGui@@YAIPEBX@Z PROC				; ImGui::GetID

; 5643 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5644 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5645 : 	return window->GetID(ptr_id);

	mov	rdx, QWORD PTR ptr_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBX@Z		; ImGuiWindow::GetID

; 5646 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetID@ImGui@@YAIPEBX@Z ENDP				; ImGui::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
str_id_begin$ = 64
str_id_end$ = 72
?GetID@ImGui@@YAIPEBD0@Z PROC				; ImGui::GetID

; 5637 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5638 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5639 : 	return window->GetID(str_id_begin, str_id_end);

	mov	r8, QWORD PTR str_id_end$[rsp]
	mov	rdx, QWORD PTR str_id_begin$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 5640 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetID@ImGui@@YAIPEBD0@Z ENDP				; ImGui::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
str_id$ = 64
?GetID@ImGui@@YAIPEBD@Z PROC				; ImGui::GetID

; 5631 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5632 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5633 : 	return window->GetID(str_id);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 5634 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetID@ImGui@@YAIPEBD@Z ENDP				; ImGui::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?PopID@ImGui@@YAXXZ PROC				; ImGui::PopID

; 5625 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5626 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5627 : 	window->IDStack.pop_back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?pop_back@?$ImVector@I@@QEAAXXZ		; ImVector<unsigned int>::pop_back
	npad	1

; 5628 : }

	add	rsp, 56					; 00000038H
	ret	0
?PopID@ImGui@@YAXXZ ENDP				; ImGui::PopID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
window$ = 40
ptr_id$ = 48
tv73 = 56
int_id$ = 80
?PushID@ImGui@@YAXH@Z PROC				; ImGui::PushID

; 5618 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 5619 : 	const void* ptr_id = (void*)(intptr_t)int_id;

	movsxd	rax, DWORD PTR int_id$[rsp]
	mov	QWORD PTR ptr_id$[rsp], rax

; 5620 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5621 : 	window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR ptr_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z ; ImGuiWindow::GetIDNoKeepAlive
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1

; 5622 : }

	add	rsp, 72					; 00000048H
	ret	0
?PushID@ImGui@@YAXH@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
window$ = 40
tv72 = 48
ptr_id$ = 80
?PushID@ImGui@@YAXPEBX@Z PROC				; ImGui::PushID

; 5612 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5613 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5614 : 	window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR ptr_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z ; ImGuiWindow::GetIDNoKeepAlive
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1

; 5615 : }

	add	rsp, 72					; 00000048H
	ret	0
?PushID@ImGui@@YAXPEBX@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
window$ = 40
tv73 = 48
str_id_begin$ = 80
str_id_end$ = 88
?PushID@ImGui@@YAXPEBD0@Z PROC				; ImGui::PushID

; 5606 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5607 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5608 : 	window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR str_id_end$[rsp]
	mov	rdx, QWORD PTR str_id_begin$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z ; ImGuiWindow::GetIDNoKeepAlive
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1

; 5609 : }

	add	rsp, 72					; 00000048H
	ret	0
?PushID@ImGui@@YAXPEBD0@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
window$ = 40
tv73 = 48
str_id$ = 80
?PushID@ImGui@@YAXPEBD@Z PROC				; ImGui::PushID

; 5600 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5601 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5602 : 	window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv73[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z ; ImGuiWindow::GetIDNoKeepAlive
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1

; 5603 : }

	add	rsp, 72					; 00000048H
	ret	0
?PushID@ImGui@@YAXPEBD@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?GetFrameHeightWithSpacing@ImGui@@YAMXZ PROC		; ImGui::GetFrameHeightWithSpacing

; 5410 : {

$LN3:
	sub	rsp, 24

; 5411 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5412 : 	return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5544]

; 5413 : }

	add	rsp, 24
	ret	0
?GetFrameHeightWithSpacing@ImGui@@YAMXZ ENDP		; ImGui::GetFrameHeightWithSpacing
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?GetFrameHeight@ImGui@@YAMXZ PROC			; ImGui::GetFrameHeight

; 5404 : {

$LN3:
	sub	rsp, 24

; 5405 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5406 : 	return g.FontSize + g.Style.FramePadding.y * 2.0f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1

; 5407 : }

	add	rsp, 24
	ret	0
?GetFrameHeight@ImGui@@YAMXZ ENDP			; ImGui::GetFrameHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?GetTextLineHeightWithSpacing@ImGui@@YAMXZ PROC		; ImGui::GetTextLineHeightWithSpacing

; 5398 : {

$LN3:
	sub	rsp, 24

; 5399 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5400 : 	return g.FontSize + g.Style.ItemSpacing.y;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	addss	xmm0, DWORD PTR [rcx+5544]

; 5401 : }

	add	rsp, 24
	ret	0
?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ENDP		; ImGui::GetTextLineHeightWithSpacing
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?GetTextLineHeight@ImGui@@YAMXZ PROC			; ImGui::GetTextLineHeight

; 5392 : {

$LN3:
	sub	rsp, 24

; 5393 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5394 : 	return g.FontSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]

; 5395 : }

	add	rsp, 24
	ret	0
?GetTextLineHeight@ImGui@@YAMXZ ENDP			; ImGui::GetTextLineHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
pos$ = 64
?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z PROC	; ImGui::SetCursorScreenPos

; 5498 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5499 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5500 : 	window->DC.CursorPos = pos;

	mov	rax, QWORD PTR pos$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 5501 : 	window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 312				; 00000138H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+312], rax

; 5502 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z ENDP	; ImGui::SetCursorScreenPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetCursorScreenPos

; 5492 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5493 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5494 : 	return window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5495 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetCursorScreenPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetCursorStartPos

; 5486 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5487 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5488 : 	return window->DC.CursorStartPos - window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 304				; 00000130H
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5489 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetCursorStartPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
y$ = 64
?SetCursorPosY@ImGui@@YAXM@Z PROC			; ImGui::SetCursorPosY

; 5479 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5480 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5481 : 	window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	subss	xmm0, DWORD PTR [rcx+96]
	addss	xmm0, DWORD PTR y$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+344], xmm0

; 5482 : 	window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+344]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+316], xmm0

; 5483 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetCursorPosY@ImGui@@YAXM@Z ENDP			; ImGui::SetCursorPosY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
x$ = 64
?SetCursorPosX@ImGui@@YAXM@Z PROC			; ImGui::SetCursorPosX

; 5472 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5473 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5474 : 	window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	subss	xmm0, DWORD PTR [rcx+92]
	addss	xmm0, DWORD PTR x$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 5475 : 	window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+312]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+312], xmm0

; 5476 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetCursorPosX@ImGui@@YAXM@Z ENDP			; ImGui::SetCursorPosX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
local_pos$ = 80
?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z PROC		; ImGui::SetCursorPos

; 5465 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5466 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5467 : 	window->DC.CursorPos = window->Pos - window->Scroll + local_pos;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 92					; 0000005cH
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	r8, QWORD PTR local_pos$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 5468 : 	window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 312				; 00000138H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T3[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+312], rax

; 5469 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z ENDP		; ImGui::SetCursorPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?GetCursorPosY@ImGui@@YAMXZ PROC			; ImGui::GetCursorPosY

; 5459 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5460 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5461 : 	return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR [rcx+52]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+96]

; 5462 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetCursorPosY@ImGui@@YAMXZ ENDP			; ImGui::GetCursorPosY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?GetCursorPosX@ImGui@@YAMXZ PROC			; ImGui::GetCursorPosX

; 5453 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5454 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5455 : 	return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+340]
	subss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+92]

; 5456 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetCursorPosX@ImGui@@YAMXZ ENDP			; ImGui::GetCursorPosX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv66 = 40
$T1 = 48
__$ReturnUdt$ = 80
?GetCursorPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetCursorPos

; 5447 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5448 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5449 : 	return window->DC.CursorPos - window->Pos + window->Scroll;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 92					; 0000005cH
	mov	QWORD PTR tv66[rsp], rax
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	rdx, QWORD PTR window$[rsp]
	add	rdx, 340				; 00000154H
	mov	r8, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, QWORD PTR tv66[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5450 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetCursorPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetCursorPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
group_data$ = 40
g$ = 48
$T1 = 56
$T2 = 64
$T3 = 72
group_bb$ = 80
?EndGroup@ImGui@@YAXXZ PROC				; ImGui::EndGroup

; 5687 : {

$LN7:
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 5688 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5689 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5690 : 	IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls
; 5691 : 
; 5692 : 	ImGuiGroupData& group_data = window->DC.GroupStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
	mov	QWORD PTR group_data$[rsp], rax

; 5693 : 
; 5694 : 	ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 312				; 00000138H
	mov	rcx, QWORD PTR group_data$[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR group_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5695 : 	group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

	lea	r8, QWORD PTR group_bb$[rsp+8]
	lea	rdx, QWORD PTR group_bb$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR group_bb$[rsp+8], rax

; 5696 : 
; 5697 : 	window->DC.CursorPos = group_data.BackupCursorPos;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 5698 : 	window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 312				; 00000138H
	mov	rcx, QWORD PTR group_data$[rsp]
	add	rcx, 20
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+312], rax

; 5699 : 	window->DC.Indent = group_data.BackupIndent;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+576], eax

; 5700 : 	window->DC.GroupOffset = group_data.BackupGroupOffset;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+580], eax

; 5701 : 	window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rax, QWORD PTR [rax+12]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+320], rax

; 5702 : 	window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR group_data$[rsp]
	movss	xmm0, DWORD PTR [rcx+40]
	movss	DWORD PTR [rax+328], xmm0

; 5703 : 	window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR __real@461c3c00
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+360], xmm0

; 5704 : 
; 5705 : 	if (group_data.AdvanceCursor)

	mov	rax, QWORD PTR group_data$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	test	eax, eax
	je	SHORT $LN2@EndGroup

; 5706 : 	{
; 5707 : 		window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.

	mov	rax, QWORD PTR group_data$[rsp]
	movss	xmm1, DWORD PTR [rax+40]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+356]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+328], xmm0

; 5708 : 		ItemSize(group_bb.GetSize(), 0.0f);

	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR group_bb$[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 5709 : 		ItemAdd(group_bb, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR group_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1
$LN2@EndGroup:

; 5710 : 	}
; 5711 : 
; 5712 : 	// If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
; 5713 : 	// It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
; 5714 : 	// (and if you grep for LastItemId you'll notice it is only used in that context.
; 5715 : 	if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	cmp	DWORD PTR [rax+36], ecx
	je	SHORT $LN3@EndGroup
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	cmp	DWORD PTR [rax+6720], ecx
	jne	SHORT $LN3@EndGroup
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN3@EndGroup

; 5716 : 		window->DC.LastItemId = g.ActiveId;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	mov	DWORD PTR [rax+412], ecx
	jmp	SHORT $LN4@EndGroup
$LN3@EndGroup:

; 5717 : 	else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)

	mov	rax, QWORD PTR group_data$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	test	eax, eax
	jne	SHORT $LN5@EndGroup
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6768]
	test	eax, eax
	je	SHORT $LN5@EndGroup

; 5718 : 		window->DC.LastItemId = g.ActiveIdPreviousFrame;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6708]
	mov	DWORD PTR [rax+412], ecx
$LN5@EndGroup:
$LN4@EndGroup:

; 5719 : 	window->DC.LastItemRect = group_bb;

	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR group_bb$[rsp]
	lea	rdi, QWORD PTR [rax+368]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 5720 : 
; 5721 : 	window->DC.GroupStack.pop_back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImGuiGroupData@@@@QEAAXXZ ; ImVector<ImGuiGroupData>::pop_back
	npad	1

; 5722 : 
; 5723 : 	//window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
; 5724 : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?EndGroup@ImGui@@YAXXZ ENDP				; ImGui::EndGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
group_data$ = 40
g$ = 48
tv74 = 56
$T1 = 64
?BeginGroup@ImGui@@YAXXZ PROC				; ImGui::BeginGroup

; 5662 : {

$LN3:
	sub	rsp, 88					; 00000058H

; 5663 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5664 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5665 : 
; 5666 : 	window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+536]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv74[rsp]
	call	?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z ; ImVector<ImGuiGroupData>::resize

; 5667 : 	ImGuiGroupData& group_data = window->DC.GroupStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
	mov	QWORD PTR group_data$[rsp], rax

; 5668 : 	group_data.BackupCursorPos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	rcx, QWORD PTR group_data$[rsp]
	mov	QWORD PTR [rcx], rax

; 5669 : 	group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+312]
	mov	rcx, QWORD PTR group_data$[rsp]
	mov	QWORD PTR [rcx+20], rax

; 5670 : 	group_data.BackupIndent = window->DC.Indent;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+576]
	mov	rcx, QWORD PTR group_data$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 5671 : 	group_data.BackupGroupOffset = window->DC.GroupOffset;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+580]
	mov	rcx, QWORD PTR group_data$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 5672 : 	group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+320]
	mov	rcx, QWORD PTR group_data$[rsp]
	mov	QWORD PTR [rcx+12], rax

; 5673 : 	group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+328]
	movss	DWORD PTR [rax+40], xmm0

; 5674 : 	group_data.BackupLogLinePosY = window->DC.LogLinePosY;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+360]
	movss	DWORD PTR [rax+32], xmm0

; 5675 : 	group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6720]
	mov	DWORD PTR [rax+36], ecx

; 5676 : 	group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rcx+6768]
	mov	BYTE PTR [rax+44], cl

; 5677 : 	group_data.AdvanceCursor = true;

	mov	rax, QWORD PTR group_data$[rsp]
	mov	BYTE PTR [rax+45], 1

; 5678 : 
; 5679 : 	window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+340]
	subss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+564]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+580], xmm0

; 5680 : 	window->DC.Indent = window->DC.GroupOffset;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+580]
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+576], eax

; 5681 : 	window->DC.CursorMaxPos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+312], rax

; 5682 : 	window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+320], rax

; 5683 : 	window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR __real@461c3c00
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+360], xmm0

; 5684 : }

	add	rsp, 88					; 00000058H
	ret	0
?BeginGroup@ImGui@@YAXXZ ENDP				; ImGui::BeginGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 32
window$ = 40
g$ = 48
indent_w$ = 80
?Unindent@ImGui@@YAXM@Z PROC				; ImGui::Unindent

; 5763 : {

$LN6:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H

; 5764 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5765 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5766 : 	window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR indent_w$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN5@Unindent
	je	SHORT $LN3@Unindent
$LN5@Unindent:
	movss	xmm0, DWORD PTR indent_w$[rsp]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@Unindent
$LN3@Unindent:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5564]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@Unindent:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+576]
	subss	xmm0, DWORD PTR tv71[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+576], xmm0

; 5767 : 	window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+576]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 5768 : }

	add	rsp, 72					; 00000048H
	ret	0
?Unindent@ImGui@@YAXM@Z ENDP				; ImGui::Unindent
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 32
window$ = 40
g$ = 48
indent_w$ = 80
?Indent@ImGui@@YAXM@Z PROC				; ImGui::Indent

; 5755 : {

$LN6:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H

; 5756 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5757 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5758 : 	window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR indent_w$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN5@Indent
	je	SHORT $LN3@Indent
$LN5@Indent:
	movss	xmm0, DWORD PTR indent_w$[rsp]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@Indent
$LN3@Indent:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5564]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@Indent:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+576]
	addss	xmm0, DWORD PTR tv71[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+576], xmm0

; 5759 : 	window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+576]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 5760 : }

	add	rsp, 72					; 00000048H
	ret	0
?Indent@ImGui@@YAXM@Z ENDP				; ImGui::Indent
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
g$ = 40
pos_x$ = 64
spacing_w$ = 72
pos_y_offset$ = 80
?SameLine@ImGui@@YAXMMM@Z PROC				; ImGui::SameLine

; 5732 : {

$LN9:
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5733 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5734 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@SameLine

; 5735 : 		return;

	jmp	$LN1@SameLine
$LN2@SameLine:

; 5736 : 
; 5737 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5738 : 	if (pos_x != 0.0f)

	movss	xmm0, DWORD PTR pos_x$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN8@SameLine
	je	SHORT $LN3@SameLine
$LN8@SameLine:

; 5739 : 	{
; 5740 : 		if (spacing_w < 0.0f) spacing_w = 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR spacing_w$[rsp]
	jbe	SHORT $LN5@SameLine
	xorps	xmm0, xmm0
	movss	DWORD PTR spacing_w$[rsp], xmm0
$LN5@SameLine:

; 5741 : 		window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	subss	xmm0, DWORD PTR [rcx+92]
	addss	xmm0, DWORD PTR pos_x$[rsp]
	addss	xmm0, DWORD PTR spacing_w$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+580]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+564]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 5742 : 		window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y + pos_y_offset;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+352]
	addss	xmm0, DWORD PTR pos_y_offset$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+344], xmm0

; 5743 : 	}

	jmp	SHORT $LN4@SameLine
$LN3@SameLine:

; 5744 : 	else
; 5745 : 	{
; 5746 : 		if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR spacing_w$[rsp]
	jbe	SHORT $LN6@SameLine
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5540]
	movss	DWORD PTR spacing_w$[rsp], xmm0
$LN6@SameLine:

; 5747 : 		window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+348]
	addss	xmm0, DWORD PTR spacing_w$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 5748 : 		window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y + pos_y_offset;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+352]
	addss	xmm0, DWORD PTR pos_y_offset$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+344], xmm0
$LN4@SameLine:

; 5749 : 	}
; 5750 : 	window->DC.CurrentLineSize = window->DC.PrevLineSize;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+332]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+320], rax

; 5751 : 	window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+356]
	movss	DWORD PTR [rax+328], xmm0
$LN1@SameLine:

; 5752 : }

	add	rsp, 56					; 00000038H
	ret	0
?SameLine@ImGui@@YAXMMM@Z ENDP				; ImGui::SameLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?PopButtonRepeat@ImGui@@YAXXZ PROC			; ImGui::PopButtonRepeat

; 4850 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 4851 : 	PopItemFlag();

	call	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag
	npad	1

; 4852 : }

	add	rsp, 40					; 00000028H
	ret	0
?PopButtonRepeat@ImGui@@YAXXZ ENDP			; ImGui::PopButtonRepeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
repeat$ = 48
?PushButtonRepeat@ImGui@@YAX_N@Z PROC			; ImGui::PushButtonRepeat

; 4845 : {

$LN3:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 4846 : 	PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);

	movzx	edx, BYTE PTR repeat$[rsp]
	mov	ecx, 2
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	npad	1

; 4847 : }

	add	rsp, 40					; 00000028H
	ret	0
?PushButtonRepeat@ImGui@@YAX_N@Z ENDP			; ImGui::PushButtonRepeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?PopAllowKeyboardFocus@ImGui@@YAXXZ PROC		; ImGui::PopAllowKeyboardFocus

; 4840 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 4841 : 	PopItemFlag();

	call	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag
	npad	1

; 4842 : }

	add	rsp, 40					; 00000028H
	ret	0
?PopAllowKeyboardFocus@ImGui@@YAXXZ ENDP		; ImGui::PopAllowKeyboardFocus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv66 = 32
allow_keyboard_focus$ = 64
?PushAllowKeyboardFocus@ImGui@@YAX_N@Z PROC		; ImGui::PushAllowKeyboardFocus

; 4835 : {

$LN5:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 4836 : 	PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);

	movzx	eax, BYTE PTR allow_keyboard_focus$[rsp]
	test	eax, eax
	jne	SHORT $LN3@PushAllowK
	mov	BYTE PTR tv66[rsp], 1
	jmp	SHORT $LN4@PushAllowK
$LN3@PushAllowK:
	mov	BYTE PTR tv66[rsp], 0
$LN4@PushAllowK:
	movzx	edx, BYTE PTR tv66[rsp]
	mov	ecx, 1
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	npad	1

; 4837 : }

	add	rsp, 56					; 00000038H
	ret	0
?PushAllowKeyboardFocus@ImGui@@YAX_N@Z ENDP		; ImGui::PushAllowKeyboardFocus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv80 = 32
window$ = 40
?PopTextWrapPos@ImGui@@YAXXZ PROC			; ImGui::PopTextWrapPos

; 4862 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 4863 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4864 : 	window->DC.TextWrapPosStack.pop_back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 496				; 000001f0H
	mov	rcx, rax
	call	?pop_back@?$ImVector@M@@QEAAXXZ		; ImVector<float>::pop_back

; 4865 : 	window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 496				; 000001f0H
	mov	rcx, rax
	call	?empty@?$ImVector@M@@QEBA_NXZ		; ImVector<float>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PopTextWra
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv80[rsp], xmm0
	jmp	SHORT $LN4@PopTextWra
$LN3@PopTextWra:
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 496				; 000001f0H
	mov	rcx, rax
	call	?back@?$ImVector@M@@QEAAAEAMXZ		; ImVector<float>::back
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv80[rsp], xmm0
$LN4@PopTextWra:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv80[rsp]
	movss	DWORD PTR [rax+516], xmm0

; 4866 : }

	add	rsp, 56					; 00000038H
	ret	0
?PopTextWrapPos@ImGui@@YAXXZ ENDP			; ImGui::PopTextWrapPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv72 = 40
wrap_pos_x$ = 64
?PushTextWrapPos@ImGui@@YAXM@Z PROC			; ImGui::PushTextWrapPos

; 4855 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 4856 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4857 : 	window->DC.TextWrapPos = wrap_pos_x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	movss	DWORD PTR [rax+516], xmm0

; 4858 : 	window->DC.TextWrapPosStack.push_back(wrap_pos_x);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 496				; 000001f0H
	mov	QWORD PTR tv72[rsp], rax
	lea	rdx, QWORD PTR wrap_pos_x$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?push_back@?$ImVector@M@@QEAAXAEBM@Z	; ImVector<float>::push_back
	npad	1

; 4859 : }

	add	rsp, 56					; 00000038H
	ret	0
?PushTextWrapPos@ImGui@@YAXM@Z ENDP			; ImGui::PushTextWrapPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
w$ = 32
width_to_right_edge$1 = 36
window$ = 40
$T2 = 48
?CalcItemWidth@ImGui@@YAMXZ PROC			; ImGui::CalcItemWidth

; 4770 : {

$LN4:
	sub	rsp, 72					; 00000048H

; 4771 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 4772 : 	float w = window->DC.ItemWidth;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+512]
	movss	DWORD PTR w$[rsp], xmm0

; 4773 : 	if (w < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR w$[rsp]
	jbe	SHORT $LN2@CalcItemWi

; 4774 : 	{
; 4775 : 		// Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.
; 4776 : 		float width_to_right_edge = GetContentRegionAvail().x;

	lea	rcx, QWORD PTR $T2[rsp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR width_to_right_edge$1[rsp], xmm0

; 4777 : 		w = ImMax(1.0f, width_to_right_edge + w);

	movss	xmm0, DWORD PTR width_to_right_edge$1[rsp]
	addss	xmm0, DWORD PTR w$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR w$[rsp], xmm0
$LN2@CalcItemWi:

; 4778 : 	}
; 4779 : 	w = (float)(int)w;

	cvttss2si eax, DWORD PTR w$[rsp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR w$[rsp], xmm0

; 4780 : 	return w;

	movss	xmm0, DWORD PTR w$[rsp]

; 4781 : }

	add	rsp, 72					; 00000048H
	ret	0
?CalcItemWidth@ImGui@@YAMXZ ENDP			; ImGui::CalcItemWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv81 = 32
window$ = 40
?PopItemWidth@ImGui@@YAXXZ PROC				; ImGui::PopItemWidth

; 4763 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 4764 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4765 : 	window->DC.ItemWidthStack.pop_back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	rcx, rax
	call	?pop_back@?$ImVector@M@@QEAAXXZ		; ImVector<float>::pop_back

; 4766 : 	window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	rcx, rax
	call	?empty@?$ImVector@M@@QEBA_NXZ		; ImVector<float>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PopItemWid
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+280]
	movss	DWORD PTR tv81[rsp], xmm0
	jmp	SHORT $LN4@PopItemWid
$LN3@PopItemWid:
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	rcx, rax
	call	?back@?$ImVector@M@@QEAAAEAMXZ		; ImVector<float>::back
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv81[rsp], xmm0
$LN4@PopItemWid:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv81[rsp]
	movss	DWORD PTR [rax+512], xmm0

; 4767 : }

	add	rsp, 56					; 00000038H
	ret	0
?PopItemWidth@ImGui@@YAXXZ ENDP				; ImGui::PopItemWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 32
window$ = 40
tv77 = 48
item_width$ = 80
?PushItemWidth@ImGui@@YAXM@Z PROC			; ImGui::PushItemWidth

; 4742 : {

$LN5:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H

; 4743 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4744 : 	window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);

	movss	xmm0, DWORD PTR item_width$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@PushItemWi
	jne	SHORT $LN3@PushItemWi
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+280]
	movss	DWORD PTR tv69[rsp], xmm0
	jmp	SHORT $LN4@PushItemWi
$LN3@PushItemWi:
	movss	xmm0, DWORD PTR item_width$[rsp]
	movss	DWORD PTR tv69[rsp], xmm0
$LN4@PushItemWi:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv69[rsp]
	movss	DWORD PTR [rax+512], xmm0

; 4745 : 	window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 512				; 00000200H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv77[rsp]
	call	?push_back@?$ImVector@M@@QEAAXAEBM@Z	; ImVector<float>::push_back
	npad	1

; 4746 : }

	add	rsp, 72					; 00000048H
	ret	0
?PushItemWidth@ImGui@@YAXM@Z ENDP			; ImGui::PushItemWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
col$ = 8
?FloatArrayGetColorU32@ImGui@@YAIUImVec4@@@Z PROC	; ImGui::FloatArrayGetColorU32

; 925  : {

	mov	QWORD PTR [rsp+8], rcx

; 926  : 	return IM_COL32(int(col.z * 255), int(col.y * 255), int(col.x * 255), int(col.w * 255));

	mov	rax, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	shl	eax, 24
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	shl	ecx, 16
	or	eax, ecx
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	shl	ecx, 8
	or	eax, ecx
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	or	eax, ecx

; 927  : }

	ret	0
?FloatArrayGetColorU32@ImGui@@YAIUImVec4@@@Z ENDP	; ImGui::FloatArrayGetColorU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
col$ = 8
?FloatArrayGetColorU32@ImGui@@YAIQEAM@Z PROC		; ImGui::FloatArrayGetColorU32

; 920  : {

	mov	QWORD PTR [rsp+8], rcx

; 921  : 	return IM_COL32(int(col[0] * 255), int(col[1] * 255), int(col[2] * 255), int(col[3] * 255));

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	shl	eax, 24
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	shl	ecx, 16
	or	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	shl	ecx, 8
	or	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	or	eax, ecx

; 922  : }

	ret	0
?FloatArrayGetColorU32@ImGui@@YAIQEAM@Z ENDP		; ImGui::FloatArrayGetColorU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
a$ = 0
style_alpha$ = 4
col$ = 32
?GetColorU32@ImGui@@YAII@Z PROC				; ImGui::GetColorU32

; 952  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 953  : 	float style_alpha = GImGui->Style.Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+5472]
	movss	DWORD PTR style_alpha$[rsp], xmm0

; 954  : 	if (style_alpha >= 1.0f)

	movss	xmm0, DWORD PTR style_alpha$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN2@GetColorU3

; 955  : 		return col;

	mov	eax, DWORD PTR col$[rsp]
	jmp	SHORT $LN1@GetColorU3
$LN2@GetColorU3:

; 956  : 	ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24
	mov	DWORD PTR a$[rsp], eax

; 957  : 	a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.

	mov	eax, DWORD PTR a$[rsp]
	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR style_alpha$[rsp]
	cvttss2si rax, xmm0
	mov	DWORD PTR a$[rsp], eax

; 958  : 	return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);

	mov	eax, DWORD PTR col$[rsp]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR a$[rsp]
	shl	ecx, 24
	or	eax, ecx
$LN1@GetColorU3:

; 959  : }

	add	rsp, 24
	ret	0
?GetColorU32@ImGui@@YAII@Z ENDP				; ImGui::GetColorU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
style$ = 48
c$ = 56
col$ = 96
?GetColorU32@ImGui@@YAIQEAM@Z PROC			; ImGui::GetColorU32

; 930  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 931  : 	ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 932  : 	ImVec4 c = ImVec4(col[0], col[1], col[2], col[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r8d, 4
	imul	r8, r8, 0
	mov	r9, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [r9+rax]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm3, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [rax+rdx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+r8]
	lea	rcx, QWORD PTR c$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 933  : 	c.w *= 1.f;

	movss	xmm0, DWORD PTR c$[rsp+12]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR c$[rsp+12], xmm0

; 934  : 	return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$[rsp]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 935  : }

	add	rsp, 88					; 00000058H
	ret	0
?GetColorU32@ImGui@@YAIQEAM@Z ENDP			; ImGui::GetColorU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
style$ = 32
c$ = 40
col$ = 96
?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z PROC		; ImGui::GetColorU32

; 938  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 939  : 	ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 940  : 	ImVec4 c = col;

	lea	rax, QWORD PTR c$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR col$[rsp]
	mov	ecx, 16
	rep movsb

; 941  : 	c.w *= style.Alpha;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR c$[rsp+12]
	mulss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR c$[rsp+12], xmm0

; 942  : 	return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$[rsp]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 943  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z ENDP		; ImGui::GetColorU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
style$ = 32
c$ = 40
idx$ = 96
alpha_mul$ = 104
?GetColorU32@ImGui@@YAIHM@Z PROC			; ImGui::GetColorU32

; 912  : {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 913  : 	ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 914  : 	ImVec4 c = style.Colors[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	lea	rcx, QWORD PTR c$[rsp]
	mov	rdx, QWORD PTR style$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+168]
	mov	ecx, 16
	rep movsb

; 915  : 	c.w *= style.Alpha * alpha_mul;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR alpha_mul$[rsp]
	movss	xmm1, DWORD PTR c$[rsp+12]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR c$[rsp+12], xmm0

; 916  : 	return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$[rsp]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 917  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?GetColorU32@ImGui@@YAIHM@Z ENDP			; ImGui::GetColorU32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
__$ReturnUdt$ = 8
?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetFontTexUvWhitePixel

; 5432 : {

	mov	QWORD PTR [rsp+8], rcx

; 5433 : 	return GImGui->DrawListSharedData.TexUvWhitePixel;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6416]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5434 : }

	ret	0
?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetFontTexUvWhitePixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetFontSize@ImGui@@YAMXZ PROC				; ImGui::GetFontSize

; 5428 : 	return GImGui->FontSize;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+6408]

; 5429 : }

	ret	0
?GetFontSize@ImGui@@YAMXZ ENDP				; ImGui::GetFontSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetFont@ImGui@@YAPEAUImFont@@XZ PROC			; ImGui::GetFont

; 5423 : 	return GImGui->Font;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+8]

; 5424 : }

	ret	0
?GetFont@ImGui@@YAPEAUImFont@@XZ ENDP			; ImGui::GetFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
style$ = 0
idx$ = 32
?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z PROC	; ImGui::GetStyleColorVec4

; 946  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 947  : 	ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 948  : 	return style.Colors[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR style$[rsp]
	lea	rax, QWORD PTR [rcx+rax+168]

; 949  : }

	add	rsp, 24
	ret	0
?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z ENDP	; ImGui::GetStyleColorVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
info$1 = 32
backup$2 = 40
data$3 = 48
g$ = 56
count$ = 80
?PopStyleVar@ImGui@@YAXH@Z PROC				; ImGui::PopStyleVar

; 4972 : {

$LN8:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 4973 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax
$LN2@PopStyleVa:

; 4974 : 	while (count > 0)

	cmp	DWORD PTR count$[rsp], 0
	jle	$LN3@PopStyleVa

; 4975 : 	{
; 4976 : 		// We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
; 4977 : 		ImGuiStyleMod& backup = g.StyleModifiers.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6840				; 00001ab8H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiStyleMod@@@@QEAAAEAUImGuiStyleMod@@XZ ; ImVector<ImGuiStyleMod>::back
	mov	QWORD PTR backup$2[rsp], rax

; 4978 : 		const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);

	mov	rax, QWORD PTR backup$2[rsp]
	mov	ecx, DWORD PTR [rax]
	call	?GetStyleVarInfo@@YAPEBUImGuiStyleVarInfo@@H@Z ; GetStyleVarInfo
	mov	QWORD PTR info$1[rsp], rax

; 4979 : 		void* data = info->GetVarPtr(&g.Style);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	rdx, rax
	mov	rcx, QWORD PTR info$1[rsp]
	call	?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z ; ImGuiStyleVarInfo::GetVarPtr
	mov	QWORD PTR data$3[rsp], rax

; 4980 : 		if (info->Type == ImGuiDataType_Float && info->Count == 1) { ((float*)data)[0] = backup.BackupFloat[0]; }

	mov	rax, QWORD PTR info$1[rsp]
	cmp	DWORD PTR [rax], 4
	jne	SHORT $LN4@PopStyleVa
	mov	rax, QWORD PTR info$1[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	SHORT $LN4@PopStyleVa
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR data$3[rsp]
	mov	r8, QWORD PTR backup$2[rsp]
	movss	xmm0, DWORD PTR [r8+rax+4]
	movss	DWORD PTR [rdx+rcx], xmm0
	jmp	SHORT $LN5@PopStyleVa
$LN4@PopStyleVa:

; 4981 : 		else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }

	mov	rax, QWORD PTR info$1[rsp]
	cmp	DWORD PTR [rax], 4
	jne	SHORT $LN6@PopStyleVa
	mov	rax, QWORD PTR info$1[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	SHORT $LN6@PopStyleVa
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR data$3[rsp]
	mov	r8, QWORD PTR backup$2[rsp]
	movss	xmm0, DWORD PTR [r8+rax+4]
	movss	DWORD PTR [rdx+rcx], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR data$3[rsp]
	mov	r8, QWORD PTR backup$2[rsp]
	movss	xmm0, DWORD PTR [r8+rax+4]
	movss	DWORD PTR [rdx+rcx], xmm0
$LN6@PopStyleVa:
$LN5@PopStyleVa:

; 4982 : 		g.StyleModifiers.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6840				; 00001ab8H
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImGuiStyleMod@@@@QEAAXXZ ; ImVector<ImGuiStyleMod>::pop_back

; 4983 : 		count--;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	mov	DWORD PTR count$[rsp], eax

; 4984 : 	}

	jmp	$LN2@PopStyleVa
$LN3@PopStyleVa:

; 4985 : }

	add	rsp, 72					; 00000048H
	ret	0
?PopStyleVar@ImGui@@YAXH@Z ENDP				; ImGui::PopStyleVar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
var_info$ = 32
g$1 = 40
pvar$2 = 48
tv82 = 56
$T3 = 64
idx$ = 96
val$ = 104
?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z PROC		; ImGui::PushStyleVar

; 4958 : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 4959 : 	const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);

	mov	ecx, DWORD PTR idx$[rsp]
	call	?GetStyleVarInfo@@YAPEBUImGuiStyleVarInfo@@H@Z ; GetStyleVarInfo
	mov	QWORD PTR var_info$[rsp], rax

; 4960 : 	if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)

	mov	rax, QWORD PTR var_info$[rsp]
	cmp	DWORD PTR [rax], 4
	jne	SHORT $LN2@PushStyleV
	mov	rax, QWORD PTR var_info$[rsp]
	cmp	DWORD PTR [rax+4], 2
	jne	SHORT $LN2@PushStyleV

; 4961 : 	{
; 4962 : 		ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$1[rsp], rax

; 4963 : 		ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);

	mov	rax, QWORD PTR g$1[rsp]
	add	rax, 5472				; 00001560H
	mov	rdx, rax
	mov	rcx, QWORD PTR var_info$[rsp]
	call	?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z ; ImGuiStyleVarInfo::GetVarPtr
	mov	QWORD PTR pvar$2[rsp], rax

; 4964 : 		g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	mov	rax, QWORD PTR g$1[rsp]
	add	rax, 6840				; 00001ab8H
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR pvar$2[rsp]
	mov	r8, QWORD PTR [rax]
	mov	edx, DWORD PTR idx$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImGuiStyleMod@@QEAA@HUImVec2@@@Z	; ImGuiStyleMod::ImGuiStyleMod
	mov	rdx, rax
	mov	rcx, QWORD PTR tv82[rsp]
	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
	npad	1

; 4965 : 		*pvar = val;

	mov	rax, QWORD PTR val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR pvar$2[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@PushStyleV:

; 4966 : 		return;
; 4967 : 	}
; 4968 : 	IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
; 4969 : }

	add	rsp, 88					; 00000058H
	ret	0
?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z ENDP		; ImGui::PushStyleVar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
var_info$ = 32
g$1 = 40
pvar$2 = 48
tv82 = 56
$T3 = 64
idx$ = 96
val$ = 104
?PushStyleVar@ImGui@@YAXHM@Z PROC			; ImGui::PushStyleVar

; 4944 : {

$LN4:
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 4945 : 	const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);

	mov	ecx, DWORD PTR idx$[rsp]
	call	?GetStyleVarInfo@@YAPEBUImGuiStyleVarInfo@@H@Z ; GetStyleVarInfo
	mov	QWORD PTR var_info$[rsp], rax

; 4946 : 	if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)

	mov	rax, QWORD PTR var_info$[rsp]
	cmp	DWORD PTR [rax], 4
	jne	SHORT $LN2@PushStyleV
	mov	rax, QWORD PTR var_info$[rsp]
	cmp	DWORD PTR [rax+4], 1
	jne	SHORT $LN2@PushStyleV

; 4947 : 	{
; 4948 : 		ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$1[rsp], rax

; 4949 : 		float* pvar = (float*)var_info->GetVarPtr(&g.Style);

	mov	rax, QWORD PTR g$1[rsp]
	add	rax, 5472				; 00001560H
	mov	rdx, rax
	mov	rcx, QWORD PTR var_info$[rsp]
	call	?GetVarPtr@ImGuiStyleVarInfo@@QEBAPEAXPEAUImGuiStyle@@@Z ; ImGuiStyleVarInfo::GetVarPtr
	mov	QWORD PTR pvar$2[rsp], rax

; 4950 : 		g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	mov	rax, QWORD PTR g$1[rsp]
	add	rax, 6840				; 00001ab8H
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR pvar$2[rsp]
	movss	xmm2, DWORD PTR [rax]
	mov	edx, DWORD PTR idx$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImGuiStyleMod@@QEAA@HM@Z		; ImGuiStyleMod::ImGuiStyleMod
	mov	rdx, rax
	mov	rcx, QWORD PTR tv82[rsp]
	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
	npad	1

; 4951 : 		*pvar = val;

	mov	rax, QWORD PTR pvar$2[rsp]
	movss	xmm0, DWORD PTR val$[rsp]
	movss	DWORD PTR [rax], xmm0
$LN2@PushStyleV:

; 4952 : 		return;
; 4953 : 	}
; 4954 : 	IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
; 4955 : }

	add	rsp, 88					; 00000058H
	ret	0
?PushStyleVar@ImGui@@YAXHM@Z ENDP			; ImGui::PushStyleVar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
backup$1 = 40
count$ = 80
?PopStyleColor@ImGui@@YAXH@Z PROC			; ImGui::PopStyleColor

; 4890 : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 4891 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax
$LN2@PopStyleCo:

; 4892 : 	while (count > 0)

	cmp	DWORD PTR count$[rsp], 0
	jle	SHORT $LN3@PopStyleCo

; 4893 : 	{
; 4894 : 		ImGuiColorMod& backup = g.ColorModifiers.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6784				; 00001a80H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiColorMod@@@@QEAAAEAUImGuiColorMod@@XZ ; ImVector<ImGuiColorMod>::back
	mov	QWORD PTR backup$1[rsp], rax

; 4895 : 		g.Style.Colors[backup.Col] = backup.BackupValue;

	mov	rax, QWORD PTR backup$1[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR backup$1[rsp]
	lea	rdi, QWORD PTR [rcx+rax+5640]
	lea	rsi, QWORD PTR [rdx+4]
	mov	ecx, 16
	rep movsb

; 4896 : 		g.ColorModifiers.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6784				; 00001a80H
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImGuiColorMod@@@@QEAAXXZ ; ImVector<ImGuiColorMod>::pop_back

; 4897 : 		count--;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	mov	DWORD PTR count$[rsp], eax

; 4898 : 	}

	jmp	SHORT $LN2@PopStyleCo
$LN3@PopStyleCo:

; 4899 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?PopStyleColor@ImGui@@YAXH@Z ENDP			; ImGui::PopStyleColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv75 = 40
backup$ = 48
idx$ = 112
col$ = 120
?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z PROC		; ImGui::PushStyleColor

; 4880 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 4881 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4882 : 	ImGuiColorMod backup;

	lea	rcx, QWORD PTR backup$[rsp]
	call	??0ImGuiColorMod@@QEAA@XZ

; 4883 : 	backup.Col = idx;

	mov	eax, DWORD PTR idx$[rsp]
	mov	DWORD PTR backup$[rsp], eax

; 4884 : 	backup.BackupValue = g.Style.Colors[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	lea	rcx, QWORD PTR backup$[rsp+4]
	mov	rdx, QWORD PTR g$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+5640]
	mov	ecx, 16
	rep movsb

; 4885 : 	g.ColorModifiers.push_back(backup);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6784				; 00001a80H
	mov	QWORD PTR tv75[rsp], rax
	lea	rdx, QWORD PTR backup$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 4886 : 	g.Style.Colors[idx] = col;

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rcx+rax+5640]
	mov	rsi, QWORD PTR col$[rsp]
	mov	ecx, 16
	rep movsb

; 4887 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ENDP		; ImGui::PushStyleColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv75 = 40
$T1 = 48
backup$ = 64
idx$ = 128
col$ = 136
?PushStyleColor@ImGui@@YAXHI@Z PROC			; ImGui::PushStyleColor

; 4870 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 4871 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4872 : 	ImGuiColorMod backup;

	lea	rcx, QWORD PTR backup$[rsp]
	call	??0ImGuiColorMod@@QEAA@XZ

; 4873 : 	backup.Col = idx;

	mov	eax, DWORD PTR idx$[rsp]
	mov	DWORD PTR backup$[rsp], eax

; 4874 : 	backup.BackupValue = g.Style.Colors[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	lea	rcx, QWORD PTR backup$[rsp+4]
	mov	rdx, QWORD PTR g$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+5640]
	mov	ecx, 16
	rep movsb

; 4875 : 	g.ColorModifiers.push_back(backup);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6784				; 00001a80H
	mov	QWORD PTR tv75[rsp], rax
	lea	rdx, QWORD PTR backup$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back
	npad	1

; 4876 : 	g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);

	mov	edx, DWORD PTR col$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z ; ImGui::ColorConvertU32ToFloat4
	movsxd	rcx, DWORD PTR idx$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+5640]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 4877 : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?PushStyleColor@ImGui@@YAXHI@Z ENDP			; ImGui::PushStyleColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv78 = 40
?PopFont@ImGui@@YAXXZ PROC				; ImGui::PopFont

; 4809 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 4810 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4811 : 	g.CurrentWindow->DrawList->PopTextureID();

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rcx, QWORD PTR [rax+696]
	call	?PopTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::PopTextureID

; 4812 : 	g.FontStack.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	rcx, rax
	call	?pop_back@?$ImVector@PEAUImFont@@@@QEAAXXZ ; ImVector<ImFont *>::pop_back

; 4813 : 	SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	rcx, rax
	call	?empty@?$ImVector@PEAUImFont@@@@QEBA_NXZ ; ImVector<ImFont *>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PopFont
	call	?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ	; ImGui::GetDefaultFont
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN4@PopFont
$LN3@PopFont:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ ; ImVector<ImFont *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv78[rsp], rax
$LN4@PopFont:
	mov	rcx, QWORD PTR tv78[rsp]
	call	?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z ; ImGui::SetCurrentFont
	npad	1

; 4814 : }

	add	rsp, 56					; 00000038H
	ret	0
?PopFont@ImGui@@YAXXZ ENDP				; ImGui::PopFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
tv71 = 40
tv79 = 48
font$ = 80
?PushFont@ImGui@@YAXPEAUImFont@@@Z PROC			; ImGui::PushFont

; 4799 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4800 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4801 : 	if (!font)

	cmp	QWORD PTR font$[rsp], 0
	jne	SHORT $LN2@PushFont

; 4802 : 		font = GetDefaultFont();

	call	?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ	; ImGui::GetDefaultFont
	mov	QWORD PTR font$[rsp], rax
$LN2@PushFont:

; 4803 : 	SetCurrentFont(font);

	mov	rcx, QWORD PTR font$[rsp]
	call	?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z ; ImGui::SetCurrentFont

; 4804 : 	g.FontStack.push_back(font);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6856				; 00001ac8H
	mov	QWORD PTR tv71[rsp], rax
	lea	rdx, QWORD PTR font$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ; ImVector<ImFont *>::push_back

; 4805 : 	g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR font$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
	npad	1

; 4806 : }

	add	rsp, 72					; 00000048H
	ret	0
?PushFont@ImGui@@YAXPEAUImFont@@@Z ENDP			; ImGui::PushFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
local_y$ = 64
center_y_ratio$ = 72
?SetScrollFromPosY@ImGui@@YAXMM@Z PROC			; ImGui::SetScrollFromPosY

; 5539 : {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5540 : 	// We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
; 5541 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5542 : 	IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
; 5543 : 	window->ScrollTarget.y = (float)(int)(local_y + window->Scroll.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR local_y$[rsp]
	addss	xmm0, DWORD PTR [rax+96]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+108], xmm0

; 5544 : 	window->ScrollTargetCenterRatio.y = center_y_ratio;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR center_y_ratio$[rsp]
	movss	DWORD PTR [rax+120], xmm0

; 5545 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetScrollFromPosY@ImGui@@YAXMM@Z ENDP			; ImGui::SetScrollFromPosY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
target_y$ = 32
window$ = 40
center_y_ratio$ = 64
?SetScrollHereY@ImGui@@YAXM@Z PROC			; ImGui::SetScrollHereY

; 5549 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5550 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5551 : 	float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+352]
	subss	xmm0, DWORD PTR [rcx+52]
	movss	DWORD PTR target_y$[rsp], xmm0

; 5552 : 	target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+336]
	mulss	xmm0, DWORD PTR center_y_ratio$[rsp]
	movss	xmm1, DWORD PTR center_y_ratio$[rsp]
	subss	xmm1, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm2, DWORD PTR [rax+5544]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR target_y$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR target_y$[rsp], xmm0

; 5553 : 	SetScrollFromPosY(target_y, center_y_ratio);

	movss	xmm1, DWORD PTR center_y_ratio$[rsp]
	movss	xmm0, DWORD PTR target_y$[rsp]
	call	?SetScrollFromPosY@ImGui@@YAXMM@Z	; ImGui::SetScrollFromPosY
	npad	1

; 5554 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetScrollHereY@ImGui@@YAXM@Z ENDP			; ImGui::SetScrollHereY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 32
window$ = 40
scroll_y$ = 64
?SetScrollY@ImGui@@YAXM@Z PROC				; ImGui::SetScrollY

; 5532 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5533 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5534 : 	window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY

	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	xmm1, DWORD PTR scroll_y$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv69[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv69[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+108], xmm0

; 5535 : 	window->ScrollTargetCenterRatio.y = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+120], xmm0

; 5536 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetScrollY@ImGui@@YAXM@Z ENDP				; ImGui::SetScrollY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
scroll_x$ = 64
?SetScrollX@ImGui@@YAXM@Z PROC				; ImGui::SetScrollX

; 5525 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 5526 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5527 : 	window->ScrollTarget.x = scroll_x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR scroll_x$[rsp]
	movss	DWORD PTR [rax+104], xmm0

; 5528 : 	window->ScrollTargetCenterRatio.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+116], xmm0

; 5529 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetScrollX@ImGui@@YAXM@Z ENDP				; ImGui::SetScrollX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollMaxY@ImGui@@YAMXZ PROC			; ImGui::GetScrollMaxY

; 5520 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 5521 : 	return GetWindowScrollMaxY(GImGui->CurrentWindow);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+6584]
	call	?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxY

; 5522 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetScrollMaxY@ImGui@@YAMXZ ENDP			; ImGui::GetScrollMaxY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollMaxX@ImGui@@YAMXZ PROC			; ImGui::GetScrollMaxX

; 5515 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 5516 : 	return GetWindowScrollMaxX(GImGui->CurrentWindow);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+6584]
	call	?GetWindowScrollMaxX@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxX

; 5517 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetScrollMaxX@ImGui@@YAMXZ ENDP			; ImGui::GetScrollMaxX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollY@ImGui@@YAMXZ PROC				; ImGui::GetScrollY

; 5511 : 	return GImGui->CurrentWindow->Scroll.y;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	movss	xmm0, DWORD PTR [rax+96]

; 5512 : }

	ret	0
?GetScrollY@ImGui@@YAMXZ ENDP				; ImGui::GetScrollY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollX@ImGui@@YAMXZ PROC				; ImGui::GetScrollX

; 5506 : 	return GImGui->CurrentWindow->Scroll.x;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	movss	xmm0, DWORD PTR [rax+92]

; 5507 : }

	ret	0
?GetScrollX@ImGui@@YAMXZ ENDP				; ImGui::GetScrollX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$1 = 32
name$ = 64
?SetWindowFocus@ImGui@@YAXPEBD@Z PROC			; ImGui::SetWindowFocus

; 5279 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5280 : 	if (name)

	cmp	QWORD PTR name$[rsp], 0
	je	SHORT $LN2@SetWindowF

; 5281 : 	{
; 5282 : 		if (ImGuiWindow* window = FindWindowByName(name))

	mov	rcx, QWORD PTR name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR window$1[rsp], rax
	cmp	QWORD PTR window$1[rsp], 0
	je	SHORT $LN4@SetWindowF

; 5283 : 			FocusWindow(window);

	mov	rcx, QWORD PTR window$1[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN4@SetWindowF:

; 5284 : 	}

	jmp	SHORT $LN3@SetWindowF
$LN2@SetWindowF:

; 5285 : 	else
; 5286 : 	{
; 5287 : 		FocusWindow(NULL);

	xor	ecx, ecx
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN3@SetWindowF:

; 5288 : 	}
; 5289 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetWindowFocus@ImGui@@YAXPEBD@Z ENDP			; ImGui::SetWindowFocus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$1 = 32
name$ = 64
collapsed$ = 72
cond$ = 80
?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z PROC		; ImGui::SetWindowCollapsed

; 5268 : {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5269 : 	if (ImGuiWindow* window = FindWindowByName(name))

	mov	rcx, QWORD PTR name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR window$1[rsp], rax
	cmp	QWORD PTR window$1[rsp], 0
	je	SHORT $LN2@SetWindowC

; 5270 : 		SetWindowCollapsed(window, collapsed, cond);

	mov	r8d, DWORD PTR cond$[rsp]
	movzx	edx, BYTE PTR collapsed$[rsp]
	mov	rcx, QWORD PTR window$1[rsp]
	call	?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z ; ImGui::SetWindowCollapsed
	npad	1
$LN2@SetWindowC:

; 5271 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z ENDP		; ImGui::SetWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$1 = 32
name$ = 64
size$ = 72
cond$ = 80
?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z PROC	; ImGui::SetWindowSize

; 5234 : {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5235 : 	if (ImGuiWindow* window = FindWindowByName(name))

	mov	rcx, QWORD PTR name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR window$1[rsp], rax
	cmp	QWORD PTR window$1[rsp], 0
	je	SHORT $LN2@SetWindowS

; 5236 : 		SetWindowSize(window, size, cond);

	mov	r8d, DWORD PTR cond$[rsp]
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR window$1[rsp]
	call	?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowSize
	npad	1
$LN2@SetWindowS:

; 5237 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z ENDP	; ImGui::SetWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$1 = 32
name$ = 64
pos$ = 72
cond$ = 80
?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z PROC	; ImGui::SetWindowPos

; 5185 : {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5186 : 	if (ImGuiWindow* window = FindWindowByName(name))

	mov	rcx, QWORD PTR name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR window$1[rsp], rax
	cmp	QWORD PTR window$1[rsp], 0
	je	SHORT $LN2@SetWindowP

; 5187 : 		SetWindowPos(window, pos, cond);

	mov	r8d, DWORD PTR cond$[rsp]
	mov	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR window$1[rsp]
	call	?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowPos
	npad	1
$LN2@SetWindowP:

; 5188 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z ENDP	; ImGui::SetWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv70 = 32
window$ = 40
g$ = 48
scale$ = 80
?SetWindowFontScale@ImGui@@YAXM@Z PROC			; ImGui::SetWindowFontScale

; 5437 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H

; 5438 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5439 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5440 : 	window->FontWindowScale = scale;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR [rax+680], xmm0

; 5441 : 	g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();

	mov	rcx, QWORD PTR window$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv70[rsp]
	movss	DWORD PTR [rax+6432], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv70[rsp]
	movss	DWORD PTR [rax+6408], xmm0

; 5442 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetWindowFontScale@ImGui@@YAXM@Z ENDP			; ImGui::SetWindowFontScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?SetWindowFocus@ImGui@@YAXXZ PROC			; ImGui::SetWindowFocus

; 5274 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 5275 : 	FocusWindow(GImGui->CurrentWindow);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+6584]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1

; 5276 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetWindowFocus@ImGui@@YAXXZ ENDP			; ImGui::SetWindowFocus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
collapsed$ = 48
cond$ = 56
?SetWindowCollapsed@ImGui@@YAX_NH@Z PROC		; ImGui::SetWindowCollapsed

; 5251 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 5252 : 	SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);

	mov	r8d, DWORD PTR cond$[rsp]
	movzx	edx, BYTE PTR collapsed$[rsp]
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+6584]
	call	?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z ; ImGui::SetWindowCollapsed
	npad	1

; 5253 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetWindowCollapsed@ImGui@@YAX_NH@Z ENDP		; ImGui::SetWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
size$ = 48
cond$ = 56
?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z PROC		; ImGui::SetWindowSize

; 5229 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5230 : 	SetWindowSize(GImGui->CurrentWindow, size, cond);

	mov	r8d, DWORD PTR cond$[rsp]
	mov	rdx, QWORD PTR size$[rsp]
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+6584]
	call	?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowSize
	npad	1

; 5231 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ENDP		; ImGui::SetWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
pos$ = 64
cond$ = 72
?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z PROC		; ImGui::SetWindowPos

; 5179 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5180 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5181 : 	SetWindowPos(window, pos, cond);

	mov	r8d, DWORD PTR cond$[rsp]
	mov	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowPos
	npad	1

; 5182 : }

	add	rsp, 56					; 00000038H
	ret	0
?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z ENDP		; ImGui::SetWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
alpha$ = 32
?SetNextWindowBgAlpha@ImGui@@YAXM@Z PROC		; ImGui::SetNextWindowBgAlpha

; 5345 : {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 5346 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5347 : 	g.NextWindowData.BgAlphaVal = alpha;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR alpha$[rsp]
	movss	DWORD PTR [rax+6996], xmm0

; 5348 : 	g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6928], 1

; 5349 : }

	add	rsp, 24
	ret	0
?SetNextWindowBgAlpha@ImGui@@YAXM@Z ENDP		; ImGui::SetNextWindowBgAlpha
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
?SetNextWindowFocus@ImGui@@YAXXZ PROC			; ImGui::SetNextWindowFocus

; 5339 : {

$LN3:
	sub	rsp, 24

; 5340 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5341 : 	g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6924], 1

; 5342 : }

	add	rsp, 24
	ret	0
?SetNextWindowFocus@ImGui@@YAXXZ ENDP			; ImGui::SetNextWindowFocus
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 0
g$ = 8
collapsed$ = 32
cond$ = 40
?SetNextWindowCollapsed@ImGui@@YAX_NH@Z PROC		; ImGui::SetNextWindowCollapsed

; 5331 : {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 5332 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5333 : 	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 5334 : 	g.NextWindowData.CollapsedVal = collapsed;

	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR collapsed$[rsp]
	mov	BYTE PTR [rax+6992], cl

; 5335 : 	g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN3@SetNextWin
	mov	eax, DWORD PTR cond$[rsp]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN4@SetNextWin
$LN3@SetNextWin:
	mov	DWORD PTR tv69[rsp], 1
$LN4@SetNextWin:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv69[rsp]
	mov	DWORD PTR [rax+6944], ecx

; 5336 : }

	add	rsp, 24
	ret	0
?SetNextWindowCollapsed@ImGui@@YAX_NH@Z ENDP		; ImGui::SetNextWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
size$ = 32
?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z PROC	; ImGui::SetNextWindowContentSize

; 5324 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5325 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5326 : 	g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.

	mov	rax, QWORD PTR size$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6964], rax

; 5327 : 	g.NextWindowData.ContentSizeCond = ImGuiCond_Always;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6940], 1

; 5328 : }

	add	rsp, 24
	ret	0
?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z ENDP	; ImGui::SetNextWindowContentSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
$T1 = 40
size_min$ = 96
size_max$ = 104
custom_callback$ = 112
custom_callback_user_data$ = 120
?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z PROC ; ImGui::SetNextWindowSizeConstraints

; 5315 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 5316 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5317 : 	g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6920], 1

; 5318 : 	g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);

	mov	r8, QWORD PTR size_max$[rsp]
	mov	rdx, QWORD PTR size_min$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	rcx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rcx+7008]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 5319 : 	g.NextWindowData.SizeCallback = custom_callback;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR custom_callback$[rsp]
	mov	QWORD PTR [rax+6976], rcx

; 5320 : 	g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR custom_callback_user_data$[rsp]
	mov	QWORD PTR [rax+6984], rcx

; 5321 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z ENDP ; ImGui::SetNextWindowSizeConstraints
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv70 = 0
g$ = 8
size$ = 32
cond$ = 40
?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z PROC	; ImGui::SetNextWindowSize

; 5307 : {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5308 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5309 : 	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 5310 : 	g.NextWindowData.SizeVal = size;

	mov	rax, QWORD PTR size$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6956], rax

; 5311 : 	g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN3@SetNextWin
	mov	eax, DWORD PTR cond$[rsp]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@SetNextWin
$LN3@SetNextWin:
	mov	DWORD PTR tv70[rsp], 1
$LN4@SetNextWin:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv70[rsp]
	mov	DWORD PTR [rax+6916], ecx

; 5312 : }

	add	rsp, 24
	ret	0
?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ENDP	; ImGui::SetNextWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv73 = 0
g$ = 8
pos$ = 32
cond$ = 40
pivot$ = 48
?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z PROC	; ImGui::SetNextWindowPos

; 5298 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5299 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5300 : 	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 5301 : 	g.NextWindowData.PosVal = pos;

	mov	rax, QWORD PTR pos$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6932], rax

; 5302 : 	g.NextWindowData.PosPivotVal = pivot;

	mov	rax, QWORD PTR pivot$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6948], rax

; 5303 : 	g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN3@SetNextWin
	mov	eax, DWORD PTR cond$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN4@SetNextWin
$LN3@SetNextWin:
	mov	DWORD PTR tv73[rsp], 1
$LN4@SetNextWin:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv73[rsp]
	mov	DWORD PTR [rax+6912], ecx

; 5304 : }

	add	rsp, 24
	ret	0
?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ENDP	; ImGui::SetNextWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
__$ReturnUdt$ = 32
?GetNextWindowPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetNextWindowPos

; 5292 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5293 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5294 : 	return g.CurrentWindow->Pos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5295 : }

	add	rsp, 24
	ret	0
?GetNextWindowPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetNextWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?GetWindowContentRegionWidth@ImGui@@YAMXZ PROC		; ImGui::GetWindowContentRegionWidth

; 5386 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5387 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5388 : 	return window->ContentsRegionRect.GetWidth();

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 208				; 000000d0H
	mov	rcx, rax
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth

; 5389 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetWindowContentRegionWidth@ImGui@@YAMXZ ENDP		; ImGui::GetWindowContentRegionWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetWindowContentRegionMax

; 5380 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5381 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5382 : 	return window->ContentsRegionRect.Max - window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 216				; 000000d8H
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5383 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetWindowContentRegionMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetWindowContentRegionMin

; 5374 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5375 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5376 : 	return window->ContentsRegionRect.Min - window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 208				; 000000d0H
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5377 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetWindowContentRegionMin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
?GetContentRegionAvailWidth@ImGui@@YAMXZ PROC		; ImGui::GetContentRegionAvailWidth

; 5368 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5369 : 	return GetContentRegionAvail().x;

	lea	rcx, QWORD PTR $T1[rsp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	movss	xmm0, DWORD PTR [rax]

; 5370 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetContentRegionAvailWidth@ImGui@@YAMXZ ENDP		; ImGui::GetContentRegionAvailWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
tv81 = 40
tv79 = 48
$T1 = 56
$T2 = 64
__$ReturnUdt$ = 96
?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetContentRegionAvail

; 5362 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 5363 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5364 : 	return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv81[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	mov	QWORD PTR tv79[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5365 : }

	add	rsp, 88					; 00000058H
	ret	0
?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetContentRegionAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
mx$ = 40
__$ReturnUdt$ = 64
?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetContentRegionMax

; 5353 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5354 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5355 : 	ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 216				; 000000d8H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR mx$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1

; 5356 : 	if (window->DC.ColumnsSet)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN2@GetContent

; 5357 : 		mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	ecx, eax
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+80]
	movss	DWORD PTR mx$[rsp], xmm0
$LN2@GetContent:

; 5358 : 	return mx;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR mx$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5359 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetContentRegionMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 0
?GetWindowHeight@ImGui@@YAMXZ PROC			; ImGui::GetWindowHeight

; 5135 : {

$LN3:
	sub	rsp, 24

; 5136 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5137 : 	return window->Size.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+4]

; 5138 : }

	add	rsp, 24
	ret	0
?GetWindowHeight@ImGui@@YAMXZ ENDP			; ImGui::GetWindowHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 0
?GetWindowWidth@ImGui@@YAMXZ PROC			; ImGui::GetWindowWidth

; 5129 : {

$LN3:
	sub	rsp, 24

; 5130 : 	ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5131 : 	return window->Size.x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]

; 5132 : }

	add	rsp, 24
	ret	0
?GetWindowWidth@ImGui@@YAMXZ ENDP			; ImGui::GetWindowWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
__$ReturnUdt$ = 64
?GetWindowSize@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetWindowSize

; 5191 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5192 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5193 : 	return window->Size;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5194 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetWindowSize@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
window$ = 8
__$ReturnUdt$ = 32
?GetWindowPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetWindowPos

; 5141 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5142 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5143 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5144 : 	return window->Pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 5145 : }

	add	rsp, 24
	ret	0
?GetWindowPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ PROC	; ImGui::GetWindowDrawList

; 5416 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5417 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5418 : 	return window->DrawList;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]

; 5419 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ENDP	; ImGui::GetWindowDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv69 = 32
g$ = 40
flags$ = 64
?IsWindowHovered@ImGui@@YA_NH@Z PROC			; ImGui::IsWindowHovered

; 5059 : {

$LN20:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 5060 : 	IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
; 5061 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5062 : 
; 5063 : 	if (flags & ImGuiHoveredFlags_AnyWindow)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN4@IsWindowHo

; 5064 : 	{
; 5065 : 		if (g.HoveredWindow == NULL)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	jne	SHORT $LN6@IsWindowHo

; 5066 : 			return false;

	xor	al, al
	jmp	$LN1@IsWindowHo
$LN6@IsWindowHo:

; 5067 : 	}

	jmp	$LN5@IsWindowHo
$LN4@IsWindowHo:

; 5068 : 	else
; 5069 : 	{
; 5070 : 		switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 3
	mov	DWORD PTR tv69[rsp], eax
	cmp	DWORD PTR tv69[rsp], 1
	je	SHORT $LN11@IsWindowHo
	cmp	DWORD PTR tv69[rsp], 2
	je	SHORT $LN9@IsWindowHo
	cmp	DWORD PTR tv69[rsp], 3
	je	SHORT $LN7@IsWindowHo
	jmp	$LN14@IsWindowHo
$LN7@IsWindowHo:

; 5071 : 		{
; 5072 : 		case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
; 5073 : 			if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR [rcx+6688], rax
	je	SHORT $LN8@IsWindowHo

; 5074 : 				return false;

	xor	al, al
	jmp	$LN1@IsWindowHo
$LN8@IsWindowHo:

; 5075 : 			break;

	jmp	$LN2@IsWindowHo
$LN9@IsWindowHo:

; 5076 : 		case ImGuiHoveredFlags_RootWindow:
; 5077 : 			if (g.HoveredWindow != g.CurrentWindow->RootWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR [rcx+6560], rax
	je	SHORT $LN10@IsWindowHo

; 5078 : 				return false;

	xor	al, al
	jmp	$LN1@IsWindowHo
$LN10@IsWindowHo:

; 5079 : 			break;

	jmp	SHORT $LN2@IsWindowHo
$LN11@IsWindowHo:

; 5080 : 		case ImGuiHoveredFlags_ChildWindows:
; 5081 : 			if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	je	SHORT $LN13@IsWindowHo
	mov	rax, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rax+6584]
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6560]
	call	?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z ; ImGui::IsWindowChildOf
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@IsWindowHo
$LN13@IsWindowHo:

; 5082 : 				return false;

	xor	al, al
	jmp	$LN1@IsWindowHo
$LN12@IsWindowHo:

; 5083 : 			break;

	jmp	SHORT $LN2@IsWindowHo
$LN14@IsWindowHo:

; 5084 : 		default:
; 5085 : 			if (g.HoveredWindow != g.CurrentWindow)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+6584]
	cmp	QWORD PTR [rax+6560], rcx
	je	SHORT $LN15@IsWindowHo

; 5086 : 				return false;

	xor	al, al
	jmp	SHORT $LN1@IsWindowHo
$LN15@IsWindowHo:
$LN2@IsWindowHo:
$LN5@IsWindowHo:

; 5087 : 			break;
; 5088 : 		}
; 5089 : 	}
; 5090 : 
; 5091 : 	if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))

	mov	edx, DWORD PTR flags$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+6688]
	call	?IsWindowContentHoverable@@YA_NPEAUImGuiWindow@@H@Z ; IsWindowContentHoverable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@IsWindowHo

; 5092 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@IsWindowHo
$LN16@IsWindowHo:

; 5093 : 	if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN17@IsWindowHo

; 5094 : 		if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN18@IsWindowHo
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6753]
	test	eax, eax
	jne	SHORT $LN18@IsWindowHo
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	rcx, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+68]
	cmp	DWORD PTR [rcx+6704], eax
	je	SHORT $LN18@IsWindowHo

; 5095 : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsWindowHo
$LN18@IsWindowHo:
$LN17@IsWindowHo:

; 5096 : 	return true;

	mov	al, 1
$LN1@IsWindowHo:

; 5097 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsWindowHovered@ImGui@@YA_NH@Z ENDP			; ImGui::IsWindowHovered
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = 32
tv68 = 36
tv79 = 40
tv85 = 44
tv128 = 48
tv133 = 52
g$ = 56
flags$ = 80
?IsWindowFocused@ImGui@@YA_NH@Z PROC			; ImGui::IsWindowFocused

; 5100 : {

$LN20:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 5101 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5102 : 
; 5103 : 	if (flags & ImGuiFocusedFlags_AnyWindow)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN4@IsWindowFo

; 5104 : 		return g.NavWindow != NULL;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN10@IsWindowFo
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN11@IsWindowFo
$LN10@IsWindowFo:
	mov	DWORD PTR tv68[rsp], 0
$LN11@IsWindowFo:
	movzx	eax, BYTE PTR tv68[rsp]
	jmp	$LN1@IsWindowFo
$LN4@IsWindowFo:

; 5105 : 
; 5106 : 	IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()
; 5107 : 	switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 3
	mov	DWORD PTR tv71[rsp], eax
	cmp	DWORD PTR tv71[rsp], 1
	je	$LN7@IsWindowFo
	cmp	DWORD PTR tv71[rsp], 2
	je	SHORT $LN6@IsWindowFo
	cmp	DWORD PTR tv71[rsp], 3
	je	SHORT $LN5@IsWindowFo
	jmp	$LN8@IsWindowFo
$LN5@IsWindowFo:

; 5108 : 	{
; 5109 : 	case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
; 5110 : 		return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN12@IsWindowFo
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+6584]
	mov	rcx, QWORD PTR [rcx+688]
	cmp	QWORD PTR [rax+688], rcx
	jne	SHORT $LN12@IsWindowFo
	mov	DWORD PTR tv79[rsp], 1
	jmp	SHORT $LN13@IsWindowFo
$LN12@IsWindowFo:
	mov	DWORD PTR tv79[rsp], 0
$LN13@IsWindowFo:
	movzx	eax, BYTE PTR tv79[rsp]
	jmp	$LN1@IsWindowFo
$LN6@IsWindowFo:

; 5111 : 	case ImGuiFocusedFlags_RootWindow:
; 5112 : 		return g.NavWindow == g.CurrentWindow->RootWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR [rcx+7024], rax
	jne	SHORT $LN14@IsWindowFo
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN15@IsWindowFo
$LN14@IsWindowFo:
	mov	DWORD PTR tv85[rsp], 0
$LN15@IsWindowFo:
	movzx	eax, BYTE PTR tv85[rsp]
	jmp	SHORT $LN1@IsWindowFo
$LN7@IsWindowFo:

; 5113 : 	case ImGuiFocusedFlags_ChildWindows:
; 5114 : 		return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN16@IsWindowFo
	mov	rax, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rax+6584]
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7024]
	call	?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z ; ImGui::IsWindowChildOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@IsWindowFo
	mov	DWORD PTR tv128[rsp], 1
	jmp	SHORT $LN17@IsWindowFo
$LN16@IsWindowFo:
	mov	DWORD PTR tv128[rsp], 0
$LN17@IsWindowFo:
	movzx	eax, BYTE PTR tv128[rsp]
	jmp	SHORT $LN1@IsWindowFo
$LN8@IsWindowFo:

; 5115 : 	default:
; 5116 : 		return g.NavWindow == g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+6584]
	cmp	QWORD PTR [rax+7024], rcx
	jne	SHORT $LN18@IsWindowFo
	mov	DWORD PTR tv133[rsp], 1
	jmp	SHORT $LN19@IsWindowFo
$LN18@IsWindowFo:
	mov	DWORD PTR tv133[rsp], 0
$LN19@IsWindowFo:
	movzx	eax, BYTE PTR tv133[rsp]
$LN1@IsWindowFo:

; 5117 : 	}
; 5118 : }

	add	rsp, 72					; 00000048H
	ret	0
?IsWindowFocused@ImGui@@YA_NH@Z ENDP			; ImGui::IsWindowFocused
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?IsWindowCollapsed@ImGui@@YA_NXZ PROC			; ImGui::IsWindowCollapsed

; 5256 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5257 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5258 : 	return window->Collapsed;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]

; 5259 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsWindowCollapsed@ImGui@@YA_NXZ ENDP			; ImGui::IsWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
?IsWindowAppearing@ImGui@@YA_NXZ PROC			; ImGui::IsWindowAppearing

; 5262 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5263 : 	ImGuiWindow* window = GetCurrentWindowRead();

	call	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
	mov	QWORD PTR window$[rsp], rax

; 5264 : 	return window->Appearing;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+133]

; 5265 : }

	add	rsp, 56					; 00000038H
	ret	0
?IsWindowAppearing@ImGui@@YA_NXZ ENDP			; ImGui::IsWindowAppearing
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 32
sz$1 = 40
g$ = 48
tv182 = 56
parent_window$2 = 64
bb$3 = 72
tv177 = 88
tv175 = 96
tv180 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
$T8 = 144
$T9 = 152
?EndChild@ImGui@@YAXXZ PROC				; ImGui::EndChild

; 3495 : {

$LN11:
	sub	rsp, 184				; 000000b8H

; 3496 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3497 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 3498 : 
; 3499 : 	IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
; 3500 : 	if (window->BeginCount > 1)

	mov	rax, QWORD PTR window$[rsp]
	movsx	eax, WORD PTR [rax+136]
	cmp	eax, 1
	jle	SHORT $LN2@EndChild

; 3501 : 	{
; 3502 : 		End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1

; 3503 : 	}

	jmp	$LN3@EndChild
$LN2@EndChild:

; 3504 : 	else
; 3505 : 	{
; 3506 : 		ImVec2 sz = window->Size;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sz$1[rsp], rax

; 3507 : 		if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+180]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@EndChild

; 3508 : 			sz.x = ImMax(4.0f, sz.x);

	movss	xmm1, DWORD PTR sz$1[rsp]
	movss	xmm0, DWORD PTR __real@40800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR sz$1[rsp], xmm0
$LN4@EndChild:

; 3509 : 		if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+180]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN5@EndChild

; 3510 : 			sz.y = ImMax(4.0f, sz.y);

	movss	xmm1, DWORD PTR sz$1[rsp+4]
	movss	xmm0, DWORD PTR __real@40800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR sz$1[rsp+4], xmm0
$LN5@EndChild:

; 3511 : 		End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 3512 : 
; 3513 : 		ImGuiWindow* parent_window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR parent_window$2[rsp], rax

; 3514 : 		ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);

	mov	rax, QWORD PTR parent_window$2[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR sz$1[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR parent_window$2[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$3[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 3515 : 		ItemSize(sz);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR sz$1[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 3516 : 		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+420], 0
	jne	SHORT $LN8@EndChild
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+456]
	test	eax, eax
	je	$LN6@EndChild
$LN8@EndChild:
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	jne	$LN6@EndChild

; 3517 : 		{
; 3518 : 			ItemAdd(bb, window->ChildId);

	xor	r8d, r8d
	mov	rax, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, QWORD PTR bb$3[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd

; 3519 : 			RenderNavHighlight(bb, window->ChildId);

	mov	r8d, 1
	mov	rax, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, QWORD PTR bb$3[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1

; 3520 : 
; 3521 : 			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child
; 3522 : 			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+420], 0
	jne	$LN9@EndChild
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	cmp	QWORD PTR window$[rsp], rax
	jne	$LN9@EndChild

; 3523 : 				RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7040]
	mov	DWORD PTR tv182[rsp], eax
	movss	xmm2, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$3[rsp+8]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv177[rsp], rax
	movss	xmm2, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$3[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv175[rsp], rax
	mov	r8, QWORD PTR tv177[rsp]
	mov	rdx, QWORD PTR tv175[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	QWORD PTR tv180[rsp], rax
	mov	r8d, 2
	mov	edx, DWORD PTR tv182[rsp]
	mov	rcx, QWORD PTR tv180[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1
$LN9@EndChild:

; 3524 : 		}

	jmp	SHORT $LN7@EndChild
$LN6@EndChild:

; 3525 : 		else
; 3526 : 		{
; 3527 : 			// Not navigable into
; 3528 : 			ItemAdd(bb, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$3[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1
$LN7@EndChild:
$LN3@EndChild:

; 3529 : 		}
; 3530 : 	}
; 3531 : }

	add	rsp, 184				; 000000b8H
	ret	0
?EndChild@ImGui@@YAXXZ ENDP				; ImGui::EndChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
id$ = 64
size_arg$ = 72
border$ = 80
extra_flags$ = 88
?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z PROC		; ImGui::BeginChild

; 3489 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 3490 : 	IM_ASSERT(id != 0);
; 3491 : 	return BeginChildEx(NULL, id, size_arg, border, extra_flags);

	mov	eax, DWORD PTR extra_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	movzx	r9d, BYTE PTR border$[rsp]
	mov	r8, QWORD PTR size_arg$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	xor	ecx, ecx
	call	?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z ; ImGui::BeginChildEx

; 3492 : }

	add	rsp, 56					; 00000038H
	ret	0
?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z ENDP		; ImGui::BeginChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 48
str_id$ = 80
size_arg$ = 88
border$ = 96
extra_flags$ = 104
?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z PROC	; ImGui::BeginChild

; 3483 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3484 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 3485 : 	return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	ecx, DWORD PTR extra_flags$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	movzx	r9d, BYTE PTR border$[rsp]
	mov	r8, QWORD PTR size_arg$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR str_id$[rsp]
	call	?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z ; ImGui::BeginChildEx

; 3486 : }

	add	rsp, 72					; 00000048H
	ret	0
?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z ENDP	; ImGui::BeginChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
tv91 = 48
?End@ImGui@@YAXXZ PROC					; ImGui::End

; 4617 : {

$LN8:
	sub	rsp, 72					; 00000048H

; 4618 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4619 : 
; 4620 : 	if (g.CurrentWindowStack.Size <= 1 && g.FrameScopePushedImplicitWindow)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6672], 1
	jg	SHORT $LN2@End
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@End

; 4621 : 	{
; 4622 : 		IM_ASSERT(g.CurrentWindowStack.Size > 1 && "Calling End() too many times!");
; 4623 : 		return; // FIXME-ERRORHANDLING

	jmp	$LN1@End
$LN2@End:

; 4624 : 	}
; 4625 : 	IM_ASSERT(g.CurrentWindowStack.Size > 0);
; 4626 : 
; 4627 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 4628 : 
; 4629 : 	if (window->DC.ColumnsSet != NULL)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN3@End

; 4630 : 		EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
	npad	1
$LN3@End:

; 4631 : 	PopClipRect();   // Inner window clip rectangle

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 4632 : 
; 4633 : 	// Stop logging
; 4634 : 	//if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
; 4635 : 	//    LogFinish();
; 4636 : 
; 4637 : 	// Pop from window stack
; 4638 : 	g.CurrentWindowStack.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	?pop_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXXZ ; ImVector<ImGuiWindow *>::pop_back
	npad	1

; 4639 : 	if (window->Flags & ImGuiWindowFlags_Popup)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN4@End

; 4640 : 		g.BeginPopupStack.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImGuiPopupRef@@@@QEAAXXZ ; ImVector<ImGuiPopupRef>::pop_back
	npad	1
$LN4@End:

; 4641 : 	CheckStacksSize(window, false);

	xor	edx, edx
	mov	rcx, QWORD PTR window$[rsp]
	call	?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z ; CheckStacksSize

; 4642 : 	SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ ; ImVector<ImGuiWindow *>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@End
	mov	QWORD PTR tv91[rsp], 0
	jmp	SHORT $LN7@End
$LN6@End:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
$LN7@End:
	mov	rcx, QWORD PTR tv91[rsp]
	call	?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z ; SetCurrentWindow
	npad	1
$LN1@End:

; 4643 : }

	add	rsp, 72					; 00000048H
	ret	0
?End@ImGui@@YAXXZ ENDP					; ImGui::End
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
window$ = 64
g$ = 72
window_just_activated_by_user$ = 80
window_pos_set_by_api$ = 81
window_size_x_set_by_api$ = 82
window_size_y_set_by_api$ = 83
first_begin_of_the_frame$ = 84
want_focus$1 = 85
style$ = 88
window_just_created$ = 96
window_just_appearing_after_hidden_for_resize$ = 97
window_is_child_tooltip$2 = 98
tv359 = 99
window_title_visible_elsewhere$3 = 100
tv788 = 101
tv1129 = 102
tv1135 = 103
dim_bg_for_modal$4 = 104
dim_bg_for_window_list$5 = 105
tv1237 = 106
title_bar_is_highlight$6 = 107
tv68 = 108
tv95 = 109
tv159 = 110
resize_grip_n$7 = 112
window_pos_with_pivot$8 = 116
window_rounding$9 = 120
parent_window$ = 128
window_border_size$10 = 136
size_full_modified$11 = 144
grip_draw_size$12 = 152
current_frame$ = 156
alpha$13 = 160
bg_col$14 = 164
rad$15 = 168
pad_right$16 = 172
tv371 = 176
size_auto_fit$17 = 184
grip$18 = 192
text_r$19 = 200
tv502 = 216
tv504 = 220
tv521 = 224
tv586 = 228
tv629 = 232
tv644 = 236
tv679 = 240
tv685 = 244
tv694 = 248
tv704 = 252
tv712 = 256
size_y_for_scrollbars$20 = 260
tv728 = 264
tv737 = 268
tv743 = 272
tv976 = 276
tv978 = 280
tv991 = 284
tv1004 = 288
tv1039 = 292
border_held$21 = 296
tv1096 = 300
tv1091 = 304
tv1145 = 308
tv1254 = 312
tv1289 = 316
tv1330 = 320
tv1355 = 324
resize_grip_count$22 = 328
rounding$23 = 332
tv1651 = 336
tv1674 = 340
tv1769 = 344
tv1798 = 348
tv1804 = 352
pad$24 = 356
tv1976 = 360
tv2005 = 364
tv2048 = 368
pad_left$25 = 372
tv2071 = 376
marker_size_x$26 = 380
tv2175 = 384
tv2282 = 388
tv2340 = 392
tv2358 = 396
tv2363 = 400
tv150 = 404
tv155 = 408
tv174 = 412
tv182 = 416
tv192 = 420
tv241 = 424
tv280 = 428
tv291 = 432
title_bar_rect$27 = 440
corner$28 = 456
tv921 = 464
tv919 = 468
tv1048 = 472
tv1148 = 476
dim_bg_col$29 = 480
tv1221 = 484
tv1219 = 488
title_bar_col$30 = 492
backup_border_size$31 = 496
tv1276 = 500
title_bar_col$32 = 504
tv1364 = 508
tv1398 = 512
tv1396 = 516
tv1545 = 520
tv1543 = 524
tv1594 = 528
tv1621 = 532
tv1624 = 536
tv1629 = 540
tv1697 = 544
tv1719 = 548
tv1717 = 552
tv1912 = 556
item_flags_backup$33 = 560
tv2178 = 564
tv2212 = 568
tv2226 = 572
tv2237 = 576
tv2245 = 580
tv2259 = 584
tv1956 = 588
tv176 = 592
tv184 = 596
tv313 = 600
tv320 = 604
tv322 = 608
tv545 = 612
tv543 = 616
tv2270 = 620
popup_ref$34 = 624
text_size$35 = 632
tv547 = 640
size_x_for_scrollbars$36 = 644
menu_bar_rect$37 = 648
viewport_rect$38 = 664
tv143 = 680
tv147 = 688
popup_ref$39 = 696
tv669 = 704
tv924 = 712
size_for_clamping$40 = 720
padding$41 = 728
tv1230 = 736
window_to_highlight$42 = 744
tv1478 = 752
tv1505 = 760
off$43 = 768
UNSAVED_DOCUMENT_MARKER$44 = 776
tv81 = 784
tv140 = 792
bb$45 = 800
bb$46 = 816
tv217 = 832
tv223 = 840
$T47 = 848
tv387 = 856
tv407 = 864
buf_len$48 = 872
$T49 = 880
$T50 = 888
$T51 = 896
$T52 = 904
tv666 = 912
$T53 = 920
$T54 = 928
$T55 = 936
$T56 = 944
tv772 = 952
tv807 = 960
tv805 = 968
tv817 = 976
tv815 = 984
$T57 = 992
$T58 = 1000
$T59 = 1008
$T60 = 1016
$T61 = 1024
$T62 = 1032
tv957 = 1040
tv955 = 1048
$T63 = 1056
$T64 = 1064
$T65 = 1072
$T66 = 1080
tv1105 = 1088
tv1189 = 1096
tv1223 = 1104
tv1314 = 1112
tv1312 = 1120
tv1319 = 1128
tv1317 = 1136
tv1321 = 1144
tv1340 = 1152
tv1366 = 1160
tv1394 = 1168
tv1392 = 1176
tv1400 = 1184
tv1432 = 1192
tv1430 = 1200
$T67 = 1208
tv1488 = 1216
tv1490 = 1224
$T68 = 1232
tv1515 = 1240
tv1517 = 1248
tv1541 = 1256
tv1547 = 1264
tv1555 = 1272
tv1596 = 1280
tv1727 = 1288
tv1725 = 1296
$T69 = 1304
$T70 = 1312
tv1790 = 1320
tv1815 = 1328
tv1821 = 1336
tv1827 = 1344
tv1842 = 1352
tv1851 = 1360
tv1870 = 1368
tv1914 = 1376
tv1942 = 1384
tv1948 = 1392
tv1946 = 1400
tv1958 = 1408
tv1994 = 1416
tv1992 = 1424
tv2110 = 1432
tv2108 = 1440
marker_pos$71 = 1448
tv2145 = 1456
tv2143 = 1464
tv2141 = 1472
tv2157 = 1480
$T72 = 1488
$T73 = 1496
size_on_first_use$74 = 1504
parent_window_in_stack$ = 1512
tv169 = 1520
tv204 = 1528
clip_rect$75 = 1536
title_bar_rect$76 = 1552
$T77 = 1568
$T78 = 1576
$T79 = 1584
$T80 = 1592
$T81 = 1600
$T82 = 1608
$T83 = 1616
$T84 = 1624
$T85 = 1632
$T86 = 1640
$T87 = 1648
$T88 = 1656
$T89 = 1664
$T90 = 1672
$T91 = 1680
$T92 = 1688
$T93 = 1696
$T94 = 1704
$T95 = 1712
$T96 = 1720
$T97 = 1728
$T98 = 1736
$T99 = 1744
$T100 = 1752
$T101 = 1760
$T102 = 1768
$T103 = 1776
$T104 = 1784
$T105 = 1792
$T106 = 1800
$T107 = 1808
$T108 = 1816
$T109 = 1824
$T110 = 1832
$T111 = 1840
$T112 = 1848
$T113 = 1856
$T114 = 1864
$T115 = 1872
$T116 = 1880
$T117 = 1888
$T118 = 1896
$T119 = 1904
$T120 = 1912
$T121 = 1920
$T122 = 1928
$T123 = 1936
$T124 = 1944
$T125 = 1952
$T126 = 1960
$T127 = 1968
$T128 = 1976
$T129 = 1984
$T130 = 2000
$T131 = 2016
$T132 = 2032
$T133 = 2048
$T134 = 2064
$T135 = 2080
resize_grip_col$136 = 2096
__$ArrayPad$ = 2112
name$ = 2160
p_open$ = 2168
flags$ = 2176
?Begin@ImGui@@YA_NPEBDPEA_NH@Z PROC			; ImGui::Begin

; 3977 : {

$LN251:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 2136				; 00000858H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3978 : 	//flags |= ImGuiWindowFlags_NoSavedSettings;
; 3979 : 
; 3980 : 
; 3981 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3982 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 3983 : 	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
; 3984 : 	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()
; 3985 : 	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
; 3986 : 
; 3987 : 	// Find or create
; 3988 : 	ImGuiWindow* window = FindWindowByName(name);

	mov	rcx, QWORD PTR name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR window$[rsp], rax

; 3989 : 	const bool window_just_created = (window == NULL);

	cmp	QWORD PTR window$[rsp], 0
	jne	SHORT $LN110@Begin
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN111@Begin
$LN110@Begin:
	mov	BYTE PTR tv68[rsp], 0
$LN111@Begin:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR window_just_created$[rsp], al

; 3990 : 	if (window_just_created)

	movzx	eax, BYTE PTR window_just_created$[rsp]
	test	eax, eax
	je	$LN5@Begin

; 3991 : 	{
; 3992 : 		ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6916], 0
	je	SHORT $LN112@Begin
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6956]
	mov	QWORD PTR $T72[rsp], rax
	lea	rax, QWORD PTR $T72[rsp]
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN113@Begin
$LN112@Begin:
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T121[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv81[rsp], rax
$LN113@Begin:
	mov	rax, QWORD PTR tv81[rsp]
	mov	QWORD PTR $T73[rsp], rax
	mov	rax, QWORD PTR $T73[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR size_on_first_use$74[rsp], rax

; 3993 : 		window = CreateNewWindow(name, size_on_first_use, flags);

	mov	r8d, DWORD PTR flags$[rsp]
	mov	rdx, QWORD PTR size_on_first_use$74[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	call	?CreateNewWindow@@YAPEAUImGuiWindow@@PEBDUImVec2@@H@Z ; CreateNewWindow
	mov	QWORD PTR window$[rsp], rax
$LN5@Begin:

; 3994 : 	}
; 3995 : 
; 3996 : 	// Automatically disable manual moving/resizing when NoInputs is set
; 3997 : 	if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 786944				; 000c0200H
	cmp	eax, 786944				; 000c0200H
	jne	SHORT $LN6@Begin

; 3998 : 		flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 6
	mov	DWORD PTR flags$[rsp], eax
$LN6@Begin:

; 3999 : 
; 4000 : 	if (flags & ImGuiWindowFlags_NavFlattened)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8388608				; 00800000H

; 4001 : 		IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
; 4002 : 
; 4003 : 	const int current_frame = g.FrameCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6552]
	mov	DWORD PTR current_frame$[rsp], eax

; 4004 : 	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR current_frame$[rsp]
	cmp	DWORD PTR [rax+224], ecx
	je	SHORT $LN114@Begin
	mov	BYTE PTR tv95[rsp], 1
	jmp	SHORT $LN115@Begin
$LN114@Begin:
	mov	BYTE PTR tv95[rsp], 0
$LN115@Begin:
	movzx	eax, BYTE PTR tv95[rsp]
	mov	BYTE PTR first_begin_of_the_frame$[rsp], al

; 4005 : 
; 4006 : 	// Update Flags, LastFrameActive, BeginOrderXXX fields
; 4007 : 	if (first_begin_of_the_frame)

	movzx	eax, BYTE PTR first_begin_of_the_frame$[rsp]
	test	eax, eax
	je	SHORT $LN8@Begin

; 4008 : 		window->Flags = (ImGuiWindowFlags)flags;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+28], ecx
	jmp	SHORT $LN9@Begin
$LN8@Begin:

; 4009 : 	else
; 4010 : 		flags = window->Flags;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR flags$[rsp], eax
$LN9@Begin:

; 4011 : 
; 4012 : 	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
; 4013 : 	ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	?empty@?$ImVector@PEAUImGuiWindow@@@@QEBA_NXZ ; ImVector<ImGuiWindow *>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN116@Begin
	mov	QWORD PTR tv140[rsp], 0
	jmp	SHORT $LN117@Begin
$LN116@Begin:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv140[rsp], rax
$LN117@Begin:
	mov	rax, QWORD PTR tv140[rsp]
	mov	QWORD PTR parent_window_in_stack$[rsp], rax

; 4014 : 	ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;

	movzx	eax, BYTE PTR first_begin_of_the_frame$[rsp]
	test	eax, eax
	je	SHORT $LN120@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 83886080				; 05000000H
	test	eax, eax
	je	SHORT $LN118@Begin
	mov	rax, QWORD PTR parent_window_in_stack$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	jmp	SHORT $LN119@Begin
$LN118@Begin:
	mov	QWORD PTR tv143[rsp], 0
$LN119@Begin:
	mov	rax, QWORD PTR tv143[rsp]
	mov	QWORD PTR tv147[rsp], rax
	jmp	SHORT $LN121@Begin
$LN120@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR tv147[rsp], rax
$LN121@Begin:
	mov	rax, QWORD PTR tv147[rsp]
	mov	QWORD PTR parent_window$[rsp], rax

; 4015 : 	IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
; 4016 : 	window->HasCloseButton = (p_open != NULL);

	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN122@Begin
	mov	DWORD PTR tv150[rsp], 1
	jmp	SHORT $LN123@Begin
$LN122@Begin:
	mov	DWORD PTR tv150[rsp], 0
$LN123@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv150[rsp]
	mov	BYTE PTR [rax+148], cl

; 4017 : 
; 4018 : 	// Update the Appearing flag
; 4019 : 	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on

	mov	eax, DWORD PTR current_frame$[rsp]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rcx+224], eax
	jge	SHORT $LN124@Begin
	mov	DWORD PTR tv155[rsp], 1
	jmp	SHORT $LN125@Begin
$LN124@Begin:
	mov	DWORD PTR tv155[rsp], 0
$LN125@Begin:
	movzx	eax, BYTE PTR tv155[rsp]
	mov	BYTE PTR window_just_activated_by_user$[rsp], al

; 4020 : 	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesForResize > 0);

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jle	SHORT $LN126@Begin
	mov	BYTE PTR tv159[rsp], 1
	jmp	SHORT $LN127@Begin
$LN126@Begin:
	mov	BYTE PTR tv159[rsp], 0
$LN127@Begin:
	movzx	eax, BYTE PTR tv159[rsp]
	mov	BYTE PTR window_just_appearing_after_hidden_for_resize$[rsp], al

; 4021 : 	if (flags & ImGuiWindowFlags_Popup)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$LN10@Begin

; 4022 : 	{
; 4023 : 		ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv169[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6888]
	mov	rcx, QWORD PTR tv169[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	QWORD PTR popup_ref$39[rsp], rax

; 4024 : 		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed

	movzx	eax, BYTE PTR window_just_activated_by_user$[rsp]
	mov	DWORD PTR tv176[rsp], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR popup_ref$39[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax+152], ecx
	je	SHORT $LN128@Begin
	mov	DWORD PTR tv174[rsp], 1
	jmp	SHORT $LN129@Begin
$LN128@Begin:
	mov	DWORD PTR tv174[rsp], 0
$LN129@Begin:
	mov	eax, DWORD PTR tv174[rsp]
	mov	ecx, DWORD PTR tv176[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR window_just_activated_by_user$[rsp], al

; 4025 : 		window_just_activated_by_user |= (window != popup_ref.Window);

	movzx	eax, BYTE PTR window_just_activated_by_user$[rsp]
	mov	DWORD PTR tv184[rsp], eax
	mov	rax, QWORD PTR popup_ref$39[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR window$[rsp], rax
	je	SHORT $LN130@Begin
	mov	DWORD PTR tv182[rsp], 1
	jmp	SHORT $LN131@Begin
$LN130@Begin:
	mov	DWORD PTR tv182[rsp], 0
$LN131@Begin:
	mov	eax, DWORD PTR tv182[rsp]
	mov	ecx, DWORD PTR tv184[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR window_just_activated_by_user$[rsp], al
$LN10@Begin:

; 4026 : 	}
; 4027 : 	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);

	movzx	eax, BYTE PTR window_just_activated_by_user$[rsp]
	test	eax, eax
	jne	SHORT $LN132@Begin
	movzx	eax, BYTE PTR window_just_appearing_after_hidden_for_resize$[rsp]
	test	eax, eax
	jne	SHORT $LN132@Begin
	mov	DWORD PTR tv192[rsp], 0
	jmp	SHORT $LN133@Begin
$LN132@Begin:
	mov	DWORD PTR tv192[rsp], 1
$LN133@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv192[rsp]
	mov	BYTE PTR [rax+133], cl

; 4028 : 	if (window->Appearing)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+133]
	test	eax, eax
	je	SHORT $LN11@Begin

; 4029 : 		SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

	mov	r8b, 1
	mov	edx, 8
	mov	rcx, QWORD PTR window$[rsp]
	call	?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z ; SetWindowConditionAllowFlags
	npad	1
$LN11@Begin:

; 4030 : 
; 4031 : 	// Add to stack
; 4032 : 	g.CurrentWindowStack.push_back(window);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	QWORD PTR tv204[rsp], rax
	lea	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv204[rsp]
	call	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back

; 4033 : 	SetCurrentWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z ; SetCurrentWindow

; 4034 : 	CheckStacksSize(window, true);

	mov	dl, 1
	mov	rcx, QWORD PTR window$[rsp]
	call	?CheckStacksSize@@YAXPEAUImGuiWindow@@_N@Z ; CheckStacksSize
	npad	1

; 4035 : 	if (flags & ImGuiWindowFlags_Popup)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$LN12@Begin

; 4036 : 	{
; 4037 : 		ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv217[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6888]
	mov	rcx, QWORD PTR tv217[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	QWORD PTR popup_ref$34[rsp], rax

; 4038 : 		popup_ref.Window = window;

	mov	rax, QWORD PTR popup_ref$34[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 4039 : 		g.BeginPopupStack.push_back(popup_ref);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	QWORD PTR tv223[rsp], rax
	mov	rdx, QWORD PTR popup_ref$34[rsp]
	mov	rcx, QWORD PTR tv223[rsp]
	call	?push_back@?$ImVector@UImGuiPopupRef@@@@QEAAXAEBUImGuiPopupRef@@@Z ; ImVector<ImGuiPopupRef>::push_back

; 4040 : 		window->PopupId = popup_ref.PopupId;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR popup_ref$34[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+152], ecx
$LN12@Begin:

; 4041 : 	}
; 4042 : 
; 4043 : 	if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))

	movzx	eax, BYTE PTR window_just_appearing_after_hidden_for_resize$[rsp]
	test	eax, eax
	je	SHORT $LN13@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN13@Begin

; 4044 : 		window->NavLastIds[0] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+rax+904], 0
$LN13@Begin:

; 4045 : 
; 4046 : 	// Process SetNextWindow***() calls
; 4047 : 	bool window_pos_set_by_api = false;

	mov	BYTE PTR window_pos_set_by_api$[rsp], 0

; 4048 : 	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;

	mov	BYTE PTR window_size_x_set_by_api$[rsp], 0
	mov	BYTE PTR window_size_y_set_by_api$[rsp], 0

; 4049 : 	if (g.NextWindowData.PosCond)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6912], 0
	je	$LN14@Begin

; 4050 : 	{
; 4051 : 		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6912]
	mov	eax, DWORD PTR [rax+172]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN134@Begin
	mov	DWORD PTR tv241[rsp], 1
	jmp	SHORT $LN135@Begin
$LN134@Begin:
	mov	DWORD PTR tv241[rsp], 0
$LN135@Begin:
	movzx	eax, BYTE PTR tv241[rsp]
	mov	BYTE PTR window_pos_set_by_api$[rsp], al

; 4052 : 		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)

	movzx	eax, BYTE PTR window_pos_set_by_api$[rsp]
	test	eax, eax
	je	SHORT $LN15@Begin
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6948				; 00001b24H
	mov	rcx, rax
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	comiss	xmm0, DWORD PTR __real@3727c5ac
	jbe	SHORT $LN15@Begin

; 4053 : 		{
; 4054 : 			// May be processed on the next frame if this is our first frame and we are measuring size
; 4055 : 			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
; 4056 : 			window->SetWindowPosVal = g.NextWindowData.PosVal;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6932]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 4057 : 			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6948]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+200], rax

; 4058 : 			window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+172]
	and	eax, -15
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+172], eax

; 4059 : 		}

	jmp	SHORT $LN16@Begin
$LN15@Begin:

; 4060 : 		else
; 4061 : 		{
; 4062 : 			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6932				; 00001b14H
	mov	rcx, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rcx+6912]
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowPos
	npad	1
$LN16@Begin:
$LN14@Begin:

; 4063 : 		}
; 4064 : 	}
; 4065 : 	if (g.NextWindowData.SizeCond)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6916], 0
	je	$LN17@Begin

; 4066 : 	{
; 4067 : 		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6916]
	mov	eax, DWORD PTR [rax+144]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN136@Begin
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6956]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN136@Begin
	mov	DWORD PTR tv280[rsp], 1
	jmp	SHORT $LN137@Begin
$LN136@Begin:
	mov	DWORD PTR tv280[rsp], 0
$LN137@Begin:
	movzx	eax, BYTE PTR tv280[rsp]
	mov	BYTE PTR window_size_x_set_by_api$[rsp], al

; 4068 : 		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6916]
	mov	eax, DWORD PTR [rax+144]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN138@Begin
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6960]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN138@Begin
	mov	DWORD PTR tv291[rsp], 1
	jmp	SHORT $LN139@Begin
$LN138@Begin:
	mov	DWORD PTR tv291[rsp], 0
$LN139@Begin:
	movzx	eax, BYTE PTR tv291[rsp]
	mov	BYTE PTR window_size_y_set_by_api$[rsp], al

; 4069 : 		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6956				; 00001b2cH
	mov	rcx, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rcx+6916]
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowSize
	npad	1
$LN17@Begin:

; 4070 : 	}
; 4071 : 	if (g.NextWindowData.ContentSizeCond)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6940], 0
	je	$LN18@Begin

; 4072 : 	{
; 4073 : 		// Adjust passed "client size" to become a "window size"
; 4074 : 		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6964]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+72], rax

; 4075 : 		if (window->SizeContentsExplicit.y != 0.0f)

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN250@Begin
	je	SHORT $LN20@Begin
$LN250@Begin:

; 4076 : 			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();

	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	DWORD PTR tv313[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv313[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv322[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv320[rsp], xmm0
	movss	xmm0, DWORD PTR tv320[rsp]
	addss	xmm0, DWORD PTR tv322[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+76], xmm0
$LN20@Begin:

; 4077 : 	}

	jmp	SHORT $LN19@Begin
$LN18@Begin:

; 4078 : 	else if (first_begin_of_the_frame)

	movzx	eax, BYTE PTR first_begin_of_the_frame$[rsp]
	test	eax, eax
	je	SHORT $LN21@Begin

; 4079 : 	{
; 4080 : 		window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T122[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T47[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T47[rsp]
	mov	QWORD PTR [rax+72], rcx
$LN21@Begin:
$LN19@Begin:

; 4081 : 	}
; 4082 : 	if (g.NextWindowData.CollapsedCond)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6944], 0
	je	SHORT $LN22@Begin

; 4083 : 		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);

	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+6944]
	mov	rax, QWORD PTR g$[rsp]
	movzx	edx, BYTE PTR [rax+6992]
	mov	rcx, QWORD PTR window$[rsp]
	call	?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z ; ImGui::SetWindowCollapsed
	npad	1
$LN22@Begin:

; 4084 : 	if (g.NextWindowData.FocusCond)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6924], 0
	je	SHORT $LN23@Begin

; 4085 : 		FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN23@Begin:

; 4086 : 	if (window->Appearing)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+133]
	test	eax, eax
	je	SHORT $LN24@Begin

; 4087 : 		SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

	xor	r8d, r8d
	mov	edx, 8
	mov	rcx, QWORD PTR window$[rsp]
	call	?SetWindowConditionAllowFlags@@YAXPEAUImGuiWindow@@H_N@Z ; SetWindowConditionAllowFlags
	npad	1
$LN24@Begin:

; 4088 : 
; 4089 : 	// When reusing window again multiple times a frame, just append content (don't need to setup again)
; 4090 : 	if (first_begin_of_the_frame)

	movzx	eax, BYTE PTR first_begin_of_the_frame$[rsp]
	test	eax, eax
	je	$LN25@Begin

; 4091 : 	{
; 4092 : 		// Initialize
; 4093 : 		const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN140@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN140@Begin
	mov	BYTE PTR tv359[rsp], 1
	jmp	SHORT $LN141@Begin
$LN140@Begin:
	mov	BYTE PTR tv359[rsp], 0
$LN141@Begin:
	movzx	eax, BYTE PTR tv359[rsp]
	mov	BYTE PTR window_is_child_tooltip$2[rsp], al

; 4094 : 		UpdateWindowParentAndRootLinks(window, flags, parent_window);

	mov	r8, QWORD PTR parent_window$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?UpdateWindowParentAndRootLinks@ImGui@@YAXPEAUImGuiWindow@@H0@Z ; ImGui::UpdateWindowParentAndRootLinks

; 4095 : 
; 4096 : 		window->Active = true;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+102], 1

; 4097 : 		window->BeginOrderWithinParent = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	WORD PTR [rcx+138], ax

; 4098 : 		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, WORD PTR [rax+6648]
	mov	WORD PTR tv371[rsp], ax
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6648]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+6648], eax
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, WORD PTR tv371[rsp]
	mov	WORD PTR [rax+150], cx

; 4099 : 		window->BeginCount = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	WORD PTR [rcx+136], ax

; 4100 : 		window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);

	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@7f7fffff
	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR __real@ff7fffff
	lea	rcx, QWORD PTR $T132[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rdx, rax
	lea	rcx, QWORD PTR $T129[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect
	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T129[rsp]
	lea	rdi, QWORD PTR [rax+248]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 4101 : 		window->LastFrameActive = current_frame;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR current_frame$[rsp]
	mov	DWORD PTR [rax+224], ecx

; 4102 : 		window->IDStack.resize(1);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv387[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv387[rsp]
	call	?resize@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::resize

; 4103 : 
; 4104 : 		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
; 4105 : 		// The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
; 4106 : 		bool window_title_visible_elsewhere = false;

	mov	BYTE PTR window_title_visible_elsewhere$3[rsp], 0

; 4107 : 		if (g.NavWindowingList != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7120], 0
	je	SHORT $LN26@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 524288				; 00080000H
	test	eax, eax
	jne	SHORT $LN26@Begin

; 4108 : 			window_title_visible_elsewhere = true;

	mov	BYTE PTR window_title_visible_elsewhere$3[rsp], 1
$LN26@Begin:

; 4109 : 		if (window_title_visible_elsewhere && !window_just_created && hash_(name) != window->Name)

	movzx	eax, BYTE PTR window_title_visible_elsewhere$3[rsp]
	test	eax, eax
	je	SHORT $LN27@Begin
	movzx	eax, BYTE PTR window_just_created$[rsp]
	test	eax, eax
	jne	SHORT $LN27@Begin
	mov	rcx, QWORD PTR name$[rsp]
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	rcx, QWORD PTR window$[rsp]
	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN27@Begin

; 4110 : 		{
; 4111 : 			size_t buf_len = (size_t)window->NameBufLen;

	mov	rax, QWORD PTR window$[rsp]
	movsxd	rax, DWORD PTR [rax+64]
	mov	QWORD PTR buf_len$48[rsp], rax

; 4112 : 			window->Name = hash_(name);// ImStrdupcpy(window->Name, &buf_len, name);

	mov	rcx, QWORD PTR name$[rsp]
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR tv407[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv407[rsp]
	mov	QWORD PTR [rax+16], rcx

; 4113 : 			window->NameBufLen = (int)buf_len;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR buf_len$48[rsp]
	mov	DWORD PTR [rax+64], ecx
$LN27@Begin:

; 4114 : 		}
; 4115 : 
; 4116 : 		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
; 4117 : 
; 4118 : 		// Update contents size from last frame for auto-fitting (or use explicit size)
; 4119 : 		window->SizeContents = CalcSizeContents(window);

	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T123[rsp]
	call	?CalcSizeContents@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; CalcSizeContents
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T49[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T49[rsp]
	mov	QWORD PTR [rax+8], rcx

; 4120 : 		if (window->HiddenFramesRegular > 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+188], 0
	jle	SHORT $LN28@Begin

; 4121 : 			window->HiddenFramesRegular--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+188]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+188], eax
$LN28@Begin:

; 4122 : 		if (window->HiddenFramesForResize > 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jle	SHORT $LN29@Begin

; 4123 : 			window->HiddenFramesForResize--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+168]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+168], eax
$LN29@Begin:

; 4124 : 
; 4125 : 		// Hide new windows for one frame until they calculate their size
; 4126 : 		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))

	movzx	eax, BYTE PTR window_just_created$[rsp]
	test	eax, eax
	je	SHORT $LN30@Begin
	movzx	eax, BYTE PTR window_size_x_set_by_api$[rsp]
	test	eax, eax
	je	SHORT $LN31@Begin
	movzx	eax, BYTE PTR window_size_y_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN30@Begin
$LN31@Begin:

; 4127 : 			window->HiddenFramesForResize = 1;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+168], 1
$LN30@Begin:

; 4128 : 
; 4129 : 		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
; 4130 : 		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
; 4131 : 		if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)

	movzx	eax, BYTE PTR window_just_activated_by_user$[rsp]
	test	eax, eax
	je	$LN32@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	je	$LN32@Begin

; 4132 : 		{
; 4133 : 			window->HiddenFramesForResize = 1;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+168], 1

; 4134 : 			if (flags & ImGuiWindowFlags_AlwaysAutoResize)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN33@Begin

; 4135 : 			{
; 4136 : 				if (!window_size_x_set_by_api)

	movzx	eax, BYTE PTR window_size_x_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN34@Begin

; 4137 : 					window->Size.x = window->SizeFull.x = 0.f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+32], xmm0
	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
$LN34@Begin:

; 4138 : 				if (!window_size_y_set_by_api)

	movzx	eax, BYTE PTR window_size_y_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN35@Begin

; 4139 : 					window->Size.y = window->SizeFull.y = 0.f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+36], xmm0
	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
$LN35@Begin:

; 4140 : 				window->SizeContents = ImVec2(0.f, 0.f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T124[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T50[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T50[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN33@Begin:
$LN32@Begin:

; 4141 : 			}
; 4142 : 		}
; 4143 : 
; 4144 : 		SetCurrentWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?SetCurrentWindow@@YAXPEAUImGuiWindow@@@Z ; SetCurrentWindow

; 4145 : 
; 4146 : 		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
; 4147 : 		window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN144@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+40]
	movss	DWORD PTR tv504[rsp], xmm0
	jmp	SHORT $LN145@Begin
$LN144@Begin:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	je	SHORT $LN142@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $LN142@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv502[rsp], xmm0
	jmp	SHORT $LN143@Begin
$LN142@Begin:
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR tv502[rsp], xmm0
$LN143@Begin:
	movss	xmm0, DWORD PTR tv502[rsp]
	movss	DWORD PTR tv504[rsp], xmm0
$LN145@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv504[rsp]
	movss	DWORD PTR [rax+56], xmm0

; 4148 : 		window->WindowPadding = style.WindowPadding;

	mov	rax, QWORD PTR style$[rsp]
	mov	rax, QWORD PTR [rax+4]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 4149 : 		if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	$LN36@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67174400				; 04010000H
	test	eax, eax
	jne	SHORT $LN36@Begin
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN36@Begin
	jne	SHORT $LN36@Begin

; 4150 : 			window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN146@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR tv521[rsp], xmm0
	jmp	SHORT $LN147@Begin
$LN146@Begin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv521[rsp], xmm0
$LN147@Begin:
	movss	xmm2, DWORD PTR tv521[rsp]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T125[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T51[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T51[rsp]
	mov	QWORD PTR [rax+80], rcx
$LN36@Begin:

; 4151 : 		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7000]
	movss	DWORD PTR tv545[rsp], xmm0
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+68]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+80]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv543[rsp], xmm0
	movss	xmm1, DWORD PTR tv545[rsp]
	movss	xmm0, DWORD PTR tv543[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv547[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv547[rsp]
	movss	DWORD PTR [rax+460], xmm0

; 4152 : 		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+7004]
	movss	DWORD PTR [rax+464], xmm0

; 4153 : 
; 4154 : 		// Collapse window by double-clicking on title bar
; 4155 : 		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
; 4156 : 		if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN37@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN37@Begin

; 4157 : 		{
; 4158 : 			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
; 4159 : 			ImRect title_bar_rect = window->TitleBarRect();

	lea	rdx, QWORD PTR title_bar_rect$76[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::TitleBarRect
	npad	1

; 4160 : 			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6560], rcx
	jne	SHORT $LN39@Begin
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	jne	SHORT $LN39@Begin
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6724], 0
	jne	SHORT $LN39@Begin
	mov	r8b, 1
	lea	rdx, QWORD PTR title_bar_rect$76[rsp+8]
	lea	rcx, QWORD PTR title_bar_rect$76[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@Begin
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1021]
	test	eax, eax
	je	SHORT $LN39@Begin

; 4161 : 				window->WantCollapseToggle = true;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+114], 1
$LN39@Begin:

; 4162 : 			if (window->WantCollapseToggle)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+114]
	test	eax, eax
	je	SHORT $LN40@Begin

; 4163 : 			{
; 4164 : 				window->Collapsed = !window->Collapsed;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	SHORT $LN148@Begin
	mov	DWORD PTR tv586[rsp], 1
	jmp	SHORT $LN149@Begin
$LN148@Begin:
	mov	DWORD PTR tv586[rsp], 0
$LN149@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv586[rsp]
	mov	BYTE PTR [rax+113], cl

; 4165 : 				//MarkIniSettingsDirty(window);
; 4166 : 				FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN40@Begin:

; 4167 : 			}
; 4168 : 		}

	jmp	SHORT $LN38@Begin
$LN37@Begin:

; 4169 : 		else
; 4170 : 		{
; 4171 : 			window->Collapsed = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+113], 0
$LN38@Begin:

; 4172 : 		}
; 4173 : 		window->WantCollapseToggle = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+114], 0

; 4174 : 
; 4175 : 		// SIZE
; 4176 : 
; 4177 : 		// Calculate auto-fit size, handle automatic resize
; 4178 : 		const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 8
	mov	r8, rax
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR size_auto_fit$17[rsp]
	call	?CalcSizeAutoFit@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z ; CalcSizeAutoFit

; 4179 : 		ImVec2 size_full_modified(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR size_full_modified$11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 4180 : 		if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN41@Begin
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	SHORT $LN41@Begin

; 4181 : 		{
; 4182 : 			// Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
; 4183 : 			if (!window_size_x_set_by_api)

	movzx	eax, BYTE PTR window_size_x_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN43@Begin

; 4184 : 				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;

	movss	xmm0, DWORD PTR size_auto_fit$17[rsp]
	movss	DWORD PTR size_full_modified$11[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR size_full_modified$11[rsp]
	movss	DWORD PTR [rax+32], xmm0
$LN43@Begin:

; 4185 : 			if (!window_size_y_set_by_api)

	movzx	eax, BYTE PTR window_size_y_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN44@Begin

; 4186 : 				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;

	movss	xmm0, DWORD PTR size_auto_fit$17[rsp+4]
	movss	DWORD PTR size_full_modified$11[rsp+4], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR size_full_modified$11[rsp+4]
	movss	DWORD PTR [rax+36], xmm0
$LN44@Begin:

; 4187 : 		}

	jmp	$LN42@Begin
$LN41@Begin:

; 4188 : 		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	SHORT $LN46@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jle	$LN45@Begin
$LN46@Begin:

; 4189 : 		{
; 4190 : 			// Auto-fit may only grow window during the first few frames
; 4191 : 			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
; 4192 : 			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)

	movzx	eax, BYTE PTR window_size_x_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN47@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jle	SHORT $LN47@Begin

; 4193 : 				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+164]
	test	eax, eax
	je	SHORT $LN150@Begin
	movss	xmm1, DWORD PTR size_auto_fit$17[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv629[rsp], xmm0
	jmp	SHORT $LN151@Begin
$LN150@Begin:
	movss	xmm0, DWORD PTR size_auto_fit$17[rsp]
	movss	DWORD PTR tv629[rsp], xmm0
$LN151@Begin:
	movss	xmm0, DWORD PTR tv629[rsp]
	movss	DWORD PTR size_full_modified$11[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR size_full_modified$11[rsp]
	movss	DWORD PTR [rax+32], xmm0
$LN47@Begin:

; 4194 : 			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)

	movzx	eax, BYTE PTR window_size_y_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN48@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jle	SHORT $LN48@Begin

; 4195 : 				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+164]
	test	eax, eax
	je	SHORT $LN152@Begin
	movss	xmm1, DWORD PTR size_auto_fit$17[rsp+4]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv644[rsp], xmm0
	jmp	SHORT $LN153@Begin
$LN152@Begin:
	movss	xmm0, DWORD PTR size_auto_fit$17[rsp+4]
	movss	DWORD PTR tv644[rsp], xmm0
$LN153@Begin:
	movss	xmm0, DWORD PTR tv644[rsp]
	movss	DWORD PTR size_full_modified$11[rsp+4], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR size_full_modified$11[rsp+4]
	movss	DWORD PTR [rax+36], xmm0
$LN48@Begin:
$LN45@Begin:
$LN42@Begin:

; 4196 : 			//if (!window->Collapsed)
; 4197 : 			   // MarkIniSettingsDirty(window);
; 4198 : 		}
; 4199 : 
; 4200 : 		// Apply minimum/maximum window size constraints and final size
; 4201 : 		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);

	mov	rax, QWORD PTR window$[rsp]
	mov	r8, QWORD PTR [rax+32]
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T126[rsp]
	call	?CalcSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@U1@@Z ; CalcSizeAfterConstraint
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T52[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T52[rsp]
	mov	QWORD PTR [rax+32], rcx

; 4202 : 		window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	je	SHORT $LN154@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN154@Begin
	lea	rdx, QWORD PTR $T133[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::TitleBarRect
	mov	QWORD PTR tv666[rsp], rax
	lea	rdx, QWORD PTR $T127[rsp]
	mov	rcx, QWORD PTR tv666[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	mov	QWORD PTR tv669[rsp], rax
	jmp	SHORT $LN155@Begin
$LN154@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR $T53[rsp], rax
	lea	rax, QWORD PTR $T53[rsp]
	mov	QWORD PTR tv669[rsp], rax
$LN155@Begin:
	mov	rax, QWORD PTR tv669[rsp]
	mov	QWORD PTR $T54[rsp], rax
	mov	rax, QWORD PTR $T54[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx], rax

; 4203 : 
; 4204 : 		// SCROLLBAR STATUS
; 4205 : 
; 4206 : 		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
; 4207 : 		if (!window->Collapsed)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	$LN49@Begin

; 4208 : 		{
; 4209 : 			// When reading the current size we need to read it after size constraints have been applied
; 4210 : 			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;

	movss	xmm0, DWORD PTR size_full_modified$11[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN249@Begin
	je	SHORT $LN156@Begin
$LN249@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	movss	DWORD PTR tv679[rsp], xmm0
	jmp	SHORT $LN157@Begin
$LN156@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+40]
	movss	DWORD PTR tv679[rsp], xmm0
$LN157@Begin:
	movss	xmm0, DWORD PTR tv679[rsp]
	movss	DWORD PTR size_x_for_scrollbars$36[rsp], xmm0

; 4211 : 			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;

	movss	xmm0, DWORD PTR size_full_modified$11[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN248@Begin
	je	SHORT $LN158@Begin
$LN248@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	movss	DWORD PTR tv685[rsp], xmm0
	jmp	SHORT $LN159@Begin
$LN158@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+44]
	movss	DWORD PTR tv685[rsp], xmm0
$LN159@Begin:
	movss	xmm0, DWORD PTR tv685[rsp]
	movss	DWORD PTR size_y_for_scrollbars$20[rsp], xmm0

; 4212 : 			window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16384				; 00004000H
	test	eax, eax
	jne	SHORT $LN161@Begin
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR size_y_for_scrollbars$20[rsp]
	jbe	SHORT $LN160@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN161@Begin
$LN160@Begin:
	mov	DWORD PTR tv694[rsp], 0
	jmp	SHORT $LN162@Begin
$LN161@Begin:
	mov	DWORD PTR tv694[rsp], 1
$LN162@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv694[rsp]
	mov	BYTE PTR [rax+101], cl

; 4213 : 			window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32768				; 00008000H
	test	eax, eax
	jne	SHORT $LN166@Begin
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	test	eax, eax
	je	SHORT $LN163@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+100]
	movss	DWORD PTR tv704[rsp], xmm0
	jmp	SHORT $LN164@Begin
$LN163@Begin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv704[rsp], xmm0
$LN164@Begin:
	movss	xmm0, DWORD PTR size_x_for_scrollbars$36[rsp]
	subss	xmm0, DWORD PTR tv704[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	comiss	xmm1, xmm0
	jbe	SHORT $LN165@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN165@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	jne	SHORT $LN166@Begin
$LN165@Begin:
	mov	DWORD PTR tv712[rsp], 0
	jmp	SHORT $LN167@Begin
$LN166@Begin:
	mov	DWORD PTR tv712[rsp], 1
$LN167@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv712[rsp]
	mov	BYTE PTR [rax+100], cl

; 4214 : 			if (window->ScrollbarX && !window->ScrollbarY)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	test	eax, eax
	je	SHORT $LN50@Begin
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	test	eax, eax
	jne	SHORT $LN50@Begin

; 4215 : 				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR size_y_for_scrollbars$20[rsp]
	subss	xmm0, DWORD PTR [rax+100]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN168@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN168@Begin
	mov	DWORD PTR tv728[rsp], 1
	jmp	SHORT $LN169@Begin
$LN168@Begin:
	mov	DWORD PTR tv728[rsp], 0
$LN169@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv728[rsp]
	mov	BYTE PTR [rax+101], cl
$LN50@Begin:

; 4216 : 			window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	test	eax, eax
	je	SHORT $LN170@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+100]
	movss	DWORD PTR tv737[rsp], xmm0
	jmp	SHORT $LN171@Begin
$LN170@Begin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv737[rsp], xmm0
$LN171@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	test	eax, eax
	je	SHORT $LN172@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+100]
	movss	DWORD PTR tv743[rsp], xmm0
	jmp	SHORT $LN173@Begin
$LN172@Begin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv743[rsp], xmm0
$LN173@Begin:
	movss	xmm2, DWORD PTR tv737[rsp]
	movss	xmm1, DWORD PTR tv743[rsp]
	lea	rcx, QWORD PTR $T128[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T55[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T55[rsp]
	mov	QWORD PTR [rax+124], rcx
$LN49@Begin:

; 4217 : 		}
; 4218 : 
; 4219 : 		// POSITION
; 4220 : 
; 4221 : 		// Popup latch its initial position, will position itself when it appears next frame
; 4222 : 		if (window_just_activated_by_user)

	movzx	eax, BYTE PTR window_just_activated_by_user$[rsp]
	test	eax, eax
	je	SHORT $LN51@Begin

; 4223 : 		{
; 4224 : 			window->AutoPosLastDirection = ImGuiDir_None;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+184], -1

; 4225 : 			if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN52@Begin
	movzx	eax, BYTE PTR window_pos_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN52@Begin

; 4226 : 				window->Pos = g.BeginPopupStack.back().OpenPopupPos;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@XZ ; ImVector<ImGuiPopupRef>::back
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR $T56[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T56[rsp]
	mov	QWORD PTR [rax+48], rcx
$LN52@Begin:
$LN51@Begin:

; 4227 : 		}
; 4228 : 
; 4229 : 		// Position child window
; 4230 : 		if (flags & ImGuiWindowFlags_ChildWindow)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN53@Begin

; 4231 : 		{
; 4232 : 			IM_ASSERT(parent_window && parent_window->Active);
; 4233 : 			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	movzx	ecx, WORD PTR [rcx+432]
	mov	WORD PTR [rax+138], cx

; 4234 : 			parent_window->DC.ChildWindows.push_back(window);

	mov	rax, QWORD PTR parent_window$[rsp]
	add	rax, 432				; 000001b0H
	mov	QWORD PTR tv772[rsp], rax
	lea	rdx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tv772[rsp]
	call	?push_back@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEBQEAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
	npad	1

; 4235 : 			if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $LN54@Begin
	movzx	eax, BYTE PTR window_pos_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN54@Begin
	movzx	eax, BYTE PTR window_is_child_tooltip$2[rsp]
	test	eax, eax
	jne	SHORT $LN54@Begin

; 4236 : 				window->Pos = parent_window->DC.CursorPos;

	mov	rax, QWORD PTR parent_window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+48], rax
$LN54@Begin:
$LN53@Begin:

; 4237 : 		}
; 4238 : 
; 4239 : 		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesForResize == 0);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+192]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN247@Begin
	je	SHORT $LN174@Begin
$LN247@Begin:
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jne	SHORT $LN174@Begin
	mov	BYTE PTR tv788[rsp], 1
	jmp	SHORT $LN175@Begin
$LN174@Begin:
	mov	BYTE PTR tv788[rsp], 0
$LN175@Begin:
	movzx	eax, BYTE PTR tv788[rsp]
	mov	BYTE PTR window_pos_with_pivot$8[rsp], al

; 4240 : 		if (window_pos_with_pivot)

	movzx	eax, BYTE PTR window_pos_with_pivot$8[rsp]
	test	eax, eax
	je	$LN55@Begin

; 4241 : 			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 200				; 000000c8H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 32					; 00000020H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T77[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	QWORD PTR tv807[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 192				; 000000c0H
	mov	QWORD PTR tv805[rsp], rax
	mov	r8, QWORD PTR tv807[rsp]
	mov	rdx, QWORD PTR tv805[rsp]
	lea	rcx, QWORD PTR $T78[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, QWORD PTR style$[rsp]
	add	rcx, 148				; 00000094H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T79[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	QWORD PTR tv817[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR tv815[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv817[rsp]
	mov	rcx, QWORD PTR tv815[rsp]
	call	?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z ; ImGui::SetWindowPos
	npad	1
	jmp	$LN56@Begin
$LN55@Begin:

; 4242 : 		else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN57@Begin

; 4243 : 			window->Pos = FindBestWindowPosForPopup(window);

	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T80[rsp]
	call	?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::FindBestWindowPosForPopup
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T57[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T57[rsp]
	mov	QWORD PTR [rax+48], rcx
	jmp	$LN58@Begin
$LN57@Begin:

; 4244 : 		else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN59@Begin
	movzx	eax, BYTE PTR window_pos_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN59@Begin
	movzx	eax, BYTE PTR window_just_appearing_after_hidden_for_resize$[rsp]
	test	eax, eax
	je	SHORT $LN59@Begin

; 4245 : 			window->Pos = FindBestWindowPosForPopup(window);

	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T81[rsp]
	call	?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::FindBestWindowPosForPopup
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T58[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T58[rsp]
	mov	QWORD PTR [rax+48], rcx
	jmp	SHORT $LN60@Begin
$LN59@Begin:

; 4246 : 		else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN61@Begin
	movzx	eax, BYTE PTR window_pos_set_by_api$[rsp]
	test	eax, eax
	jne	SHORT $LN61@Begin
	movzx	eax, BYTE PTR window_is_child_tooltip$2[rsp]
	test	eax, eax
	jne	SHORT $LN61@Begin

; 4247 : 			window->Pos = FindBestWindowPosForPopup(window);

	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T82[rsp]
	call	?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::FindBestWindowPosForPopup
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T59[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T59[rsp]
	mov	QWORD PTR [rax+48], rcx
$LN61@Begin:
$LN60@Begin:
$LN58@Begin:
$LN56@Begin:

; 4248 : 
; 4249 : 		// Clamp position so it stays visible
; 4250 : 		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
; 4251 : 		if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)

	movzx	eax, BYTE PTR window_pos_set_by_api$[rsp]
	test	eax, eax
	jne	$LN62@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	$LN62@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	$LN62@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jg	$LN62@Begin

; 4252 : 		{
; 4253 : 			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN63@Begin
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN63@Begin

; 4254 : 			{
; 4255 : 				ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 148				; 00000094H
	mov	rcx, QWORD PTR style$[rsp]
	add	rcx, 140				; 0000008cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR padding$41[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	npad	1

; 4256 : 				ImVec2 size_for_clamping = ((g.IO.ConfigWindowsMoveFromTitleBarOnly) && !(window->Flags & ImGuiWindowFlags_NoTitleBar)) ? ImVec2(window->Size.x, window->TitleBarHeight()) : window->Size;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+211]
	test	eax, eax
	je	SHORT $LN176@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN176@Begin
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	DWORD PTR tv921[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv919[rsp], xmm0
	movss	xmm2, DWORD PTR tv921[rsp]
	movss	xmm1, DWORD PTR tv919[rsp]
	lea	rcx, QWORD PTR $T83[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv924[rsp], rax
	jmp	SHORT $LN177@Begin
$LN176@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T60[rsp], rax
	lea	rax, QWORD PTR $T60[rsp]
	mov	QWORD PTR tv924[rsp], rax
$LN177@Begin:
	mov	rax, QWORD PTR tv924[rsp]
	mov	QWORD PTR $T61[rsp], rax
	mov	rax, QWORD PTR $T61[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR size_for_clamping$40[rsp], rax

; 4257 : 				window->Pos = ImMax(window->Pos + size_for_clamping, padding) - size_for_clamping;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	lea	r8, QWORD PTR size_for_clamping$40[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T84[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	lea	r8, QWORD PTR padding$41[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T85[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	lea	r8, QWORD PTR size_for_clamping$40[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T86[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T62[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T62[rsp]
	mov	QWORD PTR [rax+48], rcx

; 4258 : 				window->Pos = ImMin(window->Pos, g.IO.DisplaySize - padding);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 20
	lea	r8, QWORD PTR padding$41[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T87[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv957[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv955[rsp], rax
	mov	r8, QWORD PTR tv957[rsp]
	mov	rdx, QWORD PTR tv955[rsp]
	lea	rcx, QWORD PTR $T88[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T63[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T63[rsp]
	mov	QWORD PTR [rax+48], rcx
$LN63@Begin:
$LN62@Begin:

; 4259 : 			}
; 4260 : 		}
; 4261 : 		window->Pos = ImFloor(window->Pos);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	rdx, rax
	lea	rcx, QWORD PTR $T89[rsp]
	call	?ImFloor@@YA?AUImVec2@@AEBU1@@Z		; ImFloor
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T64[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T64[rsp]
	mov	QWORD PTR [rax+48], rcx

; 4262 : 
; 4263 : 		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
; 4264 : 		window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN180@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	movss	DWORD PTR tv978[rsp], xmm0
	jmp	SHORT $LN181@Begin
$LN180@Begin:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN178@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $LN178@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+44]
	movss	DWORD PTR tv976[rsp], xmm0
	jmp	SHORT $LN179@Begin
$LN178@Begin:
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv976[rsp], xmm0
$LN179@Begin:
	movss	xmm0, DWORD PTR tv976[rsp]
	movss	DWORD PTR tv978[rsp], xmm0
$LN181@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv978[rsp]
	movss	DWORD PTR [rax+88], xmm0

; 4265 : 
; 4266 : 		// Prepare for item focus requests
; 4267 : 		window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter + 1)) % (window->FocusIdxAllCounter + 1);

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+952], 2147483647		; 7fffffffH
	je	SHORT $LN182@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+944], -1
	je	SHORT $LN182@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+944]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+952]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+944]
	inc	ecx
	cdq
	idiv	ecx
	mov	eax, edx
	mov	DWORD PTR tv991[rsp], eax
	jmp	SHORT $LN183@Begin
$LN182@Begin:
	mov	DWORD PTR tv991[rsp], 2147483647	; 7fffffffH
$LN183@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv991[rsp]
	mov	DWORD PTR [rax+948], ecx

; 4268 : 		window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter + 1)) % (window->FocusIdxTabCounter + 1);

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+964], 2147483647		; 7fffffffH
	je	SHORT $LN184@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+960], -1
	je	SHORT $LN184@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+960]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+964]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+960]
	inc	ecx
	cdq
	idiv	ecx
	mov	eax, edx
	mov	DWORD PTR tv1004[rsp], eax
	jmp	SHORT $LN185@Begin
$LN184@Begin:
	mov	DWORD PTR tv1004[rsp], 2147483647	; 7fffffffH
$LN185@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv1004[rsp]
	mov	DWORD PTR [rax+956], ecx

; 4269 : 		window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+960], -1
	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+944], -1

; 4270 : 		window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+964], 2147483647		; 7fffffffH
	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+952], 2147483647		; 7fffffffH

; 4271 : 
; 4272 : 		// Apply scrolling
; 4273 : 		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);

	mov	r8b, 1
	mov	rdx, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T90[rsp]
	call	?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PEAUImGuiWindow@@_N@Z ; CalcNextScrollFromScrollTargetAndClamp
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T65[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T65[rsp]
	mov	QWORD PTR [rax+92], rcx

; 4274 : 		window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T91[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T66[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T66[rsp]
	mov	QWORD PTR [rax+104], rcx

; 4275 : 
; 4276 : 		// Apply window focus (new and reactivated windows are moved to front)
; 4277 : 		bool want_focus = false;

	mov	BYTE PTR want_focus$1[rsp], 0

; 4278 : 		if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))

	movzx	eax, BYTE PTR window_just_activated_by_user$[rsp]
	test	eax, eax
	je	SHORT $LN64@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	jne	SHORT $LN64@Begin

; 4279 : 		{
; 4280 : 			if (flags & ImGuiWindowFlags_Popup)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN65@Begin

; 4281 : 				want_focus = true;

	mov	BYTE PTR want_focus$1[rsp], 1
	jmp	SHORT $LN66@Begin
$LN65@Begin:

; 4282 : 			else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 50331648				; 03000000H
	test	eax, eax
	jne	SHORT $LN67@Begin

; 4283 : 				want_focus = true;

	mov	BYTE PTR want_focus$1[rsp], 1
$LN67@Begin:
$LN66@Begin:
$LN64@Begin:

; 4284 : 		}
; 4285 : 
; 4286 : 		// Handle manual resize: Resize Grips, Borders, Gamepad
; 4287 : 		int border_held = -1;

	mov	DWORD PTR border_held$21[rsp], -1

; 4288 : 		ImU32 resize_grip_col[4] = { 0 };

	lea	rax, QWORD PTR resize_grip_col$136[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 4289 : 		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+212]
	test	eax, eax
	je	SHORT $LN186@Begin
	mov	DWORD PTR tv1039[rsp], 2
	jmp	SHORT $LN187@Begin
$LN186@Begin:
	mov	DWORD PTR tv1039[rsp], 1
$LN187@Begin:
	mov	eax, DWORD PTR tv1039[rsp]
	mov	DWORD PTR resize_grip_count$22[rsp], eax

; 4290 : 		const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3e4ccccd
	addss	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3faccccd
	movss	DWORD PTR tv1048[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1048[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR grip_draw_size$12[rsp], xmm0

; 4291 : 		if (!window->Collapsed)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	SHORT $LN68@Begin

; 4292 : 			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);

	mov	eax, 4
	imul	rax, rax, 0
	lea	rax, QWORD PTR resize_grip_col$136[rsp+rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR resize_grip_count$22[rsp]
	lea	r8, QWORD PTR border_held$21[rsp]
	lea	rdx, QWORD PTR size_auto_fit$17[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?UpdateManualResize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@PEAHHQEAI@Z ; ImGui::UpdateManualResize
	npad	1
$LN68@Begin:

; 4293 : 		window->ResizeBorderHeld = (signed char)border_held;

	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR border_held$21[rsp]
	mov	BYTE PTR [rax+134], cl

; 4294 : 
; 4295 : 		// Default item width. Make it proportional to window size if window manually resizes
; 4296 : 		if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN69@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	jne	SHORT $LN69@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN69@Begin

; 4297 : 			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR __real@3f266666
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+280], xmm0
	jmp	SHORT $LN70@Begin
$LN69@Begin:

; 4298 : 		else
; 4299 : 			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@41800000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+280], xmm0
$LN70@Begin:

; 4300 : 
; 4301 : 		// DRAWING
; 4302 : 
; 4303 : 		// Setup draw list and outer clipping rectangle
; 4304 : 		window->DrawList->Clear();

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?Clear@ImDrawList@@QEAAXXZ		; ImDrawList::Clear

; 4305 : 		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+5632]
	test	eax, eax
	je	SHORT $LN188@Begin
	mov	DWORD PTR tv1091[rsp], 1
	jmp	SHORT $LN189@Begin
$LN188@Begin:
	mov	DWORD PTR tv1091[rsp], 0
$LN189@Begin:
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+5633]
	test	eax, eax
	je	SHORT $LN190@Begin
	mov	DWORD PTR tv1096[rsp], 2
	jmp	SHORT $LN191@Begin
$LN190@Begin:
	mov	DWORD PTR tv1096[rsp], 0
$LN191@Begin:
	mov	eax, DWORD PTR tv1096[rsp]
	mov	ecx, DWORD PTR tv1091[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rcx+696]
	mov	DWORD PTR [rcx+16], eax

; 4306 : 		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1105[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+72]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv1105[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID

; 4307 : 		ImRect viewport_rect(GetViewportRect());

	lea	rcx, QWORD PTR viewport_rect$38[rsp]
	call	?GetViewportRect@@YA?AUImRect@@XZ	; GetViewportRect
	npad	1

; 4308 : 		if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN71@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $LN71@Begin
	movzx	eax, BYTE PTR window_is_child_tooltip$2[rsp]
	test	eax, eax
	jne	SHORT $LN71@Begin

; 4309 : 			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);

	mov	rax, QWORD PTR parent_window$[rsp]
	add	rax, 256				; 00000100H
	mov	rcx, QWORD PTR parent_window$[rsp]
	add	rcx, 248				; 000000f8H
	mov	r8b, 1
	mov	rdx, rax
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1
	jmp	SHORT $LN72@Begin
$LN71@Begin:

; 4310 : 		else
; 4311 : 			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

	mov	r8b, 1
	lea	rdx, QWORD PTR viewport_rect$38[rsp+8]
	lea	rcx, QWORD PTR viewport_rect$38[rsp]
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1
$LN72@Begin:

; 4312 : 
; 4313 : 		// Draw modal window background (darkens what is behind them, all viewports)
; 4314 : 		const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesForResize <= 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN192@Begin
	call	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
	cmp	QWORD PTR window$[rsp], rax
	jne	SHORT $LN192@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jg	SHORT $LN192@Begin
	mov	BYTE PTR tv1129[rsp], 1
	jmp	SHORT $LN193@Begin
$LN192@Begin:
	mov	BYTE PTR tv1129[rsp], 0
$LN193@Begin:
	movzx	eax, BYTE PTR tv1129[rsp]
	mov	BYTE PTR dim_bg_for_modal$4[rsp], al

; 4315 : 		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7112], 0
	je	SHORT $LN194@Begin
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7112]
	mov	rax, QWORD PTR [rax+688]
	cmp	QWORD PTR window$[rsp], rax
	jne	SHORT $LN194@Begin
	mov	BYTE PTR tv1135[rsp], 1
	jmp	SHORT $LN195@Begin
$LN194@Begin:
	mov	BYTE PTR tv1135[rsp], 0
$LN195@Begin:
	movzx	eax, BYTE PTR tv1135[rsp]
	mov	BYTE PTR dim_bg_for_window_list$5[rsp], al

; 4316 : 		if (dim_bg_for_modal || dim_bg_for_window_list)

	movzx	eax, BYTE PTR dim_bg_for_modal$4[rsp]
	test	eax, eax
	jne	SHORT $LN74@Begin
	movzx	eax, BYTE PTR dim_bg_for_window_list$5[rsp]
	test	eax, eax
	je	$LN73@Begin
$LN74@Begin:

; 4317 : 		{
; 4318 : 			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7592]
	movss	DWORD PTR tv1148[rsp], xmm0
	movzx	eax, BYTE PTR dim_bg_for_modal$4[rsp]
	test	eax, eax
	je	SHORT $LN196@Begin
	mov	DWORD PTR tv1145[rsp], 47		; 0000002fH
	jmp	SHORT $LN197@Begin
$LN196@Begin:
	mov	DWORD PTR tv1145[rsp], 46		; 0000002eH
$LN197@Begin:
	movss	xmm1, DWORD PTR tv1148[rsp]
	mov	ecx, DWORD PTR tv1145[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR dim_bg_col$29[rsp], eax

; 4319 : 			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1189[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR dim_bg_col$29[rsp]
	lea	r8, QWORD PTR viewport_rect$38[rsp+8]
	lea	rdx, QWORD PTR viewport_rect$38[rsp]
	mov	rcx, QWORD PTR tv1189[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN73@Begin:

; 4320 : 		}
; 4321 : 
; 4322 : 		// Draw navigation selection/windowing rectangle background
; 4323 : 		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)

	movzx	eax, BYTE PTR dim_bg_for_window_list$5[rsp]
	test	eax, eax
	je	$LN75@Begin
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7112]
	cmp	QWORD PTR window$[rsp], rax
	jne	$LN75@Begin

; 4324 : 		{
; 4325 : 			ImRect bb = window->Rect();

	lea	rdx, QWORD PTR bb$46[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect

; 4326 : 			bb.Expand(g.FontSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	lea	rcx, QWORD PTR bb$46[rsp]
	call	?Expand@ImRect@@QEAAXM@Z		; ImRect::Expand
	npad	1

; 4327 : 			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway

	lea	rdx, QWORD PTR viewport_rect$38[rsp]
	lea	rcx, QWORD PTR bb$46[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	$LN76@Begin

; 4328 : 				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1223[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5484]
	movss	DWORD PTR tv1221[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7096]
	mulss	xmm0, DWORD PTR __real@3e800000
	movaps	xmm1, xmm0
	mov	ecx, 45					; 0000002dH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv1219[rsp], eax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR tv1221[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1219[rsp]
	lea	r8, QWORD PTR bb$46[rsp+8]
	lea	rdx, QWORD PTR bb$46[rsp]
	mov	rcx, QWORD PTR tv1223[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN76@Begin:
$LN75@Begin:

; 4329 : 		}
; 4330 : 
; 4331 : 		// Draw window + handle manual resize
; 4332 : 		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
; 4333 : 		const float window_rounding = window->WindowRounding;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	movss	DWORD PTR window_rounding$9[rsp], xmm0

; 4334 : 		const float window_border_size = window->WindowBorderSize;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR window_border_size$10[rsp], xmm0

; 4335 : 		const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	SHORT $LN198@Begin
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	QWORD PTR tv1230[rsp], rax
	jmp	SHORT $LN199@Begin
$LN198@Begin:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR tv1230[rsp], rax
$LN199@Begin:
	mov	rax, QWORD PTR tv1230[rsp]
	mov	QWORD PTR window_to_highlight$42[rsp], rax

; 4336 : 		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);

	movzx	eax, BYTE PTR want_focus$1[rsp]
	test	eax, eax
	jne	SHORT $LN201@Begin
	cmp	QWORD PTR window_to_highlight$42[rsp], 0
	je	SHORT $LN200@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window_to_highlight$42[rsp]
	mov	rcx, QWORD PTR [rcx+704]
	cmp	QWORD PTR [rax+704], rcx
	je	SHORT $LN201@Begin
$LN200@Begin:
	mov	BYTE PTR tv1237[rsp], 0
	jmp	SHORT $LN202@Begin
$LN201@Begin:
	mov	BYTE PTR tv1237[rsp], 1
$LN202@Begin:
	movzx	eax, BYTE PTR tv1237[rsp]
	mov	BYTE PTR title_bar_is_highlight$6[rsp], al

; 4337 : 		const ImRect title_bar_rect = window->TitleBarRect();

	lea	rdx, QWORD PTR title_bar_rect$27[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::TitleBarRect
	npad	1

; 4338 : 		if (window->Collapsed)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	je	$LN77@Begin

; 4339 : 		{
; 4340 : 			// Title bar only
; 4341 : 			float backup_border_size = style.FrameBorderSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR backup_border_size$31[rsp], xmm0

; 4342 : 			g.Style.FrameBorderSize = window->WindowBorderSize;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR [rax+5536], xmm0

; 4343 : 			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);

	movzx	eax, BYTE PTR title_bar_is_highlight$6[rsp]
	test	eax, eax
	je	SHORT $LN203@Begin
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN203@Begin
	mov	DWORD PTR tv1254[rsp], 11
	jmp	SHORT $LN204@Begin
$LN203@Begin:
	mov	DWORD PTR tv1254[rsp], 12
$LN204@Begin:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv1254[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR title_bar_col$30[rsp], eax

; 4344 : 			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);

	movss	xmm0, DWORD PTR window_rounding$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR title_bar_col$30[rsp]
	mov	rdx, QWORD PTR title_bar_rect$27[rsp+8]
	mov	rcx, QWORD PTR title_bar_rect$27[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 4345 : 			g.Style.FrameBorderSize = backup_border_size;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR backup_border_size$31[rsp]
	movss	DWORD PTR [rax+5536], xmm0

; 4346 : 		}

	jmp	$LN78@Begin
$LN77@Begin:

; 4347 : 		else
; 4348 : 		{
; 4349 : 			// Window background
; 4350 : 			if (!(flags & ImGuiWindowFlags_NoBackground))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	$LN79@Begin

; 4351 : 			{
; 4352 : 				ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));

	mov	ecx, DWORD PTR flags$[rsp]
	call	?GetWindowBgColorIdxFromFlags@@YAHH@Z	; GetWindowBgColorIdxFromFlags
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR bg_col$14[rsp], eax

; 4353 : 				float alpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR alpha$13[rsp], xmm0

; 4354 : 				if (g.NextWindowData.BgAlphaCond != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6928], 0
	je	SHORT $LN80@Begin

; 4355 : 					alpha = g.NextWindowData.BgAlphaVal;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6996]
	movss	DWORD PTR alpha$13[rsp], xmm0
$LN80@Begin:

; 4356 : 				if (alpha != 1.0f)

	movss	xmm0, DWORD PTR alpha$13[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN246@Begin
	je	SHORT $LN81@Begin
$LN246@Begin:

; 4357 : 					bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);

	mov	eax, DWORD PTR bg_col$14[rsp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR tv1276[rsp], eax
	movss	xmm0, DWORD PTR alpha$13[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	shl	eax, 24
	mov	ecx, DWORD PTR tv1276[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR bg_col$14[rsp], eax
$LN81@Begin:

; 4358 : 				window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1321[rsp], rax
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN205@Begin
	mov	DWORD PTR tv1289[rsp], 15
	jmp	SHORT $LN206@Begin
$LN205@Begin:
	mov	DWORD PTR tv1289[rsp], 12
$LN206@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T92[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1319[rsp], rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movaps	xmm2, xmm0
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T93[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1314[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv1312[rsp], rax
	mov	r8, QWORD PTR tv1314[rsp]
	mov	rdx, QWORD PTR tv1312[rsp]
	lea	rcx, QWORD PTR $T94[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1317[rsp], rax
	mov	eax, DWORD PTR tv1289[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR window_rounding$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR bg_col$14[rsp]
	mov	r8, QWORD PTR tv1319[rsp]
	mov	rdx, QWORD PTR tv1317[rsp]
	mov	rcx, QWORD PTR tv1321[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN79@Begin:

; 4359 : 			}
; 4360 : 			g.NextWindowData.BgAlphaCond = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6928], 0

; 4361 : 
; 4362 : 			// Title bar
; 4363 : 			if (!(flags & ImGuiWindowFlags_NoTitleBar))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN82@Begin

; 4364 : 			{
; 4365 : 				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);

	movzx	eax, BYTE PTR title_bar_is_highlight$6[rsp]
	test	eax, eax
	je	SHORT $LN207@Begin
	mov	DWORD PTR tv1330[rsp], 11
	jmp	SHORT $LN208@Begin
$LN207@Begin:
	mov	DWORD PTR tv1330[rsp], 10
$LN208@Begin:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv1330[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR title_bar_col$32[rsp], eax

; 4366 : 				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1340[rsp], rax
	mov	DWORD PTR [rsp+40], 3
	movss	xmm0, DWORD PTR window_rounding$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR title_bar_col$32[rsp]
	lea	r8, QWORD PTR title_bar_rect$27[rsp+8]
	lea	rdx, QWORD PTR title_bar_rect$27[rsp]
	mov	rcx, QWORD PTR tv1340[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN82@Begin:

; 4367 : 			}
; 4368 : 
; 4369 : 			// Menu bar
; 4370 : 			if (flags & ImGuiWindowFlags_MenuBar)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	$LN83@Begin

; 4371 : 			{
; 4372 : 				ImRect menu_bar_rect = window->MenuBarRect();

	lea	rdx, QWORD PTR menu_bar_rect$37[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::MenuBarRect
	npad	1

; 4373 : 				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.

	lea	rdx, QWORD PTR $T134[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect
	mov	rdx, rax
	lea	rcx, QWORD PTR menu_bar_rect$37[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith
	npad	1

; 4374 : 				window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1366[rsp], rax
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN209@Begin
	movss	xmm0, DWORD PTR window_rounding$9[rsp]
	movss	DWORD PTR tv1355[rsp], xmm0
	jmp	SHORT $LN210@Begin
$LN209@Begin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv1355[rsp], xmm0
$LN210@Begin:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 13
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv1364[rsp], eax
	mov	DWORD PTR [rsp+40], 3
	movss	xmm0, DWORD PTR tv1355[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1364[rsp]
	lea	r8, QWORD PTR menu_bar_rect$37[rsp+8]
	lea	rdx, QWORD PTR menu_bar_rect$37[rsp]
	mov	rcx, QWORD PTR tv1366[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 4375 : 				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN84@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR [rcx+4]
	comiss	xmm0, DWORD PTR menu_bar_rect$37[rsp+12]
	jbe	$LN84@Begin

; 4376 : 					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1400[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR tv1398[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv1396[rsp], eax
	lea	rdx, QWORD PTR $T95[rsp]
	lea	rcx, QWORD PTR menu_bar_rect$37[rsp]
	call	?GetBR@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBR
	mov	QWORD PTR tv1394[rsp], rax
	lea	rdx, QWORD PTR $T96[rsp]
	lea	rcx, QWORD PTR menu_bar_rect$37[rsp]
	call	?GetBL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBL
	mov	QWORD PTR tv1392[rsp], rax
	movss	xmm0, DWORD PTR tv1398[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1396[rsp]
	mov	r8, QWORD PTR tv1394[rsp]
	mov	rdx, QWORD PTR tv1392[rsp]
	mov	rcx, QWORD PTR tv1400[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
$LN84@Begin:
$LN83@Begin:

; 4377 : 			}
; 4378 : 
; 4379 : 			// Scrollbars
; 4380 : 			if (window->ScrollbarX)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	test	eax, eax
	je	SHORT $LN85@Begin

; 4381 : 				Scrollbar(ImGuiAxis_X);

	xor	ecx, ecx
	call	?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z	; ImGui::Scrollbar
	npad	1
$LN85@Begin:

; 4382 : 			if (window->ScrollbarY)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	test	eax, eax
	je	SHORT $LN86@Begin

; 4383 : 				Scrollbar(ImGuiAxis_Y);

	mov	ecx, 1
	call	?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z	; ImGui::Scrollbar
	npad	1
$LN86@Begin:

; 4384 : 
; 4385 : 			// Render resize grips (after their input handling so we don't have a frame of latency)
; 4386 : 			if (!(flags & ImGuiWindowFlags_NoResize))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	$LN87@Begin

; 4387 : 			{
; 4388 : 				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)

	mov	DWORD PTR resize_grip_n$7[rsp], 0
	jmp	SHORT $LN4@Begin
$LN2@Begin:
	mov	eax, DWORD PTR resize_grip_n$7[rsp]
	inc	eax
	mov	DWORD PTR resize_grip_n$7[rsp], eax
$LN4@Begin:
	mov	eax, DWORD PTR resize_grip_count$22[rsp]
	cmp	DWORD PTR resize_grip_n$7[rsp], eax
	jge	$LN3@Begin

; 4389 : 				{
; 4390 : 					const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];

	movsxd	rax, DWORD PTR resize_grip_n$7[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:?resize_grip_def@@3QBUImGuiResizeGripDef@@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR grip$18[rsp], rax

; 4391 : 					const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T97[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1432[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv1430[rsp], rax
	mov	rax, QWORD PTR grip$18[rsp]
	mov	r9, rax
	mov	r8, QWORD PTR tv1432[rsp]
	mov	rdx, QWORD PTR tv1430[rsp]
	lea	rcx, QWORD PTR corner$28[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	npad	1

; 4392 : 					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1490[rsp], rax
	mov	eax, DWORD PTR resize_grip_n$7[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN211@Begin
	movss	xmm2, DWORD PTR grip_draw_size$12[rsp]
	movss	xmm1, DWORD PTR window_border_size$10[rsp]
	lea	rcx, QWORD PTR $T98[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1478[rsp], rax
	jmp	SHORT $LN212@Begin
$LN211@Begin:
	movss	xmm2, DWORD PTR window_border_size$10[rsp]
	movss	xmm1, DWORD PTR grip_draw_size$12[rsp]
	lea	rcx, QWORD PTR $T99[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1478[rsp], rax
$LN212@Begin:
	mov	rax, QWORD PTR tv1478[rsp]
	mov	QWORD PTR $T67[rsp], rax
	mov	rax, QWORD PTR grip$18[rsp]
	add	rax, 8
	mov	r8, QWORD PTR $T67[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T100[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR corner$28[rsp]
	lea	rcx, QWORD PTR $T101[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1488[rsp], rax
	mov	rdx, QWORD PTR tv1488[rsp]
	mov	rcx, QWORD PTR tv1490[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 4393 : 					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1517[rsp], rax
	mov	eax, DWORD PTR resize_grip_n$7[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN213@Begin
	movss	xmm2, DWORD PTR window_border_size$10[rsp]
	movss	xmm1, DWORD PTR grip_draw_size$12[rsp]
	lea	rcx, QWORD PTR $T102[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1505[rsp], rax
	jmp	SHORT $LN214@Begin
$LN213@Begin:
	movss	xmm2, DWORD PTR grip_draw_size$12[rsp]
	movss	xmm1, DWORD PTR window_border_size$10[rsp]
	lea	rcx, QWORD PTR $T103[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1505[rsp], rax
$LN214@Begin:
	mov	rax, QWORD PTR tv1505[rsp]
	mov	QWORD PTR $T68[rsp], rax
	mov	rax, QWORD PTR grip$18[rsp]
	add	rax, 8
	mov	r8, QWORD PTR $T68[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T104[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR corner$28[rsp]
	lea	rcx, QWORD PTR $T105[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1515[rsp], rax
	mov	rdx, QWORD PTR tv1515[rsp]
	mov	rcx, QWORD PTR tv1517[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 4394 : 					window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1547[rsp], rax
	mov	rax, QWORD PTR grip$18[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR tv1545[rsp], eax
	mov	rax, QWORD PTR grip$18[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv1543[rsp], eax
	movss	xmm0, DWORD PTR window_rounding$9[rsp]
	addss	xmm0, DWORD PTR window_border_size$10[rsp]
	mov	rax, QWORD PTR grip$18[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR corner$28[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR window_rounding$9[rsp]
	addss	xmm1, DWORD PTR window_border_size$10[rsp]
	mov	rax, QWORD PTR grip$18[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	movss	xmm2, DWORD PTR corner$28[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T106[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1541[rsp], rax
	mov	eax, DWORD PTR tv1545[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv1543[rsp]
	movss	xmm2, DWORD PTR window_rounding$9[rsp]
	mov	rdx, QWORD PTR tv1541[rsp]
	mov	rcx, QWORD PTR tv1547[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 4395 : 					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1555[rsp], rax
	movsxd	rax, DWORD PTR resize_grip_n$7[rsp]
	mov	edx, DWORD PTR resize_grip_col$136[rsp+rax*4]
	mov	rcx, QWORD PTR tv1555[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1

; 4396 : 				}

	jmp	$LN2@Begin
$LN3@Begin:
$LN87@Begin:

; 4397 : 			}
; 4398 : 
; 4399 : 			// Borders
; 4400 : 			RenderOuterBorders(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?RenderOuterBorders@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::RenderOuterBorders
	npad	1
$LN78@Begin:

; 4401 : 		}
; 4402 : 
; 4403 : 		// Draw navigation selection/windowing rectangle border
; 4404 : 		if (g.NavWindowingTargetAnim == window)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+7112], rcx
	jne	$LN88@Begin

; 4405 : 		{
; 4406 : 			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5484]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR rounding$23[rsp], xmm0

; 4407 : 			ImRect bb = window->Rect();

	lea	rdx, QWORD PTR bb$45[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect

; 4408 : 			bb.Expand(g.FontSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	lea	rcx, QWORD PTR bb$45[rsp]
	call	?Expand@ImRect@@QEAAXM@Z		; ImRect::Expand
	npad	1

; 4409 : 			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward

	lea	rdx, QWORD PTR viewport_rect$38[rsp]
	lea	rcx, QWORD PTR bb$45[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN89@Begin

; 4410 : 			{
; 4411 : 				bb.Expand(-g.FontSize - 1.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb$45[rsp]
	call	?Expand@ImRect@@QEAAXM@Z		; ImRect::Expand

; 4412 : 				rounding = window->WindowRounding;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	movss	DWORD PTR rounding$23[rsp], xmm0
$LN89@Begin:

; 4413 : 			}
; 4414 : 			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1596[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+7096]
	mov	ecx, 45					; 0000002dH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv1594[rsp], eax
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], -1
	movss	xmm0, DWORD PTR rounding$23[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1594[rsp]
	lea	r8, QWORD PTR bb$45[rsp+8]
	lea	rdx, QWORD PTR bb$45[rsp]
	mov	rcx, QWORD PTR tv1596[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN88@Begin:

; 4415 : 		}
; 4416 : 
; 4417 : 		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
; 4418 : 		window->SizeFullAtLastBegin = window->SizeFull;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 4419 : 
; 4420 : 		// Update various regions. Variables they depends on are set above in this function.
; 4421 : 		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
; 4422 : 		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	subss	xmm0, DWORD PTR [rcx+92]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+80]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+208], xmm0

; 4423 : 		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	subss	xmm0, DWORD PTR [rcx+96]
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+84]
	movss	DWORD PTR tv1621[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	xmm1, DWORD PTR tv1621[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv1624[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv1624[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv1629[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv1629[rsp]
	movss	DWORD PTR [rax+212], xmm0

; 4424 : 		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN245@Begin
	je	SHORT $LN215@Begin
$LN245@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	movss	DWORD PTR tv1651[rsp], xmm0
	jmp	SHORT $LN216@Begin
$LN215@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx+124]
	movss	DWORD PTR tv1651[rsp], xmm0
$LN216@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	subss	xmm0, DWORD PTR [rcx+92]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+80]
	addss	xmm0, DWORD PTR tv1651[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+216], xmm0

; 4425 : 		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN244@Begin
	je	SHORT $LN217@Begin
$LN244@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv1674[rsp], xmm0
	jmp	SHORT $LN218@Begin
$LN217@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+128]
	movss	DWORD PTR tv1674[rsp], xmm0
$LN218@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	subss	xmm0, DWORD PTR [rcx+96]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+84]
	addss	xmm0, DWORD PTR tv1674[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+220], xmm0

; 4426 : 
; 4427 : 		// Setup drawing context
; 4428 : 		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
; 4429 : 		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	addss	xmm0, DWORD PTR [rax+80]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+92]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+576], xmm0

; 4430 : 		window->DC.GroupOffset.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+580], xmm0

; 4431 : 		window->DC.ColumnsOffset.x = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+564], xmm0

; 4432 : 		window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);

	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	movss	DWORD PTR tv1697[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv1697[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	addss	xmm0, DWORD PTR [rax+84]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+96]
	movss	DWORD PTR tv1719[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+576]
	addss	xmm0, DWORD PTR [rcx+564]
	movss	DWORD PTR tv1717[rsp], xmm0
	movss	xmm2, DWORD PTR tv1719[rsp]
	movss	xmm1, DWORD PTR tv1717[rsp]
	lea	rcx, QWORD PTR $T107[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1727[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv1725[rsp], rax
	mov	r8, QWORD PTR tv1727[rsp]
	mov	rdx, QWORD PTR tv1725[rsp]
	lea	rcx, QWORD PTR $T108[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T69[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T69[rsp]
	mov	QWORD PTR [rax+304], rcx

; 4433 : 		window->DC.CursorPos = window->DC.CursorStartPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+304]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 4434 : 		window->DC.CursorPosPrevLine = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+348], rax

; 4435 : 		window->DC.CursorMaxPos = window->DC.CursorStartPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+304]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+312], rax

; 4436 : 		window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T109[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T70[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR $T70[rsp]
	mov	QWORD PTR [rax+332], rcx
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+332]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+320], rax

; 4437 : 		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;

	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+356], xmm0
	mov	rax, QWORD PTR window$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+328], xmm0

; 4438 : 		window->DC.NavHideHighlightOneFrame = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+428], 0

; 4439 : 		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);

	mov	rcx, QWORD PTR window$[rsp]
	call	?GetWindowScrollMaxY@ImGui@@YAMPEAUImGuiWindow@@@Z ; ImGui::GetWindowScrollMaxY
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN219@Begin
	mov	DWORD PTR tv1769[rsp], 1
	jmp	SHORT $LN220@Begin
$LN219@Begin:
	mov	DWORD PTR tv1769[rsp], 0
$LN220@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv1769[rsp]
	mov	BYTE PTR [rax+456], cl

; 4440 : 		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+424]
	mov	DWORD PTR [rax+420], ecx

; 4441 : 		window->DC.NavLayerActiveMaskNext = 0x00;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+424], 0

; 4442 : 		window->DC.MenuBarAppending = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+457], 0

; 4443 : 		window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR __real@461c3c00
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+360], xmm0

; 4444 : 		window->DC.ChildWindows.resize(0);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 432				; 000001b0H
	mov	QWORD PTR tv1790[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv1790[rsp]
	call	?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::resize

; 4445 : 		window->DC.LayoutType = ImGuiLayoutType_Vertical;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+468], 1

; 4446 : 		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN221@Begin
	mov	rax, QWORD PTR parent_window$[rsp]
	mov	eax, DWORD PTR [rax+468]
	mov	DWORD PTR tv1798[rsp], eax
	jmp	SHORT $LN222@Begin
$LN221@Begin:
	mov	DWORD PTR tv1798[rsp], 1
$LN222@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv1798[rsp]
	mov	DWORD PTR [rax+472], ecx

; 4447 : 		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN223@Begin
	mov	rax, QWORD PTR parent_window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	mov	DWORD PTR tv1804[rsp], eax
	jmp	SHORT $LN224@Begin
$LN223@Begin:
	mov	DWORD PTR tv1804[rsp], 0
$LN224@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv1804[rsp]
	mov	DWORD PTR [rax+476], ecx

; 4448 : 		window->DC.ItemWidth = window->ItemWidthDefault;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+280]
	movss	DWORD PTR [rax+512], xmm0

; 4449 : 		window->DC.TextWrapPos = -1.0f; // disabled

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rax+516], xmm0

; 4450 : 		window->DC.ItemFlagsStack.resize(0);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 520				; 00000208H
	mov	QWORD PTR tv1815[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv1815[rsp]
	call	?resize@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::resize

; 4451 : 		window->DC.ItemWidthStack.resize(0);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 480				; 000001e0H
	mov	QWORD PTR tv1821[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv1821[rsp]
	call	?resize@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::resize

; 4452 : 		window->DC.TextWrapPosStack.resize(0);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 496				; 000001f0H
	mov	QWORD PTR tv1827[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv1827[rsp]
	call	?resize@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::resize

; 4453 : 		window->DC.ColumnsSet = NULL;

	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+568], 0

; 4454 : 		window->DC.TreeDepth = 0;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+364], 0

; 4455 : 		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+408], 0

; 4456 : 		window->DC.StateStorage = &window->StateStorage;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 288				; 00000120H
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+448], rax

; 4457 : 		window->DC.GroupStack.resize(0);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	QWORD PTR tv1842[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv1842[rsp]
	call	?resize@?$ImVector@UImGuiGroupData@@@@QEAAXH@Z ; ImVector<ImGuiGroupData>::resize

; 4458 : 		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 616				; 00000268H
	mov	QWORD PTR tv1851[rsp], rax
	movzx	r9d, BYTE PTR window_just_activated_by_user$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+68]
	mov	edx, 3
	mov	rcx, QWORD PTR tv1851[rsp]
	call	?Update@ImGuiMenuColumns@@QEAAXHM_N@Z	; ImGuiMenuColumns::Update
	npad	1

; 4459 : 
; 4460 : 		if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN90@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	ecx, DWORD PTR [rcx+476]
	cmp	DWORD PTR [rax+476], ecx
	je	SHORT $LN90@Begin

; 4461 : 		{
; 4462 : 			window->DC.ItemFlags = parent_window->DC.ItemFlags;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	ecx, DWORD PTR [rcx+476]
	mov	DWORD PTR [rax+476], ecx

; 4463 : 			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 520				; 00000208H
	mov	QWORD PTR tv1870[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 476				; 000001dcH
	mov	rdx, rax
	mov	rcx, QWORD PTR tv1870[rsp]
	call	?push_back@?$ImVector@H@@QEAAXAEBH@Z	; ImVector<int>::push_back
	npad	1
$LN90@Begin:

; 4464 : 		}
; 4465 : 
; 4466 : 		if (window->AutoFitFramesX > 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jle	SHORT $LN91@Begin

; 4467 : 			window->AutoFitFramesX--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+156]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+156], eax
$LN91@Begin:

; 4468 : 		if (window->AutoFitFramesY > 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jle	SHORT $LN92@Begin

; 4469 : 			window->AutoFitFramesY--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+160]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+160], eax
$LN92@Begin:

; 4470 : 
; 4471 : 		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
; 4472 : 		if (want_focus)

	movzx	eax, BYTE PTR want_focus$1[rsp]
	test	eax, eax
	je	SHORT $LN93@Begin

; 4473 : 		{
; 4474 : 			FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 4475 : 			NavInitWindow(window, false);

	xor	edx, edx
	mov	rcx, QWORD PTR window$[rsp]
	call	?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z ; ImGui::NavInitWindow
	npad	1
$LN93@Begin:

; 4476 : 		}
; 4477 : 
; 4478 : 		// Title bar
; 4479 : 		if (!(flags & ImGuiWindowFlags_NoTitleBar))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN94@Begin

; 4480 : 		{
; 4481 : 			// Close & collapse button are on layer 1 (same as menus) and don't default focus
; 4482 : 			const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	mov	DWORD PTR item_flags_backup$33[rsp], eax

; 4483 : 			window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	or	eax, 16
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+476], eax

; 4484 : 			window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+400], 1

; 4485 : 			window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+404], 2

; 4486 : 
; 4487 : 			// Collapse button
; 4488 : 			if (!(flags & ImGuiWindowFlags_NoCollapse))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN95@Begin

; 4489 : 				if (CollapseButton(window->GetID(("#COLLAPSE")), window->Pos))

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv1914[rsp], rax
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_09BJOGEADB@?$CDCOLLAPSE@
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR tv1912[rsp], eax
	mov	rdx, QWORD PTR tv1914[rsp]
	mov	ecx, DWORD PTR tv1912[rsp]
	call	?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z ; ImGui::CollapseButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN96@Begin

; 4490 : 					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+114], 1
$LN96@Begin:
$LN95@Begin:

; 4491 : 
; 4492 : 			// Close button
; 4493 : 			if (p_open != NULL)

	cmp	QWORD PTR p_open$[rsp], 0
	je	$LN97@Begin

; 4494 : 			{
; 4495 : 				const float pad = style.FramePadding.y;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR pad$24[rsp], xmm0

; 4496 : 				const float rad = g.FontSize * 0.5f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR rad$15[rsp], xmm0

; 4497 : 				if (CloseButton(window->GetID(("#CLOSE")), window->Rect().GetTR() + ImVec2(-pad - rad, pad + rad), rad + 1))

	movss	xmm0, DWORD PTR pad$24[rsp]
	addss	xmm0, DWORD PTR rad$15[rsp]
	movss	xmm1, DWORD PTR pad$24[rsp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm1, DWORD PTR rad$15[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T110[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1948[rsp], rax
	lea	rdx, QWORD PTR $T135[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect
	mov	QWORD PTR tv1942[rsp], rax
	lea	rdx, QWORD PTR $T111[rsp]
	mov	rcx, QWORD PTR tv1942[rsp]
	call	?GetTR@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetTR
	mov	QWORD PTR tv1946[rsp], rax
	mov	r8, QWORD PTR tv1948[rsp]
	mov	rdx, QWORD PTR tv1946[rsp]
	lea	rcx, QWORD PTR $T112[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1958[rsp], rax
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_06KIIKKNMI@?$CDCLOSE@
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR tv1956[rsp], eax
	movss	xmm0, DWORD PTR rad$15[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rdx, QWORD PTR tv1958[rsp]
	mov	ecx, DWORD PTR tv1956[rsp]
	call	?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z ; ImGui::CloseButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN98@Begin

; 4498 : 					*p_open = false;

	mov	rax, QWORD PTR p_open$[rsp]
	mov	BYTE PTR [rax], 0
$LN98@Begin:
$LN97@Begin:

; 4499 : 			}
; 4500 : 
; 4501 : 			window->DC.NavLayerCurrent = ImGuiNavLayer_Main;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+400], 0

; 4502 : 			window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+404], 1

; 4503 : 			window->DC.ItemFlags = item_flags_backup;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR item_flags_backup$33[rsp]
	mov	DWORD PTR [rax+476], ecx

; 4504 : 
; 4505 : 			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
; 4506 : 			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
; 4507 : 			const char* UNSAVED_DOCUMENT_MARKER = "*";

	lea	rax, OFFSET FLAT:??_C@_01NBENCBCI@?$CK@
	mov	QWORD PTR UNSAVED_DOCUMENT_MARKER$44[rsp], rax

; 4508 : 			float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN225@Begin
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR UNSAVED_DOCUMENT_MARKER$44[rsp]
	lea	rcx, QWORD PTR $T113[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv1976[rsp], xmm0
	jmp	SHORT $LN226@Begin
$LN225@Begin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv1976[rsp], xmm0
$LN226@Begin:
	movss	xmm0, DWORD PTR tv1976[rsp]
	movss	DWORD PTR marker_size_x$26[rsp], xmm0

; 4509 : 			ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR marker_size_x$26[rsp]
	lea	rcx, QWORD PTR $T114[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1994[rsp], rax
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, QWORD PTR $T115[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	mov	QWORD PTR tv1992[rsp], rax
	mov	r8, QWORD PTR tv1994[rsp]
	mov	rdx, QWORD PTR tv1992[rsp]
	lea	rcx, QWORD PTR text_size$35[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 4510 : 			ImRect text_r = title_bar_rect;

	lea	rax, QWORD PTR text_r$19[rsp]
	lea	rcx, QWORD PTR title_bar_rect$27[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 4511 : 			float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN227@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	movss	DWORD PTR tv2005[rsp], xmm0
	jmp	SHORT $LN228@Begin
$LN227@Begin:
	mov	rax, QWORD PTR style$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR [rcx+6408]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv2005[rsp], xmm0
$LN228@Begin:
	movss	xmm0, DWORD PTR tv2005[rsp]
	movss	DWORD PTR pad_left$25[rsp], xmm0

; 4512 : 			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);

	cmp	QWORD PTR p_open$[rsp], 0
	jne	SHORT $LN229@Begin
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	movss	DWORD PTR tv2048[rsp], xmm0
	jmp	SHORT $LN230@Begin
$LN229@Begin:
	mov	rax, QWORD PTR style$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR [rcx+6408]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv2048[rsp], xmm0
$LN230@Begin:
	movss	xmm0, DWORD PTR tv2048[rsp]
	movss	DWORD PTR pad_right$16[rsp], xmm0

; 4513 : 			if (style.WindowTitleAlign.x > 0.0f)

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN99@Begin

; 4514 : 				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+28]
	movss	xmm1, DWORD PTR pad_left$25[rsp]
	movss	xmm0, DWORD PTR pad_right$16[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR pad_right$16[rsp], xmm0
$LN99@Begin:

; 4515 : 			text_r.Min.x += pad_left;

	movss	xmm0, DWORD PTR text_r$19[rsp]
	addss	xmm0, DWORD PTR pad_left$25[rsp]
	movss	DWORD PTR text_r$19[rsp], xmm0

; 4516 : 			text_r.Max.x -= pad_right;

	movss	xmm0, DWORD PTR text_r$19[rsp+8]
	subss	xmm0, DWORD PTR pad_right$16[rsp]
	movss	DWORD PTR text_r$19[rsp+8], xmm0

; 4517 : 			ImRect clip_rect = text_r;

	lea	rax, QWORD PTR clip_rect$75[rsp]
	lea	rcx, QWORD PTR text_r$19[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 4518 : 			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()

	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN231@Begin
	lea	rcx, QWORD PTR title_bar_rect$27[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	subss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR tv2071[rsp], xmm0
	jmp	SHORT $LN232@Begin
$LN231@Begin:
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	movss	DWORD PTR tv2071[rsp], xmm0
$LN232@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx]
	subss	xmm0, DWORD PTR tv2071[rsp]
	movss	DWORD PTR clip_rect$75[rsp+8], xmm0

; 4519 : 			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 28
	lea	rcx, QWORD PTR clip_rect$75[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR text_size$35[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, QWORD PTR text_r$19[rsp+8]
	lea	rcx, QWORD PTR text_r$19[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1

; 4520 : 			if (flags & ImGuiWindowFlags_UnsavedDocument)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	$LN100@Begin

; 4521 : 			{
; 4522 : 				ImVec2 marker_pos = ImVec2(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + ImVec2(2 - marker_size_x, 0.0f);

	movss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR marker_size_x$26[rsp]
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T116[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv2110[rsp], rax
	lea	rcx, QWORD PTR text_r$19[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	subss	xmm0, DWORD PTR text_size$35[rsp]
	mov	rax, QWORD PTR style$[rsp]
	mulss	xmm0, DWORD PTR [rax+28]
	movss	xmm1, DWORD PTR text_r$19[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR text_r$19[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	addss	xmm0, DWORD PTR text_size$35[rsp]
	movss	xmm2, DWORD PTR text_r$19[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T117[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv2108[rsp], rax
	mov	r8, QWORD PTR tv2110[rsp]
	mov	rdx, QWORD PTR tv2108[rsp]
	lea	rcx, QWORD PTR marker_pos$71[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 4523 : 				ImVec2 off = ImVec2(0.0f, (float)(int)(-g.FontSize * 0.25f));

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3e800000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm2, xmm0
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR off$43[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 4524 : 				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2(0, style.WindowTitleAlign.y), &clip_rect);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+32]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T118[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv2145[rsp], rax
	lea	r8, QWORD PTR off$43[rsp]
	lea	rdx, QWORD PTR text_r$19[rsp+8]
	lea	rcx, QWORD PTR $T119[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv2143[rsp], rax
	lea	r8, QWORD PTR off$43[rsp]
	lea	rdx, QWORD PTR marker_pos$71[rsp]
	lea	rcx, QWORD PTR $T120[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv2141[rsp], rax
	lea	rax, QWORD PTR clip_rect$75[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR tv2145[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR UNSAVED_DOCUMENT_MARKER$44[rsp]
	mov	rdx, QWORD PTR tv2143[rsp]
	mov	rcx, QWORD PTR tv2141[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1
$LN100@Begin:
$LN94@Begin:

; 4525 : 			}
; 4526 : 		}
; 4527 : 
; 4528 : 		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
; 4529 : 		window->OuterRectClipped = window->Rect();

	lea	rdx, QWORD PTR $T131[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect
	lea	rcx, QWORD PTR $T130[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR $T130[rsp]
	lea	rdi, QWORD PTR [rax+264]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 4530 : 		window->OuterRectClipped.ClipWith(window->ClipRect);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 264				; 00000108H
	mov	QWORD PTR tv2157[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 248				; 000000f8H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv2157[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith

; 4531 : 
; 4532 : 		// Pressing CTRL+C while holding on a window copy its content to the clipboard
; 4533 : 		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
; 4534 : 		// Maybe we can support CTRL+C on every element?
; 4535 : 		/*
; 4536 : 		if (g.ActiveId == move_id)
; 4537 : 			if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
; 4538 : 				LogToClipboard();
; 4539 : 		*/
; 4540 : 
; 4541 : 		// Inner rectangle
; 4542 : 		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
; 4543 : 		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
; 4544 : 		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR title_bar_rect$27[rsp]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+584], xmm0

; 4545 : 		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $LN233@Begin
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN233@Begin
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR tv2175[rsp], xmm0
	jmp	SHORT $LN234@Begin
$LN233@Begin:
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR tv2175[rsp], xmm0
$LN234@Begin:
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR title_bar_rect$27[rsp+12]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR tv2175[rsp]
	movss	DWORD PTR tv2178[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv2178[rsp]
	movss	DWORD PTR [rax+588], xmm0

; 4546 : 		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+124]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+592], xmm0

; 4547 : 		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+128]
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+596], xmm0

; 4548 : 		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);
; 4549 : 
; 4550 : 		// Inner clipping rectangle
; 4551 : 		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
; 4552 : 		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR [rax+584]
	movss	DWORD PTR tv2212[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+80]
	mulss	xmm1, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm1, DWORD PTR [rax+56]
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR tv2212[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv2226[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv2226[rsp]
	movss	DWORD PTR [rax+600], xmm0

; 4553 : 		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR [rax+588]
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv2237[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv2237[rsp]
	movss	DWORD PTR [rax+604], xmm0

; 4554 : 		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR [rax+592]
	movss	DWORD PTR tv2245[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+80]
	mulss	xmm1, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR window$[rsp]
	subss	xmm1, DWORD PTR [rax+56]
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR tv2245[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv2259[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv2259[rsp]
	movss	DWORD PTR [rax+608], xmm0

; 4555 : 		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR [rax+596]
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv2270[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR tv2270[rsp]
	movss	DWORD PTR [rax+612], xmm0

; 4556 : 
; 4557 : 		// We fill last item data based on Title Bar, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
; 4558 : 		// This is useful to allow creating context menus on title bar only, etc.
; 4559 : 		window->DC.LastItemId = window->MoveId;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+68]
	mov	DWORD PTR [rax+412], ecx

; 4560 : 		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;

	xor	r8d, r8d
	lea	rdx, QWORD PTR title_bar_rect$27[rsp+8]
	lea	rcx, QWORD PTR title_bar_rect$27[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN235@Begin
	mov	DWORD PTR tv2282[rsp], 1
	jmp	SHORT $LN236@Begin
$LN235@Begin:
	mov	DWORD PTR tv2282[rsp], 0
$LN236@Begin:
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR tv2282[rsp]
	mov	DWORD PTR [rax+416], ecx

; 4561 : 		window->DC.LastItemRect = title_bar_rect;

	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR title_bar_rect$27[rsp]
	lea	rdi, QWORD PTR [rax+368]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN25@Begin:

; 4562 : 	}
; 4563 : 
; 4564 : 	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 608				; 00000260H
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 600				; 00000258H
	mov	r8b, 1
	mov	rdx, rax
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1

; 4565 : 
; 4566 : 	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
; 4567 : 	if (first_begin_of_the_frame)

	movzx	eax, BYTE PTR first_begin_of_the_frame$[rsp]
	test	eax, eax
	je	SHORT $LN101@Begin

; 4568 : 		window->WriteAccessed = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+112], 0
$LN101@Begin:

; 4569 : 
; 4570 : 	window->BeginCount++;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, WORD PTR [rax+136]
	inc	ax
	mov	rcx, QWORD PTR window$[rsp]
	mov	WORD PTR [rcx+136], ax

; 4571 : 	g.NextWindowData.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6912				; 00001b00H
	mov	rcx, rax
	call	?Clear@ImGuiNextWindowData@@QEAAXXZ	; ImGuiNextWindowData::Clear
	npad	1

; 4572 : 
; 4573 : 	if (flags & ImGuiWindowFlags_ChildWindow)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	$LN102@Begin

; 4574 : 	{
; 4575 : 		// Child window can be out of sight and have "negative" clip windows.
; 4576 : 		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
; 4577 : 		IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);
; 4578 : 		if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN103@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	SHORT $LN103@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jg	SHORT $LN103@Begin

; 4579 : 			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+264]
	comiss	xmm0, DWORD PTR [rcx+272]
	jae	SHORT $LN105@Begin
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+268]
	comiss	xmm0, DWORD PTR [rcx+276]
	jb	SHORT $LN104@Begin
$LN105@Begin:

; 4580 : 				window->HiddenFramesRegular = 1;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+188], 1
$LN104@Begin:
$LN103@Begin:

; 4581 : 
; 4582 : 		// Completely hide along with parent or if parent is collapsed
; 4583 : 		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))

	cmp	QWORD PTR parent_window$[rsp], 0
	je	SHORT $LN106@Begin
	mov	rax, QWORD PTR parent_window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	SHORT $LN107@Begin
	mov	rax, QWORD PTR parent_window$[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	je	SHORT $LN106@Begin
$LN107@Begin:

; 4584 : 			window->HiddenFramesRegular = 1;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+188], 1
$LN106@Begin:
$LN102@Begin:

; 4585 : 	}
; 4586 : 
; 4587 : 	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
; 4588 : 	if (style.Alpha <= 0.0f)

	mov	rax, QWORD PTR style$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	jb	SHORT $LN108@Begin

; 4589 : 		window->HiddenFramesRegular = 1;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+188], 1
$LN108@Begin:

; 4590 : 
; 4591 : 	// Update the Hidden flag
; 4592 : 	window->Hidden = (window->HiddenFramesRegular > 0) || (window->HiddenFramesForResize > 0);

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+188], 0
	jg	SHORT $LN237@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jg	SHORT $LN237@Begin
	mov	DWORD PTR tv2340[rsp], 0
	jmp	SHORT $LN238@Begin
$LN237@Begin:
	mov	DWORD PTR tv2340[rsp], 1
$LN238@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv2340[rsp]
	mov	BYTE PTR [rax+140], cl

; 4593 : 
; 4594 : 	// Return false if we don't intend to display anything to allow user to perform an early out optimization
; 4595 : 	window->SkipItems = (window->Collapsed || !window->Active || window->Hidden) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesForResize <= 0;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	jne	SHORT $LN239@Begin
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN239@Begin
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	je	SHORT $LN240@Begin
$LN239@Begin:
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+156], 0
	jg	SHORT $LN240@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+160], 0
	jg	SHORT $LN240@Begin
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+168], 0
	jg	SHORT $LN240@Begin
	mov	DWORD PTR tv2358[rsp], 1
	jmp	SHORT $LN241@Begin
$LN240@Begin:
	mov	DWORD PTR tv2358[rsp], 0
$LN241@Begin:
	mov	rax, QWORD PTR window$[rsp]
	movzx	ecx, BYTE PTR tv2358[rsp]
	mov	BYTE PTR [rax+115], cl

; 4596 : 
; 4597 : 	return !window->SkipItems;

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	jne	SHORT $LN242@Begin
	mov	DWORD PTR tv2363[rsp], 1
	jmp	SHORT $LN243@Begin
$LN242@Begin:
	mov	DWORD PTR tv2363[rsp], 0
$LN243@Begin:
	movzx	eax, BYTE PTR tv2363[rsp]

; 4598 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2136				; 00000858H
	pop	rdi
	pop	rsi
	ret	0
?Begin@ImGui@@YA_NPEBDPEA_NH@Z ENDP			; ImGui::Begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetVersion@ImGui@@YAPEBDXZ PROC			; ImGui::GetVersion

; 2091 : 	return IMGUI_VERSION;

	lea	rax, OFFSET FLAT:??_C@_01HIHLOKLC@1@

; 2092 : }

	ret	0
?GetVersion@ImGui@@YAPEBDXZ ENDP			; ImGui::GetVersion
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 80
i$1 = 88
i$2 = 92
n$3 = 96
n$4 = 100
io$ = 104
font_size$5 = 112
window$6 = 120
window$7 = 128
tv190 = 136
tv196 = 144
tv200 = 152
tv240 = 160
tv247 = 168
tv281 = 176
tv320 = 184
tv327 = 192
tv366 = 200
overlay_draw_list$8 = 208
tv164 = 216
tv184 = 224
tv207 = 232
tv230 = 240
tv397 = 248
$T9 = 256
$T10 = 264
input_source_names$11 = 272
buf$12 = 312
__$ArrayPad$ = 344
p_open$ = 368
?ShowMetricsWindow@ImGui@@YAXPEA_N@Z PROC		; ImGui::ShowMetricsWindow

; 8400 : {

$LN41:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 360				; 00000168H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 8401 : 	if (!ImGui::Begin(("ImGui Metrics"), p_open))

	xor	r8d, r8d
	mov	rdx, QWORD PTR p_open$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0O@JMODJGLN@ImGui?5Metrics@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@ShowMetric

; 8402 : 	{
; 8403 : 		ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1

; 8404 : 		return;

	jmp	$LN1@ShowMetric
$LN14@ShowMetric:

; 8405 : 	}
; 8406 : 
; 8407 : 	static bool show_draw_cmd_clip_rects = true;
; 8408 : 	static bool show_window_begin_order = false;
; 8409 : 	ImGuiIO& io = ImGui::GetIO();

	call	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ		; ImGui::GetIO
	mov	QWORD PTR io$[rsp], rax

; 8410 : 	ImGui::Text(("Dear ImGui %s"), ImGui::GetVersion());

	call	?GetVersion@ImGui@@YAPEBDXZ		; ImGui::GetVersion
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0O@NCHBJMJF@Dear?5ImGui?5?$CFs@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8411 : 	ImGui::Text(("Application average %.3f ms/frame (%.1f FPS)"), 1000.0f / io.Framerate, io.Framerate);

	mov	rax, QWORD PTR io$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+932]
	mov	rax, QWORD PTR io$[rsp]
	movss	xmm1, DWORD PTR __real@447a0000
	divss	xmm1, DWORD PTR [rax+932]
	cvtss2sd xmm1, xmm1
	movaps	xmm2, xmm0
	movq	r8, xmm2
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0CN@EIPBEGMP@Application?5average?5?$CF?43f?5ms?1fra@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8412 : 	ImGui::Text(("%d vertices, %d indices (%d triangles)"), io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);

	mov	rax, QWORD PTR io$[rsp]
	mov	eax, DWORD PTR [rax+924]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	r9d, eax
	mov	rax, QWORD PTR io$[rsp]
	mov	r8d, DWORD PTR [rax+924]
	mov	rax, QWORD PTR io$[rsp]
	mov	edx, DWORD PTR [rax+936]
	lea	rcx, OFFSET FLAT:??_C@_0CH@HHKODNBE@?$CFd?5vertices?0?5?$CFd?5indices?5?$CI?$CFd?5tri@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8413 : 	ImGui::Text(("%d active windows (%d visible)"), io.MetricsActiveWindows, io.MetricsRenderWindows);

	mov	rax, QWORD PTR io$[rsp]
	mov	r8d, DWORD PTR [rax+940]
	mov	rax, QWORD PTR io$[rsp]
	mov	edx, DWORD PTR [rax+948]
	lea	rcx, OFFSET FLAT:??_C@_0BP@OPGGNCEP@?$CFd?5active?5windows?5?$CI?$CFd?5visible?$CJ@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8414 : 	ImGui::Text(("%d allocations"), io.MetricsActiveAllocations);

	mov	rax, QWORD PTR io$[rsp]
	mov	edx, DWORD PTR [rax+944]
	lea	rcx, OFFSET FLAT:??_C@_0P@EGHDCIHB@?$CFd?5allocations@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8415 : 	ImGui::Checkbox(("Show clipping rectangles when hovering draw commands"), &show_draw_cmd_clip_rects);

	lea	rdx, OFFSET FLAT:?show_draw_cmd_clip_rects@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA
	lea	rcx, OFFSET FLAT:??_C@_0DF@PLCAEOIM@Show?5clipping?5rectangles?5when?5h@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 8416 : 	ImGui::Checkbox(("Ctrl shows window begin order"), &show_window_begin_order);

	lea	rdx, OFFSET FLAT:?show_window_begin_order@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA
	lea	rcx, OFFSET FLAT:??_C@_0BO@BAAKGIGK@Ctrl?5shows?5window?5begin?5order@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 8417 : 	ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 8418 : 
; 8419 : 	struct Funcs
; 8420 : 	{
; 8421 : 		static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)
; 8422 : 		{
; 8423 : 			bool node_open = ImGui::TreeNode(draw_list, ("%s: '%lld' %d vtx, %d indices, %d cmds"), label, draw_list->_OwnerName ? draw_list->_OwnerName : 0, draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
; 8424 : 			if (draw_list == ImGui::GetWindowDrawList())
; 8425 : 			{
; 8426 : 				ImGui::SameLine();
; 8427 : 				ImGui::TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), ("CURRENTLY APPENDING")); // Can't display stats for active draw list! (we don't have the data double-buffered)
; 8428 : 				if (node_open) ImGui::TreePop();
; 8429 : 				return;
; 8430 : 			}
; 8431 : 
; 8432 : 			ImDrawList* overlay_draw_list = GetOverlayDrawList(window); // Render additional visuals into the top-most draw list
; 8433 : 			if (window && IsItemHovered())
; 8434 : 				overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
; 8435 : 			if (!node_open)
; 8436 : 				return;
; 8437 : 
; 8438 : 			int elem_offset = 0;
; 8439 : 			for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
; 8440 : 			{
; 8441 : 				if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
; 8442 : 					continue;
; 8443 : 				if (pcmd->UserCallback)
; 8444 : 				{
; 8445 : 					ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
; 8446 : 					continue;
; 8447 : 				}
; 8448 : 				ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
; 8449 : 				bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), ("Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)"), pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
; 8450 : 				if (show_draw_cmd_clip_rects && ImGui::IsItemHovered())
; 8451 : 				{
; 8452 : 					ImRect clip_rect = pcmd->ClipRect;
; 8453 : 					ImRect vtxs_rect;
; 8454 : 					for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
; 8455 : 						vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
; 8456 : 					clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255, 255, 0, 255));
; 8457 : 					vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255, 0, 255, 255));
; 8458 : 				}
; 8459 : 				if (!pcmd_node_open)
; 8460 : 					continue;
; 8461 : 
; 8462 : 				// Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
; 8463 : 				ImGuiListClipper clipper(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
; 8464 : 				while (clipper.Step())
; 8465 : 					for (int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)
; 8466 : 					{
; 8467 : 						char buf[300];
; 8468 : 						char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE(buf);
; 8469 : 						ImVec2 triangles_pos[3];
; 8470 : 						for (int n = 0; n < 3; n++, idx_i++)
; 8471 : 						{
; 8472 : 							int vtx_i = idx_buffer ? idx_buffer[idx_i] : idx_i;
; 8473 : 							ImDrawVert& v = draw_list->VtxBuffer[vtx_i];
; 8474 : 							triangles_pos[n] = v.pos;
; 8475 : 							buf_p += ImFormatString(buf_p, buf_end - buf_p, ("%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n"),
; 8476 : 								(n == 0) ? "idx" : "   ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
; 8477 : 						}
; 8478 : 						ImGui::Selectable(buf, false);
; 8479 : 						if (ImGui::IsItemHovered())
; 8480 : 						{
; 8481 : 							ImDrawListFlags backup_flags = overlay_draw_list->Flags;
; 8482 : 							overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
; 8483 : 							overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255, 255, 0, 255), true, 1.0f);
; 8484 : 							overlay_draw_list->Flags = backup_flags;
; 8485 : 						}
; 8486 : 					}
; 8487 : 				ImGui::TreePop();
; 8488 : 			}
; 8489 : 			ImGui::TreePop();
; 8490 : 		}
; 8491 : 
; 8492 : 		static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
; 8493 : 		{
; 8494 : 			if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
; 8495 : 				return;
; 8496 : 			for (int i = 0; i < windows.Size; i++)
; 8497 : 				Funcs::NodeWindow(windows[i], "Window");
; 8498 : 			ImGui::TreePop();
; 8499 : 		}
; 8500 : 
; 8501 : 		static void NodeWindow(ImGuiWindow* window, const char* label)
; 8502 : 		{
; 8503 : 			if (!ImGui::TreeNode(window, ("%s '%s', %d @ 0x%p"), label, window->Name, window->Active || window->WasActive, window))
; 8504 : 				return;
; 8505 : 			ImGuiWindowFlags flags = window->Flags;
; 8506 : 			NodeDrawList(window, window->DrawList, ("DrawList"));
; 8507 : 			ImGui::BulletText(("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)"), window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
; 8508 : 			ImGui::BulletText(("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)"), flags,
; 8509 : 				(flags & ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_Tooltip) ? ("Tooltip ") : "", (flags & ImGuiWindowFlags_Popup) ? ("Popup ") : "",
; 8510 : 				(flags & ImGuiWindowFlags_Modal) ? "Modal " : "", (flags & ImGuiWindowFlags_ChildMenu) ? ("ChildMenu ") : "", ("NoSavedSettings "),
; 8511 : 				(flags & ImGuiWindowFlags_NoMouseInputs) ? "NoMouseInputs" : "", (flags & ImGuiWindowFlags_NoNavInputs) ? ("NoNavInputs") : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? ("AlwaysAutoResize") : "");
; 8512 : 			ImGui::BulletText(("Scroll: (%.2f/%.2f,%.2f/%.2f)"), window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));
; 8513 : 			ImGui::BulletText(("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d"), window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
; 8514 : 			ImGui::BulletText(("Appearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d"), window->Appearing, window->Hidden, window->HiddenFramesRegular, window->HiddenFramesForResize, window->SkipItems);
; 8515 : 			ImGui::BulletText(("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X"), window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
; 8516 : 			ImGui::BulletText(("NavLastChildNavWindow: %lld"), window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : 0);
; 8517 : 			if (!window->NavRectRel[0].IsInverted())
; 8518 : 				ImGui::BulletText(("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)"), window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
; 8519 : 			else
; 8520 : 				ImGui::BulletText(("NavRectRel[0]: <None>"));
; 8521 : 			if (window->RootWindow != window) NodeWindow(window->RootWindow, ("RootWindow"));
; 8522 : 			if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, ("ParentWindow"));
; 8523 : 			if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, ("ChildWindows"));
; 8524 : 			if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode(("Columns"), ("Columns sets (%d)"), window->ColumnsStorage.Size))
; 8525 : 			{
; 8526 : 				for (int n = 0; n < window->ColumnsStorage.Size; n++)
; 8527 : 				{
; 8528 : 					const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];
; 8529 : 					if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, ("Columns Id: 0x%08X, Count: %d, Flags: 0x%04X"), columns->ID, columns->Count, columns->Flags))
; 8530 : 					{
; 8531 : 						ImGui::BulletText(("Width: %.1f (MinX: %.1f, MaxX: %.1f)"), columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
; 8532 : 						for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
; 8533 : 							ImGui::BulletText(("Column %02d: OffsetNorm %.3f (= %.1f px)"), column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
; 8534 : 						ImGui::TreePop();
; 8535 : 					}
; 8536 : 				}
; 8537 : 				ImGui::TreePop();
; 8538 : 			}
; 8539 : 			ImGui::BulletText(("Storage: %d bytes"), window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
; 8540 : 			ImGui::TreePop();
; 8541 : 		}
; 8542 : 
; 8543 : 		static void NodeTabBar(ImGuiTabBar* tab_bar)
; 8544 : 		{
; 8545 : 			// Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
; 8546 : 			char buf[256];
; 8547 : 			char* p = buf;
; 8548 : 			const char* buf_end = buf + IM_ARRAYSIZE(buf);
; 8549 : 			ImFormatString(p, buf_end - p, ("TabBar (%d tabs)%s"), tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2) ? (" *Inactive*") : "");
; 8550 : 			if (ImGui::TreeNode(tab_bar, "%s", buf))
; 8551 : 			{
; 8552 : 				for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
; 8553 : 				{
; 8554 : 					const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
; 8555 : 					ImGui::PushID(tab);
; 8556 : 					if (ImGui::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } ImGui::SameLine(0, 2);
; 8557 : 					if (ImGui::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } ImGui::SameLine();
; 8558 : 					ImGui::Text(("%02d%c Tab 0x%08X"), tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);
; 8559 : 					ImGui::PopID();
; 8560 : 				}
; 8561 : 				ImGui::TreePop();
; 8562 : 			}
; 8563 : 		}
; 8564 : 	};
; 8565 : 
; 8566 : 	// Access private state, we are going to display the draw lists from last frame
; 8567 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 8568 : 	Funcs::NodeWindows(g.Windows, "Windows");

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	lea	rdx, OFFSET FLAT:??_C@_07LDLFNPGN@Windows@
	mov	rcx, rax
	call	?NodeWindows@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXAEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeWindows
	npad	1

; 8569 : 	if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rcx+rax+7560]
	lea	rdx, OFFSET FLAT:??_C@_0BG@JOELHCIA@Active?5DrawLists?5?$CI?$CFd?$CJ@
	lea	rcx, OFFSET FLAT:??_C@_08IJNCDCKF@DrawList@
	call	?TreeNode@ImGui@@YA_NPEBD0ZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@ShowMetric

; 8570 : 	{
; 8571 : 		for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@ShowMetric
$LN2@ShowMetric:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@ShowMetric:
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rcx+rax+7560]
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN3@ShowMetric

; 8572 : 			Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+7560]
	mov	QWORD PTR tv164[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv164[rsp]
	call	??A?$ImVector@PEAUImDrawList@@@@QEAAAEAPEAUImDrawList@@H@Z ; ImVector<ImDrawList *>::operator[]
	lea	r8, OFFSET FLAT:??_C@_08IJNCDCKF@DrawList@
	mov	rdx, QWORD PTR [rax]
	xor	ecx, ecx
	call	?NodeDrawList@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiWindow@@PEAUImDrawList@@PEBD@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeDrawList
	npad	1
	jmp	SHORT $LN2@ShowMetric
$LN3@ShowMetric:

; 8573 : 		ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN15@ShowMetric:

; 8574 : 	}
; 8575 : 	if (ImGui::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))

	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+6872]
	lea	rdx, OFFSET FLAT:??_C@_0M@CMLJJLKO@Popups?5?$CI?$CFd?$CJ@
	lea	rcx, OFFSET FLAT:??_C@_06ENDEIGLN@Popups@
	call	?TreeNode@ImGui@@YA_NPEBD0ZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	$LN16@ShowMetric

; 8576 : 	{
; 8577 : 		for (int i = 0; i < g.OpenPopupStack.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ShowMetric
$LN5@ShowMetric:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@ShowMetric:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6872]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN6@ShowMetric

; 8578 : 		{
; 8579 : 			ImGuiWindow* window = g.OpenPopupStack[i].Window;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv184[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv184[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR window$7[rsp], rax

; 8580 : 			ImGui::BulletText("PopupID: %08x, Window: '%lld'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : 0, window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");

	cmp	QWORD PTR window$7[rsp], 0
	je	SHORT $LN23@ShowMetric
	mov	rax, QWORD PTR window$7[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN23@ShowMetric
	lea	rax, OFFSET FLAT:??_C@_0L@CMJPHOMG@?5ChildMenu@
	mov	QWORD PTR tv190[rsp], rax
	jmp	SHORT $LN24@ShowMetric
$LN23@ShowMetric:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv190[rsp], rax
$LN24@ShowMetric:
	cmp	QWORD PTR window$7[rsp], 0
	je	SHORT $LN25@ShowMetric
	mov	rax, QWORD PTR window$7[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN25@ShowMetric
	lea	rax, OFFSET FLAT:??_C@_0N@FFCBFAEB@?5ChildWindow@
	mov	QWORD PTR tv196[rsp], rax
	jmp	SHORT $LN26@ShowMetric
$LN25@ShowMetric:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv196[rsp], rax
$LN26@ShowMetric:
	cmp	QWORD PTR window$7[rsp], 0
	je	SHORT $LN27@ShowMetric
	mov	rax, QWORD PTR window$7[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv200[rsp], rax
	jmp	SHORT $LN28@ShowMetric
$LN27@ShowMetric:
	mov	QWORD PTR tv200[rsp], 0
$LN28@ShowMetric:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv207[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv207[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rcx, QWORD PTR tv190[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR tv196[rsp]
	mov	r8, QWORD PTR tv200[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0CC@KHIGFAF@PopupID?3?5?$CF08x?0?5Window?3?5?8?$CFlld?8?$CFs@
	call	?BulletText@ImGui@@YAXPEBDZZ		; ImGui::BulletText
	npad	1

; 8581 : 		}

	jmp	$LN5@ShowMetric
$LN6@ShowMetric:

; 8582 : 		ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN16@ShowMetric:

; 8583 : 	}
; 8584 : 	if (ImGui::TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.Data.Size))

	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+7744]
	lea	rdx, OFFSET FLAT:??_C@_0O@JLIGAOM@Tab?5Bars?5?$CI?$CFd?$CJ@
	lea	rcx, OFFSET FLAT:??_C@_07NBICDJOO@TabBars@
	call	?TreeNode@ImGui@@YA_NPEBD0ZZ		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@ShowMetric

; 8585 : 	{
; 8586 : 		for (int n = 0; n < g.TabBars.Data.Size; n++)

	mov	DWORD PTR n$3[rsp], 0
	jmp	SHORT $LN10@ShowMetric
$LN8@ShowMetric:
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN10@ShowMetric:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7744]
	cmp	DWORD PTR n$3[rsp], eax
	jge	SHORT $LN9@ShowMetric

; 8587 : 			Funcs::NodeTabBar(g.TabBars.GetByIndex(n));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7744				; 00001e40H
	mov	QWORD PTR tv230[rsp], rax
	mov	edx, DWORD PTR n$3[rsp]
	mov	rcx, QWORD PTR tv230[rsp]
	call	?GetByIndex@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@H@Z ; ImPool<ImGuiTabBar>::GetByIndex
	mov	rcx, rax
	call	?NodeTabBar@Funcs@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@SAXPEAUImGuiTabBar@@@Z ; `ImGui::ShowMetricsWindow'::`2'::Funcs::NodeTabBar
	npad	1
	jmp	SHORT $LN8@ShowMetric
$LN9@ShowMetric:

; 8588 : 		ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN17@ShowMetric:

; 8589 : 	}
; 8590 : 	if (ImGui::TreeNode("Internal state"))

	lea	rcx, OFFSET FLAT:??_C@_0P@DKNCHHLP@Internal?5state@
	call	?TreeNode@ImGui@@YA_NPEBD@Z		; ImGui::TreeNode
	movzx	eax, al
	test	eax, eax
	je	$LN18@ShowMetric

; 8591 : 	{
; 8592 : 		const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);

	lea	rax, OFFSET FLAT:??_C@_04OHJIHAFH@None@
	mov	QWORD PTR input_source_names$11[rsp], rax
	lea	rax, OFFSET FLAT:??_C@_05PEEFLODH@Mouse@
	mov	QWORD PTR input_source_names$11[rsp+8], rax
	lea	rax, OFFSET FLAT:??_C@_03JFAAHAIK@Nav@
	mov	QWORD PTR input_source_names$11[rsp+16], rax
	lea	rax, OFFSET FLAT:??_C@_0M@BGJILJC@NavKeyboard@
	mov	QWORD PTR input_source_names$11[rsp+24], rax
	lea	rax, OFFSET FLAT:??_C@_0L@GFEAGONP@NavGamepad@
	mov	QWORD PTR input_source_names$11[rsp+32], rax

; 8593 : 		ImGui::Text("HoveredWindow: '%lld'", g.HoveredWindow ? g.HoveredWindow->Name : 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6560], 0
	je	SHORT $LN29@ShowMetric
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv240[rsp], rax
	jmp	SHORT $LN30@ShowMetric
$LN29@ShowMetric:
	mov	QWORD PTR tv240[rsp], 0
$LN30@ShowMetric:
	mov	rdx, QWORD PTR tv240[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BG@CLFHKGNJ@HoveredWindow?3?5?8?$CFlld?8@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8594 : 		ImGui::Text("HoveredRootWindow: '%lld'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6688], 0
	je	SHORT $LN31@ShowMetric
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6688]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv247[rsp], rax
	jmp	SHORT $LN32@ShowMetric
$LN31@ShowMetric:
	mov	QWORD PTR tv247[rsp], 0
$LN32@ShowMetric:
	mov	rdx, QWORD PTR tv247[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BK@PENLHICC@HoveredRootWindow?3?5?8?$CFlld?8@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8595 : 		ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6700]
	mov	rcx, QWORD PTR g$[rsp]
	cvtss2sd xmm0, DWORD PTR [rcx+6728]
	mov	DWORD PTR [rsp+32], eax
	movaps	xmm3, xmm0
	movq	r9, xmm3
	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+6724]
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6696]
	lea	rcx, OFFSET FLAT:??_C@_0DG@FAAGHPBL@HoveredId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8596 : 		ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+6820]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rcx+6753]
	mov	rdx, QWORD PTR g$[rsp]
	cvtss2sd xmm0, DWORD PTR [rdx+6736]
	mov	rax, QWORD PTR input_source_names$11[rsp+rax*8]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ecx
	movaps	xmm3, xmm0
	movq	r9, xmm3
	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+6708]
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6704]
	lea	rcx, OFFSET FLAT:??_C@_0EB@PEJDHKLE@ActiveId?3?50x?$CF08X?10x?$CF08X?5?$CI?$CF?42f?5s@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8597 : 		ImGui::Text("ActiveIdWindow: '%lld'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6744], 0
	je	SHORT $LN33@ShowMetric
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6744]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv281[rsp], rax
	jmp	SHORT $LN34@ShowMetric
$LN33@ShowMetric:
	mov	QWORD PTR tv281[rsp], 0
$LN34@ShowMetric:
	mov	rdx, QWORD PTR tv281[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BH@CKLACKBD@ActiveIdWindow?3?5?8?$CFlld?8@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8598 : 		ImGui::Text("MovingWindow: '%lld'", g.MovingWindow ? g.MovingWindow->Name : 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6776], 0
	je	SHORT $LN35@ShowMetric
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6776]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv320[rsp], rax
	jmp	SHORT $LN36@ShowMetric
$LN35@ShowMetric:
	mov	QWORD PTR tv320[rsp], 0
$LN36@ShowMetric:
	mov	rdx, QWORD PTR tv320[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BF@CFCDIHDM@MovingWindow?3?5?8?$CFlld?8@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8599 : 		ImGui::Text("NavWindow: '%lld'", g.NavWindow ? g.NavWindow->Name : 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN37@ShowMetric
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv327[rsp], rax
	jmp	SHORT $LN38@ShowMetric
$LN37@ShowMetric:
	mov	QWORD PTR tv327[rsp], 0
$LN38@ShowMetric:
	mov	rdx, QWORD PTR tv327[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BC@NLCAEKMP@NavWindow?3?5?8?$CFlld?8@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8600 : 		ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);

	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+7132]
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+7040]
	lea	rcx, OFFSET FLAT:??_C@_0BM@KFFINKHC@NavId?3?50x?$CF08X?0?5NavLayer?3?5?$CFd@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8601 : 		ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+7060]
	mov	rdx, QWORD PTR input_source_names$11[rsp+rax*8]
	lea	rcx, OFFSET FLAT:??_C@_0BD@HIKDFBG@NavInputSource?3?5?$CFs@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8602 : 		ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+935]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rcx+944]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BO@PADIALFI@NavActive?3?5?$CFd?0?5NavVisible?3?5?$CFd@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8603 : 		ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);

	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+7048]
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+7044]
	lea	rcx, OFFSET FLAT:??_C@_0CK@FMBJOEO@NavActivateId?3?50x?$CF08X?0?5NavInput@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8604 : 		ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rcx+7140]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0DC@PBLGJJAI@NavDisableHighlight?3?5?$CFd?0?5NavDis@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8605 : 		ImGui::Text("NavWindowingTarget: '%lld'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : 0);

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	SHORT $LN39@ShowMetric
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv366[rsp], rax
	jmp	SHORT $LN40@ShowMetric
$LN39@ShowMetric:
	mov	QWORD PTR tv366[rsp], 0
$LN40@ShowMetric:
	mov	rdx, QWORD PTR tv366[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BL@MDEMGJOE@NavWindowingTarget?3?5?8?$CFlld?8@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8606 : 		ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7640				; 00001dd8H
	mov	rcx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rcx+7596]
	mov	rdx, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rdx+7624]
	mov	DWORD PTR [rsp+32], edx
	mov	r9, rax
	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+7628]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0DJ@OPOHHHAC@DragDrop?3?5?$CFd?0?5SourceId?5?$DN?50x?$CF08X@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 8607 : 		ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	npad	1
$LN18@ShowMetric:

; 8608 : 	}
; 8609 : 
; 8610 : 
; 8611 : 	if (g.IO.KeyCtrl && show_window_begin_order)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	je	$LN19@ShowMetric
	movzx	eax, BYTE PTR ?show_window_begin_order@?1??ShowMetricsWindow@ImGui@@YAXPEA_N@Z@4_NA
	test	eax, eax
	je	$LN19@ShowMetric

; 8612 : 	{
; 8613 : 		for (int n = 0; n < g.Windows.Size; n++)

	mov	DWORD PTR n$4[rsp], 0
	jmp	SHORT $LN13@ShowMetric
$LN11@ShowMetric:
	mov	eax, DWORD PTR n$4[rsp]
	inc	eax
	mov	DWORD PTR n$4[rsp], eax
$LN13@ShowMetric:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	cmp	DWORD PTR n$4[rsp], eax
	jge	$LN12@ShowMetric

; 8614 : 		{
; 8615 : 			ImGuiWindow* window = g.Windows[n];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv397[rsp], rax
	mov	edx, DWORD PTR n$4[rsp]
	mov	rcx, QWORD PTR tv397[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$6[rsp], rax

; 8616 : 			if ((window->Flags & ImGuiWindowFlags_ChildWindow) || !window->WasActive)

	mov	rax, QWORD PTR window$6[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN21@ShowMetric
	mov	rax, QWORD PTR window$6[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	jne	SHORT $LN20@ShowMetric
$LN21@ShowMetric:

; 8617 : 				continue;

	jmp	SHORT $LN11@ShowMetric
$LN20@ShowMetric:

; 8618 : 			char buf[32];
; 8619 : 			ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);

	mov	rax, QWORD PTR window$6[rsp]
	movsx	eax, WORD PTR [rax+150]
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	edx, 32					; 00000020H
	lea	rcx, QWORD PTR buf$12[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 8620 : 			float font_size = ImGui::GetFontSize() * 2;

	call	?GetFontSize@ImGui@@YAMXZ		; ImGui::GetFontSize
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR font_size$5[rsp], xmm0

; 8621 : 			ImDrawList* overlay_draw_list = GetOverlayDrawList(window);

	mov	rcx, QWORD PTR window$6[rsp]
	call	?GetOverlayDrawList@@YAPEAUImDrawList@@PEAUImGuiWindow@@@Z ; GetOverlayDrawList
	mov	QWORD PTR overlay_draw_list$8[rsp], rax

; 8622 : 			overlay_draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));

	movss	xmm2, DWORD PTR font_size$5[rsp]
	movss	xmm1, DWORD PTR font_size$5[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$6[rsp]
	add	rcx, 48					; 00000030H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T10[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$6[rsp]
	add	rcx, 48					; 00000030H
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, -10197816				; ff6464c8H
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR overlay_draw_list$8[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 8623 : 			overlay_draw_list->AddText(NULL, font_size, window->Pos, IM_COL32(255, 255, 255, 255), buf);

	mov	rax, QWORD PTR window$6[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], 0
	lea	rcx, QWORD PTR buf$12[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], -1			; ffffffffH
	mov	r9, rax
	movss	xmm2, DWORD PTR font_size$5[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR overlay_draw_list$8[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 8624 : 		}

	jmp	$LN11@ShowMetric
$LN12@ShowMetric:
$LN19@ShowMetric:

; 8625 : 	}
; 8626 : 	ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1
$LN1@ShowMetric:

; 8627 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 360				; 00000168H
	ret	0
?ShowMetricsWindow@ImGui@@YAXPEA_N@Z ENDP		; ImGui::ShowMetricsWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 0
tv69 = 8
?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ PROC		; ImGui::GetDrawData

; 2164 : {

$LN5:
	sub	rsp, 24

; 2165 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2166 : 	return g.DrawData.Valid ? &g.DrawData : NULL;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7512]
	test	eax, eax
	je	SHORT $LN3@GetDrawDat
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7512				; 00001d58H
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@GetDrawDat
$LN3@GetDrawDat:
	mov	QWORD PTR tv69[rsp], 0
$LN4@GetDrawDat:
	mov	rax, QWORD PTR tv69[rsp]

; 2167 : }

	add	rsp, 24
	ret	0
?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ ENDP		; ImGui::GetDrawData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
n$1 = 40
n$2 = 44
window$3 = 48
windows_to_render_front_most$ = 56
tv87 = 72
tv93 = 80
tv135 = 88
tv222 = 96
?Render@ImGui@@YAXXZ PROC				; ImGui::Render

; 2962 : {

$LN19:
	sub	rsp, 120				; 00000078H

; 2963 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2964 : 	IM_ASSERT(g.Initialized);
; 2965 : 
; 2966 : 	if (g.FrameCountEnded != g.FrameCount)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	cmp	DWORD PTR [rax+6568], ecx
	je	SHORT $LN8@Render

; 2967 : 		EndFrame();

	call	?EndFrame@ImGui@@YAXXZ			; ImGui::EndFrame
	npad	1
$LN8@Render:

; 2968 : 	g.FrameCountRendered = g.FrameCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+6592], ecx

; 2969 : 
; 2970 : 	// Gather ImDrawList to render (for each active window)
; 2971 : 	g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+956], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+940], 0
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+952], 0

; 2972 : 	g.DrawDataBuilder.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7560				; 00001d88H
	mov	rcx, rax
	call	?Clear@ImDrawDataBuilder@@QEAAXXZ	; ImDrawDataBuilder::Clear

; 2973 : 	ImGuiWindow* windows_to_render_front_most[2];
; 2974 : 	windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	SHORT $LN15@Render
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 8192				; 00002000H
	test	eax, eax
	jne	SHORT $LN15@Render
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7104]
	mov	rax, QWORD PTR [rax+688]
	mov	QWORD PTR tv87[rsp], rax
	jmp	SHORT $LN16@Render
$LN15@Render:
	mov	QWORD PTR tv87[rsp], 0
$LN16@Render:
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tv87[rsp]
	mov	QWORD PTR windows_to_render_front_most$[rsp+rax], rcx

; 2975 : 	windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	SHORT $LN17@Render
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7120]
	mov	QWORD PTR tv93[rsp], rax
	jmp	SHORT $LN18@Render
$LN17@Render:
	mov	QWORD PTR tv93[rsp], 0
$LN18@Render:
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tv93[rsp]
	mov	QWORD PTR windows_to_render_front_most$[rsp+rax], rcx

; 2976 : 	for (int n = 0; n != g.Windows.Size; n++)

	mov	DWORD PTR n$2[rsp], 0
	jmp	SHORT $LN4@Render
$LN2@Render:
	mov	eax, DWORD PTR n$2[rsp]
	inc	eax
	mov	DWORD PTR n$2[rsp], eax
$LN4@Render:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	cmp	DWORD PTR n$2[rsp], eax
	je	$LN3@Render

; 2977 : 	{
; 2978 : 		ImGuiWindow* window = g.Windows[n];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv135[rsp], rax
	mov	edx, DWORD PTR n$2[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$3[rsp], rax

; 2979 : 		if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])

	mov	rcx, QWORD PTR window$3[rsp]
	call	?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z ; IsWindowActiveAndVisible
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Render
	mov	rax, QWORD PTR window$3[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	jne	SHORT $LN9@Render
	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR windows_to_render_front_most$[rsp+rax]
	cmp	QWORD PTR window$3[rsp], rax
	je	SHORT $LN9@Render
	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR windows_to_render_front_most$[rsp+rax]
	cmp	QWORD PTR window$3[rsp], rax
	je	SHORT $LN9@Render

; 2980 : 			AddRootWindowToDrawData(window);

	mov	rcx, QWORD PTR window$3[rsp]
	call	?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z ; AddRootWindowToDrawData
	npad	1
$LN9@Render:

; 2981 : 	}

	jmp	$LN2@Render
$LN3@Render:

; 2982 : 	for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN7@Render
$LN5@Render:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN7@Render:
	cmp	DWORD PTR n$1[rsp], 2
	jge	SHORT $LN6@Render

; 2983 : 		if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window

	movsxd	rax, DWORD PTR n$1[rsp]
	cmp	QWORD PTR windows_to_render_front_most$[rsp+rax*8], 0
	je	SHORT $LN10@Render
	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR windows_to_render_front_most$[rsp+rax*8]
	call	?IsWindowActiveAndVisible@@YA_NPEAUImGuiWindow@@@Z ; IsWindowActiveAndVisible
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@Render

; 2984 : 			AddRootWindowToDrawData(windows_to_render_front_most[n]);

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR windows_to_render_front_most$[rsp+rax*8]
	call	?AddRootWindowToDrawData@@YAXPEAUImGuiWindow@@@Z ; AddRootWindowToDrawData
	npad	1
$LN10@Render:
	jmp	SHORT $LN5@Render
$LN6@Render:

; 2985 : 	g.DrawDataBuilder.FlattenIntoSingleLayer();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7560				; 00001d88H
	mov	rcx, rax
	call	?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ ; ImDrawDataBuilder::FlattenIntoSingleLayer
	npad	1

; 2986 : 
; 2987 : 	// Draw software mouse cursor if requested
; 2988 : 	if (g.IO.MouseDrawCursor)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+210]
	test	eax, eax
	je	SHORT $LN11@Render

; 2989 : 		RenderMouseCursor(&g.OverlayDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	rcx, QWORD PTR g$[rsp]
	mov	r9d, DWORD PTR [rcx+7504]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rcx+5628]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rcx+316]
	mov	rcx, rax
	call	?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z ; ImGui::RenderMouseCursor
	npad	1
$LN11@Render:

; 2990 : 
; 2991 : 	if (!g.OverlayDrawList.VtxBuffer.empty())

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	rcx, rax
	call	?empty@?$ImVector@UImDrawVert@@@@QEBA_NXZ ; ImVector<ImDrawVert>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@Render

; 2992 : 		AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.OverlayDrawList);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR g$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+7560]
	mov	rdx, rax
	call	?AddDrawListToDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z ; AddDrawListToDrawData
	npad	1
$LN12@Render:

; 2993 : 
; 2994 : 	// Setup ImDrawData structure for end-user
; 2995 : 	SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7512				; 00001d58H
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR g$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+7560]
	mov	rdx, rax
	call	?SetupDrawData@@YAXPEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawData@@@Z ; SetupDrawData

; 2996 : 	g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7540]
	mov	DWORD PTR [rax+952], ecx

; 2997 : 	g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7536]
	mov	DWORD PTR [rax+940], ecx

; 2998 : 
; 2999 : 	// (Legacy) Call the Render callback function. The current prefer way is to let the user retrieve GetDrawData() and call the render function themselves.
; 3000 : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 3001 : 	if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7516], 0
	jle	SHORT $LN13@Render
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+296], 0
	je	SHORT $LN13@Render

; 3002 : 		g.IO.RenderDrawListsFn(&g.DrawData);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+296]
	mov	QWORD PTR tv222[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7512				; 00001d58H
	mov	rcx, rax
	call	QWORD PTR tv222[rsp]
	npad	1
$LN13@Render:

; 3003 : #endif
; 3004 : }

	add	rsp, 120				; 00000078H
	ret	0
?Render@ImGui@@YAXXZ ENDP				; ImGui::Render
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 32
is_delivered$1 = 40
is_elapsed$2 = 41
i$3 = 44
tv165 = 48
window$4 = 56
tv93 = 64
tv187 = 72
tv194 = 80
tv204 = 88
tv219 = 96
tv235 = 104
$T5 = 112
?EndFrame@ImGui@@YAXXZ PROC				; ImGui::EndFrame

; 2871 : {

$LN24:
	sub	rsp, 136				; 00000088H

; 2872 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2873 : 	IM_ASSERT(g.Initialized);
; 2874 : 	if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	cmp	DWORD PTR [rax+6568], ecx
	jne	SHORT $LN7@EndFrame

; 2875 : 		return;

	jmp	$LN1@EndFrame
$LN7@EndFrame:

; 2876 : 	IM_ASSERT(g.FrameScopeActive && "Forgot to call ImGui::NewFrame()?");
; 2877 : 
; 2878 : 	// Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
; 2879 : 	if (g.IO.ImeSetInputScreenPosFn && (g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+280], 0
	je	$LN8@EndFrame
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11732]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN23@EndFrame
	je	SHORT $LN9@EndFrame
$LN23@EndFrame:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 11740				; 00002ddcH
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 11732				; 00002dd4H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rcx, rax
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	comiss	xmm0, DWORD PTR __real@38d1b717
	jbe	SHORT $LN8@EndFrame
$LN9@EndFrame:

; 2880 : 	{
; 2881 : 		g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+280]
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	cvttss2si eax, DWORD PTR [rax+11744]
	mov	rcx, QWORD PTR g$[rsp]
	cvttss2si ecx, DWORD PTR [rcx+11740]
	mov	edx, eax
	call	QWORD PTR tv93[rsp]

; 2882 : 		g.PlatformImeLastPos = g.PlatformImePos;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+11740]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+11732], rax
$LN8@EndFrame:

; 2883 : 	}
; 2884 : 
; 2885 : 	// Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
; 2886 : 	// to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
; 2887 : 	if (g.CurrentWindowStack.Size != 1)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6672], 1
	je	SHORT $LN10@EndFrame

; 2888 : 	{
; 2889 : 		if (g.CurrentWindowStack.Size > 1)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6672], 1
	jle	SHORT $LN11@EndFrame
$LN2@EndFrame:

; 2890 : 		{
; 2891 : 			IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
; 2892 : 			while (g.CurrentWindowStack.Size > 1) // FIXME-ERRORHANDLING

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6672], 1
	jle	SHORT $LN3@EndFrame

; 2893 : 				End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1
	jmp	SHORT $LN2@EndFrame
$LN3@EndFrame:
$LN11@EndFrame:
$LN10@EndFrame:

; 2894 : 		}
; 2895 : 		else
; 2896 : 		{
; 2897 : 			IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
; 2898 : 		}
; 2899 : 	}
; 2900 : 
; 2901 : 	// Hide implicit/fallback "Debug" window if it hasn't been used
; 2902 : 	g.FrameScopePushedImplicitWindow = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax], 0

; 2903 : 	if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+6584], 0
	je	SHORT $LN13@EndFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movzx	eax, BYTE PTR [rax+112]
	test	eax, eax
	jne	SHORT $LN13@EndFrame

; 2904 : 		g.CurrentWindow->Active = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	BYTE PTR [rax+102], 0
$LN13@EndFrame:

; 2905 : 	End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1

; 2906 : 
; 2907 : 	// Show CTRL+TAB list window
; 2908 : 	/*if (g.NavWindowingTarget)
; 2909 : 		NavUpdateWindowingList();*/
; 2910 : 
; 2911 : 		// Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
; 2912 : 	if (g.DragDropActive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	$LN14@EndFrame

; 2913 : 	{
; 2914 : 		bool is_delivered = g.DragDropPayload.Delivery;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7674]
	mov	BYTE PTR is_delivered$1[rsp], al

; 2915 : 		bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7632]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx+6552]
	jge	SHORT $LN21@EndFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7608]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN20@EndFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7604]
	call	?IsMouseDown@ImGui@@YA_NH@Z		; ImGui::IsMouseDown
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN21@EndFrame
$LN20@EndFrame:
	mov	DWORD PTR tv165[rsp], 1
	jmp	SHORT $LN22@EndFrame
$LN21@EndFrame:
	mov	DWORD PTR tv165[rsp], 0
$LN22@EndFrame:
	movzx	eax, BYTE PTR tv165[rsp]
	mov	BYTE PTR is_elapsed$2[rsp], al

; 2916 : 		if (is_delivered || is_elapsed)

	movzx	eax, BYTE PTR is_delivered$1[rsp]
	test	eax, eax
	jne	SHORT $LN16@EndFrame
	movzx	eax, BYTE PTR is_elapsed$2[rsp]
	test	eax, eax
	je	SHORT $LN15@EndFrame
$LN16@EndFrame:

; 2917 : 			ClearDragDrop();

	call	?ClearDragDrop@ImGui@@YAXXZ		; ImGui::ClearDragDrop
	npad	1
$LN15@EndFrame:
$LN14@EndFrame:

; 2918 : 	}
; 2919 : 
; 2920 : 	// Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
; 2921 : 	if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN17@EndFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	cmp	DWORD PTR [rax+7600], ecx
	jge	SHORT $LN17@EndFrame

; 2922 : 	{
; 2923 : 		g.DragDropWithinSourceOrTarget = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 1

; 2924 : 		SetTooltip("...");

	lea	rcx, OFFSET FLAT:??_C@_03KHICJKCI@?4?4?4@
	call	?SetTooltip@ImGui@@YAXPEBDZZ		; ImGui::SetTooltip

; 2925 : 		g.DragDropWithinSourceOrTarget = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 0
$LN17@EndFrame:

; 2926 : 	}
; 2927 : 
; 2928 : 	// End frame
; 2929 : 	g.FrameScopeActive = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+3], 0

; 2930 : 	g.FrameCountEnded = g.FrameCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+6568], ecx

; 2931 : 
; 2932 : 	// Initiate moving window + handle left-click and right-click focus
; 2933 : 	UpdateMouseMovingWindowEndFrame();

	call	?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ ; ImGui::UpdateMouseMovingWindowEndFrame

; 2934 : 
; 2935 : 	// Sort the window list so that all child windows are after their parent
; 2936 : 	// We cannot do that on FocusWindow() because childs may not exist yet
; 2937 : 	g.WindowsSortBuffer.resize(0);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6632				; 000019e8H
	mov	QWORD PTR tv187[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv187[rsp]
	call	?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::resize

; 2938 : 	g.WindowsSortBuffer.reserve(g.Windows.Size);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6632				; 000019e8H
	mov	QWORD PTR tv194[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6600]
	mov	rcx, QWORD PTR tv194[rsp]
	call	?reserve@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::reserve
	npad	1

; 2939 : 	for (int i = 0; i != g.Windows.Size; i++)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN6@EndFrame
$LN4@EndFrame:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN6@EndFrame:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	cmp	DWORD PTR i$3[rsp], eax
	je	SHORT $LN5@EndFrame

; 2940 : 	{
; 2941 : 		ImGuiWindow* window = g.Windows[i];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv204[rsp], rax
	mov	edx, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR tv204[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$4[rsp], rax

; 2942 : 		if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it

	mov	rax, QWORD PTR window$4[rsp]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	SHORT $LN18@EndFrame
	mov	rax, QWORD PTR window$4[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN18@EndFrame

; 2943 : 			continue;

	jmp	SHORT $LN4@EndFrame
$LN18@EndFrame:

; 2944 : 		AddWindowToSortBuffer(&g.WindowsSortBuffer, window);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6632				; 000019e8H
	mov	rdx, QWORD PTR window$4[rsp]
	mov	rcx, rax
	call	?AddWindowToSortBuffer@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEAUImGuiWindow@@@Z ; AddWindowToSortBuffer
	npad	1

; 2945 : 	}

	jmp	SHORT $LN4@EndFrame
$LN5@EndFrame:

; 2946 : 
; 2947 : 	// This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
; 2948 : 	IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);
; 2949 : 	g.Windows.swap(g.WindowsSortBuffer);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv219[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6632				; 000019e8H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv219[rsp]
	call	?swap@?$ImVector@PEAUImGuiWindow@@@@QEAAXAEAU1@@Z ; ImVector<ImGuiWindow *>::swap

; 2950 : 	g.IO.MetricsActiveWindows = g.WindowsActiveCount;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6648]
	mov	DWORD PTR [rax+964], ecx

; 2951 : 
; 2952 : 	// Unlock font atlas
; 2953 : 	g.IO.Fonts->Locked = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+176]
	mov	BYTE PTR [rax], 0

; 2954 : 
; 2955 : 	// Clear Input data for next frame
; 2956 : 	g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+328], xmm0
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+312], xmm0

; 2957 : 	g.IO.InputQueueCharacters.resize(0);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5456				; 00001550H
	mov	QWORD PTR tv235[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv235[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 2958 : 	memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 848				; 00000350H
	mov	r8d, 84					; 00000054H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1
$LN1@EndFrame:

; 2959 : }

	add	rsp, 136				; 00000088H
	ret	0
?EndFrame@ImGui@@YAXXZ ENDP				; ImGui::EndFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
g$ = 48
i$1 = 56
i$2 = 60
n$3 = 64
tv171 = 68
tv166 = 72
tv290 = 76
tv293 = 80
tv323 = 84
tv391 = 88
tv399 = 92
window$4 = 96
tv157 = 104
tv410 = 112
tv426 = 120
tv431 = 128
$T5 = 136
$T6 = 144
$T7 = 152
?NewFrame@ImGui@@YAXXZ PROC				; ImGui::NewFrame

; 2468 : {

$LN44:
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 2469 : 	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
; 2470 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2471 : 
; 2472 : #ifdef IMGUI_ENABLE_TEST_ENGINE
; 2473 : 	ImGuiTestEngineHook_PreNewFrame(&g);
; 2474 : #endif
; 2475 : 
; 2476 : 	// Check user data
; 2477 : 	// (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
; 2478 : 	IM_ASSERT(g.Initialized);
; 2479 : 	IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0) && "Need a positive DeltaTime!");
; 2480 : 	IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && "Invalid DisplaySize value!");
; 2481 : 	IM_ASSERT(g.IO.Fonts->Fonts.Size > 0 && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
; 2482 : 	IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded() && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
; 2483 : 	IM_ASSERT(g.Style.CurveTessellationTol > 0.0f && "Invalid style setting!");
; 2484 : 	IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)!");
; 2485 : 	IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
; 2486 : 	for (int n = 0; n < ImGuiKey_COUNT; n++)

	mov	DWORD PTR n$3[rsp], 0
	jmp	SHORT $LN4@NewFrame
$LN2@NewFrame:
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN4@NewFrame:
	cmp	DWORD PTR n$3[rsp], 21
	jge	SHORT $LN3@NewFrame

; 2487 : 		IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

	jmp	SHORT $LN2@NewFrame
$LN3@NewFrame:

; 2488 : 
; 2489 : 	// Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
; 2490 : 	if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1

; 2491 : 		IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
; 2492 : 
; 2493 : 	// Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
; 2494 : 	if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+212]
	test	eax, eax
	je	SHORT $LN12@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN12@NewFrame

; 2495 : 		g.IO.ConfigWindowsResizeFromEdges = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+212], 0
$LN12@NewFrame:

; 2496 : 
; 2497 : 	// Load settings on first frame (if not explicitly loaded manually before)
; 2498 :    /* if (!g.SettingsLoaded)
; 2499 : 	{
; 2500 : 		IM_ASSERT(g.SettingsWindows.empty());
; 2501 : 		if (g.IO.IniFilename)
; 2502 : 			LoadIniSettingsFromDisk(g.IO.IniFilename);
; 2503 : 		g.SettingsLoaded = true;
; 2504 : 	}*/
; 2505 : 
; 2506 : 	// Save settings (with a delay after the last modification, so we don't spam disk too much)
; 2507 : 	//if (g.SettingsDirtyTimer > 0.0f)
; 2508 : 	//{
; 2509 : 	//    g.SettingsDirtyTimer -= g.IO.DeltaTime;
; 2510 : 	//    if (g.SettingsDirtyTimer <= 0.0f)
; 2511 : 	//    {
; 2512 : 	//        if (g.IO.IniFilename != NULL)
; 2513 : 	//            SaveIniSettingsToDisk(g.IO.IniFilename);
; 2514 : 	//        else
; 2515 : 	//            g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
; 2516 : 	//        g.SettingsDirtyTimer = 0.0f;
; 2517 : 	//    }
; 2518 : 	//}
; 2519 : 
; 2520 : 	g.Time += g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+48]
	mov	rax, QWORD PTR g$[rsp]
	movsd	xmm1, QWORD PTR [rax+6576]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movsd	QWORD PTR [rax+6576], xmm0

; 2521 : 	g.FrameScopeActive = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+3], 1

; 2522 : 	g.FrameCount += 1;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6552]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+6552], eax

; 2523 : 	g.TooltipOverrideCount = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+11700], 0

; 2524 : 	g.WindowsActiveCount = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6648], 0

; 2525 : 
; 2526 : 	// Setup current font and draw list shared data
; 2527 : 	g.IO.Fonts->Locked = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+176]
	mov	BYTE PTR [rax], 1

; 2528 : 	SetCurrentFont(GetDefaultFont());

	call	?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ	; ImGui::GetDefaultFont
	mov	rcx, rax
	call	?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z ; ImGui::SetCurrentFont
	npad	1

; 2529 : 	IM_ASSERT(g.Font->IsLoaded());
; 2530 : 	g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm3, DWORD PTR [rax+20]
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, QWORD PTR g$[rsp]
	lea	rdi, QWORD PTR [rcx+6440]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 2531 : 	g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+5636]
	movss	DWORD PTR [rax+6436], xmm0

; 2532 : 
; 2533 : 	g.OverlayDrawList.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	rcx, rax
	call	?Clear@ImDrawList@@QEAAXXZ		; ImDrawList::Clear

; 2534 : 	g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	QWORD PTR tv157[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+176]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv157[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID

; 2535 : 	g.OverlayDrawList.PushClipRectFullScreen();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7336				; 00001ca8H
	mov	rcx, rax
	call	?PushClipRectFullScreen@ImDrawList@@QEAAXXZ ; ImDrawList::PushClipRectFullScreen

; 2536 : 	g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+5632]
	test	eax, eax
	je	SHORT $LN30@NewFrame
	mov	DWORD PTR tv166[rsp], 1
	jmp	SHORT $LN31@NewFrame
$LN30@NewFrame:
	mov	DWORD PTR tv166[rsp], 0
$LN31@NewFrame:
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+5633]
	test	eax, eax
	je	SHORT $LN32@NewFrame
	mov	DWORD PTR tv171[rsp], 2
	jmp	SHORT $LN33@NewFrame
$LN32@NewFrame:
	mov	DWORD PTR tv171[rsp], 0
$LN33@NewFrame:
	mov	eax, DWORD PTR tv171[rsp]
	mov	ecx, DWORD PTR tv166[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+7352], eax

; 2537 : 
; 2538 : 	// Mark rendering data as invalid to prevent user who may have a handle on it to use it.
; 2539 : 	g.DrawData.Clear();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7512				; 00001d58H
	mov	rcx, rax
	call	?Clear@ImDrawData@@QEAAXXZ		; ImDrawData::Clear
	npad	1

; 2540 : 
; 2541 : 	// Drag and drop keep the source ID alive so even if the source disappear our state is consistent
; 2542 : 	if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN13@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	cmp	DWORD PTR [rax+7628], ecx
	jne	SHORT $LN13@NewFrame

; 2543 : 		KeepAliveID(g.DragDropPayload.SourceId);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+7628]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	npad	1
$LN13@NewFrame:

; 2544 : 
; 2545 : 	// Clear reference to active widget if the widget isn't alive anymore
; 2546 : 	if (!g.HoveredIdPreviousFrame)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6724], 0
	jne	SHORT $LN14@NewFrame

; 2547 : 		g.HoveredIdTimer = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6728], xmm0
$LN14@NewFrame:

; 2548 : 	if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6724], 0
	je	SHORT $LN16@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	je	SHORT $LN15@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6696]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN15@NewFrame
$LN16@NewFrame:

; 2549 : 		g.HoveredIdNotActiveTimer = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6712], xmm0
$LN15@NewFrame:

; 2550 : 	if (g.HoveredId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	je	SHORT $LN17@NewFrame

; 2551 : 		g.HoveredIdTimer += g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6728]
	addss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+6728], xmm0
$LN17@NewFrame:

; 2552 : 	if (g.HoveredId && g.ActiveId != g.HoveredId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6696], 0
	je	SHORT $LN18@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6696]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN18@NewFrame

; 2553 : 		g.HoveredIdNotActiveTimer += g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6712]
	addss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+6712], xmm0
$LN18@NewFrame:

; 2554 : 	g.HoveredIdPreviousFrame = g.HoveredId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6696]
	mov	DWORD PTR [rax+6724], ecx

; 2555 : 	g.HoveredId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6696], 0

; 2556 : 	g.HoveredIdAllowOverlap = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6700], 0

; 2557 : 	if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	cmp	DWORD PTR [rax+6720], ecx
	je	SHORT $LN19@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	cmp	DWORD PTR [rax+6708], ecx
	jne	SHORT $LN19@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN19@NewFrame

; 2558 : 		ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN19@NewFrame:

; 2559 : 	if (g.ActiveId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN20@NewFrame

; 2560 : 		g.ActiveIdTimer += g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6736]
	addss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+6736], xmm0
$LN20@NewFrame:

; 2561 : 	g.LastActiveIdTimer += g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6828]
	addss	xmm0, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+6828], xmm0

; 2562 : 	g.ActiveIdPreviousFrame = g.ActiveId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	mov	DWORD PTR [rax+6708], ecx

; 2563 : 	g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+6744]
	mov	QWORD PTR [rax+6760], rcx

; 2564 : 	g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rcx+6732]
	mov	BYTE PTR [rax+6800], cl

; 2565 : 	g.ActiveIdIsAlive = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6720], 0

; 2566 : 	g.ActiveIdPreviousFrameIsAlive = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6768], 0

; 2567 : 	g.ActiveIdIsJustActivated = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6752], 0

; 2568 : 	if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+11664], 0
	je	SHORT $LN21@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+11664]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN21@NewFrame

; 2569 : 		g.ScalarAsInputTextId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+11664], 0
$LN21@NewFrame:

; 2570 : 
; 2571 : 	// Drag and drop
; 2572 : 	g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+7708]
	mov	DWORD PTR [rax+7736], ecx

; 2573 : 	g.DragDropAcceptIdCurr = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7708], 0

; 2574 : 	g.DragDropAcceptIdCurrRectSurface = FLT_MAX;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+7696], xmm0

; 2575 : 	g.DragDropWithinSourceOrTarget = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7597], 0

; 2576 : 
; 2577 : 	// Update keyboard input state
; 2578 : 	memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 1132				; 0000046cH
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 3324				; 00000cfcH
	mov	r8d, 2048				; 00000800H
	mov	rdx, rax
	call	memcpy
	npad	1

; 2579 : 	for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@NewFrame
$LN5@NewFrame:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@NewFrame:
	cmp	DWORD PTR i$1[rsp], 512			; 00000200H
	jge	$LN6@NewFrame

; 2580 : 		g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+333]
	test	eax, eax
	je	SHORT $LN36@NewFrame
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rcx+rax*4+1132]
	jbe	SHORT $LN34@NewFrame
	xorps	xmm0, xmm0
	movss	DWORD PTR tv290[rsp], xmm0
	jmp	SHORT $LN35@NewFrame
$LN34@NewFrame:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+1132]
	addss	xmm0, DWORD PTR [rdx+48]
	movss	DWORD PTR tv290[rsp], xmm0
$LN35@NewFrame:
	movss	xmm0, DWORD PTR tv290[rsp]
	movss	DWORD PTR tv293[rsp], xmm0
	jmp	SHORT $LN37@NewFrame
$LN36@NewFrame:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv293[rsp], xmm0
$LN37@NewFrame:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv293[rsp]
	movss	DWORD PTR [rcx+rax*4+1132], xmm0
	jmp	$LN5@NewFrame
$LN6@NewFrame:

; 2581 : 
; 2582 : 	// Update gamepad/keyboard directional navigation
; 2583 : 	NavUpdate();

	call	?NavUpdate@ImGui@@YAXXZ			; ImGui::NavUpdate

; 2584 : 
; 2585 : 	// Update mouse input state
; 2586 : 	UpdateMouseInputs();

	call	?UpdateMouseInputs@ImGui@@YAXXZ		; ImGui::UpdateMouseInputs

; 2587 : 
; 2588 : 	// Calculate frame-rate for the user, as a purely luxurious feature
; 2589 : 	g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+12228]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+48]
	subss	xmm0, DWORD PTR [rdx+rax*4+11748]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+12232]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+12232], xmm0

; 2590 : 	g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+12228]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rdx+48]
	movss	DWORD PTR [rcx+rax*4+11748], xmm0

; 2591 : 	g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+12228]
	inc	eax
	cdq
	mov	ecx, 120				; 00000078H
	idiv	ecx
	mov	eax, edx
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+12228], eax

; 2592 : 	g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+12232]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN38@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+12232]
	divss	xmm0, DWORD PTR __real@42f00000
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv323[rsp], xmm0
	jmp	SHORT $LN39@NewFrame
$LN38@NewFrame:
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR tv323[rsp], xmm0
$LN39@NewFrame:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR tv323[rsp]
	movss	DWORD PTR [rax+948], xmm0

; 2593 : 
; 2594 : 	// Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
; 2595 : 	UpdateMouseMovingWindowNewFrame();

	call	?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ ; ImGui::UpdateMouseMovingWindowNewFrame

; 2596 : 	UpdateHoveredWindowAndCaptureFlags();

	call	?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ ; ImGui::UpdateHoveredWindowAndCaptureFlags
	npad	1

; 2597 : 
; 2598 : 	// Background darkening/whitening
; 2599 : 	if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))

	call	?GetFrontMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetFrontMostPopupModal
	test	rax, rax
	jne	SHORT $LN24@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7104], 0
	je	SHORT $LN22@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7096]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@NewFrame
$LN24@NewFrame:

; 2600 : 		g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	mulss	xmm0, DWORD PTR __real@40c00000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+7592]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7592], xmm0
	jmp	SHORT $LN23@NewFrame
$LN22@NewFrame:

; 2601 : 	else
; 2602 : 		g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+7592]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	xorps	xmm1, xmm1
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7592], xmm0
$LN23@NewFrame:

; 2603 : 
; 2604 : 	g.MouseCursor = ImGuiMouseCursor_Arrow;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7504], 0

; 2605 : 	g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+12236], -1
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+15320], -1
	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+15316], -1

; 2606 : 	g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+11740], rax

; 2607 : 
; 2608 : 	// Mouse wheel scrolling, scale
; 2609 : 	UpdateMouseWheel();

	call	?UpdateMouseWheel@ImGui@@YAXXZ		; ImGui::UpdateMouseWheel
	npad	1

; 2610 : 
; 2611 : 	// Pressing TAB activate widget focus
; 2612 : 	if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	$LN25@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	$LN25@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	movzx	eax, BYTE PTR [rax+102]
	test	eax, eax
	je	$LN25@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	$LN25@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	$LN25@NewFrame
	xor	edx, edx
	xor	ecx, ecx
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	$LN25@NewFrame

; 2613 : 	{
; 2614 : 		if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7040], 0
	je	SHORT $LN26@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7136], 2147483647	; 7fffffffH
	je	SHORT $LN26@NewFrame

; 2615 : 			g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN40@NewFrame
	mov	DWORD PTR tv391[rsp], -1
	jmp	SHORT $LN41@NewFrame
$LN40@NewFrame:
	mov	DWORD PTR tv391[rsp], 1
$LN41@NewFrame:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7136]
	mov	ecx, DWORD PTR tv391[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	mov	DWORD PTR [rcx+964], eax
	jmp	SHORT $LN27@NewFrame
$LN26@NewFrame:

; 2616 : 		else
; 2617 : 			g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN42@NewFrame
	mov	DWORD PTR tv399[rsp], -1
	jmp	SHORT $LN43@NewFrame
$LN42@NewFrame:
	mov	DWORD PTR tv399[rsp], 0
$LN43@NewFrame:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	ecx, DWORD PTR tv399[rsp]
	mov	DWORD PTR [rax+964], ecx
$LN27@NewFrame:
$LN25@NewFrame:

; 2618 : 	}
; 2619 : 	g.NavIdTabCounter = INT_MAX;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7136], 2147483647	; 7fffffffH

; 2620 : 
; 2621 : 	// Mark all windows as not visible
; 2622 : 	IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);
; 2623 : 	for (int i = 0; i != g.Windows.Size; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN10@NewFrame
$LN8@NewFrame:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN10@NewFrame:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6600]
	cmp	DWORD PTR i$2[rsp], eax
	je	SHORT $LN9@NewFrame

; 2624 : 	{
; 2625 : 		ImGuiWindow* window = g.Windows[i];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6600				; 000019c8H
	mov	QWORD PTR tv410[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv410[rsp]
	call	??A?$ImVector@PEAUImGuiWindow@@@@QEAAAEAPEAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR window$4[rsp], rax

; 2626 : 		window->WasActive = window->Active;

	mov	rax, QWORD PTR window$4[rsp]
	mov	rcx, QWORD PTR window$4[rsp]
	movzx	ecx, BYTE PTR [rcx+102]
	mov	BYTE PTR [rax+132], cl

; 2627 : 		window->Active = false;

	mov	rax, QWORD PTR window$4[rsp]
	mov	BYTE PTR [rax+102], 0

; 2628 : 		window->WriteAccessed = false;

	mov	rax, QWORD PTR window$4[rsp]
	mov	BYTE PTR [rax+112], 0

; 2629 : 	}

	jmp	SHORT $LN8@NewFrame
$LN9@NewFrame:

; 2630 : 
; 2631 : 	// Closing the focused window restore focus to the first active root window in descending z-order
; 2632 : 	if (g.NavWindow && !g.NavWindow->WasActive)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN28@NewFrame
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	jne	SHORT $LN28@NewFrame

; 2633 : 		FocusPreviousWindowIgnoringOne(NULL);

	xor	ecx, ecx
	call	?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusPreviousWindowIgnoringOne
	npad	1
$LN28@NewFrame:

; 2634 : 
; 2635 : 	// No window should be open at the beginning of the frame.
; 2636 : 	// But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
; 2637 : 	g.CurrentWindowStack.resize(0);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6672				; 00001a10H
	mov	QWORD PTR tv426[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv426[rsp]
	call	?resize@?$ImVector@PEAUImGuiWindow@@@@QEAAXH@Z ; ImVector<ImGuiWindow *>::resize

; 2638 : 	g.BeginPopupStack.resize(0);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6888				; 00001ae8H
	mov	QWORD PTR tv431[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv431[rsp]
	call	?resize@?$ImVector@UImGuiPopupRef@@@@QEAAXH@Z ; ImVector<ImGuiPopupRef>::resize

; 2639 : 	ClosePopupsOverWindow(g.NavWindow);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7024]
	call	?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::ClosePopupsOverWindow
	npad	1

; 2640 : 
; 2641 : 	// Create implicit/fallback window - which we will only render it if the user has added something to it.
; 2642 : 	// We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
; 2643 : 	// This fallback is particularly important as it avoid ImGui:: calls from crashing.
; 2644 : 	SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);

	movss	xmm2, DWORD PTR __real@43c80000
	movss	xmm1, DWORD PTR __real@43c80000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	edx, 4
	mov	rcx, rax
	call	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ; ImGui::SetNextWindowSize
	npad	1

; 2645 : 	Begin(("Default"));

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin

; 2646 : 	g.FrameScopePushedImplicitWindow = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax], 1

; 2647 : 
; 2648 : #ifdef IMGUI_ENABLE_TEST_ENGINE
; 2649 : 	ImGuiTestEngineHook_PostNewFrame(&g);
; 2650 : #endif
; 2651 : }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?NewFrame@ImGui@@YAXXZ ENDP				; ImGui::NewFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ PROC		; ImGui::GetStyle

; 2158 : 	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
; 2159 : 	return GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 5472				; 00001560H

; 2160 : }

	ret	0
?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ ENDP		; ImGui::GetStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetIO@ImGui@@YAAEAUImGuiIO@@XZ PROC			; ImGui::GetIO

; 2152 : 	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
; 2153 : 	return GImGui->IO;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rax, 16

; 2154 : }

	ret	0
?GetIO@ImGui@@YAAEAUImGuiIO@@XZ ENDP			; ImGui::GetIO
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
error$ = 32
tv75 = 36
version$ = 64
sz_io$ = 72
sz_style$ = 80
sz_vec2$ = 88
sz_vec4$ = 96
sz_vert$ = 104
?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K1111@Z PROC ; ImGui::DebugCheckVersionAndDataLayout

; 2113 : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2114 : 	bool error = false;

	mov	BYTE PTR error$[rsp], 0

; 2115 : 	if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && ("Mismatched version string!")); }

	lea	rdx, OFFSET FLAT:??_C@_01HIHLOKLC@1@
	mov	rcx, QWORD PTR version$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN2@DebugCheck
	mov	BYTE PTR error$[rsp], 1
$LN2@DebugCheck:

; 2116 : 	if (sz_io != sizeof(ImGuiIO)) { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && ("Mismatched struct layout!")); }

	cmp	QWORD PTR sz_io$[rsp], 5456		; 00001550H
	je	SHORT $LN3@DebugCheck
	mov	BYTE PTR error$[rsp], 1
$LN3@DebugCheck:

; 2117 : 	if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && ("Mismatched struct layout!")); }

	cmp	QWORD PTR sz_style$[rsp], 936		; 000003a8H
	je	SHORT $LN4@DebugCheck
	mov	BYTE PTR error$[rsp], 1
$LN4@DebugCheck:

; 2118 : 	if (sz_vec2 != sizeof(ImVec2)) { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && ("Mismatched struct layout!")); }

	cmp	QWORD PTR sz_vec2$[rsp], 8
	je	SHORT $LN5@DebugCheck
	mov	BYTE PTR error$[rsp], 1
$LN5@DebugCheck:

; 2119 : 	if (sz_vec4 != sizeof(ImVec4)) { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && ("Mismatched struct layout!")); }

	cmp	QWORD PTR sz_vec4$[rsp], 16
	je	SHORT $LN6@DebugCheck
	mov	BYTE PTR error$[rsp], 1
$LN6@DebugCheck:

; 2120 : 	if (sz_vert != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && ("Mismatched struct layout!")); }

	cmp	QWORD PTR sz_vert$[rsp], 20
	je	SHORT $LN7@DebugCheck
	mov	BYTE PTR error$[rsp], 1
$LN7@DebugCheck:

; 2121 : 	return !error;

	movzx	eax, BYTE PTR error$[rsp]
	test	eax, eax
	jne	SHORT $LN9@DebugCheck
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN10@DebugCheck
$LN9@DebugCheck:
	mov	DWORD PTR tv75[rsp], 0
$LN10@DebugCheck:
	movzx	eax, BYTE PTR tv75[rsp]

; 2122 : }

	add	rsp, 56					; 00000038H
	ret	0
?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K1111@Z ENDP ; ImGui::DebugCheckVersionAndDataLayout
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ctx$ = 8
?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z PROC	; ImGui::SetCurrentContext

; 2102 : {

	mov	QWORD PTR [rsp+8], rcx

; 2103 : #ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
; 2104 : 	IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
; 2105 : #else
; 2106 : 	GImGui = ctx;

	mov	rax, QWORD PTR ctx$[rsp]
	mov	QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA, rax ; GImGui

; 2107 : #endif
; 2108 : }

	ret	0
?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z ENDP	; ImGui::SetCurrentContext
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ PROC	; ImGui::GetCurrentContext

; 2098 : 	return GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2099 : }

	ret	0
?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ ENDP	; ImGui::GetCurrentContext
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
ctx$ = 48
?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z PROC	; ImGui::DestroyContext

; 2141 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2142 : 	if (ctx == NULL)

	cmp	QWORD PTR ctx$[rsp], 0
	jne	SHORT $LN2@DestroyCon

; 2143 : 		ctx = GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR ctx$[rsp], rax
$LN2@DestroyCon:

; 2144 : 	Shutdown(ctx);

	mov	rcx, QWORD PTR ctx$[rsp]
	call	?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z ; ImGui::Shutdown
	npad	1

; 2145 : 	if (GImGui == ctx)

	mov	rax, QWORD PTR ctx$[rsp]
	cmp	QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA, rax ; GImGui
	jne	SHORT $LN3@DestroyCon

; 2146 : 		SetCurrentContext(NULL);

	xor	ecx, ecx
	call	?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z ; ImGui::SetCurrentContext
	npad	1
$LN3@DestroyCon:

; 2147 : 	IM_DELETE(ctx);

	mov	rcx, QWORD PTR ctx$[rsp]
	call	??$IM_DELETE@UImGuiContext@@@@YAXPEAUImGuiContext@@@Z ; IM_DELETE<ImGuiContext>
	npad	1

; 2148 : }

	add	rsp, 40					; 00000028H
	ret	0
?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z ENDP	; ImGui::DestroyContext
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 32
ctx$ = 40
$T2 = 48
tv81 = 56
$T3 = 64
$T4 = 72
$T5 = 80
shared_font_atlas$ = 112
?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z PROC ; ImGui::CreateContext

; 2132 : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2133 : 	ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);

	mov	ecx, 15328				; 00003be0H
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	r8, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR $T4[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 15328				; 00003be0H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN4@CreateCont
	mov	rdx, QWORD PTR shared_font_atlas$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0ImGuiContext@@QEAA@PEAUImFontAtlas@@@Z ; ImGuiContext::ImGuiContext
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN5@CreateCont
$LN4@CreateCont:
	mov	QWORD PTR tv81[rsp], 0
$LN5@CreateCont:
	mov	rax, QWORD PTR tv81[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR ctx$[rsp], rax

; 2134 : 	if (GImGui == NULL)

	cmp	QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA, 0 ; GImGui
	jne	SHORT $LN2@CreateCont

; 2135 : 		SetCurrentContext(ctx);

	mov	rcx, QWORD PTR ctx$[rsp]
	call	?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z ; ImGui::SetCurrentContext
	npad	1
$LN2@CreateCont:

; 2136 : 	Initialize(ctx);

	mov	rcx, QWORD PTR ctx$[rsp]
	call	?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z ; ImGui::Initialize

; 2137 : 	return ctx;

	mov	rax, QWORD PTR ctx$[rsp]

; 2138 : }

	add	rsp, 104				; 00000068H
	ret	0
?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z ENDP ; ImGui::CreateContext
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
ctx$ = 40
$T2 = 48
tv81 = 56
$T3 = 64
$T4 = 72
$T5 = 80
shared_font_atlas$ = 112
?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA PROC ; `ImGui::CreateContext'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z@4HA ENDP ; `ImGui::CreateContext'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
??0ImVec4@@QEAA@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT

; 190  : 	ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _z$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _w$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec4@@QEAA@XZ PROC					; ImVec4::ImVec4, COMDAT

; 189  : 	ImVec4() { x = y = z = w = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 175  : 	ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec2@@QEAA@XZ PROC					; ImVec2::ImVec2, COMDAT

; 173  : 	ImVec2() { x = y = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?hash_@@YA?B_KPEBD@Z
_TEXT	SEGMENT
ret$ = 0
str$ = 32
?hash_@@YA?B_KPEBD@Z PROC				; hash_, COMDAT

; 203  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 204  : 	hash_t ret{ basis };

	mov	rax, -3750763034361777355		; cbf29ce484333335H
	mov	QWORD PTR ret$[rsp], rax
$LN2@hash_:

; 205  : 
; 206  : 	while (*str) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@hash_

; 207  : 		ret ^= *str;

	mov	rax, QWORD PTR str$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR ret$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 208  : 		ret *= prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR ret$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 209  : 		str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 210  : 	}

	jmp	SHORT $LN2@hash_
$LN3@hash_:

; 211  : 
; 212  : 	return ret;

	mov	rax, QWORD PTR ret$[rsp]

; 213  : }

	add	rsp, 24
	ret	0
?hash_@@YA?B_KPEBD@Z ENDP				; hash_
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 48
fabsf	PROC						; COMDAT

; 719  :         {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 720  :             return (float)fabs(_X);

	cvtss2sd xmm0, DWORD PTR _X$[rsp]
	call	fabs
	cvtsd2ss xmm0, xmm0

; 721  :         }

	add	rsp, 40					; 00000028H
	ret	0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
_vsnprintf PROC						; COMDAT

; 1411 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1413 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1397 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
