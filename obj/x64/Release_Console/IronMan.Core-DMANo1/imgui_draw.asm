; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB DB '..-         -XXXXXXX-    X'
	DB	'    -           X           -XXXXXXX          -          XXXX'
	DB	'XXX-     XX          ..-         -X.....X-   X.X   -         '
	DB	' X.X          -X.....X          -          X.....X-    X..X  '
	DB	'       ---         -XXX.XXX-  X...X  -         X...X         '
	DB	'-X....X           -           X....X-    X..X         X      '
	DB	'     -  X.X  - X.....X -        X.....X        -X...X        '
	DB	'    -            X...X-    X..X         XX          -  X.X  -'
	DB	'X.......X-       X.......X       -X..X.X           -         '
	DB	'  X.X..X-    X..X         X.X         -  X.X  -XXXX.XXXX-    '
	DB	'   XXXX.XXXX       -X.X X.X          -          X.X X.X-    X'
	DB	'..XXX       X..X        -  X.X  -   X.X   -          X.X     '
	DB	'     -XX   X.X         -         X.X   XX-    X..X..XXX    X.'
	DB	'..X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.'
	DB	'X        -        X.X      -    X..X..X..XX  X....X      -  X'
	DB	'.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -    '
	DB	'   X.X       -    X..X..X..X.X X.....X     -  X.X  -   X.X   '
	DB	'-  X..X    X.X    X..X  -        X.X      -      X.X        -'
	DB	'XXX X..X..X..X..XX......X    -  X.X  -   X.X   - X...XXXXXX.X'
	DB	'XXXXX...X -         X.X   XX-XX   X.X         -X..XX........X'
	DB	'..XX.......X   -  X.X  -   X.X   -X.....................X-   '
	DB	'       X.X X.X-X.X X.X          -X...X...........XX........X '
	DB	' -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X'
	DB	'-X..X.X           - X..............XX.........X -XXX.XXX-   X'
	DB	'.X   -  X..X    X.X    X..X  -            X...X-X...X        '
	DB	'    -  X.............XX..........X-X.....X-   X.X   -   X.X  '
	DB	'  X.X    X.X   -           X....X-X....X           -  X......'
	DB	'.......XX......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX   '
	DB	' -          X.....X-X.....X          -   X............XX...X.'
	DB	'.X    ---------   X.X   -          X.X          -          XX'
	DB	'XXXXX-XXXXXXX          -   X...........X X..X X..X   -       '
	DB	'-XXXX.XXXX-       XXXX.XXXX       ---------------------------'
	DB	'----------    X..........X X.X  X..X   -       -X.......X-   '
	DB	'    X.......X       -    XX           XX    -           -    '
	DB	'X..........X XX    X..X  -       - X.....X -        X.....X  '
	DB	'      -   X.X           X.X   -           -     X........X   '
	DB	'     X..X          -  X...X  -         X...X         -  X..X '
	DB	'          X..X  -           -     X........X         XX      '
	DB	'     -   X.X   -          X.X          - X...XXXXXXXXXXXXX...'
	DB	'X -           -     XXXXXXXXXX  ------------        -    X   '
	DB	' -           X           -X.....................X-           '
	DB	'------------------                    -----------------------'
	DB	'------------ X...XXXXXXXXXXXXX...X -                         '
	DB	'                                                          -  '
	DB	'X..X           X..X  -                                       '
	DB	'                                            -   X.X          '
	DB	' X.X   -                                                     '
	DB	'                              -    XX           XX    -      '
	DB	'                       ', 00H		; FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS
CONST	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_MarkAllocaS
PUBLIC	_MallocaComputeSize
PUBLIC	fabsf
PUBLIC	?round@@YAMM@Z					; round
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	??0ImVec2@@QEAA@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QEAA@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QEAA@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z	; ImGui::StyleColorsDark
PUBLIC	?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z ; ImGui::StyleColorsClassic
PUBLIC	?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z	; ImGui::StyleColorsLight
PUBLIC	??0?$ImVector@G@@QEAA@XZ			; ImVector<unsigned short>::ImVector<unsigned short>
PUBLIC	??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z		; ImVector<unsigned short>::operator=
PUBLIC	??1?$ImVector@G@@QEAA@XZ			; ImVector<unsigned short>::~ImVector<unsigned short>
PUBLIC	?empty@?$ImVector@G@@QEBA_NXZ			; ImVector<unsigned short>::empty
PUBLIC	??A?$ImVector@G@@QEAAAEAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?clear@?$ImVector@G@@QEAAXXZ			; ImVector<unsigned short>::clear
PUBLIC	?_grow_capacity@?$ImVector@G@@QEBAHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?resize@?$ImVector@G@@QEAAXHAEBG@Z		; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	?push_back@?$ImVector@G@@QEAAXAEBG@Z		; ImVector<unsigned short>::push_back
PUBLIC	??2@YAPEAX_KUImNewDummy@@PEAX@Z			; operator new
PUBLIC	??3@YAXPEAXUImNewDummy@@0@Z			; operator delete
PUBLIC	??0ImDrawCmd@@QEAA@XZ				; ImDrawCmd::ImDrawCmd
PUBLIC	??0?$ImVector@UImDrawCmd@@@@QEAA@XZ		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
PUBLIC	??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z	; ImVector<ImDrawCmd>::operator=
PUBLIC	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ		; ImVector<ImDrawCmd>::clear
PUBLIC	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
PUBLIC	?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z	; ImVector<ImDrawCmd>::resize
PUBLIC	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z	; ImVector<ImDrawCmd>::reserve
PUBLIC	?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
PUBLIC	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ	; ImVector<ImDrawCmd>::pop_back
PUBLIC	??0ImDrawChannel@@QEAA@XZ			; ImDrawChannel::ImDrawChannel
PUBLIC	??0?$ImVector@UImDrawVert@@@@QEAA@XZ		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
PUBLIC	??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z	; ImVector<ImDrawVert>::operator=
PUBLIC	??1?$ImVector@UImDrawVert@@@@QEAA@XZ		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
PUBLIC	??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ	; ImVector<ImDrawVert>::clear
PUBLIC	?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z	; ImVector<ImDrawVert>::swap
PUBLIC	?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ; ImVector<ImDrawVert>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z	; ImVector<ImDrawVert>::resize
PUBLIC	?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z	; ImVector<ImDrawVert>::reserve
PUBLIC	??0?$ImVector@UImDrawChannel@@@@QEAA@XZ		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
PUBLIC	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
PUBLIC	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ	; ImVector<ImDrawChannel>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z	; ImVector<ImDrawChannel>::resize
PUBLIC	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z	; ImVector<ImDrawChannel>::reserve
PUBLIC	??0?$ImVector@UImVec4@@@@QEAA@XZ		; ImVector<ImVec4>::ImVector<ImVec4>
PUBLIC	??1?$ImVector@UImVec4@@@@QEAA@XZ		; ImVector<ImVec4>::~ImVector<ImVec4>
PUBLIC	?clear@?$ImVector@UImVec4@@@@QEAAXXZ		; ImVector<ImVec4>::clear
PUBLIC	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ	; ImVector<ImVec4>::back
PUBLIC	?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z	; ImVector<ImVec4>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec4@@@@QEAAXH@Z		; ImVector<ImVec4>::resize
PUBLIC	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z		; ImVector<ImVec4>::reserve
PUBLIC	?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ; ImVector<ImVec4>::push_back
PUBLIC	?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ		; ImVector<ImVec4>::pop_back
PUBLIC	??0?$ImVector@PEAX@@QEAA@XZ			; ImVector<void *>::ImVector<void *>
PUBLIC	??1?$ImVector@PEAX@@QEAA@XZ			; ImVector<void *>::~ImVector<void *>
PUBLIC	?empty@?$ImVector@PEAX@@QEBA_NXZ		; ImVector<void *>::empty
PUBLIC	?clear@?$ImVector@PEAX@@QEAAXXZ			; ImVector<void *>::clear
PUBLIC	?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ		; ImVector<void *>::back
PUBLIC	?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z	; ImVector<void *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PEAX@@QEAAXH@Z		; ImVector<void *>::resize
PUBLIC	?reserve@?$ImVector@PEAX@@QEAAXH@Z		; ImVector<void *>::reserve
PUBLIC	?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z	; ImVector<void *>::push_back
PUBLIC	?pop_back@?$ImVector@PEAX@@QEAAXXZ		; ImVector<void *>::pop_back
PUBLIC	??0?$ImVector@UImVec2@@@@QEAA@XZ		; ImVector<ImVec2>::ImVector<ImVec2>
PUBLIC	??1?$ImVector@UImVec2@@@@QEAA@XZ		; ImVector<ImVec2>::~ImVector<ImVec2>
PUBLIC	?clear@?$ImVector@UImVec2@@@@QEAAXXZ		; ImVector<ImVec2>::clear
PUBLIC	?back@?$ImVector@UImVec2@@@@QEAAAEAUImVec2@@XZ	; ImVector<ImVec2>::back
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec2@@@@QEAAXH@Z		; ImVector<ImVec2>::resize
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ; ImDrawList::ImDrawList
PUBLIC	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z	; ImDrawList::PushClipRect
PUBLIC	?PushClipRectFullScreen@ImDrawList@@QEAAXXZ	; ImDrawList::PushClipRectFullScreen
PUBLIC	?PopClipRect@ImDrawList@@QEAAXXZ		; ImDrawList::PopClipRect
PUBLIC	?PushTextureID@ImDrawList@@QEAAXPEAX@Z		; ImDrawList::PushTextureID
PUBLIC	?PopTextureID@ImDrawList@@QEAAXXZ		; ImDrawList::PopTextureID
PUBLIC	?DrawBox_S@ImDrawList@@QEAAXAEBUImVec2@@0IMM@Z	; ImDrawList::DrawBox_S
PUBLIC	?DrawHealthBar@ImDrawList@@QEAAXAEBUImVec2@@0MM@Z ; ImDrawList::DrawHealthBar
PUBLIC	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z	; ImDrawList::AddLine
PUBLIC	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z	; ImDrawList::AddRect
PUBLIC	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
PUBLIC	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
PUBLIC	?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z	; ImDrawList::AddQuad
PUBLIC	?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::AddQuadFilled
PUBLIC	?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ; ImDrawList::AddTriangle
PUBLIC	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
PUBLIC	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z	; ImDrawList::AddCircle
PUBLIC	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
PUBLIC	?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z	; ImDrawList::AddText
PUBLIC	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
PUBLIC	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
PUBLIC	?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z ; ImDrawList::AddImageQuad
PUBLIC	?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z ; ImDrawList::AddImageRounded
PUBLIC	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline
PUBLIC	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
PUBLIC	?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z ; ImDrawList::AddBezierCurve
PUBLIC	?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ ; ImDrawList::DrawTextOutline
PUBLIC	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFillConvex@ImDrawList@@QEAAXI@Z		; ImDrawList::PathFillConvex
PUBLIC	?PathStroke@ImDrawList@@QEAAXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z	; ImDrawList::PathArcTo
PUBLIC	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
PUBLIC	?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ; ImDrawList::PathBezierCurveTo
PUBLIC	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z	; ImDrawList::PathRect
PUBLIC	?ChannelsSplit@ImDrawList@@QEAAXH@Z		; ImDrawList::ChannelsSplit
PUBLIC	?ChannelsMerge@ImDrawList@@QEAAXXZ		; ImDrawList::ChannelsMerge
PUBLIC	?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z	; ImDrawList::ChannelsSetCurrent
PUBLIC	?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z ; ImDrawList::AddCallback
PUBLIC	?AddDrawCmd@ImDrawList@@QEAAXXZ			; ImDrawList::AddDrawCmd
PUBLIC	?CloneOutput@ImDrawList@@QEBAPEAU1@XZ		; ImDrawList::CloneOutput
PUBLIC	?Clear@ImDrawList@@QEAAXXZ			; ImDrawList::Clear
PUBLIC	?ClearFreeMemory@ImDrawList@@QEAAXXZ		; ImDrawList::ClearFreeMemory
PUBLIC	?PrimReserve@ImDrawList@@QEAAXHH@Z		; ImDrawList::PrimReserve
PUBLIC	?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimRect
PUBLIC	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z	; ImDrawList::PrimRectUV
PUBLIC	?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z ; ImDrawList::PrimQuadUV
PUBLIC	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimWriteVtx
PUBLIC	?PrimWriteIdx@ImDrawList@@QEAAXG@Z		; ImDrawList::PrimWriteIdx
PUBLIC	?UpdateClipRect@ImDrawList@@QEAAXXZ		; ImDrawList::UpdateClipRect
PUBLIC	?UpdateTextureID@ImDrawList@@QEAAXXZ		; ImDrawList::UpdateTextureID
PUBLIC	?DeIndexAllBuffers@ImDrawData@@QEAAXXZ		; ImDrawData::DeIndexAllBuffers
PUBLIC	?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z	; ImDrawData::ScaleClipRects
PUBLIC	??0ImFontConfig@@QEAA@XZ			; ImFontConfig::ImFontConfig
PUBLIC	??1?$ImVector@H@@QEAA@XZ			; ImVector<int>::~ImVector<int>
PUBLIC	?empty@?$ImVector@H@@QEBA_NXZ			; ImVector<int>::empty
PUBLIC	??A?$ImVector@H@@QEAAAEAHH@Z			; ImVector<int>::operator[]
PUBLIC	??A?$ImVector@H@@QEBAAEBHH@Z			; ImVector<int>::operator[]
PUBLIC	?clear@?$ImVector@H@@QEAAXXZ			; ImVector<int>::clear
PUBLIC	?begin@?$ImVector@H@@QEBAPEBHXZ			; ImVector<int>::begin
PUBLIC	?end@?$ImVector@H@@QEBAPEBHXZ			; ImVector<int>::end
PUBLIC	?_grow_capacity@?$ImVector@H@@QEBAHH@Z		; ImVector<int>::_grow_capacity
PUBLIC	?resize@?$ImVector@H@@QEAAXH@Z			; ImVector<int>::resize
PUBLIC	?reserve@?$ImVector@H@@QEAAXH@Z			; ImVector<int>::reserve
PUBLIC	?push_back@?$ImVector@H@@QEAAXAEBH@Z		; ImVector<int>::push_back
PUBLIC	?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z	; ImFontGlyphRangesBuilder::GetBit
PUBLIC	?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z	; ImFontGlyphRangesBuilder::SetBit
PUBLIC	?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z	; ImFontGlyphRangesBuilder::AddChar
PUBLIC	?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z	; ImFontGlyphRangesBuilder::AddText
PUBLIC	?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z ; ImFontGlyphRangesBuilder::AddRanges
PUBLIC	?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z ; ImFontGlyphRangesBuilder::BuildRanges
PUBLIC	??0ImFontAtlas@@QEAA@XZ				; ImFontAtlas::ImFontAtlas
PUBLIC	??1ImFontAtlas@@QEAA@XZ				; ImFontAtlas::~ImFontAtlas
PUBLIC	?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont
PUBLIC	?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromFileTTF
PUBLIC	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
PUBLIC	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
PUBLIC	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
PUBLIC	?ClearInputData@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearInputData
PUBLIC	?ClearTexData@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearTexData
PUBLIC	?ClearFonts@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearFonts
PUBLIC	?Clear@ImFontAtlas@@QEAAXXZ			; ImFontAtlas::Clear
PUBLIC	?Build@ImFontAtlas@@QEAA_NXZ			; ImFontAtlas::Build
PUBLIC	?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8
PUBLIC	?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32
PUBLIC	?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesDefault
PUBLIC	?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesKorean
PUBLIC	?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesJapanese
PUBLIC	?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ ; ImFontAtlas::GetGlyphRangesChineseFull
PUBLIC	?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ ; ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon
PUBLIC	?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesCyrillic
PUBLIC	?GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesThai
PUBLIC	??0CustomRect@ImFontAtlas@@QEAA@XZ		; ImFontAtlas::CustomRect::CustomRect
PUBLIC	?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z	; ImFontAtlas::AddCustomRectRegular
PUBLIC	?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z ; ImFontAtlas::AddCustomRectFontGlyph
PUBLIC	?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z ; ImFontAtlas::CalcCustomRectUV
PUBLIC	?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ; ImFontAtlas::GetMouseCursorTexData
PUBLIC	??0?$ImVector@PEAUImFont@@@@QEAA@XZ		; ImVector<ImFont *>::ImVector<ImFont *>
PUBLIC	??1?$ImVector@PEAUImFont@@@@QEAA@XZ		; ImVector<ImFont *>::~ImVector<ImFont *>
PUBLIC	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
PUBLIC	?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ		; ImVector<ImFont *>::clear
PUBLIC	?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ ; ImVector<ImFont *>::back
PUBLIC	?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z ; ImVector<ImFont *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z	; ImVector<ImFont *>::reserve
PUBLIC	?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ; ImVector<ImFont *>::push_back
PUBLIC	??0?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ; ImVector<ImFontAtlas::CustomRect>::ImVector<ImFontAtlas::CustomRect>
PUBLIC	??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ; ImVector<ImFontAtlas::CustomRect>::~ImVector<ImFontAtlas::CustomRect>
PUBLIC	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
PUBLIC	?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ ; ImVector<ImFontAtlas::CustomRect>::clear
PUBLIC	?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z ; ImVector<ImFontAtlas::CustomRect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z ; ImVector<ImFontAtlas::CustomRect>::reserve
PUBLIC	?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z ; ImVector<ImFontAtlas::CustomRect>::push_back
PUBLIC	??0?$ImVector@UImFontConfig@@@@QEAA@XZ		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
PUBLIC	??1?$ImVector@UImFontConfig@@@@QEAA@XZ		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
PUBLIC	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
PUBLIC	?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ	; ImVector<ImFontConfig>::clear
PUBLIC	?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
PUBLIC	?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ; ImVector<ImFontConfig>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z	; ImVector<ImFontConfig>::reserve
PUBLIC	?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back
PUBLIC	??0?$ImVector@M@@QEAA@XZ			; ImVector<float>::ImVector<float>
PUBLIC	??1?$ImVector@M@@QEAA@XZ			; ImVector<float>::~ImVector<float>
PUBLIC	??A?$ImVector@M@@QEAAAEAMH@Z			; ImVector<float>::operator[]
PUBLIC	?clear@?$ImVector@M@@QEAAXXZ			; ImVector<float>::clear
PUBLIC	?_grow_capacity@?$ImVector@M@@QEBAHH@Z		; ImVector<float>::_grow_capacity
PUBLIC	?resize@?$ImVector@M@@QEAAXHAEBM@Z		; ImVector<float>::resize
PUBLIC	?reserve@?$ImVector@M@@QEAAXH@Z			; ImVector<float>::reserve
PUBLIC	??0?$ImVector@UImFontGlyph@@@@QEAA@XZ		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
PUBLIC	??1?$ImVector@UImFontGlyph@@@@QEAA@XZ		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
PUBLIC	??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
PUBLIC	?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ	; ImVector<ImFontGlyph>::clear
PUBLIC	?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
PUBLIC	?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ; ImVector<ImFontGlyph>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z	; ImVector<ImFontGlyph>::resize
PUBLIC	?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z	; ImVector<ImFontGlyph>::reserve
PUBLIC	??0ImFont@@QEAA@XZ				; ImFont::ImFont
PUBLIC	??1ImFont@@QEAA@XZ				; ImFont::~ImFont
PUBLIC	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z	; ImFont::FindGlyph
PUBLIC	?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
PUBLIC	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
PUBLIC	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
PUBLIC	?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z ; ImFont::RenderChar
PUBLIC	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
PUBLIC	?BuildLookupTable@ImFont@@QEAAXXZ		; ImFont::BuildLookupTable
PUBLIC	?ClearOutputData@ImFont@@QEAAXXZ		; ImFont::ClearOutputData
PUBLIC	?GrowIndex@ImFont@@QEAAXH@Z			; ImFont::GrowIndex
PUBLIC	?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z		; ImFont::AddGlyph
PUBLIC	?AddRemapChar@ImFont@@QEAAXGG_N@Z		; ImFont::AddRemapChar
PUBLIC	?SetFallbackChar@ImFont@@QEAAXG@Z		; ImFont::SetFallbackChar
PUBLIC	??_GImFont@@QEAAPEAXI@Z				; ImFont::`scalar deleting destructor'
PUBLIC	?Resize@ImBoolVector@@QEAAXH@Z			; ImBoolVector::Resize
PUBLIC	?Clear@ImBoolVector@@QEAAXXZ			; ImBoolVector::Clear
PUBLIC	?GetBit@ImBoolVector@@QEBA_NH@Z			; ImBoolVector::GetBit
PUBLIC	?SetBit@ImBoolVector@@QEAAXH_N@Z		; ImBoolVector::SetBit
PUBLIC	??1ImBoolVector@@QEAA@XZ			; ImBoolVector::~ImBoolVector
PUBLIC	??0ImDrawListSharedData@@QEAA@XZ		; ImDrawListSharedData::ImDrawListSharedData
PUBLIC	?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z ; ImGui::RenderMouseCursor
PUBLIC	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
PUBLIC	?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z ; ImGui::RenderRectFilledRangeH
PUBLIC	?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z ; ImGui::RenderPixelEllipsis
PUBLIC	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
PUBLIC	?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z ; ImGui::ShadeVertsLinearUV
PUBLIC	?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
PUBLIC	?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRegisterDefaultCustomRects
PUBLIC	?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ; ImFontAtlasBuildSetupFont
PUBLIC	?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ; ImFontAtlasBuildPackCustomRects
PUBLIC	?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z	; ImFontAtlasBuildFinish
PUBLIC	?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ; ImFontAtlasBuildMultiplyCalcLookupTable
PUBLIC	?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ; ImFontAtlasBuildMultiplyRectAlpha8
PUBLIC	??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z ; _vsnprintf_s<1024>
PUBLIC	??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z	; IM_DELETE<ImFont>
PUBLIC	??1ImFontBuildSrcData@@QEAA@XZ			; ImFontBuildSrcData::~ImFontBuildSrcData
PUBLIC	??_GImFontBuildSrcData@@QEAAPEAXI@Z		; ImFontBuildSrcData::`scalar deleting destructor'
PUBLIC	??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
PUBLIC	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ; ImVector<ImFontBuildSrcData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ; ImVector<ImFontBuildSrcData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::resize
PUBLIC	?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::reserve
PUBLIC	??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
PUBLIC	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ; ImVector<ImFontBuildDstData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
PUBLIC	?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ; ImVector<ImFontBuildDstData>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ; ImVector<ImFontBuildDstData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::resize
PUBLIC	?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::reserve
PUBLIC	??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
PUBLIC	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
PUBLIC	?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ; ImVector<stbrp_rect>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
PUBLIC	?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ	; ImVector<stbrp_rect>::clear
PUBLIC	?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ; ImVector<stbrp_rect>::_grow_capacity
PUBLIC	?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z	; ImVector<stbrp_rect>::resize
PUBLIC	?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z	; ImVector<stbrp_rect>::reserve
PUBLIC	??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ	; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
PUBLIC	??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ	; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
PUBLIC	?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ; ImVector<stbtt_packedchar>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ; ImVector<stbtt_packedchar>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ; ImVector<stbtt_packedchar>::_grow_capacity
PUBLIC	?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::resize
PUBLIC	?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::reserve
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_04LBBEMOBJ@typ1@				; `string'
PUBLIC	??_C@_04LLEFIKCJ@OTTO@				; `string'
PUBLIC	??_C@_04KIOEMAHO@ttcf@				; `string'
PUBLIC	??_C@_04EICJPCEA@cmap@				; `string'
PUBLIC	??_C@_04DACNFKGE@loca@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04LLIHEPK@glyf@				; `string'
PUBLIC	??_C@_04FMPHLIKP@hhea@				; `string'
PUBLIC	??_C@_04ONMNCIMC@hmtx@				; `string'
PUBLIC	??_C@_04HHMMLDJI@kern@				; `string'
PUBLIC	??_C@_04PCFDEHHD@GPOS@				; `string'
PUBLIC	??_C@_04HJGCPIEK@CFF?5@				; `string'
PUBLIC	??_C@_04KODIGLGG@maxp@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@		; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	__real@00000000
PUBLIC	__real@358637bd
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3d23d70a
PUBLIC	__real@3d75c28f
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3de147ae
PUBLIC	__real@3e0f5c29
PUBLIC	__real@3e23d70a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e75c28f
PUBLIC	__real@3e800000
PUBLIC	__real@3e851eb8
PUBLIC	__real@3e8a3d71
PUBLIC	__real@3e947ae1
PUBLIC	__real@3e99999a
PUBLIC	__real@3e9eb852
PUBLIC	__real@3ea3d70a
PUBLIC	__real@3eb33333
PUBLIC	__real@3ec7ae14
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ed1eb85
PUBLIC	__real@3ed70a3d
PUBLIC	__real@3edc28f6
PUBLIC	__real@3ee147ae
PUBLIC	__real@3ee66666
PUBLIC	__real@3eeb851f
PUBLIC	__real@3ef0a3d7
PUBLIC	__real@3ef5c28f
PUBLIC	__real@3efae148
PUBLIC	__real@3f000000
PUBLIC	__real@3f028f5c
PUBLIC	__real@3f051eb8
PUBLIC	__real@3f07ae14
PUBLIC	__real@3f0a3d71
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f0f5c29
PUBLIC	__real@3f170a3d
PUBLIC	__real@3f19999a
PUBLIC	__real@3f1c28f6
PUBLIC	__real@3f1eb852
PUBLIC	__real@3f2147ae
PUBLIC	__real@3f23d70a
PUBLIC	__real@3f2b851f
PUBLIC	__real@3f30a3d7
PUBLIC	__real@3f333333
PUBLIC	__real@3f35c28f
PUBLIC	__real@3f400000
PUBLIC	__real@3f47ae14
PUBLIC	__real@3f4a3d71
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f51eb85
PUBLIC	__real@3f547ae1
PUBLIC	__real@3f5c28f6
PUBLIC	__real@3f5eb852
PUBLIC	__real@3f6147ae
PUBLIC	__real@3f666666
PUBLIC	__real@3f6b851f
PUBLIC	__real@3f70a3d7
PUBLIC	__real@3f733333
PUBLIC	__real@3f75c28f
PUBLIC	__real@3f7ae148
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ffeb852
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41300000
PUBLIC	__real@41400000
PUBLIC	__real@41500000
PUBLIC	__real@41800000
PUBLIC	__real@41880000
PUBLIC	__real@41900000
PUBLIC	__real@41980000
PUBLIC	__real@41a80000
PUBLIC	__real@41b00000
PUBLIC	__real@41b80000
PUBLIC	__real@41f80000
PUBLIC	__real@425c0000
PUBLIC	__real@42920000
PUBLIC	__real@42b60000
PUBLIC	__real@42c80000
PUBLIC	__real@42da0000
PUBLIC	__real@437f0000
PUBLIC	__real@44333333
PUBLIC	__real@44b33333
PUBLIC	__real@45333333
PUBLIC	__real@46000000
PUBLIC	__real@46800000
PUBLIC	__real@47800000
PUBLIC	__real@7f7fffff
PUBLIC	__real@bf800000
PUBLIC	__real@c6000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__stdio_common_vsnprintf_s:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	malloc:PROC
EXTRN	fabs:PROC
EXTRN	acosf:PROC
EXTRN	ceilf:PROC
EXTRN	cosf:PROC
EXTRN	floorf:PROC
EXTRN	sinf:PROC
EXTRN	sqrtf:PROC
EXTRN	qsort:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z:PROC	; ImGui::GetColorU32
EXTRN	?GetColorU32@ImGui@@YAII@Z:PROC			; ImGui::GetColorU32
EXTRN	?GetOverlayDrawList@ImGui@@YAPEAUImDrawList@@XZ:PROC ; ImGui::GetOverlayDrawList
EXTRN	?MemAlloc@ImGui@@YAPEAX_K@Z:PROC		; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPEAX@Z:PROC			; ImGui::MemFree
EXTRN	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z:PROC	; ImTextCharFromUtf8
EXTRN	?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z:PROC	; ImFileLoadToMemory
EXTRN	?ImFormatString@@YAHPEAD_KPEBDZZ:PROC		; ImFormatString
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	roundf:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
	ALIGN	8

?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A DQ 018H DUP (?) ; FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA
_BSS	ENDS
;	COMDAT ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 01393H DUP (?) ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::full_ranges
_BSS	ENDS
;	COMDAT ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 0f3dH DUP (?) ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::full_ranges
_BSS	ENDS
_BSS	SEGMENT
?stb__barrier_out_e@@3PEAEEA DQ 01H DUP (?)		; stb__barrier_out_e
?stb__barrier_out_b@@3PEAEEA DQ 01H DUP (?)		; stb__barrier_out_b
?stb__barrier_in_b@@3PEBEEB DQ 01H DUP (?)		; stb__barrier_in_b
?stb__dout@@3PEAEEA DQ 01H DUP (?)			; stb__dout
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+126
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MallocaComputeSize DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$_MallocaComputeSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fabsf DD	imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fabsf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?round@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?round@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z DD imagerel $LN5
	DD	imagerel $LN5+3811
	DD	imagerel $unwind$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z
$pdata$?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z DD imagerel $LN5
	DD	imagerel $LN5+3796
	DD	imagerel $unwind$?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z
$pdata$?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z DD imagerel $LN5
	DD	imagerel $LN5+3801
	DD	imagerel $unwind$?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@G@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@G@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@G@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@G@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@G@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@G@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXHAEBG@Z DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXHAEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@G@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?reserve@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@G@@QEAAXAEBG@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@G@@QEAAXAEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawCmd@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+138
	DD	imagerel $unwind$??0ImDrawCmd@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawChannel@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$??0ImDrawChannel@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImDrawVert@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImVec4@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImVec4@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImVec4@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImVec4@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAX@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAX@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@PEAX@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@PEAX@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAX@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@PEAX@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImVec2@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImVec2@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImVec2@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImVec2@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DD imagerel $LN10
	DD	imagerel $LN10+188
	DD	imagerel $unwind$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD imagerel ?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DD	imagerel ?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z DD imagerel $LN8
	DD	imagerel $LN8+365
	DD	imagerel $unwind$?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z
$pdata$?PushClipRectFullScreen@ImDrawList@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$?PushClipRectFullScreen@ImDrawList@@QEAAXXZ
$pdata$?PopClipRect@ImDrawList@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?PopClipRect@ImDrawList@@QEAAXXZ
$pdata$?PushTextureID@ImDrawList@@QEAAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?PushTextureID@ImDrawList@@QEAAXPEAX@Z
$pdata$?PopTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?PopTextureID@ImDrawList@@QEAAXXZ
$pdata$?DrawBox_S@ImDrawList@@QEAAXAEBUImVec2@@0IMM@Z DD imagerel $LN3
	DD	imagerel $LN3+10230
	DD	imagerel $unwind$?DrawBox_S@ImDrawList@@QEAAXAEBUImVec2@@0IMM@Z
$pdata$?DrawHealthBar@ImDrawList@@QEAAXAEBUImVec2@@0MM@Z DD imagerel $LN28
	DD	imagerel $LN28+1750
	DD	imagerel $unwind$?DrawHealthBar@ImDrawList@@QEAAXAEBUImVec2@@0MM@Z
$pdata$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$pdata$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z DD imagerel $LN6
	DD	imagerel $LN6+418
	DD	imagerel $unwind$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z
$pdata$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN6
	DD	imagerel $LN6+157
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
$pdata$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD imagerel $LN4
	DD	imagerel $LN4+398
	DD	imagerel $unwind$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
$pdata$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD imagerel $LN4
	DD	imagerel $LN4+128
	DD	imagerel $unwind$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z
$pdata$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN4
	DD	imagerel $LN4+119
	DD	imagerel $unwind$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$pdata$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD imagerel $LN4
	DD	imagerel $LN4+113
	DD	imagerel $unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
$pdata$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
$pdata$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z DD imagerel $LN5
	DD	imagerel $LN5+178
	DD	imagerel $unwind$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z
$pdata$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z
$pdata$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$pdata$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD imagerel $LN11
	DD	imagerel $LN11+509
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
$pdata$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN8
	DD	imagerel $LN8+239
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
$pdata$?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z DD imagerel $LN8
	DD	imagerel $LN8+303
	DD	imagerel $unwind$?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z
$pdata$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD imagerel $LN10
	DD	imagerel $LN10+411
	DD	imagerel $unwind$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
$pdata$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z DD imagerel $LN57
	DD	imagerel $LN57+6723
	DD	imagerel $unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z
$pdata$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN25
	DD	imagerel $LN25+2068
	DD	imagerel $unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
$pdata$?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z DD imagerel $LN4
	DD	imagerel $LN4+116
	DD	imagerel $unwind$?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z
$pdata$?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ DD imagerel $LN14
	DD	imagerel $LN14+1347
	DD	imagerel $unwind$?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathFillConvex@ImDrawList@@QEAAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathStroke@ImDrawList@@QEAAXI_NM@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$?PathStroke@ImDrawList@@QEAAXI_NM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN7
	DD	imagerel $LN7+366
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD imagerel $LN9
	DD	imagerel $LN9+368
	DD	imagerel $unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
$pdata$?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z DD imagerel $LN8
	DD	imagerel $LN8+717
	DD	imagerel $unwind$?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z
$pdata$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN18
	DD	imagerel $LN18+1032
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$pdata$?ChannelsSplit@ImDrawList@@QEAAXH@Z DD imagerel $LN13
	DD	imagerel $LN13+655
	DD	imagerel $unwind$?ChannelsSplit@ImDrawList@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA DD imagerel ?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA
	DD	imagerel ?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA+35
	DD	imagerel $unwind$?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ChannelsMerge@ImDrawList@@QEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+749
	DD	imagerel $unwind$?ChannelsMerge@ImDrawList@@QEAAXXZ
$pdata$?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+282
	DD	imagerel $unwind$?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z
$pdata$?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+180
	DD	imagerel $unwind$?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z
$pdata$?AddDrawCmd@ImDrawList@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+248
	DD	imagerel $unwind$?AddDrawCmd@ImDrawList@@QEAAXXZ
$pdata$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ DD imagerel $LN6
	DD	imagerel $LN6+214
	DD	imagerel $unwind$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA DD imagerel ?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA
	DD	imagerel ?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA+35
	DD	imagerel $unwind$?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?Clear@ImDrawList@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+244
	DD	imagerel $unwind$?Clear@ImDrawList@@QEAAXXZ
$pdata$?ClearFreeMemory@ImDrawList@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+366
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawList@@QEAAXXZ
$pdata$?PrimReserve@ImDrawList@@QEAAXHH@Z DD imagerel $LN3
	DD	imagerel $LN3+222
	DD	imagerel $unwind$?PrimReserve@ImDrawList@@QEAAXHH@Z
$pdata$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD imagerel $LN3
	DD	imagerel $LN3+684
	DD	imagerel $unwind$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
$pdata$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN3
	DD	imagerel $LN3+752
	DD	imagerel $unwind$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$pdata$?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z DD imagerel $LN3
	DD	imagerel $LN3+620
	DD	imagerel $unwind$?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z
$pdata$?UpdateClipRect@ImDrawList@@QEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+529
	DD	imagerel $unwind$?UpdateClipRect@ImDrawList@@QEAAXXZ
$pdata$?UpdateTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+444
	DD	imagerel $unwind$?UpdateTextureID@ImDrawList@@QEAAXXZ
$pdata$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+415
	DD	imagerel $unwind$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA DD imagerel ?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z DD imagerel $LN9
	DD	imagerel $LN9+314
	DD	imagerel $unwind$?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z
$pdata$??0ImFontConfig@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$??0ImFontConfig@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@H@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@H@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@H@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@H@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@H@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@H@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@H@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@H@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@H@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@H@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@H@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@H@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@H@@QEAAXAEBH@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@H@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z DD imagerel $LN11
	DD	imagerel $LN11+184
	DD	imagerel $unwind$?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z
$pdata$?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z DD imagerel $LN9
	DD	imagerel $LN9+142
	DD	imagerel $unwind$?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z
$pdata$?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z DD imagerel $LN9
	DD	imagerel $LN9+197
	DD	imagerel $unwind$?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z
$pdata$??0ImFontAtlas@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+317
	DD	imagerel $unwind$??0ImFontAtlas@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA
$pdata$?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1ImFontAtlas@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$??1ImFontAtlas@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA
$pdata$?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN10
	DD	imagerel $LN10+390
	DD	imagerel $unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA DD imagerel ?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA
	DD	imagerel ?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA+35
	DD	imagerel $unwind$?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD imagerel $LN10
	DD	imagerel $LN10+467
	DD	imagerel $unwind$?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN6
	DD	imagerel $LN6+255
	DD	imagerel $unwind$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN5
	DD	imagerel $LN5+294
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD imagerel $LN3
	DD	imagerel $LN3+160
	DD	imagerel $unwind$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
$pdata$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+561
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
$pdata$?ClearTexData@ImFontAtlas@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$?ClearTexData@ImFontAtlas@@QEAAXXZ
$pdata$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+105
	DD	imagerel $unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ
$pdata$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?Clear@ImFontAtlas@@QEAAXXZ
$pdata$?Build@ImFontAtlas@@QEAA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?Build@ImFontAtlas@@QEAA_NXZ
$pdata$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN7
	DD	imagerel $LN7+134
	DD	imagerel $unwind$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN11
	DD	imagerel $LN11+362
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ
$pdata$?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CustomRect@ImFontAtlas@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??0CustomRect@ImFontAtlas@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z
$pdata$?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+152
	DD	imagerel $unwind$?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z
$pdata$?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z DD imagerel $LN3
	DD	imagerel $LN3+189
	DD	imagerel $unwind$?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z
$pdata$?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z DD imagerel $LN6
	DD	imagerel $LN6+636
	DD	imagerel $unwind$?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@PEAUImFont@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+149
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN4
	DD	imagerel $LN4+129
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@M@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@M@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@M@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@M@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@M@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@M@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@M@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@M@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0ImFont@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+269
	DD	imagerel $unwind$??0ImFont@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImFont@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImFont@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImFont@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ImFont@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???0ImFont@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImFont@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImFont@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImFont@@QEAA@XZ@4HA
$pdata$?dtor$2@?0???0ImFont@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0ImFont@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0ImFont@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0ImFont@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1ImFont@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$??1ImFont@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImFont@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImFont@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImFont@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ImFont@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???1ImFont@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImFont@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImFont@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1ImFont@@QEAA@XZ@4HA
$pdata$?dtor$2@?0???1ImFont@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1ImFont@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1ImFont@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???1ImFont@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z
$pdata$?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z
$pdata$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN35
	DD	imagerel $LN35+953
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
$pdata$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN26
	DD	imagerel $LN26+758
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$pdata$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z DD imagerel $LN8
	DD	imagerel $LN8+587
	DD	imagerel $unwind$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z
$pdata$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN50
	DD	imagerel $LN50+3493
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+970
	DD	imagerel $unwind$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$?ClearOutputData@ImFont@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+160
	DD	imagerel $unwind$?ClearOutputData@ImFont@@QEAAXXZ
$pdata$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
$pdata$?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z DD imagerel $LN4
	DD	imagerel $LN4+448
	DD	imagerel $unwind$?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z
$pdata$?AddRemapChar@ImFont@@QEAAXGG_N@Z DD imagerel $LN9
	DD	imagerel $LN9+312
	DD	imagerel $unwind$?AddRemapChar@ImFont@@QEAAXGG_N@Z
$pdata$?SetFallbackChar@ImFont@@QEAAXG@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?SetFallbackChar@ImFont@@QEAAXG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFont@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImFont@@QEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ImCharIsBlankA@@YA_ND@Z DD imagerel ?ImCharIsBlankA@@YA_ND@Z
	DD	imagerel ?ImCharIsBlankA@@YA_ND@Z+53
	DD	imagerel $unwind$?ImCharIsBlankA@@YA_ND@Z
$pdata$?ImCharIsBlankW@@YA_NI@Z DD imagerel ?ImCharIsBlankW@@YA_NI@Z
	DD	imagerel ?ImCharIsBlankW@@YA_NI@Z+57
	DD	imagerel $unwind$?ImCharIsBlankW@@YA_NI@Z
$pdata$??D@YA?AUImVec2@@AEBU0@M@Z DD imagerel ??D@YA?AUImVec2@@AEBU0@M@Z
	DD	imagerel ??D@YA?AUImVec2@@AEBU0@M@Z+74
	DD	imagerel $unwind$??D@YA?AUImVec2@@AEBU0@M@Z
$pdata$??H@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??H@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??H@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??H@YA?AUImVec2@@AEBU0@0@Z
$pdata$??G@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??G@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??G@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??G@YA?AUImVec2@@AEBU0@0@Z
$pdata$??D@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??D@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??D@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??D@YA?AUImVec2@@AEBU0@0@Z
$pdata$?ImFabs@@YAMM@Z DD imagerel ?ImFabs@@YAMM@Z
	DD	imagerel ?ImFabs@@YAMM@Z+26
	DD	imagerel $unwind$?ImFabs@@YAMM@Z
$pdata$?ImSqrt@@YAMM@Z DD imagerel ?ImSqrt@@YAMM@Z
	DD	imagerel ?ImSqrt@@YAMM@Z+26
	DD	imagerel $unwind$?ImSqrt@@YAMM@Z
$pdata$?ImCos@@YAMM@Z DD imagerel ?ImCos@@YAMM@Z
	DD	imagerel ?ImCos@@YAMM@Z+26
	DD	imagerel $unwind$?ImCos@@YAMM@Z
$pdata$?ImSin@@YAMM@Z DD imagerel ?ImSin@@YAMM@Z
	DD	imagerel ?ImSin@@YAMM@Z+26
	DD	imagerel $unwind$?ImSin@@YAMM@Z
$pdata$?ImAcos@@YAMM@Z DD imagerel ?ImAcos@@YAMM@Z
	DD	imagerel ?ImAcos@@YAMM@Z+26
	DD	imagerel $unwind$?ImAcos@@YAMM@Z
$pdata$?ImFloorStd@@YAMM@Z DD imagerel ?ImFloorStd@@YAMM@Z
	DD	imagerel ?ImFloorStd@@YAMM@Z+26
	DD	imagerel $unwind$?ImFloorStd@@YAMM@Z
$pdata$?ImCeil@@YAMM@Z DD imagerel ?ImCeil@@YAMM@Z
	DD	imagerel ?ImCeil@@YAMM@Z+26
	DD	imagerel $unwind$?ImCeil@@YAMM@Z
$pdata$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z+157
	DD	imagerel $unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z
$pdata$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z+157
	DD	imagerel $unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z
$pdata$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
	DD	imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z+247
	DD	imagerel $unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
$pdata$?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z DD imagerel ?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z
	DD	imagerel ?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z+238
	DD	imagerel $unwind$?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z
$pdata$??$ImMin@M@@YAMMM@Z DD imagerel ??$ImMin@M@@YAMMM@Z
	DD	imagerel ??$ImMin@M@@YAMMM@Z+63
	DD	imagerel $unwind$??$ImMin@M@@YAMMM@Z
$pdata$??$ImMax@M@@YAMMM@Z DD imagerel ??$ImMax@M@@YAMMM@Z
	DD	imagerel ??$ImMax@M@@YAMMM@Z+63
	DD	imagerel $unwind$??$ImMax@M@@YAMMM@Z
$pdata$?ImMul@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMul@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMul@@YA?AUImVec2@@AEBU1@0@Z+80
	DD	imagerel $unwind$?ImMul@@YA?AUImVec2@@AEBU1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Resize@ImBoolVector@@QEAAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?Resize@ImBoolVector@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImBoolVector@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?Clear@ImBoolVector@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBit@ImBoolVector@@QEBA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$?GetBit@ImBoolVector@@QEBA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetBit@ImBoolVector@@QEAAXH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+176
	DD	imagerel $unwind$?SetBit@ImBoolVector@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImBoolVector@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1ImBoolVector@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??0ImDrawListSharedData@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+363
	DD	imagerel $unwind$??0ImDrawListSharedData@@QEAA@XZ
$pdata$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z DD imagerel $LN5
	DD	imagerel $LN5+1293
	DD	imagerel $unwind$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z
$pdata$?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z DD imagerel $LN11
	DD	imagerel $LN11+731
	DD	imagerel $unwind$?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z
$pdata$?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z DD imagerel $LN15
	DD	imagerel $LN15+1962
	DD	imagerel $unwind$?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z
$pdata$?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z DD imagerel $LN6
	DD	imagerel $LN6+359
	DD	imagerel $unwind$?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z
$pdata$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD imagerel $LN6
	DD	imagerel $LN6+455
	DD	imagerel $unwind$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
$pdata$?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z DD imagerel $LN17
	DD	imagerel $LN17+691
	DD	imagerel $unwind$?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z
$pdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DD imagerel $LN94
	DD	imagerel $LN94+6183
	DD	imagerel $unwind$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
$pdata$?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
$pdata$?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
$pdata$?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD imagerel ?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DD	imagerel ?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN6
	DD	imagerel $LN6+144
	DD	imagerel $unwind$?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z
$pdata$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z DD imagerel $LN4
	DD	imagerel $LN4+154
	DD	imagerel $unwind$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z
$pdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DD imagerel $LN11
	DD	imagerel $LN11+507
	DD	imagerel $unwind$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA DD imagerel ?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN12
	DD	imagerel $LN12+527
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$pdata$?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z DD imagerel $LN8
	DD	imagerel $LN8+120
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z
$pdata$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN9
	DD	imagerel $LN9+178
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
$pdata$stbrp_pack_rects DD imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+644
	DD	imagerel $unwind$stbrp_pack_rects
$pdata$stbrp_init_target DD imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+406
	DD	imagerel $unwind$stbrp_init_target
$pdata$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+377
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
$pdata$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+867
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$pdata$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+538
	DD	imagerel $unwind$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$pdata$?rect_height_compare@@YAHPEBX0@Z DD imagerel ?rect_height_compare@@YAHPEBX0@Z
	DD	imagerel ?rect_height_compare@@YAHPEBX0@Z+178
	DD	imagerel $unwind$?rect_height_compare@@YAHPEBX0@Z
$pdata$?rect_original_order@@YAHPEBX0@Z DD imagerel ?rect_original_order@@YAHPEBX0@Z
	DD	imagerel ?rect_original_order@@YAHPEBX0@Z+112
	DD	imagerel $unwind$?rect_original_order@@YAHPEBX0@Z
$pdata$stbtt_PackBegin DD imagerel stbtt_PackBegin
	DD	imagerel stbtt_PackBegin+421
	DD	imagerel $unwind$stbtt_PackBegin
$pdata$stbtt_PackEnd DD imagerel stbtt_PackEnd
	DD	imagerel stbtt_PackEnd+43
	DD	imagerel $unwind$stbtt_PackEnd
$pdata$stbtt_GetPackedQuad DD imagerel stbtt_GetPackedQuad
	DD	imagerel stbtt_GetPackedQuad+612
	DD	imagerel $unwind$stbtt_GetPackedQuad
$pdata$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+1948
	DD	imagerel $unwind$stbtt_PackFontRangesRenderIntoRects
$pdata$stbtt_GetFontOffsetForIndex DD imagerel stbtt_GetFontOffsetForIndex
	DD	imagerel stbtt_GetFontOffsetForIndex+32
	DD	imagerel $unwind$stbtt_GetFontOffsetForIndex
$pdata$stbtt_InitFont DD imagerel stbtt_InitFont
	DD	imagerel stbtt_InitFont+44
	DD	imagerel $unwind$stbtt_InitFont
$pdata$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+1417
	DD	imagerel $unwind$stbtt_FindGlyphIndex
$pdata$stbtt_ScaleForPixelHeight DD imagerel stbtt_ScaleForPixelHeight
	DD	imagerel stbtt_ScaleForPixelHeight+116
	DD	imagerel $unwind$stbtt_ScaleForPixelHeight
$pdata$stbtt_ScaleForMappingEmToPixels DD imagerel stbtt_ScaleForMappingEmToPixels
	DD	imagerel stbtt_ScaleForMappingEmToPixels+77
	DD	imagerel $unwind$stbtt_ScaleForMappingEmToPixels
$pdata$stbtt_GetFontVMetrics DD imagerel stbtt_GetFontVMetrics
	DD	imagerel stbtt_GetFontVMetrics+170
	DD	imagerel $unwind$stbtt_GetFontVMetrics
$pdata$stbtt_GetGlyphHMetrics DD imagerel stbtt_GetGlyphHMetrics
	DD	imagerel stbtt_GetGlyphHMetrics+357
	DD	imagerel $unwind$stbtt_GetGlyphHMetrics
$pdata$stbtt_GetGlyphBox DD imagerel stbtt_GetGlyphBox
	DD	imagerel stbtt_GetGlyphBox+298
	DD	imagerel $unwind$stbtt_GetGlyphBox
$pdata$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+76
	DD	imagerel $unwind$stbtt_GetGlyphShape
$pdata$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+384
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixel
$pdata$stbtt_GetGlyphBitmapBox DD imagerel stbtt_GetGlyphBitmapBox
	DD	imagerel stbtt_GetGlyphBitmapBox+127
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBox
$pdata$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+399
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
$pdata$stbtt_Rasterize DD imagerel stbtt_Rasterize
	DD	imagerel stbtt_Rasterize+354
	DD	imagerel $unwind$stbtt_Rasterize
$pdata$?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z DD imagerel ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z+82
	DD	imagerel $unwind$?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z
$pdata$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z+70
	DD	imagerel $unwind$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
$pdata$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z+43
	DD	imagerel $unwind$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
$pdata$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z+98
	DD	imagerel $unwind$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
$pdata$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z DD imagerel ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
	DD	imagerel ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z+77
	DD	imagerel $unwind$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
$pdata$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z DD imagerel ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
	DD	imagerel ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z+192
	DD	imagerel $unwind$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
$pdata$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+208
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+252
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
$pdata$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+130
	DD	imagerel $unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$pdata$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
	DD	imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z+370
	DD	imagerel $unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
$pdata$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
	DD	imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z+141
	DD	imagerel $unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
$pdata$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z+41
	DD	imagerel $unwind$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
$pdata$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z+231
	DD	imagerel $unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
$pdata$?stbtt__find_table@@YAIPEAEIPEBD@Z DD imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z
	DD	imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z+349
	DD	imagerel $unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z
$pdata$?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z DD imagerel ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z
	DD	imagerel ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z+366
	DD	imagerel $unwind$?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z
$pdata$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
	DD	imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z+488
	DD	imagerel $unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
$pdata$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
	DD	imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z+2232
	DD	imagerel $unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
$pdata$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z+354
	DD	imagerel $unwind$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
$pdata$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
	DD	imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z+387
	DD	imagerel $unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
$pdata$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+420
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$pdata$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+5047
	DD	imagerel $unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
$pdata$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+252
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$pdata$?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z DD imagerel ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z
	DD	imagerel ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z+131
	DD	imagerel $unwind$?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z
$pdata$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
	DD	imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z+215
	DD	imagerel $unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
$pdata$?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z DD imagerel ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z
	DD	imagerel ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z+149
	DD	imagerel $unwind$?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z
$pdata$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
	DD	imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z+245
	DD	imagerel $unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
$pdata$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z+303
	DD	imagerel $unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
$pdata$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z+559
	DD	imagerel $unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
$pdata$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
	DD	imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z+5184
	DD	imagerel $unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
$pdata$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+365
	DD	imagerel $unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
$pdata$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
	DD	imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z+299
	DD	imagerel $unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
$pdata$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+75
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$pdata$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
	DD	imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z+404
	DD	imagerel $unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
$pdata$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+3564
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$pdata$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1183
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+340
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+1114
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z+47
	DD	imagerel $unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+1003
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+638
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$pdata$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1322
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$pdata$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+1481
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$pdata$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+1046
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$pdata$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+1160
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$pdata$?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z DD imagerel ?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z
	DD	imagerel ?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z+1155
	DD	imagerel $unwind$?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImClamp@M@@YAMMMM@Z DD imagerel ??$ImClamp@M@@YAMMMM@Z
	DD	imagerel ??$ImClamp@M@@YAMMMM@Z+108
	DD	imagerel $unwind$??$ImClamp@M@@YAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ DD imagerel ??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ
	DD	imagerel ??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ+632
	DD	imagerel $unwind$??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?stb_decompress@@YAIPEAEPEBEI@Z DD imagerel ?stb_decompress@@YAIPEAEPEBEI@Z
	DD	imagerel ?stb_decompress@@YAIPEAEPEBEI@Z+603
	DD	imagerel $unwind$?stb_decompress@@YAIPEAEPEBEI@Z
$pdata$?Decode85Byte@@YAID@Z DD imagerel ?Decode85Byte@@YAID@Z
	DD	imagerel ?Decode85Byte@@YAID@Z+50
	DD	imagerel $unwind$?Decode85Byte@@YAID@Z
$pdata$?Decode85@@YAXPEBEPEAE@Z DD imagerel ?Decode85@@YAXPEBEPEAE@Z
	DD	imagerel ?Decode85@@YAXPEBEPEAE@Z+360
	DD	imagerel $unwind$?Decode85@@YAXPEBEPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImFontBuildSrcData@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$??1ImFontBuildSrcData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GImFontBuildSrcData@@QEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z+231
	DD	imagerel $unwind$?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+149
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMax@H@@YAHHH@Z DD imagerel ??$ImMax@H@@YAHHH@Z
	DD	imagerel ??$ImMax@H@@YAHHH@Z+46
	DD	imagerel $unwind$??$ImMax@H@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z+560
	DD	imagerel $unwind$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
$pdata$?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z DD imagerel ?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z
	DD	imagerel ?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z+184
	DD	imagerel $unwind$?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z
$pdata$?ImAcos01@@YAMM@Z DD imagerel ?ImAcos01@@YAMM@Z
	DD	imagerel ?ImAcos01@@YAMM@Z+66
	DD	imagerel $unwind$?ImAcos01@@YAMM@Z
$pdata$??$ImSwap@M@@YAXAEAM0@Z DD imagerel ??$ImSwap@M@@YAXAEAM0@Z
	DD	imagerel ??$ImSwap@M@@YAXAEAM0@Z+65
	DD	imagerel $unwind$??$ImSwap@M@@YAXAEAM0@Z
$pdata$?stb__match@@YAXPEBEI@Z DD imagerel ?stb__match@@YAXPEBEI@Z
	DD	imagerel ?stb__match@@YAXPEBEI@Z+184
	DD	imagerel $unwind$?stb__match@@YAXPEBEI@Z
$pdata$?stb__lit@@YAXPEBEI@Z DD imagerel ?stb__lit@@YAXPEBEI@Z
	DD	imagerel ?stb__lit@@YAXPEBEI@Z+151
	DD	imagerel $unwind$?stb__lit@@YAXPEBEI@Z
$pdata$?stb_decompress_token@@YAPEBEPEBE@Z DD imagerel ?stb_decompress_token@@YAPEBEPEBE@Z
	DD	imagerel ?stb_decompress_token@@YAPEBEPEBE@Z+1260
	DD	imagerel $unwind$?stb_decompress_token@@YAPEBEPEBE@Z
$pdata$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+638
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c6000000
CONST	SEGMENT
__real@c6000000 DD 0c6000000r			; -8192
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@46800000
CONST	SEGMENT
__real@46800000 DD 046800000r			; 16384
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@45333333
CONST	SEGMENT
__real@45333333 DD 045333333r			; 2867.2
CONST	ENDS
;	COMDAT __real@44b33333
CONST	SEGMENT
__real@44b33333 DD 044b33333r			; 1433.6
CONST	ENDS
;	COMDAT __real@44333333
CONST	SEGMENT
__real@44333333 DD 044333333r			; 716.8
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42da0000
CONST	SEGMENT
__real@42da0000 DD 042da0000r			; 109
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b60000
CONST	SEGMENT
__real@42b60000 DD 042b60000r			; 91
CONST	ENDS
;	COMDAT __real@42920000
CONST	SEGMENT
__real@42920000 DD 042920000r			; 73
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@41f80000
CONST	SEGMENT
__real@41f80000 DD 041f80000r			; 31
CONST	ENDS
;	COMDAT __real@41b80000
CONST	SEGMENT
__real@41b80000 DD 041b80000r			; 23
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@41a80000
CONST	SEGMENT
__real@41a80000 DD 041a80000r			; 21
CONST	ENDS
;	COMDAT __real@41980000
CONST	SEGMENT
__real@41980000 DD 041980000r			; 19
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ffeb852
CONST	SEGMENT
__real@3ffeb852 DD 03ffeb852r			; 1.99
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ae148
CONST	SEGMENT
__real@3f7ae148 DD 03f7ae148r			; 0.98
CONST	ENDS
;	COMDAT __real@3f75c28f
CONST	SEGMENT
__real@3f75c28f DD 03f75c28fr			; 0.96
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f70a3d7
CONST	SEGMENT
__real@3f70a3d7 DD 03f70a3d7r			; 0.94
CONST	ENDS
;	COMDAT __real@3f6b851f
CONST	SEGMENT
__real@3f6b851f DD 03f6b851fr			; 0.92
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f6147ae
CONST	SEGMENT
__real@3f6147ae DD 03f6147aer			; 0.88
CONST	ENDS
;	COMDAT __real@3f5eb852
CONST	SEGMENT
__real@3f5eb852 DD 03f5eb852r			; 0.87
CONST	ENDS
;	COMDAT __real@3f5c28f6
CONST	SEGMENT
__real@3f5c28f6 DD 03f5c28f6r			; 0.86
CONST	ENDS
;	COMDAT __real@3f547ae1
CONST	SEGMENT
__real@3f547ae1 DD 03f547ae1r			; 0.83
CONST	ENDS
;	COMDAT __real@3f51eb85
CONST	SEGMENT
__real@3f51eb85 DD 03f51eb85r			; 0.82
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f4a3d71
CONST	SEGMENT
__real@3f4a3d71 DD 03f4a3d71r			; 0.79
CONST	ENDS
;	COMDAT __real@3f47ae14
CONST	SEGMENT
__real@3f47ae14 DD 03f47ae14r			; 0.78
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f35c28f
CONST	SEGMENT
__real@3f35c28f DD 03f35c28fr			; 0.71
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f30a3d7
CONST	SEGMENT
__real@3f30a3d7 DD 03f30a3d7r			; 0.69
CONST	ENDS
;	COMDAT __real@3f2b851f
CONST	SEGMENT
__real@3f2b851f DD 03f2b851fr			; 0.67
CONST	ENDS
;	COMDAT __real@3f23d70a
CONST	SEGMENT
__real@3f23d70a DD 03f23d70ar			; 0.64
CONST	ENDS
;	COMDAT __real@3f2147ae
CONST	SEGMENT
__real@3f2147ae DD 03f2147aer			; 0.63
CONST	ENDS
;	COMDAT __real@3f1eb852
CONST	SEGMENT
__real@3f1eb852 DD 03f1eb852r			; 0.62
CONST	ENDS
;	COMDAT __real@3f1c28f6
CONST	SEGMENT
__real@3f1c28f6 DD 03f1c28f6r			; 0.61
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f170a3d
CONST	SEGMENT
__real@3f170a3d DD 03f170a3dr			; 0.59
CONST	ENDS
;	COMDAT __real@3f0f5c29
CONST	SEGMENT
__real@3f0f5c29 DD 03f0f5c29r			; 0.56
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f0a3d71
CONST	SEGMENT
__real@3f0a3d71 DD 03f0a3d71r			; 0.54
CONST	ENDS
;	COMDAT __real@3f07ae14
CONST	SEGMENT
__real@3f07ae14 DD 03f07ae14r			; 0.53
CONST	ENDS
;	COMDAT __real@3f051eb8
CONST	SEGMENT
__real@3f051eb8 DD 03f051eb8r			; 0.52
CONST	ENDS
;	COMDAT __real@3f028f5c
CONST	SEGMENT
__real@3f028f5c DD 03f028f5cr			; 0.51
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3efae148
CONST	SEGMENT
__real@3efae148 DD 03efae148r			; 0.49
CONST	ENDS
;	COMDAT __real@3ef5c28f
CONST	SEGMENT
__real@3ef5c28f DD 03ef5c28fr			; 0.48
CONST	ENDS
;	COMDAT __real@3ef0a3d7
CONST	SEGMENT
__real@3ef0a3d7 DD 03ef0a3d7r			; 0.47
CONST	ENDS
;	COMDAT __real@3eeb851f
CONST	SEGMENT
__real@3eeb851f DD 03eeb851fr			; 0.46
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3ee147ae
CONST	SEGMENT
__real@3ee147ae DD 03ee147aer			; 0.44
CONST	ENDS
;	COMDAT __real@3edc28f6
CONST	SEGMENT
__real@3edc28f6 DD 03edc28f6r			; 0.43
CONST	ENDS
;	COMDAT __real@3ed70a3d
CONST	SEGMENT
__real@3ed70a3d DD 03ed70a3dr			; 0.42
CONST	ENDS
;	COMDAT __real@3ed1eb85
CONST	SEGMENT
__real@3ed1eb85 DD 03ed1eb85r			; 0.41
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3ec7ae14
CONST	SEGMENT
__real@3ec7ae14 DD 03ec7ae14r			; 0.39
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3ea3d70a
CONST	SEGMENT
__real@3ea3d70a DD 03ea3d70ar			; 0.32
CONST	ENDS
;	COMDAT __real@3e9eb852
CONST	SEGMENT
__real@3e9eb852 DD 03e9eb852r			; 0.31
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e947ae1
CONST	SEGMENT
__real@3e947ae1 DD 03e947ae1r			; 0.29
CONST	ENDS
;	COMDAT __real@3e8a3d71
CONST	SEGMENT
__real@3e8a3d71 DD 03e8a3d71r			; 0.27
CONST	ENDS
;	COMDAT __real@3e851eb8
CONST	SEGMENT
__real@3e851eb8 DD 03e851eb8r			; 0.26
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e75c28f
CONST	SEGMENT
__real@3e75c28f DD 03e75c28fr			; 0.24
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e23d70a
CONST	SEGMENT
__real@3e23d70a DD 03e23d70ar			; 0.16
CONST	ENDS
;	COMDAT __real@3e0f5c29
CONST	SEGMENT
__real@3e0f5c29 DD 03e0f5c29r			; 0.14
CONST	ENDS
;	COMDAT __real@3de147ae
CONST	SEGMENT
__real@3de147ae DD 03de147aer			; 0.11
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3d75c28f
CONST	SEGMENT
__real@3d75c28f DD 03d75c28fr			; 0.06
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-06
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesThai'::`2'::ranges
	DW	0ffH
	DW	02010H
	DW	0205eH
	DW	0e00H
	DW	0e7fH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesCyrillic'::`2'::ranges
	DW	0ffH
	DW	0400H
	DW	052fH
	DW	02de0H
	DW	02dffH
	DW	0a640H
	DW	0a69fH
	DW	00H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::base_ranges
	DW	0ffH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
_DATA	ENDS
;	COMDAT ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB
CONST	SEGMENT
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	02H
	DW	01H
	DW	08H
	DW	05H
	DW	07H
	DW	0bH
	DW	01H
	DW	02H
	DW	0aH
	DW	0aH
	DW	08H
	DW	02H
	DW	04H
	DW	014H
	DW	02H
	DW	0bH
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	07H
	DW	05H
	DW	03H
	DW	07H
	DW	01H
	DW	01H
	DW	0dH
	DW	07H
	DW	09H
	DW	01H
	DW	04H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	09H
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	06H
	DW	0eH
	DW	01H
	DW	01H
	DW	09H
	DW	03H
	DW	012H
	DW	05H
	DW	04H
	DW	02H
	DW	02H
	DW	0aH
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	03H
	DW	017H
	DW	02H
	DW	0aH
	DW	0cH
	DW	02H
	DW	0eH
	DW	02H
	DW	04H
	DW	0dH
	DW	01H
	DW	06H
	DW	0aH
	DW	03H
	DW	01H
	DW	07H
	DW	0dH
	DW	06H
	DW	04H
	DW	0dH
	DW	05H
	DW	02H
	DW	03H
	DW	011H
	DW	02H
	DW	02H
	DW	05H
	DW	07H
	DW	06H
	DW	04H
	DW	01H
	DW	07H
	DW	0eH
	DW	010H
	DW	06H
	DW	0dH
	DW	09H
	DW	0fH
	DW	01H
	DW	01H
	DW	07H
	DW	010H
	DW	04H
	DW	07H
	DW	01H
	DW	013H
	DW	09H
	DW	02H
	DW	07H
	DW	0fH
	DW	02H
	DW	06H
	DW	05H
	DW	0dH
	DW	019H
	DW	04H
	DW	0eH
	DW	0dH
	DW	0bH
	DW	019H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	0aH
	DW	0bH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	09H
	DW	01H
	DW	04H
	DW	03H
	DW	05H
	DW	05H
	DW	02H
	DW	07H
	DW	0cH
	DW	0bH
	DW	0fH
	DW	07H
	DW	010H
	DW	04H
	DW	05H
	DW	010H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	06H
	DW	06H
	DW	07H
	DW	01H
	DW	04H
	DW	07H
	DW	06H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0cH
	DW	03H
	DW	03H
	DW	09H
	DW	05H
	DW	08H
	DW	01H
	DW	0bH
	DW	01H
	DW	02H
	DW	03H
	DW	012H
	DW	014H
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	07H
	DW	03H
	DW	05H
	DW	05H
	DW	07H
	DW	02H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	0bH
	DW	08H
	DW	07H
	DW	04H
	DW	011H
	DW	01H
	DW	09H
	DW	019H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	06H
	DW	010H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	0cH
	DW	014H
	DW	02H
	DW	05H
	DW	014H
	DW	08H
	DW	07H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	0cH
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	07H
	DW	05H
	DW	0dH
	DW	01H
	DW	0fH
	DW	01H
	DW	01H
	DW	01eH
	DW	0bH
	DW	09H
	DW	01H
	DW	0fH
	DW	026H
	DW	0eH
	DW	01H
	DW	020H
	DW	011H
	DW	014H
	DW	01H
	DW	09H
	DW	01fH
	DW	02H
	DW	015H
	DW	09H
	DW	04H
	DW	031H
	DW	016H
	DW	02H
	DW	01H
	DW	0dH
	DW	01H
	DW	0bH
	DW	02dH
	DW	023H
	DW	02bH
	DW	037H
	DW	0cH
	DW	013H
	DW	053H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	0dH
	DW	02H
	DW	01H
	DW	07H
	DW	03H
	DW	012H
	DW	03H
	DW	0dH
	DW	08H
	DW	01H
	DW	08H
	DW	012H
	DW	05H
	DW	03H
	DW	07H
	DW	019H
	DW	018H
	DW	09H
	DW	018H
	DW	028H
	DW	03H
	DW	011H
	DW	018H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	010H
	DW	0fH
	DW	06H
	DW	07H
	DW	03H
	DW	0cH
	DW	01H
	DW	09H
	DW	07H
	DW	03H
	DW	03H
	DW	03H
	DW	0fH
	DW	015H
	DW	05H
	DW	010H
	DW	04H
	DW	05H
	DW	0cH
	DW	0bH
	DW	0bH
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	01fH
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	017H
	DW	06H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	06H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	016H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	011H
	DW	03H
	DW	02H
	DW	04H
	DW	05H
	DW	01H
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	0fH
	DW	0cH
	DW	03H
	DW	011H
	DW	02H
	DW	0eH
	DW	02H
	DW	08H
	DW	01H
	DW	017H
	DW	010H
	DW	04H
	DW	02H
	DW	017H
	DW	08H
	DW	0fH
	DW	017H
	DW	014H
	DW	0cH
	DW	019H
	DW	013H
	DW	02fH
	DW	0bH
	DW	015H
	DW	041H
	DW	02eH
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	06H
	DW	01H
	DW	02H
	DW	05H
	DW	01aH
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	0bH
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	0aH
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	02H
	DW	06H
	DW	06H
	DW	09H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	05H
	DW	0aH
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	09H
	DW	017H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	02H
	DW	01H
	DW	0aH
	DW	09H
	DW	06H
	DW	01H
	DW	0aH
	DW	02H
	DW	01fH
	DW	019H
	DW	03H
	DW	07H
	DW	05H
	DW	028H
	DW	01H
	DW	0fH
	DW	06H
	DW	011H
	DW	07H
	DW	01bH
	DW	0b4H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	0aH
	DW	07H
	DW	01H
	DW	03H
	DW	06H
	DW	011H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	05H
	DW	08H
	DW	010H
	DW	0eH
	DW	0fH
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	07H
	DW	05H
	DW	06H
	DW	02H
	DW	05H
	DW	0aH
	DW	01H
	DW	04H
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	0bH
	DW	06H
	DW	01H
	DW	02cH
	DW	01H
	DW	03H
	DW	07H
	DW	09H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0aH
	DW	07H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	015H
	DW	0fH
	DW	07H
	DW	02H
	DW	05H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	0aH
	DW	08H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	05H
	DW	0aH
	DW	02H
	DW	07H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0bH
	DW	0aH
	DW	01dH
	DW	04H
	DW	07H
	DW	03H
	DW	05H
	DW	02H
	DW	03H
	DW	021H
	DW	05H
	DW	02H
	DW	013H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	06H
	DW	01fH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	08H
	DW	0aH
	DW	09H
	DW	0cH
	DW	0bH
	DW	0cH
	DW	08H
	DW	03H
	DW	0eH
	DW	08H
	DW	06H
	DW	0bH
	DW	01H
	DW	04H
	DW	029H
	DW	03H
	DW	01H
	DW	02H
	DW	07H
	DW	0dH
	DW	01H
	DW	05H
	DW	06H
	DW	02H
	DW	06H
	DW	0cH
	DW	0cH
	DW	016H
	DW	05H
	DW	09H
	DW	04H
	DW	08H
	DW	09H
	DW	09H
	DW	022H
	DW	06H
	DW	018H
	DW	01H
	DW	01H
	DW	014H
	DW	09H
	DW	09H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	01cH
	DW	05H
	DW	03H
	DW	06H
	DW	01H
	DW	04H
	DW	06H
	DW	07H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	0dH
	DW	06H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	08H
	DW	08H
	DW	03H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	0bH
	DW	0bH
	DW	07H
	DW	03H
	DW	06H
	DW	0aH
	DW	08H
	DW	06H
	DW	010H
	DW	010H
	DW	016H
	DW	07H
	DW	0cH
	DW	06H
	DW	015H
	DW	05H
	DW	04H
	DW	06H
	DW	06H
	DW	03H
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01dH
	DW	01H
	DW	0aH
	DW	01H
	DW	06H
	DW	0dH
	DW	06H
	DW	06H
	DW	013H
	DW	01fH
	DW	01H
	DW	0dH
	DW	04H
	DW	04H
	DW	016H
	DW	011H
	DW	01aH
	DW	021H
	DW	0aH
	DW	04H
	DW	0fH
	DW	0cH
	DW	019H
	DW	06H
	DW	043H
	DW	0aH
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	0aH
	DW	02H
	DW	06H
	DW	02H
	DW	09H
	DW	01H
	DW	09H
	DW	04H
	DW	04H
	DW	01H
	DW	02H
	DW	010H
	DW	02H
	DW	05H
	DW	09H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	08H
	DW	03H
	DW	09H
	DW	04H
	DW	08H
	DW	06H
	DW	04H
	DW	08H
	DW	0bH
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01aH
	DW	01H
	DW	07H
	DW	05H
	DW	01H
	DW	0bH
	DW	01H
	DW	05H
	DW	03H
	DW	05H
	DW	02H
	DW	0dH
	DW	06H
	DW	027H
	DW	05H
	DW	01H
	DW	05H
	DW	02H
	DW	0bH
	DW	06H
	DW	0aH
	DW	05H
	DW	01H
	DW	0fH
	DW	05H
	DW	03H
	DW	06H
	DW	013H
	DW	015H
	DW	016H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	01H
	DW	08H
	DW	01H
	DW	04H
	DW	08H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	03H
	DW	0cH
	DW	07H
	DW	01H
	DW	0eH
	DW	02H
	DW	04H
	DW	0aH
	DW	02H
	DW	0dH
	DW	01H
	DW	011H
	DW	07H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	0dH
	DW	07H
	DW	0eH
	DW	0cH
	DW	03H
	DW	01H
	DW	01dH
	DW	02H
	DW	08H
	DW	09H
	DW	0fH
	DW	0eH
	DW	09H
	DW	0eH
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	05H
	DW	09H
	DW	0bH
	DW	03H
	DW	026H
	DW	02bH
	DW	014H
	DW	07H
	DW	07H
	DW	08H
	DW	05H
	DW	0fH
	DW	0cH
	DW	013H
	DW	0fH
	DW	051H
	DW	08H
	DW	07H
	DW	01H
	DW	05H
	DW	049H
	DW	0dH
	DW	025H
	DW	01cH
	DW	08H
	DW	08H
	DW	01H
	DW	0fH
	DW	012H
	DW	014H
	DW	0a5H
	DW	01cH
	DW	01H
	DW	06H
	DW	0bH
	DW	08H
	DW	04H
	DW	0eH
	DW	07H
	DW	0fH
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	07H
	DW	0eH
	DW	01H
	DW	01H
	DW	0bH
	DW	01eH
	DW	01H
	DW	05H
	DW	01H
	DW	04H
	DW	0eH
	DW	01H
	DW	04H
	DW	02H
	DW	07H
	DW	034H
	DW	02H
	DW	06H
	DW	01dH
	DW	03H
	DW	01H
	DW	09H
	DW	01H
	DW	015H
	DW	03H
	DW	05H
	DW	01H
	DW	01aH
	DW	03H
	DW	0bH
	DW	0eH
	DW	0bH
	DW	01H
	DW	011H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	08H
	DW	01H
	DW	02H
	DW	09H
	DW	0cH
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	08H
	DW	03H
	DW	018H
	DW	0cH
	DW	07H
	DW	07H
	DW	05H
	DW	011H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	017H
	DW	0aH
	DW	04H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	010H
	DW	011H
	DW	016H
	DW	03H
	DW	0aH
	DW	015H
	DW	010H
	DW	010H
	DW	06H
	DW	04H
	DW	0aH
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	08H
	DW	08H
	DW	06H
	DW	05H
	DW	03H
	DW	03H
	DW	03H
	DW	027H
	DW	019H
	DW	0fH
	DW	01H
	DW	01H
	DW	010H
	DW	06H
	DW	07H
	DW	019H
	DW	0fH
	DW	06H
	DW	06H
	DW	0cH
	DW	01H
	DW	016H
	DW	0dH
	DW	01H
	DW	04H
	DW	09H
	DW	05H
	DW	0cH
	DW	02H
	DW	09H
	DW	01H
	DW	0cH
	DW	01cH
	DW	08H
	DW	03H
	DW	05H
	DW	0aH
	DW	016H
	DW	03cH
	DW	01H
	DW	02H
	DW	028H
	DW	04H
	DW	03dH
	DW	03fH
	DW	04H
	DW	01H
	DW	0dH
	DW	0cH
	DW	01H
	DW	04H
	DW	01fH
	DW	0cH
	DW	01H
	DW	0eH
	DW	059H
	DW	05H
	DW	010H
	DW	06H
	DW	01dH
	DW	0eH
	DW	02H
	DW	05H
	DW	031H
	DW	012H
	DW	012H
	DW	05H
	DW	01dH
	DW	021H
	DW	02fH
	DW	01H
	DW	011H
	DW	01H
	DW	013H
	DW	0cH
	DW	02H
	DW	09H
	DW	07H
	DW	027H
	DW	0cH
	DW	03H
	DW	07H
	DW	0cH
	DW	027H
	DW	03H
	DW	01H
	DW	02eH
	DW	04H
	DW	0cH
	DW	03H
	DW	08H
	DW	09H
	DW	05H
	DW	01fH
	DW	0fH
	DW	012H
	DW	03H
	DW	02H
	DW	02H
	DW	042H
	DW	013H
	DW	0dH
	DW	011H
	DW	05H
	DW	03H
	DW	02eH
	DW	07cH
	DW	0dH
	DW	039H
	DW	022H
	DW	02H
	DW	05H
	DW	04H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	011H
	DW	05H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	08H
	DW	05H
	DW	06H
	DW	03H
	DW	01bH
	DW	03H
	DW	01aH
	DW	07H
	DW	0cH
	DW	07H
	DW	02H
	DW	011H
	DW	03H
	DW	07H
	DW	012H
	DW	04eH
	DW	010H
	DW	04H
	DW	024H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	027H
	DW	011H
	DW	07H
	DW	04H
	DW	0dH
	DW	04H
	DW	04H
	DW	04H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	04H
	DW	06H
	DW	03H
	DW	0aH
	DW	01H
	DW	013H
	DW	01H
	DW	01aH
	DW	02H
	DW	04H
	DW	021H
	DW	02H
	DW	049H
	DW	02fH
	DW	07H
	DW	03H
	DW	08H
	DW	02H
	DW	04H
	DW	0fH
	DW	012H
	DW	01H
	DW	01dH
	DW	02H
	DW	029H
	DW	0eH
	DW	01H
	DW	015H
	DW	010H
	DW	029H
	DW	07H
	DW	027H
	DW	019H
	DW	0dH
	DW	02cH
	DW	02H
	DW	02H
	DW	0aH
	DW	01H
	DW	0dH
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	05H
	DW	014H
	DW	04H
	DW	08H
	DW	02H
	DW	031H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	06H
	DW	07H
	DW	0aH
	DW	07H
	DW	0bH
	DW	010H
	DW	03H
	DW	0cH
	DW	014H
	DW	04H
	DW	0aH
	DW	03H
	DW	01H
	DW	02H
	DW	0bH
	DW	02H
	DW	01cH
	DW	09H
	DW	02H
	DW	04H
	DW	07H
	DW	02H
	DW	0fH
	DW	01H
	DW	01bH
	DW	01H
	DW	01cH
	DW	011H
	DW	04H
	DW	05H
	DW	0aH
	DW	07H
	DW	03H
	DW	018H
	DW	0aH
	DW	0bH
	DW	06H
	DW	01aH
	DW	03H
	DW	02H
	DW	07H
	DW	02H
	DW	02H
	DW	031H
	DW	010H
	DW	0aH
	DW	010H
	DW	0fH
	DW	04H
	DW	05H
	DW	01bH
	DW	03dH
	DW	01eH
	DW	0eH
	DW	026H
	DW	016H
	DW	02H
	DW	07H
	DW	05H
	DW	01H
	DW	03H
	DW	0cH
	DW	017H
	DW	018H
	DW	011H
	DW	011H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	02H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	09H
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	08H
	DW	02H
	DW	08H
	DW	04H
	DW	0eH
	DW	03H
	DW	05H
	DW	0bH
	DW	04H
	DW	01H
	DW	03H
	DW	020H
	DW	01H
	DW	013H
	DW	04H
	DW	01H
	DW	0dH
	DW	0bH
	DW	05H
	DW	02H
	DW	01H
	DW	08H
	DW	06H
	DW	08H
	DW	01H
	DW	06H
	DW	05H
	DW	0dH
	DW	03H
	DW	017H
	DW	0bH
	DW	05H
	DW	03H
	DW	010H
	DW	03H
	DW	09H
	DW	0aH
	DW	01H
	DW	018H
	DW	03H
	DW	0c6H
	DW	034H
	DW	04H
	DW	02H
	DW	02H
	DW	05H
	DW	0eH
	DW	05H
	DW	04H
	DW	016H
	DW	05H
	DW	014H
	DW	04H
	DW	0bH
	DW	06H
	DW	029H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	0bH
	DW	05H
	DW	02H
	DW	01cH
	DW	023H
	DW	08H
	DW	016H
	DW	03H
	DW	012H
	DW	03H
	DW	0aH
	DW	07H
	DW	05H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	08H
	DW	09H
	DW	03H
	DW	06H
	DW	02H
	DW	010H
	DW	016H
	DW	04H
	DW	05H
	DW	05H
	DW	03H
	DW	03H
	DW	012H
	DW	017H
	DW	02H
	DW	06H
	DW	017H
	DW	05H
	DW	01bH
	DW	08H
	DW	01H
	DW	021H
	DW	02H
	DW	0cH
	DW	02bH
	DW	010H
	DW	05H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	014H
	DW	04H
	DW	02H
	DW	09H
	DW	07H
	DW	01H
	DW	0bH
	DW	02H
	DW	0aH
	DW	03H
	DW	0eH
	DW	01fH
	DW	09H
	DW	03H
	DW	019H
	DW	012H
	DW	014H
	DW	02H
	DW	05H
	DW	05H
	DW	01aH
	DW	0eH
	DW	01H
	DW	0bH
	DW	011H
	DW	0cH
	DW	028H
	DW	013H
	DW	09H
	DW	06H
	DW	01fH
	DW	053H
	DW	02H
	DW	07H
	DW	09H
	DW	013H
	DW	04eH
	DW	0cH
	DW	0eH
	DW	015H
	DW	04cH
	DW	0cH
	DW	071H
	DW	04fH
	DW	022H
	DW	04H
	DW	01H
	DW	01H
	DW	03dH
	DW	012H
	DW	055H
	DW	0aH
	DW	02H
	DW	02H
	DW	0dH
	DW	01fH
	DW	0bH
	DW	032H
	DW	06H
	DW	021H
	DW	09fH
	DW	0b3H
	DW	06H
	DW	06H
	DW	07H
	DW	04H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	05H
	DW	08H
	DW	07H
	DW	014H
	DW	020H
	DW	016H
	DW	01H
	DW	03H
	DW	0aH
	DW	06H
	DW	07H
	DW	01cH
	DW	05H
	DW	0aH
	DW	09H
	DW	02H
	DW	04dH
	DW	013H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	04H
	DW	07H
	DW	04H
	DW	0dH
	DW	03H
	DW	09H
	DW	01fH
	DW	011H
	DW	03H
	DW	01aH
	DW	02H
	DW	06H
	DW	06H
	DW	05H
	DW	04H
	DW	01H
	DW	07H
	DW	0bH
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	014H
	DW	04H
	DW	01H
	DW	09H
	DW	02H
	DW	06H
	DW	03H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	014H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	08H
	DW	01H
	DW	05H
	DW	0dH
	DW	08H
	DW	04H
	DW	0bH
	DW	017H
	DW	01H
	DW	0aH
	DW	06H
	DW	02H
	DW	01H
	DW	03H
	DW	015H
	DW	02H
	DW	02H
	DW	04H
	DW	018H
	DW	01fH
	DW	04H
	DW	0aH
	DW	0aH
	DW	02H
	DW	05H
	DW	0c0H
	DW	0fH
	DW	04H
	DW	010H
	DW	07H
	DW	09H
	DW	033H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	09H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	04H
	DW	04H
	DW	012H
	DW	0cH
	DW	05cH
	DW	02H
	DW	0aH
	DW	04H
	DW	03H
	DW	0eH
	DW	05H
	DW	019H
	DW	010H
	DW	02aH
	DW	04H
	DW	0eH
	DW	04H
	DW	02H
	DW	015H
	DW	05H
	DW	07eH
	DW	01eH
	DW	01fH
	DW	02H
	DW	01H
	DW	05H
	DW	0dH
	DW	03H
	DW	016H
	DW	05H
	DW	06H
	DW	06H
	DW	014H
	DW	0cH
	DW	01H
	DW	0eH
	DW	0cH
	DW	057H
	DW	03H
	DW	013H
	DW	01H
	DW	08H
	DW	02H
	DW	09H
	DW	09H
	DW	03H
	DW	03H
	DW	017H
	DW	02H
	DW	03H
	DW	07H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	0bH
	DW	03H
	DW	01H
	DW	06H
	DW	0aH
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	0bH
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	02H
	DW	05H
	DW	05H
	DW	022H
	DW	04H
	DW	0eH
	DW	012H
	DW	04H
	DW	013H
	DW	07H
	DW	05H
	DW	08H
	DW	02H
	DW	06H
	DW	04fH
	DW	01H
	DW	05H
	DW	02H
	DW	0eH
	DW	08H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	024H
	DW	01cH
	DW	010H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	0cH
	DW	06H
	DW	02aH
	DW	027H
	DW	010H
	DW	017H
	DW	07H
	DW	0fH
	DW	0fH
	DW	03H
	DW	02H
	DW	0cH
	DW	07H
	DW	015H
	DW	040H
	DW	06H
	DW	09H
	DW	01cH
	DW	08H
	DW	0cH
	DW	03H
	DW	03H
	DW	029H
	DW	03bH
	DW	018H
	DW	033H
	DW	037H
	DW	039H
	DW	0126H
	DW	09H
	DW	09H
	DW	02H
	DW	06H
	DW	02H
	DW	0fH
	DW	01H
	DW	02H
	DW	0dH
	DW	026H
	DW	05aH
	DW	09H
	DW	09H
	DW	09H
	DW	03H
	DW	0bH
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	05H
	DW	07H
	DW	01H
	DW	04H
	DW	03H
	DW	014H
	DW	04H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	05H
	DW	011H
	DW	01H
	DW	05H
	DW	02H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	05H
	DW	07H
	DW	03H
	DW	012H
	DW	0bH
	DW	0bH
	DW	020H
	DW	07H
	DW	05H
	DW	04H
	DW	07H
	DW	0bH
	DW	07fH
	DW	08H
	DW	04H
	DW	03H
	DW	03H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	06H
	DW	015H
	DW	0eH
	DW	01H
	DW	010H
	DW	01H
	DW	07H
	DW	01H
	DW	03H
	DW	06H
	DW	09H
	DW	041H
	DW	033H
	DW	04H
	DW	03H
	DW	0dH
	DW	03H
	DW	0aH
	DW	01H
	DW	01H
	DW	0cH
	DW	09H
	DW	015H
	DW	06eH
	DW	03H
	DW	013H
	DW	018H
	DW	01H
	DW	01H
	DW	0aH
	DW	03eH
	DW	04H
	DW	01H
	DW	01dH
	DW	02aH
	DW	04eH
	DW	01cH
	DW	014H
	DW	012H
	DW	052H
	DW	06H
	DW	03H
	DW	0fH
	DW	06H
	DW	054H
	DW	03aH
	DW	0fdH
	DW	0fH
	DW	09bH
	DW	0108H
	DW	0fH
	DW	015H
	DW	09H
	DW	0eH
	DW	07H
	DW	03aH
	DW	028H
	DW	027H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::base_ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
_DATA	ENDS
;	COMDAT ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB
CONST	SEGMENT
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	08H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	05H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	0aH
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	0eH
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	06H
	DW	07H
	DW	0aH
	DW	04H
	DW	07H
	DW	0dH
	DW	01H
	DW	05H
	DW	04H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01cH
	DW	05H
	DW	06H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	014H
	DW	02H
	DW	02H
	DW	09H
	DW	08H
	DW	0bH
	DW	02H
	DW	09H
	DW	011H
	DW	01H
	DW	08H
	DW	06H
	DW	08H
	DW	01bH
	DW	04H
	DW	06H
	DW	09H
	DW	014H
	DW	0bH
	DW	01bH
	DW	06H
	DW	044H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	06H
	DW	0bH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	07H
	DW	02H
	DW	01H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	05H
	DW	06H
	DW	03H
	DW	06H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	03H
	DW	09H
	DW	02H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	04H
	DW	05H
	DW	0fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	03H
	DW	016H
	DW	013H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	0cH
	DW	08H
	DW	02H
	DW	09H
	DW	012H
	DW	016H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	010H
	DW	01H
	DW	02H
	DW	07H
	DW	0aH
	DW	0fH
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	02H
	DW	05H
	DW	07H
	DW	02H
	DW	013H
	DW	04H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	02H
	DW	0eH
	DW	04H
	DW	06H
	DW	06H
	DW	0bH
	DW	09H
	DW	01H
	DW	0fH
	DW	03H
	DW	01H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	05H
	DW	04H
	DW	06H
	DW	0eH
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	015H
	DW	02H
	DW	07H
	DW	014H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	04H
	DW	01cH
	DW	01cH
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	0eH
	DW	04H
	DW	01H
	DW	01aH
	DW	01cH
	DW	02aH
	DW	0cH
	DW	028H
	DW	03H
	DW	034H
	DW	04fH
	DW	05H
	DW	0eH
	DW	011H
	DW	03H
	DW	02H
	DW	02H
	DW	0bH
	DW	03H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	08H
	DW	02H
	DW	017H
	DW	04H
	DW	05H
	DW	08H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01cH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	014H
	DW	05H
	DW	03H
	DW	01dH
	DW	03H
	DW	011H
	DW	01aH
	DW	01H
	DW	08H
	DW	04H
	DW	01bH
	DW	03H
	DW	06H
	DW	0bH
	DW	017H
	DW	05H
	DW	03H
	DW	04H
	DW	06H
	DW	0dH
	DW	018H
	DW	010H
	DW	06H
	DW	05H
	DW	0aH
	DW	019H
	DW	023H
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	06H
	DW	02H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	0dH
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	0eH
	DW	0eH
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	0eH
	DW	03H
	DW	0cH
	DW	03H
	DW	011H
	DW	02H
	DW	010H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	08H
	DW	09H
	DW	03H
	DW	013H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	011H
	DW	019H
	DW	015H
	DW	014H
	DW	01cH
	DW	04bH
	DW	01H
	DW	0aH
	DW	01dH
	DW	067H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	018H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	06H
	DW	0dH
	DW	09H
	DW	010H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	05H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	0dH
	DW	07H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	01H
	DW	0eH
	DW	02H
	DW	0eH
	DW	02H
	DW	01H
	DW	012H
	DW	03H
	DW	04H
	DW	0eH
	DW	04H
	DW	0bH
	DW	029H
	DW	0fH
	DW	017H
	DW	0fH
	DW	017H
	DW	0b0H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	07H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	09H
	DW	07H
	DW	01H
	DW	0aH
	DW	05H
	DW	08H
	DW	010H
	DW	01dH
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	05H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	07H
	DW	01H
	DW	06H
	DW	0aH
	DW	01H
	DW	011H
	DW	01H
	DW	02cH
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	05H
	DW	04H
	DW	02H
	DW	0aH
	DW	01H
	DW	06H
	DW	09H
	DW	02H
	DW	08H
	DW	01H
	DW	018H
	DW	01H
	DW	02H
	DW	0dH
	DW	07H
	DW	08H
	DW	08H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	02H
	DW	05H
	DW	0aH
	DW	09H
	DW	04H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	04H
	DW	0aH
	DW	08H
	DW	03H
	DW	01H
	DW	0dH
	DW	04H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	011H
	DW	010H
	DW	05H
	DW	02H
	DW	010H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	05H
	DW	0bH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	06H
	DW	0aH
	DW	09H
	DW	05H
	DW	07H
	DW	04H
	DW	07H
	DW	04H
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	08H
	DW	07H
	DW	01H
	DW	06H
	DW	0bH
	DW	05H
	DW	05H
	DW	03H
	DW	018H
	DW	09H
	DW	04H
	DW	02H
	DW	07H
	DW	0dH
	DW	05H
	DW	01H
	DW	08H
	DW	052H
	DW	010H
	DW	03dH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	010H
	DW	0aH
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	06H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	08H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	0bH
	DW	03H
	DW	09H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	09H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	07H
	DW	09H
	DW	09H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	020H
	DW	06H
	DW	01H
	DW	02H
	DW	0fH
	DW	09H
	DW	03H
	DW	07H
	DW	0dH
	DW	01H
	DW	03H
	DW	0aH
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0dH
	DW	0aH
	DW	02H
	DW	01H
	DW	03H
	DW	0aH
	DW	04H
	DW	0fH
	DW	02H
	DW	0fH
	DW	0fH
	DW	0aH
	DW	01H
	DW	03H
	DW	09H
	DW	06H
	DW	09H
	DW	020H
	DW	019H
	DW	01aH
	DW	02fH
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	03H
	DW	04H
	DW	03H
	DW	02H
	DW	08H
	DW	05H
	DW	04H
	DW	01H
	DW	09H
	DW	04H
	DW	02H
	DW	02H
	DW	013H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	06H
	DW	04H
	DW	08H
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	05H
	DW	05H
	DW	01H
	DW	03H
	DW	08H
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	04H
	DW	0cH
	DW	01H
	DW	05H
	DW	03H
	DW	07H
	DW	0dH
	DW	02H
	DW	05H
	DW	08H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	05H
	DW	0eH
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	08H
	DW	0fH
	DW	05H
	DW	01H
	DW	017H
	DW	06H
	DW	03eH
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	0aH
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	07H
	DW	01H
	DW	0eH
	DW	01H
	DW	02H
	DW	03H
	DW	0cH
	DW	05H
	DW	02H
	DW	05H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	07H
	DW	0eH
	DW	0bH
	DW	01H
	DW	03H
	DW	01H
	DW	08H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	0bH
	DW	08H
	DW	04H
	DW	04H
	DW	02H
	DW	06H
	DW	0aH
	DW	09H
	DW	0dH
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	05H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	012H
	DW	02H
	DW	03H
	DW	0eH
	DW	0bH
	DW	04H
	DW	01dH
	DW	04H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	0dH
	DW	09H
	DW	02H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	014H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	048H
	DW	022H
	DW	06H
	DW	04H
	DW	016H
	DW	0cH
	DW	0cH
	DW	01cH
	DW	02dH
	DW	024H
	DW	09H
	DW	07H
	DW	027H
	DW	09H
	DW	0bfH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0bH
	DW	08H
	DW	04H
	DW	09H
	DW	02H
	DW	03H
	DW	016H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	011H
	DW	01H
	DW	07H
	DW	07H
	DW	01H
	DW	0bH
	DW	01fH
	DW	0aH
	DW	02H
	DW	04H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	010H
	DW	04H
	DW	020H
	DW	02H
	DW	03H
	DW	013H
	DW	0dH
	DW	04H
	DW	09H
	DW	01H
	DW	05H
	DW	02H
	DW	0eH
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	013H
	DW	06H
	DW	05H
	DW	01H
	DW	010H
	DW	06H
	DW	02H
	DW	0aH
	DW	08H
	DW	05H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	05H
	DW	01H
	DW	0bH
	DW	06H
	DW	06H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	07H
	DW	05H
	DW	07H
	DW	07H
	DW	05H
	DW	08H
	DW	09H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	010H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	03H
	DW	0fH
	DW	02H
	DW	09H
	DW	02H
	DW	0aH
	DW	019H
	DW	0dH
	DW	09H
	DW	010H
	DW	06H
	DW	02H
	DW	02H
	DW	0aH
	DW	0bH
	DW	04H
	DW	03H
	DW	09H
	DW	01H
	DW	02H
	DW	06H
	DW	06H
	DW	05H
	DW	04H
	DW	01eH
	DW	028H
	DW	01H
	DW	0aH
	DW	07H
	DW	0cH
	DW	0eH
	DW	021H
	DW	06H
	DW	03H
	DW	06H
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	0eH
	DW	04H
	DW	09H
	DW	05H
	DW	0cH
	DW	0bH
	DW	031H
	DW	012H
	DW	033H
	DW	01fH
	DW	08cH
	DW	01fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	08H
	DW	01H
	DW	0aH
	DW	01H
	DW	04H
	DW	04H
	DW	03H
	DW	018H
	DW	01H
	DW	0aH
	DW	01H
	DW	03H
	DW	06H
	DW	06H
	DW	010H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	039H
	DW	0aH
	DW	06H
	DW	016H
	DW	02H
	DW	016H
	DW	03H
	DW	07H
	DW	016H
	DW	06H
	DW	0aH
	DW	0bH
	DW	024H
	DW	012H
	DW	010H
	DW	021H
	DW	024H
	DW	02H
	DW	05H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	01H
	DW	04H
	DW	0dH
	DW	02H
	DW	07H
	DW	05H
	DW	02H
	DW	09H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02bH
	DW	03H
	DW	07H
	DW	03H
	DW	09H
	DW	0eH
	DW	07H
	DW	09H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	04H
	DW	012H
	DW	0dH
	DW	01H
	DW	0eH
	DW	01H
	DW	03H
	DW	06H
	DW	0aH
	DW	049H
	DW	02H
	DW	02H
	DW	01eH
	DW	06H
	DW	01H
	DW	0bH
	DW	012H
	DW	013H
	DW	0dH
	DW	016H
	DW	03H
	DW	02eH
	DW	02aH
	DW	025H
	DW	059H
	DW	07H
	DW	03H
	DW	010H
	DW	022H
	DW	02H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	03H
	DW	0aH
	DW	03H
	DW	09H
	DW	05H
	DW	01cH
	DW	09H
	DW	02H
	DW	06H
	DW	0dH
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	0aH
	DW	02H
	DW	07H
	DW	02H
	DW	0bH
	DW	03H
	DW	06H
	DW	015H
	DW	036H
	DW	055H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	027H
	DW	03H
	DW	015H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0fH
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	014H
	DW	01H
	DW	08H
	DW	07H
	DW	0dH
	DW	04H
	DW	01H
	DW	01aH
	DW	06H
	DW	02H
	DW	09H
	DW	022H
	DW	04H
	DW	015H
	DW	034H
	DW	0aH
	DW	04H
	DW	04H
	DW	01H
	DW	05H
	DW	0cH
	DW	02H
	DW	0bH
	DW	01H
	DW	07H
	DW	02H
	DW	01eH
	DW	0cH
	DW	02cH
	DW	02H
	DW	01eH
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	010H
	DW	09H
	DW	011H
	DW	027H
	DW	052H
	DW	02H
	DW	02H
	DW	018H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	010H
	DW	09H
	DW	0eH
	DW	02cH
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	0bH
	DW	05H
	DW	0bH
	DW	02H
	DW	01H
	DW	012H
	DW	013H
	DW	08H
	DW	01H
	DW	03H
	DW	018H
	DW	01dH
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	0dH
	DW	06H
	DW	05H
	DW	01H
	DW	02eH
	DW	0bH
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	08H
	DW	02H
	DW	0aH
	DW	06H
	DW	0cH
	DW	06H
	DW	03H
	DW	07H
	DW	0bH
	DW	02H
	DW	04H
	DW	010H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	05H
	DW	02H
	DW	01cH
	DW	05H
	DW	02H
	DW	017H
	DW	0aH
	DW	08H
	DW	04H
	DW	04H
	DW	016H
	DW	027H
	DW	05fH
	DW	026H
	DW	08H
	DW	0eH
	DW	09H
	DW	05H
	DW	01H
	DW	0dH
	DW	05H
	DW	04H
	DW	03H
	DW	0dH
	DW	0cH
	DW	0bH
	DW	01H
	DW	09H
	DW	01H
	DW	01bH
	DW	025H
	DW	02H
	DW	05H
	DW	04H
	DW	04H
	DW	03fH
	DW	0d3H
	DW	05fH
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	05H
	DW	03H
	DW	02H
	DW	05H
	DW	03H
	DW	09H
	DW	0bH
	DW	04H
	DW	02H
	DW	016H
	DW	01H
	DW	06H
	DW	03H
	DW	08H
	DW	07H
	DW	01H
	DW	04H
	DW	01cH
	DW	04H
	DW	010H
	DW	03H
	DW	03H
	DW	019H
	DW	04H
	DW	04H
	DW	01bH
	DW	01bH
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01cH
	DW	08H
	DW	02H
	DW	0eH
	DW	01H
	DW	08H
	DW	06H
	DW	010H
	DW	019H
	DW	03H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	06H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	012H
	DW	03H
	DW	02H
	DW	05H
	DW	05H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	04H
	DW	017H
	DW	07H
	DW	06H
	DW	0cH
	DW	06H
	DW	04H
	DW	011H
	DW	0bH
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	0aH
	DW	05H
	DW	0cH
	DW	01H
	DW	01H
	DW	0bH
	DW	01aH
	DW	021H
	DW	07H
	DW	03H
	DW	06H
	DW	01H
	DW	011H
	DW	07H
	DW	01H
	DW	05H
	DW	0cH
	DW	01H
	DW	0bH
	DW	02H
	DW	04H
	DW	01H
	DW	08H
	DW	0eH
	DW	011H
	DW	017H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	08H
	DW	010H
	DW	0bH
	DW	09H
	DW	06H
	DW	05H
	DW	02H
	DW	06H
	DW	04H
	DW	010H
	DW	02H
	DW	08H
	DW	0eH
	DW	01H
	DW	0bH
	DW	08H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	019H
	DW	04H
	DW	0bH
	DW	013H
	DW	07H
	DW	02H
	DW	0fH
	DW	02H
	DW	0cH
	DW	08H
	DW	034H
	DW	07H
	DW	05H
	DW	013H
	DW	02H
	DW	010H
	DW	04H
	DW	024H
	DW	08H
	DW	01H
	DW	010H
	DW	08H
	DW	018H
	DW	01aH
	DW	04H
	DW	06H
	DW	02H
	DW	09H
	DW	05H
	DW	04H
	DW	024H
	DW	03H
	DW	01cH
	DW	0cH
	DW	019H
	DW	0fH
	DW	025H
	DW	01bH
	DW	011H
	DW	0cH
	DW	03bH
	DW	026H
	DW	05H
	DW	020H
	DW	07fH
	DW	01H
	DW	02H
	DW	09H
	DW	011H
	DW	0eH
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	08H
	DW	0bH
	DW	032H
	DW	04H
	DW	0eH
	DW	02H
	DW	013H
	DW	010H
	DW	04H
	DW	011H
	DW	05H
	DW	04H
	DW	05H
	DW	01aH
	DW	0cH
	DW	02dH
	DW	02H
	DW	017H
	DW	02dH
	DW	068H
	DW	01eH
	DW	0cH
	DW	08H
	DW	03H
	DW	0aH
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	014H
	DW	07H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	02H
	DW	014H
	DW	01H
	DW	03H
	DW	010H
	DW	04H
	DW	0bH
	DW	0fH
	DW	06H
	DW	086H
	DW	02H
	DW	05H
	DW	03bH
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	09H
	DW	011H
	DW	03H
	DW	01aH
	DW	089H
	DW	0aH
	DW	0d3H
	DW	03bH
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	0eH
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	01bH
	DW	09H
	DW	022H
	DW	091H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	08H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	05H
	DW	01H
	DW	014H
	DW	04H
	DW	010H
	DW	01H
	DW	0fH
	DW	09H
	DW	05H
	DW	0cH
	DW	02H
	DW	09H
	DW	02H
	DW	05H
	DW	04H
	DW	02H
	DW	01aH
	DW	013H
	DW	07H
	DW	01H
	DW	01aH
	DW	04H
	DW	01eH
	DW	0cH
	DW	0fH
	DW	02aH
	DW	01H
	DW	06H
	DW	08H
	DW	0acH
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	08H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	0cH
	DW	0eH
	DW	0bH
	DW	06H
	DW	06H
	DW	04H
	DW	0cH
	DW	02H
	DW	08H
	DW	01H
	DW	07H
	DW	0aH
	DW	01H
	DW	023H
	DW	07H
	DW	04H
	DW	0dH
	DW	0fH
	DW	04H
	DW	03H
	DW	017H
	DW	015H
	DW	01cH
	DW	034H
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	01H
	DW	07H
	DW	0aH
	DW	02H
	DW	07H
	DW	035H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	0a3H
	DW	0214H
	DW	01H
	DW	0aH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	04H
	DW	08H
	DW	02H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	017H
	DW	016H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	09H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01H
	DW	0aH
	DW	02H
	DW	0cH
	DW	015H
	DW	014H
	DW	0fH
	DW	069H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	0fH
	DW	0bH
	DW	013H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	0fH
	DW	09H
	DW	01H
	DW	04H
	DW	05H
	DW	03H
	DW	01aH
	DW	08H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0fH
	DW	013H
	DW	02H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	02H
	DW	07H
	DW	02H
	DW	013H
	DW	02H
	DW	014H
	DW	06H
	DW	01aH
	DW	07H
	DW	05H
	DW	02H
	DW	02H
	DW	07H
	DW	022H
	DW	015H
	DW	0dH
	DW	046H
	DW	02H
	DW	080H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0fH
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02aH
	DW	0aH
	DW	06H
	DW	01H
	DW	031H
	DW	055H
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	05H
	DW	07H
	DW	04H
	DW	03H
	DW	0d3H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	06H
	DW	05H
	DW	06H
	DW	0aH
	DW	03H
	DW	04H
	DW	030H
	DW	064H
	DW	06H
	DW	02H
	DW	010H
	DW	0128H
	DW	05H
	DW	01bH
	DW	0183H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	026H
	DW	0fH
	DW	027H
	DW	015H
	DW	09H
	DW	0aH
	DW	03H
	DW	07H
	DW	03bH
	DW	0dH
	DW	01bH
	DW	015H
	DW	02fH
	DW	05H
	DW	015H
	DW	06H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesChineseFull'::`2'::ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	04e00H
	DW	09fafH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesKorean'::`2'::ranges
	DW	0ffH
	DW	03131H
	DW	03163H
	DW	0ac00H
	DW	0d79dH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesDefault'::`2'::ranges
	DW	0ffH
	DW	00H
CONST	ENDS
;	COMDAT ??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
CONST	SEGMENT
??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@ DB '%s, %.0fpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04KODIGLGG@maxp@
CONST	SEGMENT
??_C@_04KODIGLGG@maxp@ DB 'maxp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJGCPIEK@CFF?5@
CONST	SEGMENT
??_C@_04HJGCPIEK@CFF?5@ DB 'CFF ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCFDEHHD@GPOS@
CONST	SEGMENT
??_C@_04PCFDEHHD@GPOS@ DB 'GPOS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HHMMLDJI@kern@
CONST	SEGMENT
??_C@_04HHMMLDJI@kern@ DB 'kern', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONMNCIMC@hmtx@
CONST	SEGMENT
??_C@_04ONMNCIMC@hmtx@ DB 'hmtx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMPHLIKP@hhea@
CONST	SEGMENT
??_C@_04FMPHLIKP@hhea@ DB 'hhea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLIHEPK@glyf@
CONST	SEGMENT
??_C@_04LLIHEPK@glyf@ DB 'glyf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DACNFKGE@loca@
CONST	SEGMENT
??_C@_04DACNFKGE@loca@ DB 'loca', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EICJPCEA@cmap@
CONST	SEGMENT
??_C@_04EICJPCEA@cmap@ DB 'cmap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIOEMAHO@ttcf@
CONST	SEGMENT
??_C@_04KIOEMAHO@ttcf@ DB 'ttcf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEFIKCJ@OTTO@
CONST	SEGMENT
??_C@_04LLEFIKCJ@OTTO@ DB 'OTTO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBBEMOBJ@typ1@
CONST	SEGMENT
??_C@_04LBBEMOBJ@typ1@ DB 'typ1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFontBuildSrcData@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImFontBuildSrcData@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImFontBuildSrcData@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImFontBuildSrcData@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImFontBuildSrcData@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFontBuildSrcData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImFontBuildSrcData@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFontBuildSrcData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z DB 040H
	DD	imagerel $ip2state$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z DD 011819H
	DD	06218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImBoolVector@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImBoolVector@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImBoolVector@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImBoolVector@@QEAA@XZ
	DD	imagerel $ip2state$??1ImBoolVector@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImBoolVector@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImBoolVector@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetBit@ImBoolVector@@QEAAXH_N@Z DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBit@ImBoolVector@@QEBA_NH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImBoolVector@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Resize@ImBoolVector@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFont@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@M@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@M@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@M@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@M@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@M@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@M@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@M@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@M@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAUImFont@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAUImFont@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAUImFont@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CustomRect@ImFontAtlas@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@H@@QEAAXAEBH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@H@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@H@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@H@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@H@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@H@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@H@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@H@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@H@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathStroke@ImDrawList@@QEAAXI_NM@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	021H
	DD	0476H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	021H
	DD	0404H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	01cH
	DD	0440H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	019H
	DD	0140H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	025H
	DD	0487H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
	DD	021H
	DD	013a9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	01fH
	DD	0139fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	017H
	DD	0180eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z
	DD	026H
	DD	04f5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
	DD	028H
	DD	010cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z
	DD	028H
	DD	0e5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
	DD	028H
	DD	01b9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ
	DD	02cH
	DD	052bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
	DD	02bH
	DD	07fcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z
	DD	02bH
	DD	01a2bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DB 012H
	DB	00H
	DB	00H
	DB	'8'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'$'
	DB	08H
	DB	'$'
	DB	0aH
	DB	'('
	DB	0cH
	DB	'('
	DB	0eH
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
	DD	imagerel $ip2state$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImVec2@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImVec2@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImVec2@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImVec2@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImVec2@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImVec2@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImVec2@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@PEAX@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAX@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@PEAX@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@PEAX@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@PEAX@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@PEAX@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@PEAX@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@PEAX@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImVec4@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImVec4@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImVec4@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImVec4@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImVec4@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImVec4@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawVert@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawVert@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawVert@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImDrawChannel@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImDrawChannel@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImDrawChannel@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImDrawChannel@@QEAA@XZ
	DD	imagerel $ip2state$??0ImDrawChannel@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawChannel@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImDrawChannel@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawCmd@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@G@@QEAAXAEBG@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXHAEBG@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@G@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@G@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@G@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@G@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@G@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
xdata	SEGMENT
$unwind$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z DD 040e01H
	DD	069010eH
	DD	060067007H
$unwind$?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z DD 040e01H
	DD	069010eH
	DD	060067007H
$unwind$?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z DD 040e01H
	DD	069010eH
	DD	060067007H
$unwind$?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$?PushClipRectFullScreen@ImDrawList@@QEAAXXZ DD 010901H
	DD	08209H
$unwind$?PopClipRect@ImDrawList@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?PushTextureID@ImDrawList@@QEAAXPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?PopTextureID@ImDrawList@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?DrawBox_S@ImDrawList@@QEAAXAEBUImVec2@@0IMM@Z DD 021b01H
	DD	0f7011bH
$unwind$?DrawHealthBar@ImDrawList@@QEAAXAEBUImVec2@@0MM@Z DD 021c01H
	DD	02b011cH
$unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 011801H
	DD	08218H
$unwind$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z DD 021b01H
	DD	013011bH
$unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 011801H
	DD	06218H
$unwind$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD 011801H
	DD	08218H
$unwind$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD 011801H
	DD	04218H
$unwind$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 011801H
	DD	04218H
$unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD 011801H
	DD	04218H
$unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD 011801H
	DD	04218H
$unwind$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z DD 011901H
	DD	08219H
$unwind$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z DD 011901H
	DD	08219H
$unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 011801H
	DD	0a218H
$unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD 031b01H
	DD	07017e21bH
	DD	06016H
$unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 011801H
	DD	08218H
$unwind$?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z DD 011801H
	DD	0c218H
$unwind$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD 011801H
	DD	0a218H
$unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z DD 025043219H
	DD	011c2321H
	DD	050150040H
	DD	imagerel __GSHandlerCheck
	DD	01f8H
$unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 025043219H
	DD	011c2321H
	DD	05015001aH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z DD 011801H
	DD	06218H
$unwind$?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ DD 055043319H
	DD	011d5322H
	DD	0501600a0H
	DD	imagerel __GSHandlerCheck
	DD	04f0H
$unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 011a01H
	DD	0a21aH
$unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD 011901H
	DD	0c219H
$unwind$?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z DD 021b01H
	DD	015011bH
$unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 021c01H
	DD	013011cH
$unwind$?ChannelsSplit@ImDrawList@@QEAAXH@Z DD 041211H
	DD	01d0112H
	DD	0600a700bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ChannelsSplit@ImDrawList@@QEAAXH@Z
$cppxdata$?ChannelsSplit@ImDrawList@@QEAAXH@Z DB 08H
	DD	imagerel $stateUnwindMap$?ChannelsSplit@ImDrawList@@QEAAXH@Z
	DD	imagerel $ip2state$?ChannelsSplit@ImDrawList@@QEAAXH@Z
$stateUnwindMap$?ChannelsSplit@ImDrawList@@QEAAXH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA
$ip2state$?ChannelsSplit@ImDrawList@@QEAAXH@Z DB 06H
	DB	00H
	DB	00H
	DB	'9', 04H
	DB	02H
	DB	'z'
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ChannelsMerge@ImDrawList@@QEAAXXZ DD 010901H
	DD	0e209H
$unwind$?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z DD 010d01H
	DD	0420dH
$unwind$?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z DD 011301H
	DD	06213H
$unwind$?AddDrawCmd@ImDrawList@@QEAAXXZ DD 030b01H
	DD	07007e20bH
	DD	06006H
$unwind$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ
$cppxdata$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ DB 08H
	DD	imagerel $stateUnwindMap$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ
	DD	imagerel $ip2state$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ
$stateUnwindMap$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA
$ip2state$?CloneOutput@ImDrawList@@QEBAPEAU1@XZ DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	'\'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?Clear@ImDrawList@@QEAAXXZ DD 010901H
	DD	0a209H
$unwind$?ClearFreeMemory@ImDrawList@@QEAAXXZ DD 010901H
	DD	08209H
$unwind$?PrimReserve@ImDrawList@@QEAAXHH@Z DD 011201H
	DD	08212H
$unwind$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD 011801H
	DD	08218H
$unwind$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 011801H
	DD	0a218H
$unwind$?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z DD 011801H
	DD	02218H
$unwind$?UpdateClipRect@ImDrawList@@QEAAXXZ DD 030b01H
	DD	07007e20bH
	DD	06006H
$unwind$?UpdateTextureID@ImDrawList@@QEAAXXZ DD 010901H
	DD	0c209H
$unwind$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ DD 040e11H
	DD	011010eH
	DD	060067007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ
$cppxdata$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ DB 08H
	DD	imagerel $stateUnwindMap$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ
	DD	imagerel $ip2state$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ
$stateUnwindMap$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA
$ip2state$?DeIndexAllBuffers@ImDrawData@@QEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	0c5H, 05H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$??0ImFontConfig@@QEAA@XZ DD 010901H
	DD	06209H
$unwind$?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z DD 011301H
	DD	06213H
$unwind$?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z DD 010e01H
	DD	0620eH
$unwind$?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z DD 010e01H
	DD	0620eH
$unwind$??0ImFontAtlas@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImFontAtlas@@QEAA@XZ
$cppxdata$??0ImFontAtlas@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImFontAtlas@@QEAA@XZ
	DD	imagerel $ip2state$??0ImFontAtlas@@QEAA@XZ
$stateUnwindMap$??0ImFontAtlas@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA
$ip2state$??0ImFontAtlas@@QEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	'z'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'I', 03H
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$??1ImFontAtlas@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFontAtlas@@QEAA@XZ
$cppxdata$??1ImFontAtlas@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImFontAtlas@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFontAtlas@@QEAA@XZ
$stateUnwindMap$??1ImFontAtlas@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA
$ip2state$??1ImFontAtlas@@QEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	012H
	DB	06H
	DB	016H
	DB	04H
	DB	'$'
	DB	02H
	DB	'$'
	DB	00H
$unwind$?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 010e11H
	DD	0e20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
$cppxdata$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
	DD	imagerel $ip2state$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
$stateUnwindMap$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA
$ip2state$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DB 06H
	DB	00H
	DB	00H
	DB	0d0H
	DB	02H
	DB	'X'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD 043019H
	DD	03f011eH
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z DD 043019H
	DD	039011eH
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 043019H
	DD	03d011eH
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD 011901H
	DD	0a219H
$unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 010901H
	DD	0e209H
$unwind$?ClearTexData@ImFontAtlas@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 010901H
	DD	06209H
$unwind$?Clear@ImFontAtlas@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?Build@ImFontAtlas@@QEAA_NXZ DD 010901H
	DD	04209H
$unwind$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 011801H
	DD	04218H
$unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 011801H
	DD	0a218H
$unwind$?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ DD 010901H
	DD	04209H
$unwind$?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ DD 010901H
	DD	04209H
$unwind$?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z DD 011701H
	DD	0a217H
$unwind$?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z DD 011901H
	DD	0a219H
$unwind$?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z DD 011801H
	DD	06218H
$unwind$?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z DD 021a01H
	DD	013011aH
$unwind$??0ImFont@@QEAA@XZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImFont@@QEAA@XZ
$cppxdata$??0ImFont@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImFont@@QEAA@XZ
	DD	imagerel $ip2state$??0ImFont@@QEAA@XZ
$stateUnwindMap$??0ImFont@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImFont@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImFont@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImFont@@QEAA@XZ@4HA
$ip2state$??0ImFont@@QEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'!', 03H
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0???0ImFont@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0ImFont@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???0ImFont@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$??1ImFont@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFont@@QEAA@XZ
$cppxdata$??1ImFont@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImFont@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFont@@QEAA@XZ
$stateUnwindMap$??1ImFont@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImFont@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImFont@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1ImFont@@QEAA@XZ@4HA
$ip2state$??1ImFont@@QEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	012H
	DB	06H
	DB	016H
	DB	04H
	DB	'$'
	DB	02H
	DB	'$'
	DB	00H
$unwind$?dtor$0@?0???1ImFont@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1ImFont@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???1ImFont@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z DD 010e01H
	DD	0220eH
$unwind$?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z DD 010e01H
	DD	0220eH
$unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 021d01H
	DD	011011dH
$unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 011901H
	DD	0e219H
$unwind$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z DD 021c01H
	DD	013011cH
$unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021c01H
	DD	021011cH
$unwind$?BuildLookupTable@ImFont@@QEAAXXZ DD 040e01H
	DD	017010eH
	DD	060067007H
$unwind$?ClearOutputData@ImFont@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?GrowIndex@ImFont@@QEAAXH@Z DD 010d01H
	DD	0820dH
$unwind$?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z DD 011a01H
	DD	0621aH
$unwind$?AddRemapChar@ImFont@@QEAAXGG_N@Z DD 011901H
	DD	08219H
$unwind$?SetFallbackChar@ImFont@@QEAAXG@Z DD 010e01H
	DD	0420eH
$unwind$?ImCharIsBlankA@@YA_ND@Z DD 010801H
	DD	02208H
$unwind$?ImCharIsBlankW@@YA_NI@Z DD 010801H
	DD	02208H
$unwind$??D@YA?AUImVec2@@AEBU0@M@Z DD 011401H
	DD	04214H
$unwind$??H@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$??G@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$??D@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$?ImFabs@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImSqrt@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImCos@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImSin@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImAcos@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImFloorStd@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImCeil@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	06213H
$unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	06213H
$unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD 011801H
	DD	06218H
$unwind$?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z DD 011901H
	DD	08219H
$unwind$??$ImMin@M@@YAMMM@Z DD 011001H
	DD	02210H
$unwind$??$ImMax@M@@YAMMM@Z DD 011001H
	DD	02210H
$unwind$?ImMul@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	04213H
$unwind$??0ImDrawListSharedData@@QEAA@XZ DD 030b01H
	DD	07007c20bH
	DD	06006H
$unwind$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z DD 022e19H
	DD	035011cH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z DD 021b01H
	DD	019011bH
$unwind$?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z DD 021c01H
	DD	01f011cH
$unwind$?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z DD 011801H
	DD	0c218H
$unwind$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD 011701H
	DD	0e217H
$unwind$?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z DD 021a01H
	DD	01b011aH
$unwind$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DD 031f19H
	DD	084010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	0412H
$cppxdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	imagerel $ip2state$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
$stateUnwindMap$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA
$ip2state$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 01eH
	DB	00H
	DB	00H
	DB	0e5H, 02H
	DB	02H
	DB	01cH
	DB	04H
	DB	'}', 06H
	DB	02H
	DB	01cH
	DB	00H
	DB	'.'
	DB	04H
	DB	0a0H
	DB	02H
	DB	01cH
	DB	00H
	DB	'.'
	DB	04H
	DB	'I', 014H
	DB	06H
	DB	01cH
	DB	08H
	DB	0c9H, '>'
	DB	06H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	01cH
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z DD 010901H
	DD	04209H
$unwind$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z DD 011901H
	DD	04219H
$unwind$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DD 010e11H
	DD	0c20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
$cppxdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 08H
	DD	imagerel $stateUnwindMap$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
	DD	imagerel $ip2state$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
$stateUnwindMap$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA
$ip2state$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 06H
	DB	00H
	DB	00H
	DB	'b'
	DB	02H
	DB	0e9H, 06H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 020c01H
	DD	015010cH
$unwind$?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z DD 010f01H
	DD	0220fH
$unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 011801H
	DD	02218H
$unwind$stbrp_pack_rects DD 031501H
	DD	07011a215H
	DD	06010H
$unwind$stbrp_init_target DD 011701H
	DD	06217H
$unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 011801H
	DD	04218H
$unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 041d01H
	DD	013011dH
	DD	060157016H
$unwind$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$?rect_height_compare@@YAHPEBX0@Z DD 010e01H
	DD	0420eH
$unwind$?rect_original_order@@YAHPEBX0@Z DD 010e01H
	DD	0420eH
$unwind$stbtt_PackBegin DD 011801H
	DD	0a218H
$unwind$stbtt_PackEnd DD 010901H
	DD	04209H
$unwind$stbtt_GetPackedQuad DD 011701H
	DD	08217H
$unwind$stbtt_PackFontRangesRenderIntoRects DD 021b01H
	DD	01b011bH
$unwind$stbtt_GetFontOffsetForIndex DD 010d01H
	DD	0420dH
$unwind$stbtt_InitFont DD 011301H
	DD	04213H
$unwind$stbtt_FindGlyphIndex DD 021001H
	DD	0130110H
$unwind$stbtt_ScaleForPixelHeight DD 010f01H
	DD	0620fH
$unwind$stbtt_ScaleForMappingEmToPixels DD 010f01H
	DD	0620fH
$unwind$stbtt_GetFontVMetrics DD 011801H
	DD	04218H
$unwind$stbtt_GetGlyphHMetrics DD 011701H
	DD	06217H
$unwind$stbtt_GetGlyphBox DD 011701H
	DD	08217H
$unwind$stbtt_GetGlyphShape DD 011201H
	DD	04212H
$unwind$stbtt_MakeGlyphBitmapSubpixel DD 021b01H
	DD	013011bH
$unwind$stbtt_GetGlyphBitmapBox DD 011901H
	DD	0a219H
$unwind$stbtt_GetGlyphBitmapBoxSubpixel DD 011901H
	DD	08219H
$unwind$stbtt_Rasterize DD 021c01H
	DD	011011cH
$unwind$?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z DD 010901H
	DD	02209H
$unwind$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z DD 010d01H
	DD	0220dH
$unwind$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z DD 010d01H
	DD	0420dH
$unwind$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z DD 031501H
	DD	070112215H
	DD	06010H
$unwind$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 010901H
	DD	06209H
$unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD 010901H
	DD	06209H
$unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD 031501H
	DD	07011e215H
	DD	06010H
$unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD 031901H
	DD	07015a219H
	DD	06014H
$unwind$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z DD 010901H
	DD	04209H
$unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD 031501H
	DD	07011a215H
	DD	06010H
$unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z DD 011201H
	DD	06212H
$unwind$?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD 041801H
	DD	0190118H
	DD	060107011H
$unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD 041801H
	DD	04b0118H
	DD	060107011H
$unwind$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD 011701H
	DD	0e217H
$unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 011701H
	DD	0a217H
$unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 022719H
	DD	0310115H
	DD	imagerel __GSHandlerCheck
	DD	0178H
$unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 011701H
	DD	06217H
$unwind$?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z DD 010901H
	DD	08209H
$unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD 011501H
	DD	0a215H
$unwind$?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z DD 011501H
	DD	08215H
$unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD 011b01H
	DD	0a21bH
$unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD 041801H
	DD	0110118H
	DD	060107011H
$unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD 041801H
	DD	01d0118H
	DD	060107011H
$unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD 042919H
	DD	05d0117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 021501H
	DD	0130115H
$unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD 011301H
	DD	08213H
$unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD 011901H
	DD	08219H
$unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 021b01H
	DD	017011bH
$unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 022d19H
	DD	05b011bH
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 031e19H
	DD	0700ba20fH
	DD	0600aH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 042419H
	DD	0130112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD 010d01H
	DD	0420dH
$unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021b01H
	DD	013011bH
$unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 011a01H
	DD	0c21aH
$unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 021d01H
	DD	01b011dH
$unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 042301H
	DD	0a6823H
	DD	017011bH
$unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 012619H
	DD	0a217H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 012619H
	DD	0a217H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z DD 021e01H
	DD	017011eH
$unwind$??$ImClamp@M@@YAMMMM@Z DD 011601H
	DD	02216H
$unwind$?stb_decompress@@YAIPEAEPEBEI@Z DD 011301H
	DD	06213H
$unwind$?Decode85Byte@@YAID@Z DD 010801H
	DD	02208H
$unwind$?Decode85@@YAXPEBEPEAE@Z DD 010e01H
	DD	0820eH
$unwind$?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z DD 010e01H
	DD	0a20eH
$unwind$??$ImMax@H@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z DD 010901H
	DD	0c209H
$unwind$?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z DD 011701H
	DD	02217H
$unwind$?ImAcos01@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$??$ImSwap@M@@YAXAEAM0@Z DD 010e01H
	DD	0220eH
$unwind$?stb__match@@YAXPEBEI@Z DD 010d01H
	DD	0220dH
$unwind$?stb__lit@@YAXPEBEI@Z DD 010d01H
	DD	0420dH
$unwind$?stb_decompress_token@@YAPEBEPEBE@Z DD 010901H
	DD	04209H
$unwind$?stb_adler32@@YAIIPEAEI@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?round@@YAMM@Z DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fabsf DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MallocaComputeSize DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA$initializer$@@3P6AXXZEA DQ FLAT:??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ ; FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
s1$ = 0
s2$ = 4
i$ = 8
blocklen$ = 12
tv149 = 16
ADLER_MOD$ = 20
adler32$ = 48
buffer$ = 56
buflen$ = 64
?stb_adler32@@YAIIPEAEI@Z PROC				; stb_adler32

; 3272 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 3273 :     const unsigned long ADLER_MOD = 65521;

	mov	DWORD PTR ADLER_MOD$[rsp], 65521	; 0000fff1H

; 3274 :     unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;

	mov	eax, DWORD PTR adler32$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR adler32$[rsp]
	shr	eax, 16
	mov	DWORD PTR s2$[rsp], eax

; 3275 :     unsigned long blocklen, i;
; 3276 : 
; 3277 :     blocklen = buflen % 5552;

	xor	edx, edx
	mov	eax, DWORD PTR buflen$[rsp]
	mov	ecx, 5552				; 000015b0H
	div	ecx
	mov	eax, edx
	mov	DWORD PTR blocklen$[rsp], eax
$LN2@stb_adler3:

; 3278 :     while (buflen) {

	cmp	DWORD PTR buflen$[rsp], 0
	je	$LN3@stb_adler3

; 3279 :         for (i = 0; i + 7 < blocklen; i += 8) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN6@stb_adler3
$LN4@stb_adler3:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	DWORD PTR i$[rsp], eax
$LN6@stb_adler3:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 7
	cmp	eax, DWORD PTR blocklen$[rsp]
	jae	$LN5@stb_adler3

; 3280 :             s1 += buffer[0], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3281 :             s1 += buffer[1], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3282 :             s1 += buffer[2], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3283 :             s1 += buffer[3], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3284 :             s1 += buffer[4], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 4
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3285 :             s1 += buffer[5], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 5
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3286 :             s1 += buffer[6], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 6
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3287 :             s1 += buffer[7], s2 += s1;

	mov	eax, 1
	imul	rax, rax, 7
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 3288 : 
; 3289 :             buffer += 8;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 8
	mov	QWORD PTR buffer$[rsp], rax

; 3290 :         }

	jmp	$LN4@stb_adler3
$LN5@stb_adler3:

; 3291 : 
; 3292 :         for (; i < blocklen; ++i)

	jmp	SHORT $LN9@stb_adler3
$LN7@stb_adler3:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@stb_adler3:
	mov	eax, DWORD PTR blocklen$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN8@stb_adler3

; 3293 :             s1 += *buffer++, s2 += s1;

	mov	rax, QWORD PTR buffer$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv149[rsp], eax
	mov	rax, QWORD PTR buffer$[rsp]
	inc	rax
	mov	QWORD PTR buffer$[rsp], rax
	mov	eax, DWORD PTR tv149[rsp]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s2$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax
	jmp	SHORT $LN7@stb_adler3
$LN8@stb_adler3:

; 3294 : 
; 3295 :         s1 %= ADLER_MOD, s2 %= ADLER_MOD;

	xor	edx, edx
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, 65521				; 0000fff1H
	div	ecx
	mov	eax, edx
	mov	DWORD PTR s1$[rsp], eax
	xor	edx, edx
	mov	eax, DWORD PTR s2$[rsp]
	mov	ecx, 65521				; 0000fff1H
	div	ecx
	mov	eax, edx
	mov	DWORD PTR s2$[rsp], eax

; 3296 :         buflen -= blocklen;

	mov	eax, DWORD PTR blocklen$[rsp]
	mov	ecx, DWORD PTR buflen$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR buflen$[rsp], eax

; 3297 :         blocklen = 5552;

	mov	DWORD PTR blocklen$[rsp], 5552		; 000015b0H

; 3298 :     }

	jmp	$LN2@stb_adler3
$LN3@stb_adler3:

; 3299 :     return (unsigned int)(s2 << 16) + (unsigned int)s1;

	mov	eax, DWORD PTR s2$[rsp]
	shl	eax, 16
	add	eax, DWORD PTR s1$[rsp]

; 3300 : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_adler32@@YAIIPEAEI@Z ENDP				; stb_adler32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$ = 48
?stb_decompress_token@@YAPEBEPEBE@Z PROC		; stb_decompress_token

; 3254 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3255 :     if (*i >= 0x20) { // use fewer if's for cases that expand small

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jl	$LN2@stb_decomp

; 3256 :         if (*i >= 0x80)       stb__match(stb__dout - i[1] - 1, i[0] - 0x80 + 1), i += 2;

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN4@stb_decomp
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 127				; 0000007fH
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	rdx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rdx, rcx
	mov	rcx, rdx
	dec	rcx
	mov	edx, eax
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	mov	rax, QWORD PTR i$[rsp]
	add	rax, 2
	mov	QWORD PTR i$[rsp], rax
	jmp	$LN5@stb_decomp
$LN4@stb_decomp:

; 3257 :         else if (*i >= 0x40)  stb__match(stb__dout - (stb__in2(0) - 0x4000 + 1), i[2] + 1), i += 3;

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	jl	SHORT $LN6@stb_decomp
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	inc	eax
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 8
	mov	edx, 1
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	lea	ecx, DWORD PTR [rcx+rdx-16383]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	mov	rax, QWORD PTR i$[rsp]
	add	rax, 3
	mov	QWORD PTR i$[rsp], rax
	jmp	SHORT $LN7@stb_decomp
$LN6@stb_decomp:

; 3258 :         else /* *i >= 0x20 */ stb__lit(i + 1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 31
	mov	rcx, QWORD PTR i$[rsp]
	inc	rcx
	mov	edx, eax
	call	?stb__lit@@YAXPEBEI@Z			; stb__lit
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 30
	cdqe
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR i$[rsp], rax
$LN7@stb_decomp:
$LN5@stb_decomp:

; 3259 :     }

	jmp	$LN3@stb_decomp
$LN2@stb_decomp:

; 3260 :     else { // more ifs for cases that expand large, since overhead is amortized
; 3261 :         if (*i >= 0x18)       stb__match(stb__dout - (stb__in3(0) - 0x180000 + 1), i[3] + 1), i += 4;

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 24
	jl	$LN8@stb_decomp
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	inc	eax
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	mov	edx, 1
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 8
	mov	r8d, 1
	imul	r8, r8, 2
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	add	edx, r8d
	lea	ecx, DWORD PTR [rcx+rdx-1572863]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	mov	rax, QWORD PTR i$[rsp]
	add	rax, 4
	mov	QWORD PTR i$[rsp], rax
	jmp	$LN9@stb_decomp
$LN8@stb_decomp:

; 3262 :         else if (*i >= 0x10)  stb__match(stb__dout - (stb__in3(0) - 0x100000 + 1), stb__in2(3) + 1), i += 5;

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 16
	jl	$LN10@stb_decomp
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	mov	edx, 1
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 8
	mov	r8d, 1
	imul	r8, r8, 2
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	add	edx, r8d
	lea	ecx, DWORD PTR [rcx+rdx-1048575]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	mov	rax, QWORD PTR i$[rsp]
	add	rax, 5
	mov	QWORD PTR i$[rsp], rax
	jmp	$LN11@stb_decomp
$LN10@stb_decomp:

; 3263 :         else if (*i >= 0x08)  stb__lit(i + 2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	jl	$LN12@stb_decomp
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx-2047]
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, 2
	mov	edx, eax
	call	?stb__lit@@YAXPEBEI@Z			; stb__lit
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx-2045]
	cdqe
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR i$[rsp], rax
	jmp	$LN13@stb_decomp
$LN12@stb_decomp:

; 3264 :         else if (*i == 0x07)  stb__lit(i + 3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 7
	jne	SHORT $LN14@stb_decomp
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, 3
	mov	edx, eax
	call	?stb__lit@@YAXPEBEI@Z			; stb__lit
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+4]
	cdqe
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR i$[rsp], rax
	jmp	$LN15@stb_decomp
$LN14@stb_decomp:

; 3265 :         else if (*i == 0x06)  stb__match(stb__dout - (stb__in3(1) + 1), i[4] + 1), i += 5;

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 6
	jne	$LN16@stb_decomp
	mov	eax, 1
	imul	rax, rax, 4
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	inc	eax
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	mov	edx, 1
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 8
	mov	r8d, 1
	imul	r8, r8, 3
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	add	edx, r8d
	lea	ecx, DWORD PTR [rcx+rdx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	mov	rax, QWORD PTR i$[rsp]
	add	rax, 5
	mov	QWORD PTR i$[rsp], rax
	jmp	$LN17@stb_decomp
$LN16@stb_decomp:

; 3266 :         else if (*i == 0x04)  stb__match(stb__dout - (stb__in3(1) + 1), stb__in2(4) + 1), i += 6;

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 4
	jne	$LN18@stb_decomp
	mov	eax, 1
	imul	rax, rax, 4
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	mov	edx, 1
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 8
	mov	r8d, 1
	imul	r8, r8, 3
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	add	edx, r8d
	lea	ecx, DWORD PTR [rcx+rdx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	mov	rax, QWORD PTR i$[rsp]
	add	rax, 6
	mov	QWORD PTR i$[rsp], rax
$LN18@stb_decomp:
$LN17@stb_decomp:
$LN15@stb_decomp:
$LN13@stb_decomp:
$LN11@stb_decomp:
$LN9@stb_decomp:
$LN3@stb_decomp:

; 3267 :     }
; 3268 :     return i;

	mov	rax, QWORD PTR i$[rsp]

; 3269 : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_decompress_token@@YAPEBEPEBE@Z ENDP		; stb_decompress_token
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
data$ = 48
length$ = 56
?stb__lit@@YAXPEBEI@Z PROC				; stb__lit

; 3241 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3242 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
; 3243 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

	mov	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
	jbe	SHORT $LN2@stb__lit
	mov	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	jmp	SHORT $LN1@stb__lit
$LN2@stb__lit:

; 3244 :     if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e + 1; return; }

	mov	rax, QWORD PTR ?stb__barrier_in_b@@3PEBEEB
	cmp	QWORD PTR data$[rsp], rax
	jae	SHORT $LN3@stb__lit
	mov	rax, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
	inc	rax
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	jmp	SHORT $LN1@stb__lit
$LN3@stb__lit:

; 3245 :     memcpy(stb__dout, data, length);

	mov	eax, DWORD PTR length$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	call	memcpy

; 3246 :     stb__dout += length;

	mov	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
$LN1@stb__lit:

; 3247 : }

	add	rsp, 40					; 00000028H
	ret	0
?stb__lit@@YAXPEBEI@Z ENDP				; stb__lit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv77 = 0
tv73 = 4
data$ = 32
length$ = 40
?stb__match@@YAXPEBEI@Z PROC				; stb__match

; 3232 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 3233 :     // INVERSE of memmove... write each byte before copying the next...
; 3234 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
; 3235 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

	mov	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
	jbe	SHORT $LN4@stb__match
	mov	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	jmp	SHORT $LN1@stb__match
$LN4@stb__match:

; 3236 :     if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e + 1; return; }

	mov	rax, QWORD PTR ?stb__barrier_out_b@@3PEAEEA
	cmp	QWORD PTR data$[rsp], rax
	jae	SHORT $LN5@stb__match
	mov	rax, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
	inc	rax
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	jmp	SHORT $LN1@stb__match
$LN5@stb__match:
$LN2@stb__match:

; 3237 :     while (length--) *stb__dout++ = *data++;

	mov	eax, DWORD PTR length$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	mov	eax, DWORD PTR length$[rsp]
	dec	eax
	mov	DWORD PTR length$[rsp], eax
	cmp	DWORD PTR tv73[rsp], 0
	je	SHORT $LN3@stb__match
	mov	rax, QWORD PTR data$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv77[rsp], al
	mov	rax, QWORD PTR data$[rsp]
	inc	rax
	mov	QWORD PTR data$[rsp], rax
	mov	rax, QWORD PTR ?stb__dout@@3PEAEEA
	movzx	ecx, BYTE PTR tv77[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR ?stb__dout@@3PEAEEA
	inc	rax
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	jmp	SHORT $LN2@stb__match
$LN3@stb__match:
$LN1@stb__match:

; 3238 : }

	add	rsp, 24
	ret	0
?stb__match@@YAXPEBEI@Z ENDP				; stb__match
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR b$[rsp]
	subss	xmm0, DWORD PTR a$[rsp]
	mulss	xmm0, DWORD PTR t$[rsp]
	movss	xmm1, DWORD PTR a$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	ret	0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tmp$ = 0
a$ = 32
b$ = 40
??$ImSwap@M@@YAXAEAM0@Z PROC				; ImSwap<float>

; 231  : template<typename T> static inline void ImSwap(T& a, T& b) { T tmp = a; a = b; b = tmp; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tmp$[rsp], xmm0
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR tmp$[rsp]
	movss	DWORD PTR [rax], xmm0
	add	rsp, 24
	ret	0
??$ImSwap@M@@YAXAEAM0@Z ENDP				; ImSwap<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
x$ = 48
?ImAcos01@@YAMM@Z PROC					; ImAcos01

; 3134 : {

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 3135 :     if (x <= 0.0f) return IM_PI * 0.5f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR x$[rsp]
	jb	SHORT $LN2@ImAcos01
	movss	xmm0, DWORD PTR __real@3fc90fdb
	jmp	SHORT $LN1@ImAcos01
$LN2@ImAcos01:

; 3136 :     if (x >= 1.0f) return 0.0f;

	movss	xmm0, DWORD PTR x$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN3@ImAcos01
	xorps	xmm0, xmm0
	jmp	SHORT $LN1@ImAcos01
$LN3@ImAcos01:

; 3137 :     return ImAcos(x);

	movss	xmm0, DWORD PTR x$[rsp]
	call	?ImAcos@@YAMM@Z				; ImAcos
$LN1@ImAcos01:

; 3138 :     //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
; 3139 : }

	add	rsp, 40					; 00000028H
	ret	0
?ImAcos01@@YAMM@Z ENDP					; ImAcos01
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
n$1 = 0
tv75 = 4
base_codepoint$ = 32
accumulative_offsets$ = 40
accumulative_offsets_count$ = 48
out_ranges$ = 56
?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z PROC ; UnpackAccumulativeOffsetsIntoRanges

; 2331 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 2332 :     for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@UnpackAccu
$LN2@UnpackAccu:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
	mov	rax, QWORD PTR out_ranges$[rsp]
	add	rax, 4
	mov	QWORD PTR out_ranges$[rsp], rax
$LN4@UnpackAccu:
	mov	eax, DWORD PTR accumulative_offsets_count$[rsp]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@UnpackAccu

; 2333 :     {
; 2334 :         out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR accumulative_offsets$[rsp]
	movsx	eax, WORD PTR [rcx+rax*2]
	mov	ecx, DWORD PTR base_codepoint$[rsp]
	add	ecx, eax
	mov	DWORD PTR tv75[rsp], ecx
	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out_ranges$[rsp]
	movzx	edx, WORD PTR tv75[rsp]
	mov	WORD PTR [rcx+rax], dx
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out_ranges$[rsp]
	movzx	edx, WORD PTR tv75[rsp]
	mov	WORD PTR [rcx+rax], dx

; 2335 :         base_codepoint += accumulative_offsets[n];

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR accumulative_offsets$[rsp]
	movsx	eax, WORD PTR [rcx+rax*2]
	mov	ecx, DWORD PTR base_codepoint$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base_codepoint$[rsp], eax

; 2336 :     }

	jmp	SHORT $LN2@UnpackAccu
$LN3@UnpackAccu:

; 2337 :     out_ranges[0] = 0;

	mov	eax, 2
	imul	rax, rax, 0
	xor	ecx, ecx
	mov	rdx, QWORD PTR out_ranges$[rsp]
	mov	WORD PTR [rdx+rax], cx

; 2338 : }

	add	rsp, 24
	ret	0
?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z ENDP ; UnpackAccumulativeOffsetsIntoRanges
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
x$1 = 32
y$2 = 36
n$3 = 40
w$ = 44
offset$4 = 48
r$ = 56
offset0$5 = 64
tv133 = 68
tv144 = 72
offset1$6 = 76
tv72 = 80
$T7 = 88
atlas$ = 112
?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRenderDefaultTexData

; 2238 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2239 :     IM_ASSERT(atlas->CustomRectIds[0] >= 0);
; 2240 :     IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);
; 2241 :     ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR tv72[rsp], rax
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	edx, DWORD PTR [rcx+rax+120]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	mov	QWORD PTR r$[rsp], rax

; 2242 :     IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
; 2243 :     IM_ASSERT(r.IsPacked());
; 2244 : 
; 2245 :     const int w = atlas->TexWidth;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR w$[rsp], eax

; 2246 :     if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 2
	test	eax, eax
	jne	$LN8@ImFontAtla

; 2247 :     {
; 2248 :         // Render/copy pixels
; 2249 :         IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
; 2250 :         for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)

	mov	DWORD PTR y$2[rsp], 0
	mov	DWORD PTR n$3[rsp], 0
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR y$2[rsp]
	inc	eax
	mov	DWORD PTR y$2[rsp], eax
$LN4@ImFontAtla:
	cmp	DWORD PTR y$2[rsp], 27
	jge	$LN3@ImFontAtla

; 2251 :             for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)

	mov	DWORD PTR x$1[rsp], 0
	jmp	SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
	mov	eax, DWORD PTR x$1[rsp]
	inc	eax
	mov	DWORD PTR x$1[rsp], eax
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN7@ImFontAtla:
	cmp	DWORD PTR x$1[rsp], 108			; 0000006cH
	jge	$LN6@ImFontAtla

; 2252 :             {
; 2253 :                 const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax]
	add	eax, DWORD PTR x$1[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movzx	ecx, WORD PTR [rcx+2]
	add	ecx, DWORD PTR y$2[rsp]
	imul	ecx, DWORD PTR w$[rsp]
	add	eax, ecx
	mov	DWORD PTR offset0$5[rsp], eax

; 2254 :                 const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;

	mov	eax, DWORD PTR offset0$5[rsp]
	add	eax, 109				; 0000006dH
	mov	DWORD PTR offset1$6[rsp], eax

; 2255 :                 atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;

	movsxd	rax, DWORD PTR n$3[rsp]
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN11@ImFontAtla
	mov	DWORD PTR tv133[rsp], 255		; 000000ffH
	jmp	SHORT $LN12@ImFontAtla
$LN11@ImFontAtla:
	mov	DWORD PTR tv133[rsp], 0
$LN12@ImFontAtla:
	movsxd	rax, DWORD PTR offset0$5[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	movzx	edx, BYTE PTR tv133[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 2256 :                 atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;

	movsxd	rax, DWORD PTR n$3[rsp]
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN13@ImFontAtla
	mov	DWORD PTR tv144[rsp], 255		; 000000ffH
	jmp	SHORT $LN14@ImFontAtla
$LN13@ImFontAtla:
	mov	DWORD PTR tv144[rsp], 0
$LN14@ImFontAtla:
	movsxd	rax, DWORD PTR offset1$6[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	movzx	edx, BYTE PTR tv144[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 2257 :             }

	jmp	$LN5@ImFontAtla
$LN6@ImFontAtla:
	jmp	$LN2@ImFontAtla
$LN3@ImFontAtla:

; 2258 :     }

	jmp	SHORT $LN9@ImFontAtla
$LN8@ImFontAtla:

; 2259 :     else
; 2260 :     {
; 2261 :         IM_ASSERT(r.Width == 2 && r.Height == 2);
; 2262 :         const int offset = (int)(r.X) + (int)(r.Y) * w;

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR r$[rsp]
	movzx	ecx, WORD PTR [rcx+2]
	imul	ecx, DWORD PTR w$[rsp]
	add	eax, ecx
	mov	DWORD PTR offset$4[rsp], eax

; 2263 :         atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;

	mov	eax, DWORD PTR offset$4[rsp]
	mov	ecx, DWORD PTR w$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdqe
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	mov	eax, DWORD PTR w$[rsp]
	mov	ecx, DWORD PTR offset$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	mov	eax, DWORD PTR offset$4[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR offset$4[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
$LN9@ImFontAtla:

; 2264 :     }
; 2265 :     atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR atlas$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax]
	cvtsi2ss xmm1, eax
	addss	xmm1, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR atlas$[rsp]
	mulss	xmm1, DWORD PTR [rax+32]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2266 : }

	add	rsp, 104				; 00000068H
	ret	0
?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRenderDefaultTexData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z PROC	; ImVector<stbtt_packedchar>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 28
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 28
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ENDP	; ImVector<stbtt_packedchar>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z PROC	; ImVector<stbtt_packedchar>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ; ImVector<stbtt_packedchar>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ENDP	; ImVector<stbtt_packedchar>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z PROC ; ImVector<stbtt_packedchar>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ENDP ; ImVector<stbtt_packedchar>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z PROC ; ImVector<stbtt_packedchar>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 28
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ENDP ; ImVector<stbtt_packedchar>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ PROC ; ImVector<stbtt_packedchar>::size_in_bytes, COMDAT

; 1226 : 	inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	imul	eax, DWORD PTR [rax], 28
	ret	0
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ENDP ; ImVector<stbtt_packedchar>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ PROC		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ENDP		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ PROC		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ENDP		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z PROC	; ImVector<stbrp_rect>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 16
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ENDP	; ImVector<stbrp_rect>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z PROC		; ImVector<stbrp_rect>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ; ImVector<stbrp_rect>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ; ImVector<stbrp_rect>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ENDP		; ImVector<stbrp_rect>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z PROC	; ImVector<stbrp_rect>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ENDP	; ImVector<stbrp_rect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ PROC		; ImVector<stbrp_rect>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ ENDP		; ImVector<stbrp_rect>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z PROC ; ImVector<stbrp_rect>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ENDP ; ImVector<stbrp_rect>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ PROC	; ImVector<stbrp_rect>::size_in_bytes, COMDAT

; 1226 : 	inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	imul	eax, DWORD PTR [rax], 16
	ret	0
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ENDP	; ImVector<stbrp_rect>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ PROC		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ENDP		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ PROC		; ImVector<stbrp_rect>::ImVector<stbrp_rect>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ ENDP		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR rhs$[rsp]
	cmp	DWORD PTR lhs$[rsp], eax
	jl	SHORT $LN3@ImMax
	mov	eax, DWORD PTR lhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	eax, DWORD PTR rhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@ImMax:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z PROC ; ImVector<ImFontBuildDstData>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ENDP ; ImVector<ImFontBuildDstData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z PROC	; ImVector<ImFontBuildDstData>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ; ImVector<ImFontBuildDstData>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ENDP	; ImVector<ImFontBuildDstData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z PROC ; ImVector<ImFontBuildDstData>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ENDP ; ImVector<ImFontBuildDstData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ PROC	; ImVector<ImFontBuildDstData>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ENDP	; ImVector<ImFontBuildDstData>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z PROC ; ImVector<ImFontBuildDstData>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ENDP ; ImVector<ImFontBuildDstData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ PROC ; ImVector<ImFontBuildDstData>::size_in_bytes, COMDAT

; 1226 : 	inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	imul	eax, DWORD PTR [rax], 32		; 00000020H
	ret	0
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ENDP ; ImVector<ImFontBuildDstData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z PROC ; ImVector<ImFontBuildSrcData>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 272				; 00000110H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 272				; 00000110H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ENDP ; ImVector<ImFontBuildSrcData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z PROC	; ImVector<ImFontBuildSrcData>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ; ImVector<ImFontBuildSrcData>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ENDP	; ImVector<ImFontBuildSrcData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z PROC ; ImVector<ImFontBuildSrcData>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ENDP ; ImVector<ImFontBuildSrcData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z PROC ; ImVector<ImFontBuildSrcData>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 272				; 00000110H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ENDP ; ImVector<ImFontBuildSrcData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ PROC ; ImVector<ImFontBuildSrcData>::size_in_bytes, COMDAT

; 1226 : 	inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	imul	eax, DWORD PTR [rax], 272		; 00000110H
	ret	0
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ENDP ; ImVector<ImFontBuildSrcData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
bit_n$1 = 32
entries_32$2 = 36
tv95 = 40
$T3 = 44
it$4 = 48
it_begin$ = 56
it_end$ = 64
in$ = 96
out$ = 104
?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z PROC ; UnpackBoolVectorToFlatIndexList

; 1919 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1920 :     IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
; 1921 :     const int* it_begin = in->Storage.begin();

	mov	rax, QWORD PTR in$[rsp]
	mov	rcx, rax
	call	?begin@?$ImVector@H@@QEBAPEBHXZ		; ImVector<int>::begin
	mov	QWORD PTR it_begin$[rsp], rax

; 1922 :     const int* it_end = in->Storage.end();

	mov	rax, QWORD PTR in$[rsp]
	mov	rcx, rax
	call	?end@?$ImVector@H@@QEBAPEBHXZ		; ImVector<int>::end
	mov	QWORD PTR it_end$[rsp], rax

; 1923 :     for (const int* it = it_begin; it < it_end; it++)

	mov	rax, QWORD PTR it_begin$[rsp]
	mov	QWORD PTR it$4[rsp], rax
	jmp	SHORT $LN4@UnpackBool
$LN2@UnpackBool:
	mov	rax, QWORD PTR it$4[rsp]
	add	rax, 4
	mov	QWORD PTR it$4[rsp], rax
$LN4@UnpackBool:
	mov	rax, QWORD PTR it_end$[rsp]
	cmp	QWORD PTR it$4[rsp], rax
	jae	$LN3@UnpackBool

; 1924 :         if (int entries_32 = *it)

	mov	rax, QWORD PTR it$4[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR entries_32$2[rsp], eax
	cmp	DWORD PTR entries_32$2[rsp], 0
	je	SHORT $LN8@UnpackBool

; 1925 :             for (int bit_n = 0; bit_n < 32; bit_n++)

	mov	DWORD PTR bit_n$1[rsp], 0
	jmp	SHORT $LN7@UnpackBool
$LN5@UnpackBool:
	mov	eax, DWORD PTR bit_n$1[rsp]
	inc	eax
	mov	DWORD PTR bit_n$1[rsp], eax
$LN7@UnpackBool:
	cmp	DWORD PTR bit_n$1[rsp], 32		; 00000020H
	jge	SHORT $LN6@UnpackBool

; 1926 :                 if (entries_32 & (1 << bit_n))

	mov	eax, DWORD PTR bit_n$1[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv95[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv95[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR entries_32$2[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN9@UnpackBool

; 1927 :                     out->push_back((int)((it - it_begin) << 5) + bit_n);

	mov	rax, QWORD PTR it_begin$[rsp]
	mov	rcx, QWORD PTR it$4[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 2
	shl	rax, 5
	add	eax, DWORD PTR bit_n$1[rsp]
	mov	DWORD PTR $T3[rsp], eax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	call	?push_back@?$ImVector@H@@QEAAXAEBH@Z	; ImVector<int>::push_back
	npad	1
$LN9@UnpackBool:
	jmp	SHORT $LN5@UnpackBool
$LN6@UnpackBool:
$LN8@UnpackBool:
	jmp	$LN2@UnpackBool
$LN3@UnpackBool:

; 1928 : }

	add	rsp, 88					; 00000058H
	ret	0
?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z ENDP ; UnpackBoolVectorToFlatIndexList
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImFontBuildSrcData@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImFontBuildSrcData@@QEAAPEAXI@Z PROC		; ImFontBuildSrcData::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImFontBuildSrcData@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 272				; 00000110H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImFontBuildSrcData@@QEAAPEAXI@Z ENDP		; ImFontBuildSrcData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImFontBuildSrcData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImFontBuildSrcData@@QEAA@XZ PROC			; ImFontBuildSrcData::~ImFontBuildSrcData, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	rcx, rax
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 240				; 000000f0H
	mov	rcx, rax
	call	??1ImBoolVector@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImFontBuildSrcData@@QEAA@XZ ENDP			; ImFontBuildSrcData::~ImFontBuildSrcData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA PROC	; `ImFontBuildSrcData::~ImFontBuildSrcData'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	call	??1ImBoolVector@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA ENDP	; `ImFontBuildSrcData::~ImFontBuildSrcData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA PROC	; `ImFontBuildSrcData::~ImFontBuildSrcData'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 256				; 00000100H
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImFontBuildSrcData@@QEAA@XZ@4HA ENDP	; `ImFontBuildSrcData::~ImFontBuildSrcData'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tmp$1 = 32
tv78 = 36
tv74 = 40
tv70 = 44
tv66 = 48
src$ = 80
dst$ = 88
?Decode85@@YAXPEBEPEAE@Z PROC				; Decode85

; 1722 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
$LN2@Decode85:

; 1723 :     while (*src)

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@Decode85

; 1724 :     {
; 1725 :         unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx+rax]
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	mov	DWORD PTR tv66[rsp], eax
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	mov	DWORD PTR tv70[rsp], eax
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	mov	DWORD PTR tv74[rsp], eax
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	mov	DWORD PTR tv78[rsp], eax
	mov	ecx, 1
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	imul	eax, eax, 85				; 00000055H
	mov	ecx, DWORD PTR tv78[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 85				; 00000055H
	mov	ecx, DWORD PTR tv74[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 85				; 00000055H
	mov	ecx, DWORD PTR tv70[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 85				; 00000055H
	mov	ecx, DWORD PTR tv66[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tmp$1[rsp], eax

; 1726 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.

	mov	eax, DWORD PTR tmp$1[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR tmp$1[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR tmp$1[rsp]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR tmp$1[rsp]
	shr	eax, 24
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 1727 :         src += 5;

	mov	rax, QWORD PTR src$[rsp]
	add	rax, 5
	mov	QWORD PTR src$[rsp], rax

; 1728 :         dst += 4;

	mov	rax, QWORD PTR dst$[rsp]
	add	rax, 4
	mov	QWORD PTR dst$[rsp], rax

; 1729 :     }

	jmp	$LN2@Decode85
$LN3@Decode85:

; 1730 : }

	add	rsp, 72					; 00000048H
	ret	0
?Decode85@@YAXPEBEPEAE@Z ENDP				; Decode85
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv70 = 0
c$ = 32
?Decode85Byte@@YAID@Z PROC				; Decode85Byte

; 1720 : static unsigned int Decode85Byte(char c) { return c >= '\\' ? c - 36 : c - 35; }

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 92					; 0000005cH
	jl	SHORT $LN3@Decode85By
	movsx	eax, BYTE PTR c$[rsp]
	sub	eax, 36					; 00000024H
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@Decode85By
$LN3@Decode85By:
	movsx	eax, BYTE PTR c$[rsp]
	sub	eax, 35					; 00000023H
	mov	DWORD PTR tv70[rsp], eax
$LN4@Decode85By:
	mov	eax, DWORD PTR tv70[rsp]
	add	rsp, 24
	ret	0
?Decode85Byte@@YAID@Z ENDP				; Decode85Byte
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
olen$ = 32
old_i$1 = 40
output$ = 64
i$ = 72
__formal$ = 80
?stb_decompress@@YAIPEAEPEBEI@Z PROC			; stb_decompress

; 3303 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3304 :     unsigned int olen;
; 3305 :     if (stb__in4(0) != 0x57bC0000) return 0;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 24
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	mov	edx, 1
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 8
	mov	r8d, 1
	imul	r8, r8, 3
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	add	edx, r8d
	add	ecx, edx
	add	eax, ecx
	cmp	eax, 1471938560				; 57bc0000H
	je	SHORT $LN5@stb_decomp
	xor	eax, eax
	jmp	$LN1@stb_decomp
$LN5@stb_decomp:

; 3306 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

	mov	eax, 1
	imul	rax, rax, 4
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 24
	mov	ecx, 1
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	mov	edx, 1
	imul	rdx, rdx, 6
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 8
	mov	r8d, 1
	imul	r8, r8, 7
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	add	edx, r8d
	add	ecx, edx
	add	eax, ecx
	test	eax, eax
	je	SHORT $LN6@stb_decomp
	xor	eax, eax
	jmp	$LN1@stb_decomp
$LN6@stb_decomp:

; 3307 :     olen = stb_decompress_length(i);

	mov	rcx, QWORD PTR i$[rsp]
	call	?stb_decompress_length@@YAIPEBE@Z	; stb_decompress_length
	mov	DWORD PTR olen$[rsp], eax

; 3308 :     stb__barrier_in_b = i;

	mov	rax, QWORD PTR i$[rsp]
	mov	QWORD PTR ?stb__barrier_in_b@@3PEBEEB, rax

; 3309 :     stb__barrier_out_e = output + olen;

	mov	eax, DWORD PTR olen$[rsp]
	mov	rcx, QWORD PTR output$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?stb__barrier_out_e@@3PEAEEA, rax

; 3310 :     stb__barrier_out_b = output;

	mov	rax, QWORD PTR output$[rsp]
	mov	QWORD PTR ?stb__barrier_out_b@@3PEAEEA, rax

; 3311 :     i += 16;

	mov	rax, QWORD PTR i$[rsp]
	add	rax, 16
	mov	QWORD PTR i$[rsp], rax

; 3312 : 
; 3313 :     stb__dout = output;

	mov	rax, QWORD PTR output$[rsp]
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
$LN2@stb_decomp:

; 3314 :     for (;;) {
; 3315 :         const unsigned char* old_i = i;

	mov	rax, QWORD PTR i$[rsp]
	mov	QWORD PTR old_i$1[rsp], rax

; 3316 :         i = stb_decompress_token(i);

	mov	rcx, QWORD PTR i$[rsp]
	call	?stb_decompress_token@@YAPEBEPEBE@Z	; stb_decompress_token
	mov	QWORD PTR i$[rsp], rax

; 3317 :         if (i == old_i) {

	mov	rax, QWORD PTR old_i$1[rsp]
	cmp	QWORD PTR i$[rsp], rax
	jne	$LN7@stb_decomp

; 3318 :             if (*i == 0x05 && i[1] == 0xfa) {

	mov	rax, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 5
	jne	$LN8@stb_decomp
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 250				; 000000faH
	jne	$LN8@stb_decomp

; 3319 :                 IM_ASSERT(stb__dout == output + olen);
; 3320 :                 if (stb__dout != output + olen) return 0;

	mov	eax, DWORD PTR olen$[rsp]
	mov	rcx, QWORD PTR output$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR ?stb__dout@@3PEAEEA, rax
	je	SHORT $LN10@stb_decomp
	xor	eax, eax
	jmp	$LN1@stb_decomp
$LN10@stb_decomp:

; 3321 :                 if (stb_adler32(1, output, olen) != (unsigned int)stb__in4(2))

	mov	r8d, DWORD PTR olen$[rsp]
	mov	rdx, QWORD PTR output$[rsp]
	mov	ecx, 1
	call	?stb_adler32@@YAIIPEAEI@Z		; stb_adler32
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR i$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 24
	mov	edx, 1
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR i$[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	shl	edx, 16
	mov	r8d, 1
	imul	r8, r8, 4
	mov	r9, QWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	shl	r8d, 8
	mov	r9d, 1
	imul	r9, r9, 5
	mov	r10, QWORD PTR i$[rsp]
	movzx	r9d, BYTE PTR [r10+r9]
	add	r8d, r9d
	add	edx, r8d
	add	ecx, edx
	cmp	eax, ecx
	je	SHORT $LN11@stb_decomp

; 3322 :                     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stb_decomp
$LN11@stb_decomp:

; 3323 :                 return olen;

	mov	eax, DWORD PTR olen$[rsp]
	jmp	SHORT $LN1@stb_decomp

; 3324 :             }

	jmp	SHORT $LN9@stb_decomp
$LN8@stb_decomp:

; 3325 :             else {
; 3326 :                 IM_ASSERT(0); /* NOTREACHED */
; 3327 :                 return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stb_decomp
$LN9@stb_decomp:
$LN7@stb_decomp:

; 3328 :             }
; 3329 :         }
; 3330 :         IM_ASSERT(stb__dout <= output + olen);
; 3331 :         if (stb__dout > output + olen)

	mov	eax, DWORD PTR olen$[rsp]
	mov	rcx, QWORD PTR output$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR ?stb__dout@@3PEAEEA, rax
	jbe	SHORT $LN12@stb_decomp

; 3332 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stb_decomp
$LN12@stb_decomp:

; 3333 :     }

	jmp	$LN2@stb_decomp
$LN1@stb_decomp:

; 3334 : }

	add	rsp, 56					; 00000038H
	ret	0
?stb_decompress@@YAIPEAEPEBEI@Z ENDP			; stb_decompress
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
input$ = 8
?stb_decompress_length@@YAIPEBE@Z PROC			; stb_decompress_length

; 3224 : {

	mov	QWORD PTR [rsp+8], rcx

; 3225 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	mov	eax, 1
	imul	rax, rax, 8
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 24
	mov	ecx, 1
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 8
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx

; 3226 : }

	ret	0
?stb_decompress_length@@YAIPEBE@Z ENDP			; stb_decompress_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z
_TEXT	SEGMENT
p$ = 48
??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z PROC		; IM_DELETE<ImFont>, COMDAT

; 1566 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@IM_DELETE
	xor	edx, edx
	mov	rcx, QWORD PTR p$[rsp]
	call	??_GImFont@@QEAAPEAXI@Z
	mov	rcx, QWORD PTR p$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@IM_DELETE:
	add	rsp, 40					; 00000028H
	ret	0
??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z ENDP		; IM_DELETE<ImFont>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
;	COMDAT ??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ
text$di	SEGMENT
??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ PROC	; `dynamic initializer for 'FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA'', COMDAT

; 1574 : };

	sub	rsp, 40					; 00000028H

; 1566 :     { ImVec2(0,3), ImVec2(12,19), ImVec2(0, 0) }, // ImGuiMouseCursor_Arrow

	movss	xmm2, DWORD PTR __real@40400000
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41980000
	movss	xmm1, DWORD PTR __real@41400000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+8
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+16
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1567 :     { ImVec2(13,0), ImVec2(7,16), ImVec2(1, 8) }, // ImGuiMouseCursor_TextInput

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@41500000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+24
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@40e00000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+32
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+40
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1568 :     { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@41f80000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+48
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41b80000
	movss	xmm1, DWORD PTR __real@41b80000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+56
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41300000
	movss	xmm1, DWORD PTR __real@41300000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+64
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1569 :     { ImVec2(21,0), ImVec2(9,23), ImVec2(4,11) }, // ImGuiMouseCursor_ResizeNS

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@41a80000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+72
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41b80000
	movss	xmm1, DWORD PTR __real@41100000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+80
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41300000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+88
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1570 :     { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW

	movss	xmm2, DWORD PTR __real@41900000
	movss	xmm1, DWORD PTR __real@425c0000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+96
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR __real@41b80000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+104
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@41300000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+112
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1571 :     { ImVec2(73,0), ImVec2(17,17), ImVec2(8, 8) }, // ImGuiMouseCursor_ResizeNESW

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@42920000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+120
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41880000
	movss	xmm1, DWORD PTR __real@41880000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+128
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR __real@41000000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+136
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1572 :     { ImVec2(55,0), ImVec2(17,17), ImVec2(8, 8) }, // ImGuiMouseCursor_ResizeNWSE

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@425c0000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+144
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41880000
	movss	xmm1, DWORD PTR __real@41880000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+152
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR __real@41000000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+160
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1573 :     { ImVec2(91,0), ImVec2(17,22), ImVec2(5, 0) }, // ImGuiMouseCursor_Hand

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@42b60000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+168
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@41b00000
	movss	xmm1, DWORD PTR __real@41880000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+176
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@40a00000
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+184
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ ENDP	; `dynamic initializer for 'FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@H@@YAHHHM@Z PROC				; ImLerp<int>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	cvtsi2ss xmm0, DWORD PTR a$[rsp]
	mov	eax, DWORD PTR a$[rsp]
	mov	ecx, DWORD PTR b$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR t$[rsp]
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	ret	0
??$ImLerp@H@@YAHHHM@Z ENDP				; ImLerp<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR mn$[rsp]
	comiss	xmm0, DWORD PTR v$[rsp]
	jbe	SHORT $LN5@ImClamp
	movss	xmm0, DWORD PTR mn$[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	movss	xmm0, DWORD PTR v$[rsp]
	comiss	xmm0, DWORD PTR mx$[rsp]
	jbe	SHORT $LN3@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@ImClamp:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
$LN6@ImClamp:
	movss	xmm0, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT ??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z PROC	; _vsnprintf_s<1024>, COMDAT

; 1610 :         )

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1603 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	edx, 1024				; 00000400H
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_s
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z ENDP	; _vsnprintf_s<1024>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
d2$ = 96
d3$ = 100
dx$ = 104
dy$ = 108
tv78 = 112
tv81 = 116
x23$1 = 120
y23$2 = 124
y123$3 = 128
x123$4 = 132
y12$5 = 136
x12$6 = 140
y34$7 = 144
x34$8 = 148
y234$9 = 152
x234$10 = 156
y1234$11 = 160
x1234$12 = 164
$T13 = 168
path$ = 192
x1$ = 200
y1$ = 208
x2$ = 216
y2$ = 224
x3$ = 232
y3$ = 240
x4$ = 248
y4$ = 256
tess_tol$ = 264
level$ = 272
?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z PROC ; PathBezierToCasteljau

; 973  : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 974  :     float dx = x4 - x1;

	movss	xmm0, DWORD PTR x4$[rsp]
	subss	xmm0, DWORD PTR x1$[rsp]
	movss	DWORD PTR dx$[rsp], xmm0

; 975  :     float dy = y4 - y1;

	movss	xmm0, DWORD PTR y4$[rsp]
	subss	xmm0, DWORD PTR y1$[rsp]
	movss	DWORD PTR dy$[rsp], xmm0

; 976  :     float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);

	movss	xmm0, DWORD PTR x2$[rsp]
	subss	xmm0, DWORD PTR x4$[rsp]
	mulss	xmm0, DWORD PTR dy$[rsp]
	movss	xmm1, DWORD PTR y2$[rsp]
	subss	xmm1, DWORD PTR y4$[rsp]
	mulss	xmm1, DWORD PTR dx$[rsp]
	subss	xmm0, xmm1
	movss	DWORD PTR d2$[rsp], xmm0

; 977  :     float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);

	movss	xmm0, DWORD PTR x3$[rsp]
	subss	xmm0, DWORD PTR x4$[rsp]
	mulss	xmm0, DWORD PTR dy$[rsp]
	movss	xmm1, DWORD PTR y3$[rsp]
	subss	xmm1, DWORD PTR y4$[rsp]
	mulss	xmm1, DWORD PTR dx$[rsp]
	subss	xmm0, xmm1
	movss	DWORD PTR d3$[rsp], xmm0

; 978  :     d2 = (d2 >= 0) ? d2 : -d2;

	movss	xmm0, DWORD PTR d2$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@PathBezier
	movss	xmm0, DWORD PTR d2$[rsp]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN7@PathBezier
$LN6@PathBezier:
	movss	xmm0, DWORD PTR d2$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv78[rsp], xmm0
$LN7@PathBezier:
	movss	xmm0, DWORD PTR tv78[rsp]
	movss	DWORD PTR d2$[rsp], xmm0

; 979  :     d3 = (d3 >= 0) ? d3 : -d3;

	movss	xmm0, DWORD PTR d3$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@PathBezier
	movss	xmm0, DWORD PTR d3$[rsp]
	movss	DWORD PTR tv81[rsp], xmm0
	jmp	SHORT $LN9@PathBezier
$LN8@PathBezier:
	movss	xmm0, DWORD PTR d3$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv81[rsp], xmm0
$LN9@PathBezier:
	movss	xmm0, DWORD PTR tv81[rsp]
	movss	DWORD PTR d3$[rsp], xmm0

; 980  :     if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))

	movss	xmm0, DWORD PTR d2$[rsp]
	addss	xmm0, DWORD PTR d3$[rsp]
	movss	xmm1, DWORD PTR d2$[rsp]
	addss	xmm1, DWORD PTR d3$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR dx$[rsp]
	mulss	xmm1, DWORD PTR dx$[rsp]
	movss	xmm2, DWORD PTR dy$[rsp]
	mulss	xmm2, DWORD PTR dy$[rsp]
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR tess_tol$[rsp]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@PathBezier

; 981  :     {
; 982  :         path->push_back(ImVec2(x4, y4));

	movss	xmm2, DWORD PTR y4$[rsp]
	movss	xmm1, DWORD PTR x4$[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR path$[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1

; 983  :     }

	jmp	$LN3@PathBezier
$LN2@PathBezier:

; 984  :     else if (level < 10)

	cmp	DWORD PTR level$[rsp], 10
	jge	$LN4@PathBezier

; 985  :     {
; 986  :         float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;

	movss	xmm0, DWORD PTR x1$[rsp]
	addss	xmm0, DWORD PTR x2$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR x12$6[rsp], xmm0
	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR y2$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR y12$5[rsp], xmm0

; 987  :         float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;

	movss	xmm0, DWORD PTR x2$[rsp]
	addss	xmm0, DWORD PTR x3$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR x23$1[rsp], xmm0
	movss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR y3$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR y23$2[rsp], xmm0

; 988  :         float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;

	movss	xmm0, DWORD PTR x3$[rsp]
	addss	xmm0, DWORD PTR x4$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR x34$8[rsp], xmm0
	movss	xmm0, DWORD PTR y3$[rsp]
	addss	xmm0, DWORD PTR y4$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR y34$7[rsp], xmm0

; 989  :         float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;

	movss	xmm0, DWORD PTR x12$6[rsp]
	addss	xmm0, DWORD PTR x23$1[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR x123$4[rsp], xmm0
	movss	xmm0, DWORD PTR y12$5[rsp]
	addss	xmm0, DWORD PTR y23$2[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR y123$3[rsp], xmm0

; 990  :         float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;

	movss	xmm0, DWORD PTR x23$1[rsp]
	addss	xmm0, DWORD PTR x34$8[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR x234$10[rsp], xmm0
	movss	xmm0, DWORD PTR y23$2[rsp]
	addss	xmm0, DWORD PTR y34$7[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR y234$9[rsp], xmm0

; 991  :         float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;

	movss	xmm0, DWORD PTR x123$4[rsp]
	addss	xmm0, DWORD PTR x234$10[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR x1234$12[rsp], xmm0
	movss	xmm0, DWORD PTR y123$3[rsp]
	addss	xmm0, DWORD PTR y234$9[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR y1234$11[rsp], xmm0

; 992  : 
; 993  :         PathBezierToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	mov	DWORD PTR [rsp+80], eax
	movss	xmm0, DWORD PTR tess_tol$[rsp]
	movss	DWORD PTR [rsp+72], xmm0
	movss	xmm0, DWORD PTR y1234$11[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR x1234$12[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR y123$3[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x123$4[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y12$5[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x12$6[rsp]
	movss	xmm2, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR x1$[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau

; 994  :         PathBezierToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	mov	DWORD PTR [rsp+80], eax
	movss	xmm0, DWORD PTR tess_tol$[rsp]
	movss	DWORD PTR [rsp+72], xmm0
	movss	xmm0, DWORD PTR y4$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR x4$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR y34$7[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x34$8[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y234$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x234$10[rsp]
	movss	xmm2, DWORD PTR y1234$11[rsp]
	movss	xmm1, DWORD PTR x1234$12[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
	npad	1
$LN4@PathBezier:
$LN3@PathBezier:

; 995  :     }
; 996  : }

	add	rsp, 184				; 000000b8H
	ret	0
?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ENDP ; PathBezierToCasteljau
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
oversample$ = 8
?stbtt__oversample_shift@@YAMH@Z PROC			; stbtt__oversample_shift

; 3977 : {

	mov	DWORD PTR [rsp+8], ecx

; 3978 :    if (!oversample)

	cmp	DWORD PTR oversample$[rsp], 0
	jne	SHORT $LN2@stbtt__ove

; 3979 :       return 0.0f;

	xorps	xmm0, xmm0
	jmp	SHORT $LN1@stbtt__ove
$LN2@stbtt__ove:

; 3980 : 
; 3981 :    // The prefilter is a box filter of width "oversample",
; 3982 :    // which shifts phase by (oversample - 1)/2 pixels in
; 3983 :    // oversampled space. We want to shift in the opposite
; 3984 :    // direction to counter this.
; 3985 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

	mov	eax, DWORD PTR oversample$[rsp]
	dec	eax
	neg	eax
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR oversample$[rsp]
	movss	xmm2, DWORD PTR __real@40000000
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	divss	xmm0, xmm1
$LN1@stbtt__ove:

; 3986 : }

	ret	0
?stbtt__oversample_shift@@YAMH@Z ENDP			; stbtt__oversample_shift
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$1 = 32
total$2 = 36
safe_h$ = 40
tv70 = 44
j$ = 48
buffer$ = 56
__$ArrayPad$ = 64
pixels$ = 96
w$ = 104
h$ = 112
stride_in_bytes$ = 120
kernel_width$ = 128
?stbtt__v_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__v_prefilter

; 3915 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3916 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3917 :    int safe_h = h - kernel_width;

	mov	eax, DWORD PTR kernel_width$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR safe_h$[rsp], eax

; 3918 :    int j;
; 3919 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

	mov	r8d, 8
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset
	npad	1

; 3920 :    for (j=0; j < w; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN4@stbtt__v_p
$LN2@stbtt__v_p:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@stbtt__v_p:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN3@stbtt__v_p

; 3921 :       int i;
; 3922 :       unsigned int total;
; 3923 :       STBTT_memset(buffer, 0, kernel_width);

	mov	eax, DWORD PTR kernel_width$[rsp]
	mov	r8d, eax
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 3924 : 
; 3925 :       total = 0;

	mov	DWORD PTR total$2[rsp], 0

; 3926 : 
; 3927 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3928 :       switch (kernel_width) {

	mov	eax, DWORD PTR kernel_width$[rsp]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 2
	je	SHORT $LN25@stbtt__v_p
	cmp	DWORD PTR tv70[rsp], 3
	je	$LN26@stbtt__v_p
	cmp	DWORD PTR tv70[rsp], 4
	je	$LN27@stbtt__v_p
	cmp	DWORD PTR tv70[rsp], 5
	je	$LN28@stbtt__v_p
	jmp	$LN29@stbtt__v_p
$LN25@stbtt__v_p:

; 3929 :          case 2:
; 3930 :             for (i=0; i <= safe_h; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@stbtt__v_p
$LN7@stbtt__v_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@stbtt__v_p:
	mov	eax, DWORD PTR safe_h$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	$LN8@stbtt__v_p

; 3931 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3932 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3933 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 2);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 2
	div	ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, DWORD PTR stride_in_bytes$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3934 :             }

	jmp	$LN7@stbtt__v_p
$LN8@stbtt__v_p:

; 3935 :             break;

	jmp	$LN5@stbtt__v_p
$LN26@stbtt__v_p:

; 3936 :          case 3:
; 3937 :             for (i=0; i <= safe_h; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN12@stbtt__v_p
$LN10@stbtt__v_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN12@stbtt__v_p:
	mov	eax, DWORD PTR safe_h$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	$LN11@stbtt__v_p

; 3938 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3939 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3940 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 3);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 3
	div	ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, DWORD PTR stride_in_bytes$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3941 :             }

	jmp	$LN10@stbtt__v_p
$LN11@stbtt__v_p:

; 3942 :             break;

	jmp	$LN5@stbtt__v_p
$LN27@stbtt__v_p:

; 3943 :          case 4:
; 3944 :             for (i=0; i <= safe_h; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN15@stbtt__v_p
$LN13@stbtt__v_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN15@stbtt__v_p:
	mov	eax, DWORD PTR safe_h$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	$LN14@stbtt__v_p

; 3945 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3946 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3947 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 4);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 4
	div	ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, DWORD PTR stride_in_bytes$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3948 :             }

	jmp	$LN13@stbtt__v_p
$LN14@stbtt__v_p:

; 3949 :             break;

	jmp	$LN5@stbtt__v_p
$LN28@stbtt__v_p:

; 3950 :          case 5:
; 3951 :             for (i=0; i <= safe_h; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN18@stbtt__v_p
$LN16@stbtt__v_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN18@stbtt__v_p:
	mov	eax, DWORD PTR safe_h$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	$LN17@stbtt__v_p

; 3952 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3953 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3954 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 5);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 5
	div	ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, DWORD PTR stride_in_bytes$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3955 :             }

	jmp	$LN16@stbtt__v_p
$LN17@stbtt__v_p:

; 3956 :             break;

	jmp	$LN5@stbtt__v_p
$LN29@stbtt__v_p:

; 3957 :          default:
; 3958 :             for (i=0; i <= safe_h; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN21@stbtt__v_p
$LN19@stbtt__v_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN21@stbtt__v_p:
	mov	eax, DWORD PTR safe_h$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	$LN20@stbtt__v_p

; 3959 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3960 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR stride_in_bytes$[rsp]
	cdqe
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3961 :                pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	div	DWORD PTR kernel_width$[rsp]
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, DWORD PTR stride_in_bytes$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3962 :             }

	jmp	$LN19@stbtt__v_p
$LN20@stbtt__v_p:
$LN5@stbtt__v_p:

; 3963 :             break;
; 3964 :       }
; 3965 : 
; 3966 :       for (; i < h; ++i) {

	jmp	SHORT $LN24@stbtt__v_p
$LN22@stbtt__v_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN24@stbtt__v_p:
	mov	eax, DWORD PTR h$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN23@stbtt__v_p

; 3967 :          STBTT_assert(pixels[i*stride_in_bytes] == 0);
; 3968 :          total -= buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	and	eax, 7
	cdqe
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	mov	ecx, DWORD PTR total$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3969 :          pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	div	DWORD PTR kernel_width$[rsp]
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, DWORD PTR stride_in_bytes$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3970 :       }

	jmp	SHORT $LN22@stbtt__v_p
$LN23@stbtt__v_p:

; 3971 : 
; 3972 :       pixels += 1;

	mov	rax, QWORD PTR pixels$[rsp]
	inc	rax
	mov	QWORD PTR pixels$[rsp], rax

; 3973 :    }

	jmp	$LN2@stbtt__v_p
$LN3@stbtt__v_p:

; 3974 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
?stbtt__v_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__v_prefilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$1 = 32
total$2 = 36
safe_w$ = 40
tv70 = 44
j$ = 48
buffer$ = 56
__$ArrayPad$ = 64
pixels$ = 96
w$ = 104
h$ = 112
stride_in_bytes$ = 120
kernel_width$ = 128
?stbtt__h_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__h_prefilter

; 3853 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3854 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3855 :    int safe_w = w - kernel_width;

	mov	eax, DWORD PTR kernel_width$[rsp]
	mov	ecx, DWORD PTR w$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR safe_w$[rsp], eax

; 3856 :    int j;
; 3857 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

	mov	r8d, 8
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset
	npad	1

; 3858 :    for (j=0; j < h; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN4@stbtt__h_p
$LN2@stbtt__h_p:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@stbtt__h_p:
	mov	eax, DWORD PTR h$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN3@stbtt__h_p

; 3859 :       int i;
; 3860 :       unsigned int total;
; 3861 :       STBTT_memset(buffer, 0, kernel_width);

	mov	eax, DWORD PTR kernel_width$[rsp]
	mov	r8d, eax
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 3862 : 
; 3863 :       total = 0;

	mov	DWORD PTR total$2[rsp], 0

; 3864 : 
; 3865 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3866 :       switch (kernel_width) {

	mov	eax, DWORD PTR kernel_width$[rsp]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 2
	je	SHORT $LN25@stbtt__h_p
	cmp	DWORD PTR tv70[rsp], 3
	je	$LN26@stbtt__h_p
	cmp	DWORD PTR tv70[rsp], 4
	je	$LN27@stbtt__h_p
	cmp	DWORD PTR tv70[rsp], 5
	je	$LN28@stbtt__h_p
	jmp	$LN29@stbtt__h_p
$LN25@stbtt__h_p:

; 3867 :          case 2:
; 3868 :             for (i=0; i <= safe_w; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@stbtt__h_p
$LN7@stbtt__h_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@stbtt__h_p:
	mov	eax, DWORD PTR safe_w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	SHORT $LN8@stbtt__h_p

; 3869 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3870 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3871 :                pixels[i] = (unsigned char) (total / 2);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 2
	div	ecx
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3872 :             }

	jmp	$LN7@stbtt__h_p
$LN8@stbtt__h_p:

; 3873 :             break;

	jmp	$LN5@stbtt__h_p
$LN26@stbtt__h_p:

; 3874 :          case 3:
; 3875 :             for (i=0; i <= safe_w; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN12@stbtt__h_p
$LN10@stbtt__h_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN12@stbtt__h_p:
	mov	eax, DWORD PTR safe_w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	SHORT $LN11@stbtt__h_p

; 3876 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3877 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3878 :                pixels[i] = (unsigned char) (total / 3);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 3
	div	ecx
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3879 :             }

	jmp	$LN10@stbtt__h_p
$LN11@stbtt__h_p:

; 3880 :             break;

	jmp	$LN5@stbtt__h_p
$LN27@stbtt__h_p:

; 3881 :          case 4:
; 3882 :             for (i=0; i <= safe_w; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN15@stbtt__h_p
$LN13@stbtt__h_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN15@stbtt__h_p:
	mov	eax, DWORD PTR safe_w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	SHORT $LN14@stbtt__h_p

; 3883 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3884 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3885 :                pixels[i] = (unsigned char) (total / 4);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 4
	div	ecx
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3886 :             }

	jmp	$LN13@stbtt__h_p
$LN14@stbtt__h_p:

; 3887 :             break;

	jmp	$LN5@stbtt__h_p
$LN28@stbtt__h_p:

; 3888 :          case 5:
; 3889 :             for (i=0; i <= safe_w; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN18@stbtt__h_p
$LN16@stbtt__h_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN18@stbtt__h_p:
	mov	eax, DWORD PTR safe_w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	SHORT $LN17@stbtt__h_p

; 3890 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3891 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3892 :                pixels[i] = (unsigned char) (total / 5);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	mov	ecx, 5
	div	ecx
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3893 :             }

	jmp	$LN16@stbtt__h_p
$LN17@stbtt__h_p:

; 3894 :             break;

	jmp	$LN5@stbtt__h_p
$LN29@stbtt__h_p:

; 3895 :          default:
; 3896 :             for (i=0; i <= safe_w; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN21@stbtt__h_p
$LN19@stbtt__h_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN21@stbtt__h_p:
	mov	eax, DWORD PTR safe_w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	SHORT $LN20@stbtt__h_p

; 3897 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR i$1[rsp]
	and	ecx, 7
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR buffer$[rsp+rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR total$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3898 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR kernel_width$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	add	edx, ecx
	mov	ecx, edx
	and	ecx, 7
	mov	ecx, ecx
	mov	rdx, QWORD PTR pixels$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR buffer$[rsp+rcx], al

; 3899 :                pixels[i] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	div	DWORD PTR kernel_width$[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3900 :             }

	jmp	$LN19@stbtt__h_p
$LN20@stbtt__h_p:
$LN5@stbtt__h_p:

; 3901 :             break;
; 3902 :       }
; 3903 : 
; 3904 :       for (; i < w; ++i) {

	jmp	SHORT $LN24@stbtt__h_p
$LN22@stbtt__h_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN24@stbtt__h_p:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN23@stbtt__h_p

; 3905 :          STBTT_assert(pixels[i] == 0);
; 3906 :          total -= buffer[i & STBTT__OVER_MASK];

	mov	eax, DWORD PTR i$1[rsp]
	and	eax, 7
	cdqe
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	mov	ecx, DWORD PTR total$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$2[rsp], eax

; 3907 :          pixels[i] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	mov	eax, DWORD PTR total$2[rsp]
	div	DWORD PTR kernel_width$[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR pixels$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 3908 :       }

	jmp	SHORT $LN22@stbtt__h_p
$LN23@stbtt__h_p:

; 3909 : 
; 3910 :       pixels += stride_in_bytes;

	movsxd	rax, DWORD PTR stride_in_bytes$[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pixels$[rsp], rax

; 3911 :    }

	jmp	$LN2@stbtt__h_p
$LN3@stbtt__h_p:

; 3912 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
?stbtt__h_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__h_prefilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$ = 96
num_points$ = 100
n$ = 104
x$1 = 108
y$2 = 112
pass$ = 116
tv95 = 120
points$ = 128
start$ = 136
objspace_flatness_squared$ = 140
tv149 = 144
tv167 = 148
vertices$ = 192
num_verts$ = 200
objspace_flatness$ = 208
contour_lengths$ = 216
num_contours$ = 224
userdata$ = 232
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z PROC ; stbtt_FlattenCurves

; 3459 : {

	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H
	movaps	XMMWORD PTR [rsp+160], xmm6

; 3460 :    stbtt__point *points=0;

	mov	QWORD PTR points$[rsp], 0

; 3461 :    int num_points=0;

	mov	DWORD PTR num_points$[rsp], 0

; 3462 : 
; 3463 :    float objspace_flatness_squared = objspace_flatness * objspace_flatness;

	movss	xmm0, DWORD PTR objspace_flatness$[rsp]
	mulss	xmm0, DWORD PTR objspace_flatness$[rsp]
	movss	DWORD PTR objspace_flatness_squared$[rsp], xmm0

; 3464 :    int i,n=0,start=0, pass;

	mov	DWORD PTR n$[rsp], 0
	mov	DWORD PTR start$[rsp], 0

; 3465 : 
; 3466 :    // count how many "moves" there are to get the contour count
; 3467 :    for (i=0; i < num_verts; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt_Flat
$LN2@stbtt_Flat:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt_Flat:
	mov	eax, DWORD PTR num_verts$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbtt_Flat

; 3468 :       if (vertices[i].type == STBTT_vmove)

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+12]
	cmp	eax, 1
	jne	SHORT $LN13@stbtt_Flat

; 3469 :          ++n;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
$LN13@stbtt_Flat:
	jmp	SHORT $LN2@stbtt_Flat
$LN3@stbtt_Flat:

; 3470 : 
; 3471 :    *num_contours = n;

	mov	rax, QWORD PTR num_contours$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	DWORD PTR [rax], ecx

; 3472 :    if (n == 0) return 0;

	cmp	DWORD PTR n$[rsp], 0
	jne	SHORT $LN14@stbtt_Flat
	xor	eax, eax
	jmp	$LN1@stbtt_Flat
$LN14@stbtt_Flat:

; 3473 : 
; 3474 :    *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

	movsxd	rax, DWORD PTR n$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	rcx, QWORD PTR contour_lengths$[rsp]
	mov	QWORD PTR [rcx], rax

; 3475 : 
; 3476 :    if (*contour_lengths == 0) {

	mov	rax, QWORD PTR contour_lengths$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN15@stbtt_Flat

; 3477 :       *num_contours = 0;

	mov	rax, QWORD PTR num_contours$[rsp]
	mov	DWORD PTR [rax], 0

; 3478 :       return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Flat
$LN15@stbtt_Flat:

; 3479 :    }
; 3480 : 
; 3481 :    // make two passes through the points so we don't need to realloc
; 3482 :    for (pass=0; pass < 2; ++pass) {

	mov	DWORD PTR pass$[rsp], 0
	jmp	SHORT $LN7@stbtt_Flat
$LN5@stbtt_Flat:
	mov	eax, DWORD PTR pass$[rsp]
	inc	eax
	mov	DWORD PTR pass$[rsp], eax
$LN7@stbtt_Flat:
	cmp	DWORD PTR pass$[rsp], 2
	jge	$LN6@stbtt_Flat

; 3483 :       float x=0,y=0;

	xorps	xmm0, xmm0
	movss	DWORD PTR x$1[rsp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR y$2[rsp], xmm0

; 3484 :       if (pass == 1) {

	cmp	DWORD PTR pass$[rsp], 1
	jne	SHORT $LN16@stbtt_Flat

; 3485 :          points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);

	movsxd	rax, DWORD PTR num_points$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR points$[rsp], rax

; 3486 :          if (points == NULL) goto error;

	cmp	QWORD PTR points$[rsp], 0
	jne	SHORT $LN17@stbtt_Flat
	jmp	$LN18@stbtt_Flat
	jmp	$error$25
$LN17@stbtt_Flat:
$LN16@stbtt_Flat:

; 3487 :       }
; 3488 :       num_points = 0;

	mov	DWORD PTR num_points$[rsp], 0

; 3489 :       n= -1;

	mov	DWORD PTR n$[rsp], -1

; 3490 :       for (i=0; i < num_verts; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@stbtt_Flat
$LN8@stbtt_Flat:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbtt_Flat:
	mov	eax, DWORD PTR num_verts$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN9@stbtt_Flat

; 3491 :          switch (vertices[i].type) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+12]
	mov	BYTE PTR tv95[rsp], al
	cmp	BYTE PTR tv95[rsp], 1
	je	SHORT $LN19@stbtt_Flat
	cmp	BYTE PTR tv95[rsp], 2
	je	$LN21@stbtt_Flat
	cmp	BYTE PTR tv95[rsp], 3
	je	$LN22@stbtt_Flat
	cmp	BYTE PTR tv95[rsp], 4
	je	$LN23@stbtt_Flat
	jmp	$LN11@stbtt_Flat
$LN19@stbtt_Flat:

; 3492 :             case STBTT_vmove:
; 3493 :                // start the next contour
; 3494 :                if (n >= 0)

	cmp	DWORD PTR n$[rsp], 0
	jl	SHORT $LN20@stbtt_Flat

; 3495 :                   (*contour_lengths)[n] = num_points - start;

	mov	eax, DWORD PTR start$[rsp]
	mov	ecx, DWORD PTR num_points$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR n$[rsp]
	mov	rdx, QWORD PTR contour_lengths$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	DWORD PTR [rdx+rcx*4], eax
$LN20@stbtt_Flat:

; 3496 :                ++n;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 3497 :                start = num_points;

	mov	eax, DWORD PTR num_points$[rsp]
	mov	DWORD PTR start$[rsp], eax

; 3498 : 
; 3499 :                x = vertices[i].x, y = vertices[i].y;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR x$1[rsp], xmm0
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR y$2[rsp], xmm0

; 3500 :                stbtt__add_point(points, num_points++, x,y);

	mov	eax, DWORD PTR num_points$[rsp]
	mov	DWORD PTR tv149[rsp], eax
	mov	eax, DWORD PTR num_points$[rsp]
	inc	eax
	mov	DWORD PTR num_points$[rsp], eax
	movss	xmm3, DWORD PTR y$2[rsp]
	movss	xmm2, DWORD PTR x$1[rsp]
	mov	edx, DWORD PTR tv149[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point
	npad	1

; 3501 :                break;

	jmp	$LN11@stbtt_Flat
$LN21@stbtt_Flat:

; 3502 :             case STBTT_vline:
; 3503 :                x = vertices[i].x, y = vertices[i].y;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR x$1[rsp], xmm0
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR y$2[rsp], xmm0

; 3504 :                stbtt__add_point(points, num_points++, x, y);

	mov	eax, DWORD PTR num_points$[rsp]
	mov	DWORD PTR tv167[rsp], eax
	mov	eax, DWORD PTR num_points$[rsp]
	inc	eax
	mov	DWORD PTR num_points$[rsp], eax
	movss	xmm3, DWORD PTR y$2[rsp]
	movss	xmm2, DWORD PTR x$1[rsp]
	mov	edx, DWORD PTR tv167[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point
	npad	1

; 3505 :                break;

	jmp	$LN11@stbtt_Flat
$LN22@stbtt_Flat:

; 3506 :             case STBTT_vcurve:
; 3507 :                stbtt__tesselate_curve(points, &num_points, x,y,

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	cvtsi2ss xmm0, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	cvtsi2ss xmm1, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+6]
	cvtsi2ss xmm2, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+4]
	cvtsi2ss xmm3, eax
	mov	DWORD PTR [rsp+72], 0
	movss	xmm4, DWORD PTR objspace_flatness_squared$[rsp]
	movss	DWORD PTR [rsp+64], xmm4
	movss	DWORD PTR [rsp+56], xmm0
	movss	DWORD PTR [rsp+48], xmm1
	movss	DWORD PTR [rsp+40], xmm2
	movss	DWORD PTR [rsp+32], xmm3
	movss	xmm3, DWORD PTR y$2[rsp]
	movss	xmm2, DWORD PTR x$1[rsp]
	lea	rdx, QWORD PTR num_points$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3508 :                                         vertices[i].cx, vertices[i].cy,
; 3509 :                                         vertices[i].x,  vertices[i].y,
; 3510 :                                         objspace_flatness_squared, 0);
; 3511 :                x = vertices[i].x, y = vertices[i].y;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR x$1[rsp], xmm0
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR y$2[rsp], xmm0

; 3512 :                break;

	jmp	$LN11@stbtt_Flat
$LN23@stbtt_Flat:

; 3513 :             case STBTT_vcubic:
; 3514 :                stbtt__tesselate_cubic(points, &num_points, x,y,

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	cvtsi2ss xmm0, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	cvtsi2ss xmm1, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+10]
	cvtsi2ss xmm2, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+8]
	cvtsi2ss xmm3, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+6]
	cvtsi2ss xmm4, eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+4]
	cvtsi2ss xmm5, eax
	mov	DWORD PTR [rsp+88], 0
	movss	xmm6, DWORD PTR objspace_flatness_squared$[rsp]
	movss	DWORD PTR [rsp+80], xmm6
	movss	DWORD PTR [rsp+72], xmm0
	movss	DWORD PTR [rsp+64], xmm1
	movss	DWORD PTR [rsp+56], xmm2
	movss	DWORD PTR [rsp+48], xmm3
	movss	DWORD PTR [rsp+40], xmm4
	movss	DWORD PTR [rsp+32], xmm5
	movss	xmm3, DWORD PTR y$2[rsp]
	movss	xmm2, DWORD PTR x$1[rsp]
	lea	rdx, QWORD PTR num_points$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3515 :                                         vertices[i].cx, vertices[i].cy,
; 3516 :                                         vertices[i].cx1, vertices[i].cy1,
; 3517 :                                         vertices[i].x,  vertices[i].y,
; 3518 :                                         objspace_flatness_squared, 0);
; 3519 :                x = vertices[i].x, y = vertices[i].y;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR x$1[rsp], xmm0
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR y$2[rsp], xmm0
$LN11@stbtt_Flat:

; 3520 :                break;
; 3521 :          }
; 3522 :       }

	jmp	$LN8@stbtt_Flat
$LN9@stbtt_Flat:

; 3523 :       (*contour_lengths)[n] = num_points - start;

	mov	eax, DWORD PTR start$[rsp]
	mov	ecx, DWORD PTR num_points$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR n$[rsp]
	mov	rdx, QWORD PTR contour_lengths$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	DWORD PTR [rdx+rcx*4], eax

; 3524 :    }

	jmp	$LN5@stbtt_Flat
$LN6@stbtt_Flat:

; 3525 : 
; 3526 :    return points;

	mov	rax, QWORD PTR points$[rsp]
	jmp	SHORT $LN1@stbtt_Flat
$LN18@stbtt_Flat:
$error$25:

; 3527 : error:
; 3528 :    STBTT_free(points, userdata);

	mov	rcx, QWORD PTR points$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 3529 :    STBTT_free(*contour_lengths, userdata);

	mov	rax, QWORD PTR contour_lengths$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 3530 :    *contour_lengths = 0;

	mov	rax, QWORD PTR contour_lengths$[rsp]
	mov	QWORD PTR [rax], 0

; 3531 :    *num_contours = 0;

	mov	rax, QWORD PTR num_contours$[rsp]
	mov	DWORD PTR [rax], 0

; 3532 :    return NULL;

	xor	eax, eax
$LN1@stbtt_Flat:

; 3533 : }

	movaps	xmm6, XMMWORD PTR [rsp+160]
	add	rsp, 184				; 000000b8H
	ret	0
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ENDP ; stbtt_FlattenCurves
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
dx0$ = 96
dy0$ = 100
dx1$ = 104
dy1$ = 108
dx2$ = 112
dy2$ = 116
dx$ = 120
dy$ = 124
longlen$ = 128
shortlen$ = 132
x12$1 = 136
y12$2 = 140
ya$3 = 144
xa$4 = 148
y01$5 = 152
x01$6 = 156
y23$7 = 160
x23$8 = 164
yb$9 = 168
xb$10 = 172
my$11 = 176
mx$12 = 180
tv72 = 184
tv82 = 188
flatness_squared$ = 192
points$ = 224
num_points$ = 232
x0$ = 240
y0$ = 248
x1$ = 256
y1$ = 264
x2$ = 272
y2$ = 280
x3$ = 288
y3$ = 296
objspace_flatness_squared$ = 304
n$ = 312
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z PROC ; stbtt__tesselate_cubic

; 3416 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 3417 :    // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
; 3418 :    float dx0 = x1-x0;

	movss	xmm0, DWORD PTR x1$[rsp]
	subss	xmm0, DWORD PTR x0$[rsp]
	movss	DWORD PTR dx0$[rsp], xmm0

; 3419 :    float dy0 = y1-y0;

	movss	xmm0, DWORD PTR y1$[rsp]
	subss	xmm0, DWORD PTR y0$[rsp]
	movss	DWORD PTR dy0$[rsp], xmm0

; 3420 :    float dx1 = x2-x1;

	movss	xmm0, DWORD PTR x2$[rsp]
	subss	xmm0, DWORD PTR x1$[rsp]
	movss	DWORD PTR dx1$[rsp], xmm0

; 3421 :    float dy1 = y2-y1;

	movss	xmm0, DWORD PTR y2$[rsp]
	subss	xmm0, DWORD PTR y1$[rsp]
	movss	DWORD PTR dy1$[rsp], xmm0

; 3422 :    float dx2 = x3-x2;

	movss	xmm0, DWORD PTR x3$[rsp]
	subss	xmm0, DWORD PTR x2$[rsp]
	movss	DWORD PTR dx2$[rsp], xmm0

; 3423 :    float dy2 = y3-y2;

	movss	xmm0, DWORD PTR y3$[rsp]
	subss	xmm0, DWORD PTR y2$[rsp]
	movss	DWORD PTR dy2$[rsp], xmm0

; 3424 :    float dx = x3-x0;

	movss	xmm0, DWORD PTR x3$[rsp]
	subss	xmm0, DWORD PTR x0$[rsp]
	movss	DWORD PTR dx$[rsp], xmm0

; 3425 :    float dy = y3-y0;

	movss	xmm0, DWORD PTR y3$[rsp]
	subss	xmm0, DWORD PTR y0$[rsp]
	movss	DWORD PTR dy$[rsp], xmm0

; 3426 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

	movss	xmm0, DWORD PTR dx0$[rsp]
	mulss	xmm0, DWORD PTR dx0$[rsp]
	movss	xmm1, DWORD PTR dy0$[rsp]
	mulss	xmm1, DWORD PTR dy0$[rsp]
	addss	xmm0, xmm1
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	DWORD PTR tv72[rsp], xmm0
	movss	xmm1, DWORD PTR dx1$[rsp]
	mulss	xmm1, DWORD PTR dx1$[rsp]
	movss	xmm2, DWORD PTR dy1$[rsp]
	mulss	xmm2, DWORD PTR dy1$[rsp]
	addss	xmm1, xmm2
	movaps	xmm0, xmm1
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR tv72[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv82[rsp], xmm0
	movss	xmm1, DWORD PTR dx2$[rsp]
	mulss	xmm1, DWORD PTR dx2$[rsp]
	movss	xmm2, DWORD PTR dy2$[rsp]
	mulss	xmm2, DWORD PTR dy2$[rsp]
	addss	xmm1, xmm2
	movaps	xmm0, xmm1
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR tv82[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR longlen$[rsp], xmm0

; 3427 :    float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);

	movss	xmm0, DWORD PTR dx$[rsp]
	mulss	xmm0, DWORD PTR dx$[rsp]
	movss	xmm1, DWORD PTR dy$[rsp]
	mulss	xmm1, DWORD PTR dy$[rsp]
	addss	xmm0, xmm1
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	DWORD PTR shortlen$[rsp], xmm0

; 3428 :    float flatness_squared = longlen*longlen-shortlen*shortlen;

	movss	xmm0, DWORD PTR longlen$[rsp]
	mulss	xmm0, DWORD PTR longlen$[rsp]
	movss	xmm1, DWORD PTR shortlen$[rsp]
	mulss	xmm1, DWORD PTR shortlen$[rsp]
	subss	xmm0, xmm1
	movss	DWORD PTR flatness_squared$[rsp], xmm0

; 3429 : 
; 3430 :    if (n > 16) // 65536 segments on one curve better be enough!

	cmp	DWORD PTR n$[rsp], 16
	jle	SHORT $LN2@stbtt__tes

; 3431 :       return;

	jmp	$LN1@stbtt__tes
$LN2@stbtt__tes:

; 3432 : 
; 3433 :    if (flatness_squared > objspace_flatness_squared) {

	movss	xmm0, DWORD PTR flatness_squared$[rsp]
	comiss	xmm0, DWORD PTR objspace_flatness_squared$[rsp]
	jbe	$LN3@stbtt__tes

; 3434 :       float x01 = (x0+x1)/2;

	movss	xmm0, DWORD PTR x0$[rsp]
	addss	xmm0, DWORD PTR x1$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR x01$6[rsp], xmm0

; 3435 :       float y01 = (y0+y1)/2;

	movss	xmm0, DWORD PTR y0$[rsp]
	addss	xmm0, DWORD PTR y1$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR y01$5[rsp], xmm0

; 3436 :       float x12 = (x1+x2)/2;

	movss	xmm0, DWORD PTR x1$[rsp]
	addss	xmm0, DWORD PTR x2$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR x12$1[rsp], xmm0

; 3437 :       float y12 = (y1+y2)/2;

	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR y2$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR y12$2[rsp], xmm0

; 3438 :       float x23 = (x2+x3)/2;

	movss	xmm0, DWORD PTR x2$[rsp]
	addss	xmm0, DWORD PTR x3$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR x23$8[rsp], xmm0

; 3439 :       float y23 = (y2+y3)/2;

	movss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR y3$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR y23$7[rsp], xmm0

; 3440 : 
; 3441 :       float xa = (x01+x12)/2;

	movss	xmm0, DWORD PTR x01$6[rsp]
	addss	xmm0, DWORD PTR x12$1[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR xa$4[rsp], xmm0

; 3442 :       float ya = (y01+y12)/2;

	movss	xmm0, DWORD PTR y01$5[rsp]
	addss	xmm0, DWORD PTR y12$2[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR ya$3[rsp], xmm0

; 3443 :       float xb = (x12+x23)/2;

	movss	xmm0, DWORD PTR x12$1[rsp]
	addss	xmm0, DWORD PTR x23$8[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR xb$10[rsp], xmm0

; 3444 :       float yb = (y12+y23)/2;

	movss	xmm0, DWORD PTR y12$2[rsp]
	addss	xmm0, DWORD PTR y23$7[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR yb$9[rsp], xmm0

; 3445 : 
; 3446 :       float mx = (xa+xb)/2;

	movss	xmm0, DWORD PTR xa$4[rsp]
	addss	xmm0, DWORD PTR xb$10[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR mx$12[rsp], xmm0

; 3447 :       float my = (ya+yb)/2;

	movss	xmm0, DWORD PTR ya$3[rsp]
	addss	xmm0, DWORD PTR yb$9[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR my$11[rsp], xmm0

; 3448 : 
; 3449 :       stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR [rsp+88], eax
	movss	xmm0, DWORD PTR objspace_flatness_squared$[rsp]
	movss	DWORD PTR [rsp+80], xmm0
	movss	xmm0, DWORD PTR my$11[rsp]
	movss	DWORD PTR [rsp+72], xmm0
	movss	xmm0, DWORD PTR mx$12[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR ya$3[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR xa$4[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR y01$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR x01$6[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR y0$[rsp]
	movss	xmm2, DWORD PTR x0$[rsp]
	mov	rdx, QWORD PTR num_points$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3450 :       stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR [rsp+88], eax
	movss	xmm0, DWORD PTR objspace_flatness_squared$[rsp]
	movss	DWORD PTR [rsp+80], xmm0
	movss	xmm0, DWORD PTR y3$[rsp]
	movss	DWORD PTR [rsp+72], xmm0
	movss	xmm0, DWORD PTR x3$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR y23$7[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR x23$8[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR yb$9[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR xb$10[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR my$11[rsp]
	movss	xmm2, DWORD PTR mx$12[rsp]
	mov	rdx, QWORD PTR num_points$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
	npad	1

; 3451 :    } else {

	jmp	SHORT $LN4@stbtt__tes
$LN3@stbtt__tes:

; 3452 :       stbtt__add_point(points, *num_points,x3,y3);

	movss	xmm3, DWORD PTR y3$[rsp]
	movss	xmm2, DWORD PTR x3$[rsp]
	mov	rax, QWORD PTR num_points$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point

; 3453 :       *num_points = *num_points+1;

	mov	rax, QWORD PTR num_points$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR num_points$[rsp]
	mov	DWORD PTR [rcx], eax
$LN4@stbtt__tes:
$LN1@stbtt__tes:

; 3454 :    }
; 3455 : }

	add	rsp, 216				; 000000d8H
	ret	0
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ENDP ; stbtt__tesselate_cubic
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
my$ = 80
mx$ = 84
dx$ = 88
dy$ = 92
points$ = 112
num_points$ = 120
x0$ = 128
y0$ = 136
x1$ = 144
y1$ = 152
x2$ = 160
y2$ = 168
objspace_flatness_squared$ = 176
n$ = 184
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z PROC ; stbtt__tesselate_curve

; 3396 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3397 :    // midpoint
; 3398 :    float mx = (x0 + 2*x1 + x2)/4;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR x1$[rsp]
	movss	xmm1, DWORD PTR x0$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR x2$[rsp]
	divss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR mx$[rsp], xmm0

; 3399 :    float my = (y0 + 2*y1 + y2)/4;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR y0$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR y2$[rsp]
	divss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR my$[rsp], xmm0

; 3400 :    // versus directly drawn line
; 3401 :    float dx = (x0+x2)/2 - mx;

	movss	xmm0, DWORD PTR x0$[rsp]
	addss	xmm0, DWORD PTR x2$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR mx$[rsp]
	movss	DWORD PTR dx$[rsp], xmm0

; 3402 :    float dy = (y0+y2)/2 - my;

	movss	xmm0, DWORD PTR y0$[rsp]
	addss	xmm0, DWORD PTR y2$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR my$[rsp]
	movss	DWORD PTR dy$[rsp], xmm0

; 3403 :    if (n > 16) // 65536 segments on one curve better be enough!

	cmp	DWORD PTR n$[rsp], 16
	jle	SHORT $LN2@stbtt__tes

; 3404 :       return 1;

	mov	eax, 1
	jmp	$LN1@stbtt__tes
$LN2@stbtt__tes:

; 3405 :    if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA

	movss	xmm0, DWORD PTR dx$[rsp]
	mulss	xmm0, DWORD PTR dx$[rsp]
	movss	xmm1, DWORD PTR dy$[rsp]
	mulss	xmm1, DWORD PTR dy$[rsp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR objspace_flatness_squared$[rsp]
	jbe	$LN3@stbtt__tes

; 3406 :       stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	movss	xmm0, DWORD PTR y0$[rsp]
	addss	xmm0, DWORD PTR y1$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR x0$[rsp]
	addss	xmm1, DWORD PTR x1$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	mov	DWORD PTR [rsp+72], eax
	movss	xmm2, DWORD PTR objspace_flatness_squared$[rsp]
	movss	DWORD PTR [rsp+64], xmm2
	movss	xmm2, DWORD PTR my$[rsp]
	movss	DWORD PTR [rsp+56], xmm2
	movss	xmm2, DWORD PTR mx$[rsp]
	movss	DWORD PTR [rsp+48], xmm2
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm1
	movss	xmm3, DWORD PTR y0$[rsp]
	movss	xmm2, DWORD PTR x0$[rsp]
	mov	rdx, QWORD PTR num_points$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3407 :       stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR y2$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR x1$[rsp]
	addss	xmm1, DWORD PTR x2$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	mov	DWORD PTR [rsp+72], eax
	movss	xmm2, DWORD PTR objspace_flatness_squared$[rsp]
	movss	DWORD PTR [rsp+64], xmm2
	movss	xmm2, DWORD PTR y2$[rsp]
	movss	DWORD PTR [rsp+56], xmm2
	movss	xmm2, DWORD PTR x2$[rsp]
	movss	DWORD PTR [rsp+48], xmm2
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm1
	movss	xmm3, DWORD PTR my$[rsp]
	movss	xmm2, DWORD PTR mx$[rsp]
	mov	rdx, QWORD PTR num_points$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve
	npad	1

; 3408 :    } else {

	jmp	SHORT $LN4@stbtt__tes
$LN3@stbtt__tes:

; 3409 :       stbtt__add_point(points, *num_points,x2,y2);

	movss	xmm3, DWORD PTR y2$[rsp]
	movss	xmm2, DWORD PTR x2$[rsp]
	mov	rax, QWORD PTR num_points$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR points$[rsp]
	call	?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point

; 3410 :       *num_points = *num_points+1;

	mov	rax, QWORD PTR num_points$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR num_points$[rsp]
	mov	DWORD PTR [rcx], eax
$LN4@stbtt__tes:

; 3411 :    }
; 3412 :    return 1;

	mov	eax, 1
$LN1@stbtt__tes:

; 3413 : }

	add	rsp, 104				; 00000068H
	ret	0
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ENDP ; stbtt__tesselate_curve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
points$ = 8
n$ = 16
x$ = 24
y$ = 32
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z PROC	; stbtt__add_point

; 3388 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 3389 :    if (!points) return; // during first pass, it's unallocated

	cmp	QWORD PTR points$[rsp], 0
	jne	SHORT $LN2@stbtt__add
	jmp	SHORT $LN1@stbtt__add
$LN2@stbtt__add:

; 3390 :    points[n].x = x;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR [rcx+rax*8], xmm0

; 3391 :    points[n].y = y;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR points$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR [rcx+rax*8+4], xmm0
$LN1@stbtt__add:

; 3392 : }

	ret	0
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ENDP	; stbtt__add_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
n$ = 64
i$ = 68
k$ = 72
j$ = 76
p$1 = 80
e$ = 88
m$ = 96
a$2 = 100
b$3 = 104
vsubsample$ = 108
tv66 = 112
tv163 = 116
tv162 = 120
tv165 = 124
y_scale_inv$ = 128
tv94 = 132
result$ = 160
pts$ = 168
wcount$ = 176
windings$ = 184
scale_x$ = 192
scale_y$ = 200
shift_x$ = 208
shift_y$ = 216
off_x$ = 224
off_y$ = 232
invert$ = 240
userdata$ = 248
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z PROC ; stbtt__rasterize

; 3331 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 3332 :    float y_scale_inv = invert ? -scale_y : scale_y;

	cmp	DWORD PTR invert$[rsp], 0
	je	SHORT $LN15@stbtt__ras
	movss	xmm0, DWORD PTR scale_y$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:
	movss	xmm0, DWORD PTR scale_y$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN16@stbtt__ras:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR y_scale_inv$[rsp], xmm0

; 3333 :    stbtt__edge *e;
; 3334 :    int n,i,j,k,m;
; 3335 : #if STBTT_RASTERIZER_VERSION == 1
; 3336 :    int vsubsample = result->h < 8 ? 15 : 5;
; 3337 : #elif STBTT_RASTERIZER_VERSION == 2
; 3338 :    int vsubsample = 1;

	mov	DWORD PTR vsubsample$[rsp], 1

; 3339 : #else
; 3340 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 3341 : #endif
; 3342 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 3343 : 
; 3344 :    // now we have to blow out the windings into explicit edge lists
; 3345 :    n = 0;

	mov	DWORD PTR n$[rsp], 0

; 3346 :    for (i=0; i < windings; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt__ras
$LN2@stbtt__ras:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt__ras:
	mov	eax, DWORD PTR windings$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbtt__ras

; 3347 :       n += wcount[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR wcount$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax
	jmp	SHORT $LN2@stbtt__ras
$LN3@stbtt__ras:

; 3348 : 
; 3349 :    e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 20
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR e$[rsp], rax

; 3350 :    if (e == 0) return;

	cmp	QWORD PTR e$[rsp], 0
	jne	SHORT $LN11@stbtt__ras
	jmp	$LN1@stbtt__ras
$LN11@stbtt__ras:

; 3351 :    n = 0;

	mov	DWORD PTR n$[rsp], 0

; 3352 : 
; 3353 :    m=0;

	mov	DWORD PTR m$[rsp], 0

; 3354 :    for (i=0; i < windings; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbtt__ras
$LN5@stbtt__ras:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbtt__ras:
	mov	eax, DWORD PTR windings$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN6@stbtt__ras

; 3355 :       stbtt__point *p = pts + m;

	movsxd	rax, DWORD PTR m$[rsp]
	mov	rcx, QWORD PTR pts$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p$1[rsp], rax

; 3356 :       m += wcount[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR wcount$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR m$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR m$[rsp], eax

; 3357 :       j = wcount[i]-1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR wcount$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	dec	eax
	mov	DWORD PTR j$[rsp], eax

; 3358 :       for (k=0; k < wcount[i]; j=k++) {

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN10@stbtt__ras
$LN8@stbtt__ras:
	mov	eax, DWORD PTR k$[rsp]
	mov	DWORD PTR tv94[rsp], eax
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	mov	eax, DWORD PTR tv94[rsp]
	mov	DWORD PTR j$[rsp], eax
$LN10@stbtt__ras:
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR wcount$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	cmp	DWORD PTR k$[rsp], eax
	jge	$LN9@stbtt__ras

; 3359 :          int a=k,b=j;

	mov	eax, DWORD PTR k$[rsp]
	mov	DWORD PTR a$2[rsp], eax
	mov	eax, DWORD PTR j$[rsp]
	mov	DWORD PTR b$3[rsp], eax

; 3360 :          // skip the edge if horizontal
; 3361 :          if (p[j].y == p[k].y)

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR p$1[rsp]
	mov	r8, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rdx+rax*8+4]
	ucomiss	xmm0, DWORD PTR [r8+rcx*8+4]
	jp	SHORT $LN12@stbtt__ras
	jne	SHORT $LN12@stbtt__ras

; 3362 :             continue;

	jmp	SHORT $LN8@stbtt__ras
$LN12@stbtt__ras:

; 3363 :          // add edge from j to k to the list
; 3364 :          e[n].invert = 0;

	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	mov	DWORD PTR [rcx+rax+16], 0

; 3365 :          if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {

	cmp	DWORD PTR invert$[rsp], 0
	je	SHORT $LN21@stbtt__ras
	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR p$1[rsp]
	mov	r8, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rdx+rax*8+4]
	comiss	xmm0, DWORD PTR [r8+rcx*8+4]
	jbe	SHORT $LN19@stbtt__ras
	mov	DWORD PTR tv163[rsp], 1
	jmp	SHORT $LN20@stbtt__ras
$LN19@stbtt__ras:
	mov	DWORD PTR tv163[rsp], 0
$LN20@stbtt__ras:
	mov	eax, DWORD PTR tv163[rsp]
	mov	DWORD PTR tv165[rsp], eax
	jmp	SHORT $LN22@stbtt__ras
$LN21@stbtt__ras:
	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR p$1[rsp]
	mov	r8, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx*8+4]
	comiss	xmm0, DWORD PTR [r8+rax*8+4]
	jbe	SHORT $LN17@stbtt__ras
	mov	DWORD PTR tv162[rsp], 1
	jmp	SHORT $LN18@stbtt__ras
$LN17@stbtt__ras:
	mov	DWORD PTR tv162[rsp], 0
$LN18@stbtt__ras:
	mov	eax, DWORD PTR tv162[rsp]
	mov	DWORD PTR tv165[rsp], eax
$LN22@stbtt__ras:
	cmp	DWORD PTR tv165[rsp], 0
	je	SHORT $LN13@stbtt__ras

; 3366 :             e[n].invert = 1;

	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	mov	DWORD PTR [rcx+rax+16], 1

; 3367 :             a=j,b=k;

	mov	eax, DWORD PTR j$[rsp]
	mov	DWORD PTR a$2[rsp], eax
	mov	eax, DWORD PTR k$[rsp]
	mov	DWORD PTR b$3[rsp], eax
$LN13@stbtt__ras:

; 3368 :          }
; 3369 :          e[n].x0 = p[a].x * scale_x + shift_x;

	movsxd	rax, DWORD PTR a$2[rsp]
	mov	rcx, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	mulss	xmm0, DWORD PTR scale_x$[rsp]
	addss	xmm0, DWORD PTR shift_x$[rsp]
	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 3370 :          e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;

	movsxd	rax, DWORD PTR a$2[rsp]
	mov	rcx, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	mulss	xmm0, DWORD PTR y_scale_inv$[rsp]
	addss	xmm0, DWORD PTR shift_y$[rsp]
	cvtsi2ss xmm1, DWORD PTR vsubsample$[rsp]
	mulss	xmm0, xmm1
	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 3371 :          e[n].x1 = p[b].x * scale_x + shift_x;

	movsxd	rax, DWORD PTR b$3[rsp]
	mov	rcx, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	mulss	xmm0, DWORD PTR scale_x$[rsp]
	addss	xmm0, DWORD PTR shift_x$[rsp]
	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	movss	DWORD PTR [rcx+rax+8], xmm0

; 3372 :          e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;

	movsxd	rax, DWORD PTR b$3[rsp]
	mov	rcx, QWORD PTR p$1[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	mulss	xmm0, DWORD PTR y_scale_inv$[rsp]
	addss	xmm0, DWORD PTR shift_y$[rsp]
	cvtsi2ss xmm1, DWORD PTR vsubsample$[rsp]
	mulss	xmm0, xmm1
	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	movss	DWORD PTR [rcx+rax+12], xmm0

; 3373 :          ++n;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 3374 :       }

	jmp	$LN8@stbtt__ras
$LN9@stbtt__ras:

; 3375 :    }

	jmp	$LN5@stbtt__ras
$LN6@stbtt__ras:

; 3376 : 
; 3377 :    // now sort the edges by their highest point (should snap to integer, and then by x)
; 3378 :    //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
; 3379 :    stbtt__sort_edges(e, n);

	mov	edx, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR e$[rsp]
	call	?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges

; 3380 : 
; 3381 :    // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
; 3382 :    stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

	mov	rax, QWORD PTR userdata$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR off_y$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR off_x$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR vsubsample$[rsp]
	mov	r8d, DWORD PTR n$[rsp]
	mov	rdx, QWORD PTR e$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	call	?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ; stbtt__rasterize_sorted_edges

; 3383 : 
; 3384 :    STBTT_free(e, userdata);

	mov	rcx, QWORD PTR e$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN1@stbtt__ras:

; 3385 : }

	add	rsp, 152				; 00000098H
	ret	0
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ENDP ; stbtt__rasterize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 48
n$ = 56
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z PROC	; stbtt__sort_edges

; 3320 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3321 :    stbtt__sort_edges_quicksort(p, n);

	mov	edx, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3322 :    stbtt__sort_edges_ins_sort(p, n);

	mov	edx, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_ins_sort
	npad	1

; 3323 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z ENDP	; stbtt__sort_edges
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
m$3 = 40
tv74 = 44
tv85 = 48
tv128 = 52
c12$4 = 56
tv131 = 60
z$5 = 64
c01$6 = 68
c$7 = 72
tv235 = 80
tv252 = 88
tv279 = 96
t$8 = 104
__$ArrayPad$ = 128
p$ = 176
n$ = 184
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_quicksort

; 3258 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
$LN2@stbtt__sor:

; 3259 :    /* threshold for transitioning to insertion sort */
; 3260 :    while (n > 12) {

	cmp	DWORD PTR n$[rsp], 12
	jle	$LN3@stbtt__sor

; 3261 :       stbtt__edge t;
; 3262 :       int c01,c12,c,m,i,j;
; 3263 : 
; 3264 :       /* compute median of three */
; 3265 :       m = n >> 1;

	mov	eax, DWORD PTR n$[rsp]
	sar	eax, 1
	mov	DWORD PTR m$3[rsp], eax

; 3266 :       c01 = STBTT__COMPARE(&p[0],&p[m]);

	mov	eax, 20
	imul	rax, rax, 0
	movsxd	rcx, DWORD PTR m$3[rsp]
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx+4]
	comiss	xmm0, DWORD PTR [r8+rax+4]
	jbe	SHORT $LN20@stbtt__sor
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN21@stbtt__sor
$LN20@stbtt__sor:
	mov	DWORD PTR tv74[rsp], 0
$LN21@stbtt__sor:
	mov	eax, DWORD PTR tv74[rsp]
	mov	DWORD PTR c01$6[rsp], eax

; 3267 :       c12 = STBTT__COMPARE(&p[m],&p[n-1]);

	movsxd	rax, DWORD PTR m$3[rsp]
	imul	rax, rax, 20
	mov	ecx, DWORD PTR n$[rsp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx+4]
	comiss	xmm0, DWORD PTR [r8+rax+4]
	jbe	SHORT $LN22@stbtt__sor
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN23@stbtt__sor
$LN22@stbtt__sor:
	mov	DWORD PTR tv85[rsp], 0
$LN23@stbtt__sor:
	mov	eax, DWORD PTR tv85[rsp]
	mov	DWORD PTR c12$4[rsp], eax

; 3268 :       /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
; 3269 :       if (c01 != c12) {

	mov	eax, DWORD PTR c12$4[rsp]
	cmp	DWORD PTR c01$6[rsp], eax
	je	$LN13@stbtt__sor

; 3270 :          /* otherwise, we'll need to swap something else to middle */
; 3271 :          int z;
; 3272 :          c = STBTT__COMPARE(&p[0],&p[n-1]);

	mov	eax, 20
	imul	rax, rax, 0
	mov	ecx, DWORD PTR n$[rsp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx+4]
	comiss	xmm0, DWORD PTR [r8+rax+4]
	jbe	SHORT $LN24@stbtt__sor
	mov	DWORD PTR tv128[rsp], 1
	jmp	SHORT $LN25@stbtt__sor
$LN24@stbtt__sor:
	mov	DWORD PTR tv128[rsp], 0
$LN25@stbtt__sor:
	mov	eax, DWORD PTR tv128[rsp]
	mov	DWORD PTR c$7[rsp], eax

; 3273 :          /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
; 3274 :          /* 0<mid && mid>n:  0>n => 0; 0<n => n */
; 3275 :          z = (c == c12) ? 0 : n-1;

	mov	eax, DWORD PTR c12$4[rsp]
	cmp	DWORD PTR c$7[rsp], eax
	jne	SHORT $LN26@stbtt__sor
	mov	DWORD PTR tv131[rsp], 0
	jmp	SHORT $LN27@stbtt__sor
$LN26@stbtt__sor:
	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	mov	DWORD PTR tv131[rsp], eax
$LN27@stbtt__sor:
	mov	eax, DWORD PTR tv131[rsp]
	mov	DWORD PTR z$5[rsp], eax

; 3276 :          t = p[z];

	movsxd	rax, DWORD PTR z$5[rsp]
	imul	rax, rax, 20
	lea	rcx, QWORD PTR t$8[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 20
	rep movsb

; 3277 :          p[z] = p[m];

	movsxd	rax, DWORD PTR m$3[rsp]
	imul	rax, rax, 20
	movsxd	rcx, DWORD PTR z$5[rsp]
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, QWORD PTR p$[rsp]
	mov	QWORD PTR tv235[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv235[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 20
	rep movsb

; 3278 :          p[m] = t;

	movsxd	rax, DWORD PTR m$3[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR p$[rsp]
	lea	rdx, QWORD PTR t$8[rsp]
	lea	rdi, QWORD PTR [rcx+rax]
	mov	rsi, rdx
	mov	ecx, 20
	rep movsb
$LN13@stbtt__sor:

; 3279 :       }
; 3280 :       /* now p[m] is the median-of-three */
; 3281 :       /* swap it to the beginning so it won't move around */
; 3282 :       t = p[0];

	mov	eax, 20
	imul	rax, rax, 0
	lea	rcx, QWORD PTR t$8[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 20
	rep movsb

; 3283 :       p[0] = p[m];

	movsxd	rax, DWORD PTR m$3[rsp]
	imul	rax, rax, 20
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, QWORD PTR p$[rsp]
	mov	QWORD PTR tv252[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv252[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 20
	rep movsb

; 3284 :       p[m] = t;

	movsxd	rax, DWORD PTR m$3[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR p$[rsp]
	lea	rdx, QWORD PTR t$8[rsp]
	lea	rdi, QWORD PTR [rcx+rax]
	mov	rsi, rdx
	mov	ecx, 20
	rep movsb

; 3285 : 
; 3286 :       /* partition loop */
; 3287 :       i=1;

	mov	DWORD PTR i$1[rsp], 1

; 3288 :       j=n-1;

	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	mov	DWORD PTR j$2[rsp], eax
$LN4@stbtt__sor:

; 3289 :       for(;;) {
; 3290 :          /* handling of equality is crucial here */
; 3291 :          /* for sentinels & efficiency with duplicates */
; 3292 :          for (;;++i) {

	jmp	SHORT $LN9@stbtt__sor
$LN7@stbtt__sor:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@stbtt__sor:

; 3293 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 20
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx+4]
	comiss	xmm0, DWORD PTR [rdi+rax+4]
	ja	SHORT $LN14@stbtt__sor
	jmp	SHORT $LN8@stbtt__sor
$LN14@stbtt__sor:

; 3294 :          }

	jmp	SHORT $LN7@stbtt__sor
$LN8@stbtt__sor:

; 3295 :          for (;;--j) {

	jmp	SHORT $LN12@stbtt__sor
$LN10@stbtt__sor:
	mov	eax, DWORD PTR j$2[rsp]
	dec	eax
	mov	DWORD PTR j$2[rsp], eax
$LN12@stbtt__sor:

; 3296 :             if (!STBTT__COMPARE(&p[0], &p[j])) break;

	mov	eax, 20
	imul	rax, rax, 0
	movsxd	rcx, DWORD PTR j$2[rsp]
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rdx+rcx+4]
	comiss	xmm0, DWORD PTR [rdi+rax+4]
	ja	SHORT $LN15@stbtt__sor
	jmp	SHORT $LN11@stbtt__sor
$LN15@stbtt__sor:

; 3297 :          }

	jmp	SHORT $LN10@stbtt__sor
$LN11@stbtt__sor:

; 3298 :          /* make sure we haven't crossed */
; 3299 :          if (i >= j) break;

	mov	eax, DWORD PTR j$2[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jl	SHORT $LN16@stbtt__sor
	jmp	$LN5@stbtt__sor
$LN16@stbtt__sor:

; 3300 :          t = p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 20
	lea	rcx, QWORD PTR t$8[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 20
	rep movsb

; 3301 :          p[i] = p[j];

	movsxd	rax, DWORD PTR j$2[rsp]
	imul	rax, rax, 20
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, QWORD PTR p$[rsp]
	mov	QWORD PTR tv279[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv279[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 20
	rep movsb

; 3302 :          p[j] = t;

	movsxd	rax, DWORD PTR j$2[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR p$[rsp]
	lea	rdx, QWORD PTR t$8[rsp]
	lea	rdi, QWORD PTR [rcx+rax]
	mov	rsi, rdx
	mov	ecx, 20
	rep movsb

; 3303 : 
; 3304 :          ++i;

	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax

; 3305 :          --j;

	mov	eax, DWORD PTR j$2[rsp]
	dec	eax
	mov	DWORD PTR j$2[rsp], eax

; 3306 :       }

	jmp	$LN4@stbtt__sor
$LN5@stbtt__sor:

; 3307 :       /* recurse on smaller side, iterate on larger */
; 3308 :       if (j < (n-i)) {

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR j$2[rsp], eax
	jge	SHORT $LN17@stbtt__sor

; 3309 :          stbtt__sort_edges_quicksort(p,j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3310 :          p = p+i;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 3311 :          n = n-i;

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3312 :       } else {

	jmp	SHORT $LN18@stbtt__sor
$LN17@stbtt__sor:

; 3313 :          stbtt__sort_edges_quicksort(p+i, n-i);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3314 :          n = j;

	mov	eax, DWORD PTR j$2[rsp]
	mov	DWORD PTR n$[rsp], eax
$LN18@stbtt__sor:

; 3315 :       }
; 3316 :    }

	jmp	$LN2@stbtt__sor
$LN3@stbtt__sor:

; 3317 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_quicksort
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
j$ = 0
i$ = 4
tv78 = 8
c$1 = 12
b$2 = 16
a$3 = 24
tv142 = 32
t$4 = 40
__$ArrayPad$ = 64
p$ = 112
n$ = 120
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_ins_sort

; 3240 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3241 :    int i,j;
; 3242 :    for (i=1; i < n; ++i) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN4@stbtt__sor
$LN2@stbtt__sor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt__sor:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbtt__sor

; 3243 :       stbtt__edge t = p[i], *a = &t;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 20
	lea	rcx, QWORD PTR t$4[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 20
	rep movsb
	lea	rax, QWORD PTR t$4[rsp]
	mov	QWORD PTR a$3[rsp], rax

; 3244 :       j = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$[rsp], eax
$LN5@stbtt__sor:

; 3245 :       while (j > 0) {

	cmp	DWORD PTR j$[rsp], 0
	jle	$LN6@stbtt__sor

; 3246 :          stbtt__edge *b = &p[j-1];

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 20
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR b$2[rsp], rax

; 3247 :          int c = STBTT__COMPARE(a,b);

	mov	rax, QWORD PTR b$2[rsp]
	mov	rcx, QWORD PTR a$3[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN10@stbtt__sor
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN11@stbtt__sor
$LN10@stbtt__sor:
	mov	DWORD PTR tv78[rsp], 0
$LN11@stbtt__sor:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR c$1[rsp], eax

; 3248 :          if (!c) break;

	cmp	DWORD PTR c$1[rsp], 0
	jne	SHORT $LN7@stbtt__sor
	jmp	SHORT $LN6@stbtt__sor
$LN7@stbtt__sor:

; 3249 :          p[j] = p[j-1];

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 20
	movsxd	rcx, DWORD PTR j$[rsp]
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdi, QWORD PTR p$[rsp]
	mov	QWORD PTR tv142[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv142[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 20
	rep movsb

; 3250 :          --j;

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax

; 3251 :       }

	jmp	$LN5@stbtt__sor
$LN6@stbtt__sor:

; 3252 :       if (i != j)

	mov	eax, DWORD PTR j$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	je	SHORT $LN8@stbtt__sor

; 3253 :          p[j] = t;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR p$[rsp]
	lea	rdx, QWORD PTR t$4[rsp]
	lea	rdi, QWORD PTR [rcx+rax]
	mov	rsi, rdx
	mov	ecx, 20
	rep movsb
$LN8@stbtt__sor:

; 3254 :    }

	jmp	$LN2@stbtt__sor
$LN3@stbtt__sor:

; 3255 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_ins_sort
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$ = 48
scan_y_top$1 = 52
j$ = 56
step$2 = 64
y$ = 72
sum$3 = 76
k$4 = 80
m$5 = 84
scanline$ = 88
active$ = 96
z$6 = 104
z$7 = 112
scan_y_bottom$8 = 120
scanline2$ = 128
z$9 = 136
hh$ = 144
scanline_data$ = 176
__$ArrayPad$ = 704
result$ = 736
e$ = 744
n$ = 752
vsubsample$ = 760
off_x$ = 768
off_y$ = 776
userdata$ = 784
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z PROC ; stbtt__rasterize_sorted_edges

; 3138 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 728				; 000002d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3139 :    stbtt__hheap hh = { 0, 0, 0 };

	mov	QWORD PTR hh$[rsp], 0
	mov	QWORD PTR hh$[rsp+8], 0
	mov	DWORD PTR hh$[rsp+16], 0

; 3140 :    stbtt__active_edge *active = NULL;

	mov	QWORD PTR active$[rsp], 0

; 3141 :    int y,j=0, i;

	mov	DWORD PTR j$[rsp], 0

; 3142 :    float scanline_data[129], *scanline, *scanline2;
; 3143 : 
; 3144 :    STBTT__NOTUSED(vsubsample);
; 3145 : 
; 3146 :    if (result->w > 64)

	mov	rax, QWORD PTR result$[rsp]
	cmp	DWORD PTR [rax], 64			; 00000040H
	jle	SHORT $LN13@stbtt__ras

; 3147 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

	mov	rax, QWORD PTR result$[rsp]
	mov	eax, DWORD PTR [rax]
	lea	eax, DWORD PTR [rax+rax+1]
	cdqe
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR scanline$[rsp], rax
	jmp	SHORT $LN14@stbtt__ras
$LN13@stbtt__ras:

; 3148 :    else
; 3149 :       scanline = scanline_data;

	lea	rax, QWORD PTR scanline_data$[rsp]
	mov	QWORD PTR scanline$[rsp], rax
$LN14@stbtt__ras:

; 3150 : 
; 3151 :    scanline2 = scanline + result->w;

	mov	rax, QWORD PTR result$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR scanline$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR scanline2$[rsp], rax

; 3152 : 
; 3153 :    y = off_y;

	mov	eax, DWORD PTR off_y$[rsp]
	mov	DWORD PTR y$[rsp], eax

; 3154 :    e[n].y0 = (float) (off_y + result->h) + 1;

	mov	rax, QWORD PTR result$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	ecx, DWORD PTR off_y$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f800000
	movsxd	rax, DWORD PTR n$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR e$[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
$LN2@stbtt__ras:

; 3155 : 
; 3156 :    while (j < result->h) {

	mov	rax, QWORD PTR result$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN3@stbtt__ras

; 3157 :       // find center of pixel for this scanline
; 3158 :       float scan_y_top    = y + 0.0f;

	cvtsi2ss xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR scan_y_top$1[rsp], xmm0

; 3159 :       float scan_y_bottom = y + 1.0f;

	cvtsi2ss xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR scan_y_bottom$8[rsp], xmm0

; 3160 :       stbtt__active_edge **step = &active;

	lea	rax, QWORD PTR active$[rsp]
	mov	QWORD PTR step$2[rsp], rax

; 3161 : 
; 3162 :       STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));

	mov	rax, QWORD PTR result$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR scanline$[rsp]
	call	memset

; 3163 :       STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

	mov	rax, QWORD PTR result$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	cdqe
	shl	rax, 2
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR scanline2$[rsp]
	call	memset
	npad	1
$LN4@stbtt__ras:

; 3164 : 
; 3165 :       // update all active edges;
; 3166 :       // remove all active edges that terminate before the top of this scanline
; 3167 :       while (*step) {

	mov	rax, QWORD PTR step$2[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN5@stbtt__ras

; 3168 :          stbtt__active_edge * z = *step;

	mov	rax, QWORD PTR step$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR z$7[rsp], rax

; 3169 :          if (z->ey <= scan_y_top) {

	mov	rax, QWORD PTR z$7[rsp]
	movss	xmm0, DWORD PTR scan_y_top$1[rsp]
	comiss	xmm0, DWORD PTR [rax+28]
	jb	SHORT $LN15@stbtt__ras

; 3170 :             *step = z->next; // delete from list

	mov	rax, QWORD PTR step$2[rsp]
	mov	rcx, QWORD PTR z$7[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 3171 :             STBTT_assert(z->direction);
; 3172 :             z->direction = 0;

	mov	rax, QWORD PTR z$7[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0

; 3173 :             stbtt__hheap_free(&hh, z);

	mov	rdx, QWORD PTR z$7[rsp]
	lea	rcx, QWORD PTR hh$[rsp]
	call	?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z ; stbtt__hheap_free
	npad	1

; 3174 :          } else {

	jmp	SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:

; 3175 :             step = &((*step)->next); // advance through list

	mov	rax, QWORD PTR step$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR step$2[rsp], rax
$LN16@stbtt__ras:

; 3176 :          }
; 3177 :       }

	jmp	SHORT $LN4@stbtt__ras
$LN5@stbtt__ras:
$LN6@stbtt__ras:

; 3178 : 
; 3179 :       // insert all edges that start before the bottom of this scanline
; 3180 :       while (e->y0 <= scan_y_bottom) {

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR scan_y_bottom$8[rsp]
	comiss	xmm0, DWORD PTR [rax+4]
	jb	$LN7@stbtt__ras

; 3181 :          if (e->y0 != e->y1) {

	mov	rax, QWORD PTR e$[rsp]
	mov	rcx, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR [rcx+12]
	jp	SHORT $LN25@stbtt__ras
	je	$LN17@stbtt__ras
$LN25@stbtt__ras:

; 3182 :             stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);

	mov	rax, QWORD PTR userdata$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR scan_y_top$1[rsp]
	mov	r8d, DWORD PTR off_x$[rsp]
	mov	rdx, QWORD PTR e$[rsp]
	lea	rcx, QWORD PTR hh$[rsp]
	call	?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z ; stbtt__new_active
	mov	QWORD PTR z$6[rsp], rax

; 3183 :             if (z != NULL) {

	cmp	QWORD PTR z$6[rsp], 0
	je	SHORT $LN18@stbtt__ras

; 3184 :                if (j == 0 && off_y != 0) {

	cmp	DWORD PTR j$[rsp], 0
	jne	SHORT $LN19@stbtt__ras
	cmp	DWORD PTR off_y$[rsp], 0
	je	SHORT $LN19@stbtt__ras

; 3185 :                   if (z->ey < scan_y_top) {

	mov	rax, QWORD PTR z$6[rsp]
	movss	xmm0, DWORD PTR scan_y_top$1[rsp]
	comiss	xmm0, DWORD PTR [rax+28]
	jbe	SHORT $LN20@stbtt__ras

; 3186 :                      // this can happen due to subpixel positioning and some kind of fp rounding error i think
; 3187 :                      z->ey = scan_y_top;

	mov	rax, QWORD PTR z$6[rsp]
	movss	xmm0, DWORD PTR scan_y_top$1[rsp]
	movss	DWORD PTR [rax+28], xmm0
$LN20@stbtt__ras:
$LN19@stbtt__ras:

; 3188 :                   }
; 3189 :                }
; 3190 :                STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
; 3191 :                // insert at front
; 3192 :                z->next = active;

	mov	rax, QWORD PTR z$6[rsp]
	mov	rcx, QWORD PTR active$[rsp]
	mov	QWORD PTR [rax], rcx

; 3193 :                active = z;

	mov	rax, QWORD PTR z$6[rsp]
	mov	QWORD PTR active$[rsp], rax
$LN18@stbtt__ras:
$LN17@stbtt__ras:

; 3194 :             }
; 3195 :          }
; 3196 :          ++e;

	mov	rax, QWORD PTR e$[rsp]
	add	rax, 20
	mov	QWORD PTR e$[rsp], rax

; 3197 :       }

	jmp	$LN6@stbtt__ras
$LN7@stbtt__ras:

; 3198 : 
; 3199 :       // now process all active edges
; 3200 :       if (active)

	cmp	QWORD PTR active$[rsp], 0
	je	SHORT $LN21@stbtt__ras

; 3201 :          stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

	mov	rax, QWORD PTR scanline2$[rsp]
	add	rax, 4
	movss	xmm0, DWORD PTR scan_y_top$1[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR active$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	mov	r8d, DWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ; stbtt__fill_active_edges_new
	npad	1
$LN21@stbtt__ras:

; 3202 : 
; 3203 :       {
; 3204 :          float sum = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR sum$3[rsp], xmm0

; 3205 :          for (i=0; i < result->w; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@stbtt__ras
$LN8@stbtt__ras:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbtt__ras:
	mov	rax, QWORD PTR result$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN9@stbtt__ras

; 3206 :             float k;
; 3207 :             int m;
; 3208 :             sum += scanline2[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR scanline2$[rsp]
	movss	xmm0, DWORD PTR sum$3[rsp]
	addss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR sum$3[rsp], xmm0

; 3209 :             k = scanline[i] + sum;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	addss	xmm0, DWORD PTR sum$3[rsp]
	movss	DWORD PTR k$4[rsp], xmm0

; 3210 :             k = (float) STBTT_fabs(k)*255 + 0.5f;

	movss	xmm0, DWORD PTR k$4[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR k$4[rsp], xmm0

; 3211 :             m = (int) k;

	cvttss2si eax, DWORD PTR k$4[rsp]
	mov	DWORD PTR m$5[rsp], eax

; 3212 :             if (m > 255) m = 255;

	cmp	DWORD PTR m$5[rsp], 255			; 000000ffH
	jle	SHORT $LN22@stbtt__ras
	mov	DWORD PTR m$5[rsp], 255			; 000000ffH
$LN22@stbtt__ras:

; 3213 :             result->pixels[j*result->stride + i] = (unsigned char) m;

	mov	rax, QWORD PTR result$[rsp]
	mov	ecx, DWORD PTR j$[rsp]
	imul	ecx, DWORD PTR [rax+8]
	mov	eax, ecx
	add	eax, DWORD PTR i$[rsp]
	cdqe
	mov	rcx, QWORD PTR result$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	edx, BYTE PTR m$5[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 3214 :          }

	jmp	$LN8@stbtt__ras
$LN9@stbtt__ras:

; 3215 :       }
; 3216 :       // advance all the edges
; 3217 :       step = &active;

	lea	rax, QWORD PTR active$[rsp]
	mov	QWORD PTR step$2[rsp], rax
$LN11@stbtt__ras:

; 3218 :       while (*step) {

	mov	rax, QWORD PTR step$2[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN12@stbtt__ras

; 3219 :          stbtt__active_edge *z = *step;

	mov	rax, QWORD PTR step$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR z$9[rsp], rax

; 3220 :          z->fx += z->fdx; // advance to position for current scanline

	mov	rax, QWORD PTR z$9[rsp]
	mov	rcx, QWORD PTR z$9[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx+12]
	mov	rax, QWORD PTR z$9[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 3221 :          step = &((*step)->next); // advance through list

	mov	rax, QWORD PTR step$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR step$2[rsp], rax

; 3222 :       }

	jmp	SHORT $LN11@stbtt__ras
$LN12@stbtt__ras:

; 3223 : 
; 3224 :       ++y;

	mov	eax, DWORD PTR y$[rsp]
	inc	eax
	mov	DWORD PTR y$[rsp], eax

; 3225 :       ++j;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 3226 :    }

	jmp	$LN2@stbtt__ras
$LN3@stbtt__ras:

; 3227 : 
; 3228 :    stbtt__hheap_cleanup(&hh, userdata);

	mov	rdx, QWORD PTR userdata$[rsp]
	lea	rcx, QWORD PTR hh$[rsp]
	call	?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z ; stbtt__hheap_cleanup
	npad	1

; 3229 : 
; 3230 :    if (scanline != scanline_data)

	lea	rax, QWORD PTR scanline_data$[rsp]
	cmp	QWORD PTR scanline$[rsp], rax
	je	SHORT $LN23@stbtt__ras

; 3231 :       STBTT_free(scanline, userdata);

	mov	rcx, QWORD PTR scanline$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN23@stbtt__ras:

; 3232 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 728				; 000002d8H
	ret	0
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ENDP ; stbtt__rasterize_sorted_edges
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
x0$1 = 64
x$2 = 68
x1$3 = 72
x2$4 = 76
x3$5 = 80
x_top$6 = 84
x0$7 = 88
x_bottom$8 = 92
x2$9 = 96
x1$10 = 100
sy1$11 = 104
sy0$12 = 108
y_bottom$ = 112
y1$13 = 116
y2$14 = 120
dx$15 = 124
y3$16 = 128
y0$17 = 132
x$18 = 136
t$19 = 140
x$20 = 144
dy$21 = 148
area$22 = 152
y_crossing$23 = 156
sign$24 = 160
xb$25 = 164
height$26 = 168
step$27 = 172
scanline$ = 192
scanline_fill$ = 200
len$ = 208
e$ = 216
y_top$ = 224
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z PROC ; stbtt__fill_active_edges_new

; 2974 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 2975 :    float y_bottom = y_top+1;

	movss	xmm0, DWORD PTR y_top$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR y_bottom$[rsp], xmm0
$LN2@stbtt__fil:

; 2976 : 
; 2977 :    while (e) {

	cmp	QWORD PTR e$[rsp], 0
	je	$LN3@stbtt__fil

; 2978 :       // brute force every pixel
; 2979 : 
; 2980 :       // compute intersection points with top & bottom
; 2981 :       STBTT_assert(e->ey >= y_top);
; 2982 : 
; 2983 :       if (e->fdx == 0) {

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	$LN10@stbtt__fil
	jne	$LN10@stbtt__fil

; 2984 :          float x0 = e->fx;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR x0$7[rsp], xmm0

; 2985 :          if (x0 < len) {

	cvtsi2ss xmm0, DWORD PTR len$[rsp]
	comiss	xmm0, DWORD PTR x0$7[rsp]
	jbe	$LN12@stbtt__fil

; 2986 :             if (x0 >= 0) {

	movss	xmm0, DWORD PTR x0$7[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN13@stbtt__fil

; 2987 :                stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);

	cvttss2si eax, DWORD PTR x0$7[rsp]
	movss	xmm0, DWORD PTR y_bottom$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x0$7[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$7[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2988 :                stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);

	cvttss2si eax, DWORD PTR x0$7[rsp]
	inc	eax
	mov	rcx, QWORD PTR scanline_fill$[rsp]
	sub	rcx, 4
	movss	xmm0, DWORD PTR y_bottom$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x0$7[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$7[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, eax
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1

; 2989 :             } else {

	jmp	SHORT $LN14@stbtt__fil
$LN13@stbtt__fil:

; 2990 :                stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);

	mov	rax, QWORD PTR scanline_fill$[rsp]
	sub	rax, 4
	movss	xmm0, DWORD PTR y_bottom$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x0$7[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$7[rsp]
	mov	r8, QWORD PTR e$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
$LN14@stbtt__fil:
$LN12@stbtt__fil:

; 2991 :             }
; 2992 :          }
; 2993 :       } else {

	jmp	$LN11@stbtt__fil
$LN10@stbtt__fil:

; 2994 :          float x0 = e->fx;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR x0$1[rsp], xmm0

; 2995 :          float dx = e->fdx;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR dx$15[rsp], xmm0

; 2996 :          float xb = x0 + dx;

	movss	xmm0, DWORD PTR x0$1[rsp]
	addss	xmm0, DWORD PTR dx$15[rsp]
	movss	DWORD PTR xb$25[rsp], xmm0

; 2997 :          float x_top, x_bottom;
; 2998 :          float sy0,sy1;
; 2999 :          float dy = e->fdy;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR dy$21[rsp], xmm0

; 3000 :          STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
; 3001 : 
; 3002 :          // compute endpoints of line segment clipped to this scanline (if the
; 3003 :          // line segment starts on this scanline. x0 is the intersection of the
; 3004 :          // line with y_top, but that may be off the line segment.
; 3005 :          if (e->sy > y_top) {

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	comiss	xmm0, DWORD PTR y_top$[rsp]
	jbe	SHORT $LN15@stbtt__fil

; 3006 :             x_top = x0 + dx * (e->sy - y_top);

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	subss	xmm0, DWORD PTR y_top$[rsp]
	movss	xmm1, DWORD PTR dx$15[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR x0$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x_top$6[rsp], xmm0

; 3007 :             sy0 = e->sy;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR sy0$12[rsp], xmm0

; 3008 :          } else {

	jmp	SHORT $LN16@stbtt__fil
$LN15@stbtt__fil:

; 3009 :             x_top = x0;

	movss	xmm0, DWORD PTR x0$1[rsp]
	movss	DWORD PTR x_top$6[rsp], xmm0

; 3010 :             sy0 = y_top;

	movss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR sy0$12[rsp], xmm0
$LN16@stbtt__fil:

; 3011 :          }
; 3012 :          if (e->ey < y_bottom) {

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR y_bottom$[rsp]
	comiss	xmm0, DWORD PTR [rax+28]
	jbe	SHORT $LN17@stbtt__fil

; 3013 :             x_bottom = x0 + dx * (e->ey - y_top);

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	subss	xmm0, DWORD PTR y_top$[rsp]
	movss	xmm1, DWORD PTR dx$15[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR x0$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x_bottom$8[rsp], xmm0

; 3014 :             sy1 = e->ey;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	movss	DWORD PTR sy1$11[rsp], xmm0

; 3015 :          } else {

	jmp	SHORT $LN18@stbtt__fil
$LN17@stbtt__fil:

; 3016 :             x_bottom = xb;

	movss	xmm0, DWORD PTR xb$25[rsp]
	movss	DWORD PTR x_bottom$8[rsp], xmm0

; 3017 :             sy1 = y_bottom;

	movss	xmm0, DWORD PTR y_bottom$[rsp]
	movss	DWORD PTR sy1$11[rsp], xmm0
$LN18@stbtt__fil:

; 3018 :          }
; 3019 : 
; 3020 :          if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {

	movss	xmm0, DWORD PTR x_top$6[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN19@stbtt__fil
	movss	xmm0, DWORD PTR x_bottom$8[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN19@stbtt__fil
	cvtsi2ss xmm0, DWORD PTR len$[rsp]
	comiss	xmm0, DWORD PTR x_top$6[rsp]
	jbe	$LN19@stbtt__fil
	cvtsi2ss xmm0, DWORD PTR len$[rsp]
	comiss	xmm0, DWORD PTR x_bottom$8[rsp]
	jbe	$LN19@stbtt__fil

; 3021 :             // from here on, we don't have to range check x values
; 3022 : 
; 3023 :             if ((int) x_top == (int) x_bottom) {

	cvttss2si eax, DWORD PTR x_top$6[rsp]
	cvttss2si ecx, DWORD PTR x_bottom$8[rsp]
	cmp	eax, ecx
	jne	$LN21@stbtt__fil

; 3024 :                float height;
; 3025 :                // simple case, only spans one pixel
; 3026 :                int x = (int) x_top;

	cvttss2si eax, DWORD PTR x_top$6[rsp]
	mov	DWORD PTR x$18[rsp], eax

; 3027 :                height = sy1 - sy0;

	movss	xmm0, DWORD PTR sy1$11[rsp]
	subss	xmm0, DWORD PTR sy0$12[rsp]
	movss	DWORD PTR height$26[rsp], xmm0

; 3028 :                STBTT_assert(x >= 0 && x < len);
; 3029 :                scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;

	cvtsi2ss xmm0, DWORD PTR x$18[rsp]
	movss	xmm1, DWORD PTR x_top$6[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR x$18[rsp]
	movss	xmm2, DWORD PTR x_bottom$8[rsp]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax+20]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR height$26[rsp]
	movsxd	rax, DWORD PTR x$18[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$18[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 3030 :                scanline_fill[x] += e->direction * height; // everything right of this pixel is filled

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	mulss	xmm0, DWORD PTR height$26[rsp]
	movsxd	rax, DWORD PTR x$18[rsp]
	mov	rcx, QWORD PTR scanline_fill$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$18[rsp]
	mov	rcx, QWORD PTR scanline_fill$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 3031 :             } else {

	jmp	$LN22@stbtt__fil
$LN21@stbtt__fil:

; 3032 :                int x,x1,x2;
; 3033 :                float y_crossing, step, sign, area;
; 3034 :                // covers 2+ pixels
; 3035 :                if (x_top > x_bottom) {

	movss	xmm0, DWORD PTR x_top$6[rsp]
	comiss	xmm0, DWORD PTR x_bottom$8[rsp]
	jbe	$LN23@stbtt__fil

; 3036 :                   // flip scanline vertically; signed area is the same
; 3037 :                   float t;
; 3038 :                   sy0 = y_bottom - (sy0 - y_top);

	movss	xmm0, DWORD PTR sy0$12[rsp]
	subss	xmm0, DWORD PTR y_top$[rsp]
	movss	xmm1, DWORD PTR y_bottom$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR sy0$12[rsp], xmm0

; 3039 :                   sy1 = y_bottom - (sy1 - y_top);

	movss	xmm0, DWORD PTR sy1$11[rsp]
	subss	xmm0, DWORD PTR y_top$[rsp]
	movss	xmm1, DWORD PTR y_bottom$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR sy1$11[rsp], xmm0

; 3040 :                   t = sy0, sy0 = sy1, sy1 = t;

	movss	xmm0, DWORD PTR sy0$12[rsp]
	movss	DWORD PTR t$19[rsp], xmm0
	movss	xmm0, DWORD PTR sy1$11[rsp]
	movss	DWORD PTR sy0$12[rsp], xmm0
	movss	xmm0, DWORD PTR t$19[rsp]
	movss	DWORD PTR sy1$11[rsp], xmm0

; 3041 :                   t = x_bottom, x_bottom = x_top, x_top = t;

	movss	xmm0, DWORD PTR x_bottom$8[rsp]
	movss	DWORD PTR t$19[rsp], xmm0
	movss	xmm0, DWORD PTR x_top$6[rsp]
	movss	DWORD PTR x_bottom$8[rsp], xmm0
	movss	xmm0, DWORD PTR t$19[rsp]
	movss	DWORD PTR x_top$6[rsp], xmm0

; 3042 :                   dx = -dx;

	movss	xmm0, DWORD PTR dx$15[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR dx$15[rsp], xmm0

; 3043 :                   dy = -dy;

	movss	xmm0, DWORD PTR dy$21[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR dy$21[rsp], xmm0

; 3044 :                   t = x0, x0 = xb, xb = t;

	movss	xmm0, DWORD PTR x0$1[rsp]
	movss	DWORD PTR t$19[rsp], xmm0
	movss	xmm0, DWORD PTR xb$25[rsp]
	movss	DWORD PTR x0$1[rsp], xmm0
	movss	xmm0, DWORD PTR t$19[rsp]
	movss	DWORD PTR xb$25[rsp], xmm0
$LN23@stbtt__fil:

; 3045 :                   // [DEAR IMGUI] Fix static analyzer warning
; 3046 :                   (void)dx; // [ImGui: fix static analyzer warning]
; 3047 :                }
; 3048 : 
; 3049 :                x1 = (int) x_top;

	cvttss2si eax, DWORD PTR x_top$6[rsp]
	mov	DWORD PTR x1$10[rsp], eax

; 3050 :                x2 = (int) x_bottom;

	cvttss2si eax, DWORD PTR x_bottom$8[rsp]
	mov	DWORD PTR x2$9[rsp], eax

; 3051 :                // compute intersection with y axis at x1+1
; 3052 :                y_crossing = (x1+1 - x0) * dy + y_top;

	mov	eax, DWORD PTR x1$10[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR x0$1[rsp]
	mulss	xmm0, DWORD PTR dy$21[rsp]
	addss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR y_crossing$23[rsp], xmm0

; 3053 : 
; 3054 :                sign = e->direction;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR sign$24[rsp], xmm0

; 3055 :                // area of the rectangle covered from y0..y_crossing
; 3056 :                area = sign * (y_crossing-sy0);

	movss	xmm0, DWORD PTR y_crossing$23[rsp]
	subss	xmm0, DWORD PTR sy0$12[rsp]
	movss	xmm1, DWORD PTR sign$24[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR area$22[rsp], xmm0

; 3057 :                // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
; 3058 :                scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

	cvtsi2ss xmm0, DWORD PTR x1$10[rsp]
	movss	xmm1, DWORD PTR x_top$6[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, DWORD PTR x1$10[rsp]
	inc	eax
	sub	eax, DWORD PTR x1$10[rsp]
	cvtsi2ss xmm1, eax
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR area$22[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x1$10[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x1$10[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 3059 : 
; 3060 :                step = sign * dy;

	movss	xmm0, DWORD PTR sign$24[rsp]
	mulss	xmm0, DWORD PTR dy$21[rsp]
	movss	DWORD PTR step$27[rsp], xmm0

; 3061 :                for (x = x1+1; x < x2; ++x) {

	mov	eax, DWORD PTR x1$10[rsp]
	inc	eax
	mov	DWORD PTR x$20[rsp], eax
	jmp	SHORT $LN6@stbtt__fil
$LN4@stbtt__fil:
	mov	eax, DWORD PTR x$20[rsp]
	inc	eax
	mov	DWORD PTR x$20[rsp], eax
$LN6@stbtt__fil:
	mov	eax, DWORD PTR x2$9[rsp]
	cmp	DWORD PTR x$20[rsp], eax
	jge	SHORT $LN5@stbtt__fil

; 3062 :                   scanline[x] += area + step/2;

	movss	xmm0, DWORD PTR step$27[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR area$22[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$20[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$20[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 3063 :                   area += step;

	movss	xmm0, DWORD PTR area$22[rsp]
	addss	xmm0, DWORD PTR step$27[rsp]
	movss	DWORD PTR area$22[rsp], xmm0

; 3064 :                }

	jmp	$LN4@stbtt__fil
$LN5@stbtt__fil:

; 3065 :                y_crossing += dy * (x2 - (x1+1));

	mov	eax, DWORD PTR x1$10[rsp]
	inc	eax
	mov	ecx, DWORD PTR x2$9[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR dy$21[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR y_crossing$23[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR y_crossing$23[rsp], xmm0

; 3066 : 
; 3067 :                STBTT_assert(STBTT_fabs(area) <= 1.01f);
; 3068 : 
; 3069 :                scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

	mov	eax, DWORD PTR x2$9[rsp]
	mov	ecx, DWORD PTR x2$9[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR x2$9[rsp]
	movss	xmm2, DWORD PTR x_bottom$8[rsp]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR sign$24[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR sy1$11[rsp]
	subss	xmm1, DWORD PTR y_crossing$23[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR area$22[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x2$9[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x2$9[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 3070 : 
; 3071 :                scanline_fill[x2] += sign * (sy1-sy0);

	movss	xmm0, DWORD PTR sy1$11[rsp]
	subss	xmm0, DWORD PTR sy0$12[rsp]
	movss	xmm1, DWORD PTR sign$24[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x2$9[rsp]
	mov	rcx, QWORD PTR scanline_fill$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x2$9[rsp]
	mov	rcx, QWORD PTR scanline_fill$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0
$LN22@stbtt__fil:

; 3072 :             }
; 3073 :          } else {

	jmp	$LN20@stbtt__fil
$LN19@stbtt__fil:

; 3074 :             // if edge goes outside of box we're drawing, we require
; 3075 :             // clipping logic. since this does not match the intended use
; 3076 :             // of this library, we use a different, very slow brute
; 3077 :             // force implementation
; 3078 :             int x;
; 3079 :             for (x=0; x < len; ++x) {

	mov	DWORD PTR x$2[rsp], 0
	jmp	SHORT $LN9@stbtt__fil
$LN7@stbtt__fil:
	mov	eax, DWORD PTR x$2[rsp]
	inc	eax
	mov	DWORD PTR x$2[rsp], eax
$LN9@stbtt__fil:
	mov	eax, DWORD PTR len$[rsp]
	cmp	DWORD PTR x$2[rsp], eax
	jge	$LN8@stbtt__fil

; 3080 :                // cases:
; 3081 :                //
; 3082 :                // there can be up to two intersections with the pixel. any intersection
; 3083 :                // with left or right edges can be handled by splitting into two (or three)
; 3084 :                // regions. intersections with top & bottom do not necessitate case-wise logic.
; 3085 :                //
; 3086 :                // the old way of doing this found the intersections with the left & right edges,
; 3087 :                // then used some simple logic to produce up to three segments in sorted order
; 3088 :                // from top-to-bottom. however, this had a problem: if an x edge was epsilon
; 3089 :                // across the x border, then the corresponding y position might not be distinct
; 3090 :                // from the other y segment, and it might ignored as an empty segment. to avoid
; 3091 :                // that, we need to explicitly produce segments based on x positions.
; 3092 : 
; 3093 :                // rename variables to clearly-defined pairs
; 3094 :                float y0 = y_top;

	movss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR y0$17[rsp], xmm0

; 3095 :                float x1 = (float) (x);

	cvtsi2ss xmm0, DWORD PTR x$2[rsp]
	movss	DWORD PTR x1$3[rsp], xmm0

; 3096 :                float x2 = (float) (x+1);

	mov	eax, DWORD PTR x$2[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR x2$4[rsp], xmm0

; 3097 :                float x3 = xb;

	movss	xmm0, DWORD PTR xb$25[rsp]
	movss	DWORD PTR x3$5[rsp], xmm0

; 3098 :                float y3 = y_bottom;

	movss	xmm0, DWORD PTR y_bottom$[rsp]
	movss	DWORD PTR y3$16[rsp], xmm0

; 3099 : 
; 3100 :                // x = e->x + e->dx * (y-y_top)
; 3101 :                // (y-y_top) = (x - e->x) / e->dx
; 3102 :                // y = (x - e->x) / e->dx + y_top
; 3103 :                float y1 = (x - x0) / dx + y_top;

	cvtsi2ss xmm0, DWORD PTR x$2[rsp]
	subss	xmm0, DWORD PTR x0$1[rsp]
	divss	xmm0, DWORD PTR dx$15[rsp]
	addss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR y1$13[rsp], xmm0

; 3104 :                float y2 = (x+1 - x0) / dx + y_top;

	mov	eax, DWORD PTR x$2[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR x0$1[rsp]
	divss	xmm0, DWORD PTR dx$15[rsp]
	addss	xmm0, DWORD PTR y_top$[rsp]
	movss	DWORD PTR y2$14[rsp], xmm0

; 3105 : 
; 3106 :                if (x0 < x1 && x3 > x2) {         // three segments descending down-right

	movss	xmm0, DWORD PTR x1$3[rsp]
	comiss	xmm0, DWORD PTR x0$1[rsp]
	jbe	$LN24@stbtt__fil
	movss	xmm0, DWORD PTR x3$5[rsp]
	comiss	xmm0, DWORD PTR x2$4[rsp]
	jbe	$LN24@stbtt__fil

; 3107 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x1$3[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3108 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);

	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x2$4[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x1$3[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3109 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x2$4[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
	jmp	$LN25@stbtt__fil
$LN24@stbtt__fil:

; 3110 :                } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left

	movss	xmm0, DWORD PTR x1$3[rsp]
	comiss	xmm0, DWORD PTR x3$5[rsp]
	jbe	$LN26@stbtt__fil
	movss	xmm0, DWORD PTR x0$1[rsp]
	comiss	xmm0, DWORD PTR x2$4[rsp]
	jbe	$LN26@stbtt__fil

; 3111 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x2$4[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3112 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);

	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x1$3[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x2$4[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3113 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x1$3[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
	jmp	$LN27@stbtt__fil
$LN26@stbtt__fil:

; 3114 :                } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right

	movss	xmm0, DWORD PTR x1$3[rsp]
	comiss	xmm0, DWORD PTR x0$1[rsp]
	jbe	$LN28@stbtt__fil
	movss	xmm0, DWORD PTR x3$5[rsp]
	comiss	xmm0, DWORD PTR x1$3[rsp]
	jbe	$LN28@stbtt__fil

; 3115 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x1$3[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3116 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x1$3[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
	jmp	$LN29@stbtt__fil
$LN28@stbtt__fil:

; 3117 :                } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left

	movss	xmm0, DWORD PTR x1$3[rsp]
	comiss	xmm0, DWORD PTR x3$5[rsp]
	jbe	$LN30@stbtt__fil
	movss	xmm0, DWORD PTR x0$1[rsp]
	comiss	xmm0, DWORD PTR x1$3[rsp]
	jbe	$LN30@stbtt__fil

; 3118 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x1$3[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3119 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y1$13[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x1$3[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
	jmp	$LN31@stbtt__fil
$LN30@stbtt__fil:

; 3120 :                } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right

	movss	xmm0, DWORD PTR x2$4[rsp]
	comiss	xmm0, DWORD PTR x0$1[rsp]
	jbe	$LN32@stbtt__fil
	movss	xmm0, DWORD PTR x3$5[rsp]
	comiss	xmm0, DWORD PTR x2$4[rsp]
	jbe	$LN32@stbtt__fil

; 3121 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x2$4[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3122 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x2$4[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
	jmp	$LN33@stbtt__fil
$LN32@stbtt__fil:

; 3123 :                } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left

	movss	xmm0, DWORD PTR x2$4[rsp]
	comiss	xmm0, DWORD PTR x3$5[rsp]
	jbe	$LN34@stbtt__fil
	movss	xmm0, DWORD PTR x0$1[rsp]
	comiss	xmm0, DWORD PTR x2$4[rsp]
	jbe	$LN34@stbtt__fil

; 3124 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x2$4[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3125 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y2$14[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x2$4[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1

; 3126 :                } else {  // one segment

	jmp	SHORT $LN35@stbtt__fil
$LN34@stbtt__fil:

; 3127 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);

	movss	xmm0, DWORD PTR y3$16[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR x3$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR y0$17[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR x0$1[rsp]
	mov	r8, QWORD PTR e$[rsp]
	mov	edx, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	npad	1
$LN35@stbtt__fil:
$LN33@stbtt__fil:
$LN31@stbtt__fil:
$LN29@stbtt__fil:
$LN27@stbtt__fil:
$LN25@stbtt__fil:

; 3128 :                }
; 3129 :             }

	jmp	$LN7@stbtt__fil
$LN8@stbtt__fil:
$LN20@stbtt__fil:
$LN11@stbtt__fil:

; 3130 :          }
; 3131 :       }
; 3132 :       e = e->next;

	mov	rax, QWORD PTR e$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR e$[rsp], rax

; 3133 :    }

	jmp	$LN2@stbtt__fil
$LN3@stbtt__fil:

; 3134 : }

	add	rsp, 184				; 000000b8H
	ret	0
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ENDP ; stbtt__fill_active_edges_new
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
scanline$ = 8
x$ = 16
e$ = 24
x0$ = 32
y0$ = 40
x1$ = 48
y1$ = 56
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z PROC ; stbtt__handle_clipped_edge

; 2937 : {

	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 2938 :    if (y0 == y1) return;

	movss	xmm0, DWORD PTR y0$[rsp]
	ucomiss	xmm0, DWORD PTR y1$[rsp]
	jp	SHORT $LN2@stbtt__han
	jne	SHORT $LN2@stbtt__han
	jmp	$LN1@stbtt__han
$LN2@stbtt__han:

; 2939 :    STBTT_assert(y0 < y1);
; 2940 :    STBTT_assert(e->sy <= e->ey);
; 2941 :    if (y0 > e->ey) return;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR y0$[rsp]
	comiss	xmm0, DWORD PTR [rax+28]
	jbe	SHORT $LN3@stbtt__han
	jmp	$LN1@stbtt__han
$LN3@stbtt__han:

; 2942 :    if (y1 < e->sy) return;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	comiss	xmm0, DWORD PTR y1$[rsp]
	jbe	SHORT $LN4@stbtt__han
	jmp	$LN1@stbtt__han
$LN4@stbtt__han:

; 2943 :    if (y0 < e->sy) {

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	comiss	xmm0, DWORD PTR y0$[rsp]
	jbe	SHORT $LN5@stbtt__han

; 2944 :       x0 += (x1-x0) * (e->sy - y0) / (y1-y0);

	movss	xmm0, DWORD PTR x1$[rsp]
	subss	xmm0, DWORD PTR x0$[rsp]
	mov	rax, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax+24]
	subss	xmm1, DWORD PTR y0$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR y1$[rsp]
	subss	xmm1, DWORD PTR y0$[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR x0$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x0$[rsp], xmm0

; 2945 :       y0 = e->sy;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR y0$[rsp], xmm0
$LN5@stbtt__han:

; 2946 :    }
; 2947 :    if (y1 > e->ey) {

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR y1$[rsp]
	comiss	xmm0, DWORD PTR [rax+28]
	jbe	SHORT $LN6@stbtt__han

; 2948 :       x1 += (x1-x0) * (e->ey - y1) / (y1-y0);

	movss	xmm0, DWORD PTR x1$[rsp]
	subss	xmm0, DWORD PTR x0$[rsp]
	mov	rax, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax+28]
	subss	xmm1, DWORD PTR y1$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR y1$[rsp]
	subss	xmm1, DWORD PTR y0$[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR x1$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x1$[rsp], xmm0

; 2949 :       y1 = e->ey;

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	movss	DWORD PTR y1$[rsp], xmm0
$LN6@stbtt__han:

; 2950 :    }
; 2951 : 
; 2952 :    if (x0 == x)

	cvtsi2ss xmm0, DWORD PTR x$[rsp]
	movss	xmm1, DWORD PTR x0$[rsp]
	ucomiss	xmm1, xmm0
	jp	SHORT $LN7@stbtt__han
	jne	SHORT $LN7@stbtt__han

; 2953 :       STBTT_assert(x1 <= x+1);

	jmp	SHORT $LN8@stbtt__han
$LN7@stbtt__han:

; 2954 :    else if (x0 == x+1)

	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR x0$[rsp]
	ucomiss	xmm1, xmm0
	jp	SHORT $LN9@stbtt__han
	jne	SHORT $LN9@stbtt__han

; 2955 :       STBTT_assert(x1 >= x);

	jmp	SHORT $LN10@stbtt__han
$LN9@stbtt__han:

; 2956 :    else if (x0 <= x)

	cvtsi2ss xmm0, DWORD PTR x$[rsp]
	comiss	xmm0, DWORD PTR x0$[rsp]
	jb	SHORT $LN11@stbtt__han

; 2957 :       STBTT_assert(x1 <= x);

	jmp	SHORT $LN12@stbtt__han
$LN11@stbtt__han:

; 2958 :    else if (x0 >= x+1)

	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR x0$[rsp]
$LN12@stbtt__han:
$LN10@stbtt__han:
$LN8@stbtt__han:

; 2959 :       STBTT_assert(x1 >= x+1);
; 2960 :    else
; 2961 :       STBTT_assert(x1 >= x && x1 <= x+1);
; 2962 : 
; 2963 :    if (x0 <= x && x1 <= x)

	cvtsi2ss xmm0, DWORD PTR x$[rsp]
	comiss	xmm0, DWORD PTR x0$[rsp]
	jb	SHORT $LN15@stbtt__han
	cvtsi2ss xmm0, DWORD PTR x$[rsp]
	comiss	xmm0, DWORD PTR x1$[rsp]
	jb	SHORT $LN15@stbtt__han

; 2964 :       scanline[x] += e->direction * (y1-y0);

	movss	xmm0, DWORD PTR y1$[rsp]
	subss	xmm0, DWORD PTR y0$[rsp]
	mov	rax, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax+20]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0
	jmp	$LN16@stbtt__han
$LN15@stbtt__han:

; 2965 :    else if (x0 >= x+1 && x1 >= x+1)

	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR x0$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN17@stbtt__han
	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR x1$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN17@stbtt__han

; 2966 :       ;

	jmp	$LN18@stbtt__han
$LN17@stbtt__han:

; 2967 :    else {
; 2968 :       STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
; 2969 :       scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position

	movss	xmm0, DWORD PTR y1$[rsp]
	subss	xmm0, DWORD PTR y0$[rsp]
	mov	rax, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax+20]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR x$[rsp]
	movss	xmm2, DWORD PTR x0$[rsp]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	cvtsi2ss xmm2, DWORD PTR x$[rsp]
	movss	xmm3, DWORD PTR x1$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	mulss	xmm0, xmm1
	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax*4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR scanline$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0
$LN18@stbtt__han:
$LN16@stbtt__han:
$LN1@stbtt__han:

; 2970 :    }
; 2971 : }

	ret	0
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ENDP ; stbtt__handle_clipped_edge
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
dxdy$ = 32
tv80 = 36
tv94 = 40
z$ = 48
hh$ = 80
e$ = 88
off_x$ = 96
start_point$ = 104
userdata$ = 112
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z PROC ; stbtt__new_active

; 2766 : {

	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2767 :    stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);

	mov	r8, QWORD PTR userdata$[rsp]
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR hh$[rsp]
	call	?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z ; stbtt__hheap_alloc
	mov	QWORD PTR z$[rsp], rax

; 2768 :    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

	mov	rax, QWORD PTR e$[rsp]
	mov	rcx, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR e$[rsp]
	mov	rcx, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	subss	xmm1, DWORD PTR [rcx+4]
	divss	xmm0, xmm1
	movss	DWORD PTR dxdy$[rsp], xmm0

; 2769 :    STBTT_assert(z != NULL);
; 2770 :    //STBTT_assert(e->y0 <= start_point);
; 2771 :    if (!z) return z;

	cmp	QWORD PTR z$[rsp], 0
	jne	SHORT $LN2@stbtt__new
	mov	rax, QWORD PTR z$[rsp]
	jmp	$LN1@stbtt__new
$LN2@stbtt__new:

; 2772 :    z->fdx = dxdy;

	mov	rax, QWORD PTR z$[rsp]
	movss	xmm0, DWORD PTR dxdy$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 2773 :    z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;

	movss	xmm0, DWORD PTR dxdy$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN8@stbtt__new
	je	SHORT $LN4@stbtt__new
$LN8@stbtt__new:
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR dxdy$[rsp]
	movss	DWORD PTR tv80[rsp], xmm0
	jmp	SHORT $LN5@stbtt__new
$LN4@stbtt__new:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv80[rsp], xmm0
$LN5@stbtt__new:
	mov	rax, QWORD PTR z$[rsp]
	movss	xmm0, DWORD PTR tv80[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 2774 :    z->fx = e->x0 + dxdy * (start_point - e->y0);

	mov	rax, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR start_point$[rsp]
	subss	xmm0, DWORD PTR [rax+4]
	movss	xmm1, DWORD PTR dxdy$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR e$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR z$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 2775 :    z->fx -= off_x;

	cvtsi2ss xmm0, DWORD PTR off_x$[rsp]
	mov	rax, QWORD PTR z$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR z$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 2776 :    z->direction = e->invert ? 1.0f : -1.0f;

	mov	rax, QWORD PTR e$[rsp]
	cmp	DWORD PTR [rax+16], 0
	je	SHORT $LN6@stbtt__new
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv94[rsp], xmm0
	jmp	SHORT $LN7@stbtt__new
$LN6@stbtt__new:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv94[rsp], xmm0
$LN7@stbtt__new:
	mov	rax, QWORD PTR z$[rsp]
	movss	xmm0, DWORD PTR tv94[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 2777 :    z->sy = e->y0;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [rax+24], xmm0

; 2778 :    z->ey = e->y1;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR e$[rsp]
	movss	xmm0, DWORD PTR [rcx+12]
	movss	DWORD PTR [rax+28], xmm0

; 2779 :    z->next = 0;

	mov	rax, QWORD PTR z$[rsp]
	mov	QWORD PTR [rax], 0

; 2780 :    return z;

	mov	rax, QWORD PTR z$[rsp]
$LN1@stbtt__new:

; 2781 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z ENDP ; stbtt__new_active
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$ = 32
n$1 = 40
hh$ = 64
userdata$ = 72
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_cleanup

; 2706 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2707 :    stbtt__hheap_chunk *c = hh->head;

	mov	rax, QWORD PTR hh$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c$[rsp], rax
$LN2@stbtt__hhe:

; 2708 :    while (c) {

	cmp	QWORD PTR c$[rsp], 0
	je	SHORT $LN3@stbtt__hhe

; 2709 :       stbtt__hheap_chunk *n = c->next;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR n$1[rsp], rax

; 2710 :       STBTT_free(c, userdata);

	mov	rcx, QWORD PTR c$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 2711 :       c = n;

	mov	rax, QWORD PTR n$1[rsp]
	mov	QWORD PTR c$[rsp], rax

; 2712 :    }

	jmp	SHORT $LN2@stbtt__hhe
$LN3@stbtt__hhe:

; 2713 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
hh$ = 8
p$ = 16
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_free

; 2700 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2701 :    *(void **) p = hh->first_free;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR hh$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 2702 :    hh->first_free = p;

	mov	rax, QWORD PTR hh$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 2703 : }

	ret	0
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_free
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv72 = 32
tv73 = 36
count$1 = 40
c$2 = 48
p$3 = 56
hh$ = 80
size$ = 88
userdata$ = 96
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z PROC ; stbtt__hheap_alloc

; 2679 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2680 :    if (hh->first_free) {

	mov	rax, QWORD PTR hh$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@stbtt__hhe

; 2681 :       void *p = hh->first_free;

	mov	rax, QWORD PTR hh$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR p$3[rsp], rax

; 2682 :       hh->first_free = * (void **) p;

	mov	rax, QWORD PTR hh$[rsp]
	mov	rcx, QWORD PTR p$3[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 2683 :       return p;

	mov	rax, QWORD PTR p$3[rsp]
	jmp	$LN1@stbtt__hhe

; 2684 :    } else {

	jmp	$LN3@stbtt__hhe
$LN2@stbtt__hhe:

; 2685 :       if (hh->num_remaining_in_head_chunk == 0) {

	mov	rax, QWORD PTR hh$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jne	$LN4@stbtt__hhe

; 2686 :          int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);

	cmp	QWORD PTR size$[rsp], 32		; 00000020H
	jae	SHORT $LN9@stbtt__hhe
	mov	DWORD PTR tv73[rsp], 2000		; 000007d0H
	jmp	SHORT $LN10@stbtt__hhe
$LN9@stbtt__hhe:
	cmp	QWORD PTR size$[rsp], 128		; 00000080H
	jae	SHORT $LN7@stbtt__hhe
	mov	DWORD PTR tv72[rsp], 800		; 00000320H
	jmp	SHORT $LN8@stbtt__hhe
$LN7@stbtt__hhe:
	mov	DWORD PTR tv72[rsp], 100		; 00000064H
$LN8@stbtt__hhe:
	mov	eax, DWORD PTR tv72[rsp]
	mov	DWORD PTR tv73[rsp], eax
$LN10@stbtt__hhe:
	mov	eax, DWORD PTR tv73[rsp]
	mov	DWORD PTR count$1[rsp], eax

; 2687 :          stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);

	movsxd	rax, DWORD PTR count$1[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	add	rax, 8
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR c$2[rsp], rax

; 2688 :          if (c == NULL)

	cmp	QWORD PTR c$2[rsp], 0
	jne	SHORT $LN5@stbtt__hhe

; 2689 :             return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@stbtt__hhe
$LN5@stbtt__hhe:

; 2690 :          c->next = hh->head;

	mov	rax, QWORD PTR c$2[rsp]
	mov	rcx, QWORD PTR hh$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 2691 :          hh->head = c;

	mov	rax, QWORD PTR hh$[rsp]
	mov	rcx, QWORD PTR c$2[rsp]
	mov	QWORD PTR [rax], rcx

; 2692 :          hh->num_remaining_in_head_chunk = count;

	mov	rax, QWORD PTR hh$[rsp]
	mov	ecx, DWORD PTR count$1[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN4@stbtt__hhe:

; 2693 :       }
; 2694 :       --hh->num_remaining_in_head_chunk;

	mov	rax, QWORD PTR hh$[rsp]
	mov	eax, DWORD PTR [rax+16]
	dec	eax
	mov	rcx, QWORD PTR hh$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 2695 :       return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

	mov	rax, QWORD PTR hh$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR hh$[rsp]
	movsxd	rcx, DWORD PTR [rcx+16]
	mov	rdx, QWORD PTR size$[rsp]
	imul	rdx, rcx
	mov	rcx, rdx
	lea	rax, QWORD PTR [rax+rcx+8]
$LN3@stbtt__hhe:
$LN1@stbtt__hhe:

; 2696 :    }
; 2697 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z ENDP ; stbtt__hheap_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
output_ctx$ = 32
count_ctx$ = 88
info$ = 160
glyph_index$ = 168
pvertices$ = 176
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeT2

; 2238 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 2239 :    // runs the charstring twice, once to count and once to output (to avoid realloc)
; 2240 :    stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

	mov	DWORD PTR count_ctx$[rsp], 1
	mov	DWORD PTR count_ctx$[rsp+4], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR count_ctx$[rsp+8], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR count_ctx$[rsp+12], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR count_ctx$[rsp+16], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR count_ctx$[rsp+20], xmm0
	mov	DWORD PTR count_ctx$[rsp+24], 0
	mov	DWORD PTR count_ctx$[rsp+28], 0
	mov	DWORD PTR count_ctx$[rsp+32], 0
	mov	DWORD PTR count_ctx$[rsp+36], 0
	mov	QWORD PTR count_ctx$[rsp+40], 0
	mov	DWORD PTR count_ctx$[rsp+48], 0

; 2241 :    stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);

	mov	DWORD PTR output_ctx$[rsp], 0
	mov	DWORD PTR output_ctx$[rsp+4], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR output_ctx$[rsp+8], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR output_ctx$[rsp+12], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR output_ctx$[rsp+16], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR output_ctx$[rsp+20], xmm0
	mov	DWORD PTR output_ctx$[rsp+24], 0
	mov	DWORD PTR output_ctx$[rsp+28], 0
	mov	DWORD PTR output_ctx$[rsp+32], 0
	mov	DWORD PTR output_ctx$[rsp+36], 0
	mov	QWORD PTR output_ctx$[rsp+40], 0
	mov	DWORD PTR output_ctx$[rsp+48], 0

; 2242 :    if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

	lea	r8, QWORD PTR count_ctx$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	test	eax, eax
	je	SHORT $LN2@stbtt__Get

; 2243 :       *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);

	movsxd	rax, DWORD PTR count_ctx$[rsp+48]
	imul	rax, rax, 14
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	rcx, QWORD PTR pvertices$[rsp]
	mov	QWORD PTR [rcx], rax

; 2244 :       output_ctx.pvertices = *pvertices;

	mov	rax, QWORD PTR pvertices$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR output_ctx$[rsp+40], rax

; 2245 :       if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

	lea	r8, QWORD PTR output_ctx$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	test	eax, eax
	je	SHORT $LN3@stbtt__Get

; 2246 :          STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
; 2247 :          return output_ctx.num_vertices;

	mov	eax, DWORD PTR output_ctx$[rsp+48]
	jmp	SHORT $LN1@stbtt__Get
$LN3@stbtt__Get:
$LN2@stbtt__Get:

; 2248 :       }
; 2249 :    }
; 2250 :    *pvertices = NULL;

	mov	rax, QWORD PTR pvertices$[rsp]
	mov	QWORD PTR [rax], 0

; 2251 :    return 0;

	xor	eax, eax
$LN1@stbtt__Get:

; 2252 : }

	add	rsp, 152				; 00000098H
	ret	0
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeT2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$ = 64
sp$ = 68
dy2$1 = 72
subr_stack_height$ = 76
dx3$2 = 80
dx2$3 = 84
dx1$4 = 88
dx6$5 = 92
dx5$6 = 96
dx4$7 = 100
b0$ = 104
dy1$8 = 108
dy5$9 = 112
f$ = 116
maskbits$ = 120
in_header$ = 124
dy6$10 = 128
tv76 = 132
tv470 = 136
dy3$11 = 140
dy4$12 = 144
clear_stack$ = 148
b$ = 152
tv225 = 168
has_subrs$ = 172
dy$13 = 176
dx$14 = 180
tv188 = 184
v$ = 188
tv456 = 192
b1$15 = 196
tv640 = 200
tv244 = 204
tv453 = 208
subrs$ = 216
$T16 = 240
$T17 = 256
$T18 = 272
$T19 = 288
$T20 = 304
$T21 = 320
$T22 = 336
$T23 = 352
s$ = 368
subr_stack$ = 560
__$ArrayPad$ = 720
info$ = 768
glyph_index$ = 776
c$ = 784
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z PROC ; stbtt__run_charstring

; 1979 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 744				; 000002e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1980 :    int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;

	mov	DWORD PTR in_header$[rsp], 1
	mov	DWORD PTR maskbits$[rsp], 0
	mov	DWORD PTR subr_stack_height$[rsp], 0
	mov	DWORD PTR sp$[rsp], 0

; 1981 :    int has_subrs = 0, clear_stack;

	mov	DWORD PTR has_subrs$[rsp], 0

; 1982 :    float s[48];
; 1983 :    stbtt__buf subr_stack[10], subrs = info->subrs, b;

	lea	rax, QWORD PTR subrs$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+112]
	mov	ecx, 16
	rep movsb

; 1984 :    float f;
; 1985 : 
; 1986 : #define STBTT__CSERR(s) (0)
; 1987 : 
; 1988 :    // this currently ignores the initial width value, which isn't needed if we have hmtx
; 1989 :    b = stbtt__cff_index_get(info->charstrings, glyph_index);

	lea	rax, QWORD PTR $T16[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+80]
	mov	ecx, 16
	rep movsb
	mov	r8d, DWORD PTR glyph_index$[rsp]
	lea	rdx, QWORD PTR $T16[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	lea	rcx, QWORD PTR $T17[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN2@stbtt__run:

; 1990 :    while (b.cursor < b.size) {

	mov	eax, DWORD PTR b$[rsp+12]
	cmp	DWORD PTR b$[rsp+8], eax
	jge	$LN3@stbtt__run

; 1991 :       i = 0;

	mov	DWORD PTR i$[rsp], 0

; 1992 :       clear_stack = 1;

	mov	DWORD PTR clear_stack$[rsp], 1

; 1993 :       b0 = stbtt__buf_get8(&b);

	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR b0$[rsp], eax

; 1994 :       switch (b0) {

	mov	eax, DWORD PTR b0$[rsp]
	mov	DWORD PTR tv76[rsp], eax
	mov	eax, DWORD PTR tv76[rsp]
	dec	eax
	mov	DWORD PTR tv76[rsp], eax
	cmp	DWORD PTR tv76[rsp], 30
	ja	$LN94@stbtt__run
	movsxd	rax, DWORD PTR tv76[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN108@stbtt__run[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN29@stbtt__run:
$LN30@stbtt__run:

; 1995 :       // @TODO implement hinting
; 1996 :       case 0x13: // hintmask
; 1997 :       case 0x14: // cntrmask
; 1998 :          if (in_header)

	cmp	DWORD PTR in_header$[rsp], 0
	je	SHORT $LN31@stbtt__run

; 1999 :             maskbits += (sp / 2); // implicit "vstem"

	mov	eax, DWORD PTR sp$[rsp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR maskbits$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR maskbits$[rsp], eax
$LN31@stbtt__run:

; 2000 :          in_header = 0;

	mov	DWORD PTR in_header$[rsp], 0

; 2001 :          stbtt__buf_skip(&b, (maskbits + 7) / 8);

	mov	eax, DWORD PTR maskbits$[rsp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	edx, eax
	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip
	npad	1

; 2002 :          break;

	jmp	$LN4@stbtt__run
$LN32@stbtt__run:
$LN33@stbtt__run:
$LN34@stbtt__run:
$LN35@stbtt__run:

; 2003 : 
; 2004 :       case 0x01: // hstem
; 2005 :       case 0x03: // vstem
; 2006 :       case 0x12: // hstemhm
; 2007 :       case 0x17: // vstemhm
; 2008 :          maskbits += (sp / 2);

	mov	eax, DWORD PTR sp$[rsp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR maskbits$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR maskbits$[rsp], eax

; 2009 :          break;

	jmp	$LN4@stbtt__run
$LN36@stbtt__run:

; 2010 : 
; 2011 :       case 0x15: // rmoveto
; 2012 :          in_header = 0;

	mov	DWORD PTR in_header$[rsp], 0

; 2013 :          if (sp < 2) return STBTT__CSERR("rmoveto stack");

	cmp	DWORD PTR sp$[rsp], 2
	jge	SHORT $LN37@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN37@stbtt__run:

; 2014 :          stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);

	mov	eax, DWORD PTR sp$[rsp]
	dec	eax
	cdqe
	mov	ecx, DWORD PTR sp$[rsp]
	sub	ecx, 2
	movsxd	rcx, ecx
	movss	xmm2, DWORD PTR s$[rsp+rax*4]
	movss	xmm1, DWORD PTR s$[rsp+rcx*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
	npad	1

; 2015 :          break;

	jmp	$LN4@stbtt__run
$LN38@stbtt__run:

; 2016 :       case 0x04: // vmoveto
; 2017 :          in_header = 0;

	mov	DWORD PTR in_header$[rsp], 0

; 2018 :          if (sp < 1) return STBTT__CSERR("vmoveto stack");

	cmp	DWORD PTR sp$[rsp], 1
	jge	SHORT $LN39@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN39@stbtt__run:

; 2019 :          stbtt__csctx_rmove_to(c, 0, s[sp-1]);

	mov	eax, DWORD PTR sp$[rsp]
	dec	eax
	cdqe
	movss	xmm2, DWORD PTR s$[rsp+rax*4]
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
	npad	1

; 2020 :          break;

	jmp	$LN4@stbtt__run
$LN40@stbtt__run:

; 2021 :       case 0x16: // hmoveto
; 2022 :          in_header = 0;

	mov	DWORD PTR in_header$[rsp], 0

; 2023 :          if (sp < 1) return STBTT__CSERR("hmoveto stack");

	cmp	DWORD PTR sp$[rsp], 1
	jge	SHORT $LN41@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN41@stbtt__run:

; 2024 :          stbtt__csctx_rmove_to(c, s[sp-1], 0);

	mov	eax, DWORD PTR sp$[rsp]
	dec	eax
	cdqe
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR s$[rsp+rax*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
	npad	1

; 2025 :          break;

	jmp	$LN4@stbtt__run
$LN42@stbtt__run:

; 2026 : 
; 2027 :       case 0x05: // rlineto
; 2028 :          if (sp < 2) return STBTT__CSERR("rlineto stack");

	cmp	DWORD PTR sp$[rsp], 2
	jge	SHORT $LN43@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN43@stbtt__run:

; 2029 :          for (; i + 1 < sp; i += 2)

	jmp	SHORT $LN8@stbtt__run
$LN6@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	mov	DWORD PTR i$[rsp], eax
$LN8@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR sp$[rsp]
	jge	SHORT $LN7@stbtt__run

; 2030 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	movsxd	rcx, DWORD PTR i$[rsp]
	movss	xmm2, DWORD PTR s$[rsp+rax*4]
	movss	xmm1, DWORD PTR s$[rsp+rcx*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	npad	1
	jmp	SHORT $LN6@stbtt__run
$LN7@stbtt__run:

; 2031 :          break;

	jmp	$LN4@stbtt__run
$LN44@stbtt__run:

; 2032 : 
; 2033 :       // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
; 2034 :       // starting from a different place.
; 2035 : 
; 2036 :       case 0x07: // vlineto
; 2037 :          if (sp < 1) return STBTT__CSERR("vlineto stack");

	cmp	DWORD PTR sp$[rsp], 1
	jge	SHORT $LN45@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN45@stbtt__run:

; 2038 :          goto vlineto;

	jmp	SHORT $LN46@stbtt__run
	jmp	SHORT $vlineto$109
$LN47@stbtt__run:

; 2039 :       case 0x06: // hlineto
; 2040 :          if (sp < 1) return STBTT__CSERR("hlineto stack");

	cmp	DWORD PTR sp$[rsp], 1
	jge	SHORT $LN48@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN48@stbtt__run:
$LN9@stbtt__run:

; 2041 :          for (;;) {
; 2042 :             if (i >= sp) break;

	mov	eax, DWORD PTR sp$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jl	SHORT $LN49@stbtt__run
	jmp	SHORT $LN10@stbtt__run
$LN49@stbtt__run:

; 2043 :             stbtt__csctx_rline_to(c, s[i], 0);

	movsxd	rax, DWORD PTR i$[rsp]
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR s$[rsp+rax*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2044 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN46@stbtt__run:
$vlineto$109:

; 2045 :       vlineto:
; 2046 :             if (i >= sp) break;

	mov	eax, DWORD PTR sp$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jl	SHORT $LN50@stbtt__run
	jmp	SHORT $LN10@stbtt__run
$LN50@stbtt__run:

; 2047 :             stbtt__csctx_rline_to(c, 0, s[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	movss	xmm2, DWORD PTR s$[rsp+rax*4]
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2048 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2049 :          }

	jmp	SHORT $LN9@stbtt__run
$LN10@stbtt__run:

; 2050 :          break;

	jmp	$LN4@stbtt__run
$LN51@stbtt__run:

; 2051 : 
; 2052 :       case 0x1F: // hvcurveto
; 2053 :          if (sp < 4) return STBTT__CSERR("hvcurveto stack");

	cmp	DWORD PTR sp$[rsp], 4
	jge	SHORT $LN52@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN52@stbtt__run:

; 2054 :          goto hvcurveto;

	jmp	$LN53@stbtt__run
	jmp	$hvcurveto$110
$LN54@stbtt__run:

; 2055 :       case 0x1E: // vhcurveto
; 2056 :          if (sp < 4) return STBTT__CSERR("vhcurveto stack");

	cmp	DWORD PTR sp$[rsp], 4
	jge	SHORT $LN55@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN55@stbtt__run:
$LN12@stbtt__run:

; 2057 :          for (;;) {
; 2058 :             if (i + 3 >= sp) break;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cmp	eax, DWORD PTR sp$[rsp]
	jl	SHORT $LN56@stbtt__run
	jmp	$LN13@stbtt__run
$LN56@stbtt__run:

; 2059 :             stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR sp$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	eax, 5
	jne	SHORT $LN102@stbtt__run
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 4
	cdqe
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR tv188[rsp], xmm0
	jmp	SHORT $LN103@stbtt__run
$LN102@stbtt__run:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv188[rsp], xmm0
$LN103@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	movsxd	rdx, edx
	movsxd	rdi, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR tv188[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rcx*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rdx*4]
	movss	xmm2, DWORD PTR s$[rsp+rdi*4]
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2060 :             i += 4;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 4
	mov	DWORD PTR i$[rsp], eax
$LN53@stbtt__run:
$hvcurveto$110:

; 2061 :       hvcurveto:
; 2062 :             if (i + 3 >= sp) break;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cmp	eax, DWORD PTR sp$[rsp]
	jl	SHORT $LN57@stbtt__run
	jmp	$LN13@stbtt__run
$LN57@stbtt__run:

; 2063 :             stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cdqe
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR tv244[rsp], xmm0
	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR sp$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	eax, 5
	jne	SHORT $LN104@stbtt__run
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 4
	cdqe
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR tv225[rsp], xmm0
	jmp	SHORT $LN105@stbtt__run
$LN104@stbtt__run:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv225[rsp], xmm0
$LN105@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	movsxd	rdx, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR tv244[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR tv225[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rcx*4]
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR s$[rsp+rdx*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2064 :             i += 4;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 4
	mov	DWORD PTR i$[rsp], eax

; 2065 :          }

	jmp	$LN12@stbtt__run
$LN13@stbtt__run:

; 2066 :          break;

	jmp	$LN4@stbtt__run
$LN58@stbtt__run:

; 2067 : 
; 2068 :       case 0x08: // rrcurveto
; 2069 :          if (sp < 6) return STBTT__CSERR("rcurveline stack");

	cmp	DWORD PTR sp$[rsp], 6
	jge	SHORT $LN59@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN59@stbtt__run:

; 2070 :          for (; i + 5 < sp; i += 6)

	jmp	SHORT $LN17@stbtt__run
$LN15@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 6
	mov	DWORD PTR i$[rsp], eax
$LN17@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 5
	cmp	eax, DWORD PTR sp$[rsp]
	jge	$LN16@stbtt__run

; 2071 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 5
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 4
	movsxd	rcx, ecx
	mov	edx, DWORD PTR i$[rsp]
	add	edx, 3
	movsxd	rdx, edx
	mov	edi, DWORD PTR i$[rsp]
	add	edi, 2
	movsxd	rdi, edi
	mov	esi, DWORD PTR i$[rsp]
	inc	esi
	movsxd	rsi, esi
	movsxd	r8, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rcx*4]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rdx*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rdi*4]
	movss	xmm2, DWORD PTR s$[rsp+rsi*4]
	movss	xmm1, DWORD PTR s$[rsp+r8*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1
	jmp	$LN15@stbtt__run
$LN16@stbtt__run:

; 2072 :          break;

	jmp	$LN4@stbtt__run
$LN60@stbtt__run:

; 2073 : 
; 2074 :       case 0x18: // rcurveline
; 2075 :          if (sp < 8) return STBTT__CSERR("rcurveline stack");

	cmp	DWORD PTR sp$[rsp], 8
	jge	SHORT $LN61@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN61@stbtt__run:

; 2076 :          for (; i + 5 < sp - 2; i += 6)

	jmp	SHORT $LN20@stbtt__run
$LN18@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 6
	mov	DWORD PTR i$[rsp], eax
$LN20@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 5
	mov	ecx, DWORD PTR sp$[rsp]
	sub	ecx, 2
	cmp	eax, ecx
	jge	$LN19@stbtt__run

; 2077 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 5
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 4
	movsxd	rcx, ecx
	mov	edx, DWORD PTR i$[rsp]
	add	edx, 3
	movsxd	rdx, edx
	mov	edi, DWORD PTR i$[rsp]
	add	edi, 2
	movsxd	rdi, edi
	mov	esi, DWORD PTR i$[rsp]
	inc	esi
	movsxd	rsi, esi
	movsxd	r8, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rcx*4]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rdx*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rdi*4]
	movss	xmm2, DWORD PTR s$[rsp+rsi*4]
	movss	xmm1, DWORD PTR s$[rsp+r8*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1
	jmp	$LN18@stbtt__run
$LN19@stbtt__run:

; 2078 :          if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR sp$[rsp]
	jl	SHORT $LN62@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN62@stbtt__run:

; 2079 :          stbtt__csctx_rline_to(c, s[i], s[i+1]);

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	movsxd	rcx, DWORD PTR i$[rsp]
	movss	xmm2, DWORD PTR s$[rsp+rax*4]
	movss	xmm1, DWORD PTR s$[rsp+rcx*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	npad	1

; 2080 :          break;

	jmp	$LN4@stbtt__run
$LN63@stbtt__run:

; 2081 : 
; 2082 :       case 0x19: // rlinecurve
; 2083 :          if (sp < 8) return STBTT__CSERR("rlinecurve stack");

	cmp	DWORD PTR sp$[rsp], 8
	jge	SHORT $LN64@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN64@stbtt__run:

; 2084 :          for (; i + 1 < sp - 6; i += 2)

	jmp	SHORT $LN23@stbtt__run
$LN21@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	mov	DWORD PTR i$[rsp], eax
$LN23@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	ecx, DWORD PTR sp$[rsp]
	sub	ecx, 6
	cmp	eax, ecx
	jge	SHORT $LN22@stbtt__run

; 2085 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	movsxd	rcx, DWORD PTR i$[rsp]
	movss	xmm2, DWORD PTR s$[rsp+rax*4]
	movss	xmm1, DWORD PTR s$[rsp+rcx*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	npad	1
	jmp	SHORT $LN21@stbtt__run
$LN22@stbtt__run:

; 2086 :          if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 5
	cmp	eax, DWORD PTR sp$[rsp]
	jl	SHORT $LN65@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN65@stbtt__run:

; 2087 :          stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 5
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 4
	movsxd	rcx, ecx
	mov	edx, DWORD PTR i$[rsp]
	add	edx, 3
	movsxd	rdx, edx
	mov	edi, DWORD PTR i$[rsp]
	add	edi, 2
	movsxd	rdi, edi
	mov	esi, DWORD PTR i$[rsp]
	inc	esi
	movsxd	rsi, esi
	movsxd	r8, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rcx*4]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rdx*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rdi*4]
	movss	xmm2, DWORD PTR s$[rsp+rsi*4]
	movss	xmm1, DWORD PTR s$[rsp+r8*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1

; 2088 :          break;

	jmp	$LN4@stbtt__run
$LN66@stbtt__run:
$LN67@stbtt__run:

; 2089 : 
; 2090 :       case 0x1A: // vvcurveto
; 2091 :       case 0x1B: // hhcurveto
; 2092 :          if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");

	cmp	DWORD PTR sp$[rsp], 4
	jge	SHORT $LN68@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN68@stbtt__run:

; 2093 :          f = 0.0;

	xorps	xmm0, xmm0
	movss	DWORD PTR f$[rsp], xmm0

; 2094 :          if (sp & 1) { f = s[i]; i++; }

	mov	eax, DWORD PTR sp$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN69@stbtt__run
	movsxd	rax, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR f$[rsp], xmm0
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN69@stbtt__run:

; 2095 :          for (; i + 3 < sp; i += 4) {

	jmp	SHORT $LN26@stbtt__run
$LN24@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 4
	mov	DWORD PTR i$[rsp], eax
$LN26@stbtt__run:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cmp	eax, DWORD PTR sp$[rsp]
	jge	$LN25@stbtt__run

; 2096 :             if (b0 == 0x1B)

	cmp	DWORD PTR b0$[rsp], 27
	jne	SHORT $LN70@stbtt__run

; 2097 :                stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	movsxd	rdx, edx
	movsxd	rdi, DWORD PTR i$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rcx*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rdx*4]
	movss	xmm2, DWORD PTR f$[rsp]
	movss	xmm1, DWORD PTR s$[rsp+rdi*4]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1
	jmp	SHORT $LN71@stbtt__run
$LN70@stbtt__run:

; 2098 :             else
; 2099 :                stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	movsxd	rdx, edx
	movsxd	rdi, DWORD PTR i$[rsp]
	movss	xmm0, DWORD PTR s$[rsp+rax*4]
	movss	DWORD PTR [rsp+48], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rsp+rcx*4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR s$[rsp+rdx*4]
	movss	xmm2, DWORD PTR s$[rsp+rdi*4]
	movss	xmm1, DWORD PTR f$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1
$LN71@stbtt__run:

; 2100 :             f = 0.0;

	xorps	xmm0, xmm0
	movss	DWORD PTR f$[rsp], xmm0

; 2101 :          }

	jmp	$LN24@stbtt__run
$LN25@stbtt__run:

; 2102 :          break;

	jmp	$LN4@stbtt__run
$LN72@stbtt__run:

; 2103 : 
; 2104 :       case 0x0A: // callsubr
; 2105 :          if (!has_subrs) {

	cmp	DWORD PTR has_subrs$[rsp], 0
	jne	SHORT $LN73@stbtt__run

; 2106 :             if (info->fdselect.size)

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+156], 0
	je	SHORT $LN74@stbtt__run

; 2107 :                subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);

	mov	r8d, DWORD PTR glyph_index$[rsp]
	mov	rdx, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T22[rsp]
	call	?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ; stbtt__cid_get_glyph_subrs
	lea	rcx, QWORD PTR $T18[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR subrs$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN74@stbtt__run:

; 2108 :             has_subrs = 1;

	mov	DWORD PTR has_subrs$[rsp], 1
$LN73@stbtt__run:
$LN75@stbtt__run:

; 2109 :          }
; 2110 :          // fallthrough
; 2111 :       case 0x1D: // callgsubr
; 2112 :          if (sp < 1) return STBTT__CSERR("call(g|)subr stack");

	cmp	DWORD PTR sp$[rsp], 1
	jge	SHORT $LN76@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN76@stbtt__run:

; 2113 :          v = (int) s[--sp];

	mov	eax, DWORD PTR sp$[rsp]
	dec	eax
	mov	DWORD PTR sp$[rsp], eax
	movsxd	rax, DWORD PTR sp$[rsp]
	cvttss2si eax, DWORD PTR s$[rsp+rax*4]
	mov	DWORD PTR v$[rsp], eax

; 2114 :          if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");

	cmp	DWORD PTR subr_stack_height$[rsp], 10
	jl	SHORT $LN77@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN77@stbtt__run:

; 2115 :          subr_stack[subr_stack_height++] = b;

	movsxd	rax, DWORD PTR subr_stack_height$[rsp]
	imul	rax, rax, 16
	lea	rcx, QWORD PTR b$[rsp]
	lea	rdi, QWORD PTR subr_stack$[rsp+rax]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	mov	eax, DWORD PTR subr_stack_height$[rsp]
	inc	eax
	mov	DWORD PTR subr_stack_height$[rsp], eax

; 2116 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR tv456[rsp], eax
	cmp	DWORD PTR b0$[rsp], 10
	jne	SHORT $LN106@stbtt__run
	lea	rax, QWORD PTR subrs$[rsp]
	mov	QWORD PTR tv453[rsp], rax
	jmp	SHORT $LN107@stbtt__run
$LN106@stbtt__run:
	mov	rax, QWORD PTR info$[rsp]
	add	rax, 96					; 00000060H
	mov	QWORD PTR tv453[rsp], rax
$LN107@stbtt__run:
	lea	rax, QWORD PTR $T19[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR tv453[rsp]
	mov	ecx, 16
	rep movsb
	mov	r8d, DWORD PTR tv456[rsp]
	lea	rdx, QWORD PTR $T19[rsp]
	lea	rcx, QWORD PTR $T23[rsp]
	call	?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__get_subr
	lea	rcx, QWORD PTR $T20[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 2117 :          if (b.size == 0) return STBTT__CSERR("subr not found");

	cmp	DWORD PTR b$[rsp+12], 0
	jne	SHORT $LN78@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN78@stbtt__run:

; 2118 :          b.cursor = 0;

	mov	DWORD PTR b$[rsp+8], 0

; 2119 :          clear_stack = 0;

	mov	DWORD PTR clear_stack$[rsp], 0

; 2120 :          break;

	jmp	$LN4@stbtt__run
$LN79@stbtt__run:

; 2121 : 
; 2122 :       case 0x0B: // return
; 2123 :          if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");

	cmp	DWORD PTR subr_stack_height$[rsp], 0
	jg	SHORT $LN80@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN80@stbtt__run:

; 2124 :          b = subr_stack[--subr_stack_height];

	mov	eax, DWORD PTR subr_stack_height$[rsp]
	dec	eax
	mov	DWORD PTR subr_stack_height$[rsp], eax
	movsxd	rax, DWORD PTR subr_stack_height$[rsp]
	imul	rax, rax, 16
	lea	rcx, QWORD PTR b$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR subr_stack$[rsp+rax]
	mov	ecx, 16
	rep movsb

; 2125 :          clear_stack = 0;

	mov	DWORD PTR clear_stack$[rsp], 0

; 2126 :          break;

	jmp	$LN4@stbtt__run
$LN81@stbtt__run:

; 2127 : 
; 2128 :       case 0x0E: // endchar
; 2129 :          stbtt__csctx_close_shape(c);

	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 2130 :          return 1;

	mov	eax, 1
	jmp	$LN1@stbtt__run
$LN82@stbtt__run:

; 2131 : 
; 2132 :       case 0x0C: { // two-byte escape
; 2133 :          float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
; 2134 :          float dx, dy;
; 2135 :          int b1 = stbtt__buf_get8(&b);

	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR b1$15[rsp], eax

; 2136 :          switch (b1) {

	mov	eax, DWORD PTR b1$15[rsp]
	mov	DWORD PTR tv470[rsp], eax
	cmp	DWORD PTR tv470[rsp], 34		; 00000022H
	je	SHORT $LN83@stbtt__run
	cmp	DWORD PTR tv470[rsp], 35		; 00000023H
	je	$LN85@stbtt__run
	cmp	DWORD PTR tv470[rsp], 36		; 00000024H
	je	$LN87@stbtt__run
	cmp	DWORD PTR tv470[rsp], 37		; 00000025H
	je	$LN89@stbtt__run
	jmp	$LN93@stbtt__run
$LN83@stbtt__run:

; 2137 :          // @TODO These "flex" implementations ignore the flex-depth and resolution,
; 2138 :          // and always draw beziers.
; 2139 :          case 0x22: // hflex
; 2140 :             if (sp < 7) return STBTT__CSERR("hflex stack");

	cmp	DWORD PTR sp$[rsp], 7
	jge	SHORT $LN84@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN84@stbtt__run:

; 2141 :             dx1 = s[0];

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx1$4[rsp], xmm0

; 2142 :             dx2 = s[1];

	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx2$3[rsp], xmm0

; 2143 :             dy2 = s[2];

	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy2$1[rsp], xmm0

; 2144 :             dx3 = s[3];

	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx3$2[rsp], xmm0

; 2145 :             dx4 = s[4];

	mov	eax, 4
	imul	rax, rax, 4
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx4$7[rsp], xmm0

; 2146 :             dx5 = s[5];

	mov	eax, 4
	imul	rax, rax, 5
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx5$6[rsp], xmm0

; 2147 :             dx6 = s[6];

	mov	eax, 4
	imul	rax, rax, 6
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx6$5[rsp], xmm0

; 2148 :             stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx3$2[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy2$1[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx2$3[rsp]
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR dx1$4[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2149 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);

	movss	xmm0, DWORD PTR dy2$1[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm1, xmm1
	movss	DWORD PTR [rsp+48], xmm1
	movss	xmm1, DWORD PTR dx6$5[rsp]
	movss	DWORD PTR [rsp+40], xmm1
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx5$6[rsp]
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR dx4$7[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1

; 2150 :             break;

	jmp	$LN27@stbtt__run
$LN85@stbtt__run:

; 2151 : 
; 2152 :          case 0x23: // flex
; 2153 :             if (sp < 13) return STBTT__CSERR("flex stack");

	cmp	DWORD PTR sp$[rsp], 13
	jge	SHORT $LN86@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN86@stbtt__run:

; 2154 :             dx1 = s[0];

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx1$4[rsp], xmm0

; 2155 :             dy1 = s[1];

	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy1$8[rsp], xmm0

; 2156 :             dx2 = s[2];

	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx2$3[rsp], xmm0

; 2157 :             dy2 = s[3];

	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy2$1[rsp], xmm0

; 2158 :             dx3 = s[4];

	mov	eax, 4
	imul	rax, rax, 4
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx3$2[rsp], xmm0

; 2159 :             dy3 = s[5];

	mov	eax, 4
	imul	rax, rax, 5
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy3$11[rsp], xmm0

; 2160 :             dx4 = s[6];

	mov	eax, 4
	imul	rax, rax, 6
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx4$7[rsp], xmm0

; 2161 :             dy4 = s[7];

	mov	eax, 4
	imul	rax, rax, 7
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy4$12[rsp], xmm0

; 2162 :             dx5 = s[8];

	mov	eax, 4
	imul	rax, rax, 8
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx5$6[rsp], xmm0

; 2163 :             dy5 = s[9];

	mov	eax, 4
	imul	rax, rax, 9
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy5$9[rsp], xmm0

; 2164 :             dx6 = s[10];

	mov	eax, 4
	imul	rax, rax, 10
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx6$5[rsp], xmm0

; 2165 :             dy6 = s[11];

	mov	eax, 4
	imul	rax, rax, 11
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy6$10[rsp], xmm0

; 2166 :             //fd is s[12]
; 2167 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

	movss	xmm0, DWORD PTR dy3$11[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx3$2[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy2$1[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx2$3[rsp]
	movss	xmm2, DWORD PTR dy1$8[rsp]
	movss	xmm1, DWORD PTR dx1$4[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2168 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

	movss	xmm0, DWORD PTR dy6$10[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx6$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy5$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx5$6[rsp]
	movss	xmm2, DWORD PTR dy4$12[rsp]
	movss	xmm1, DWORD PTR dx4$7[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1

; 2169 :             break;

	jmp	$LN27@stbtt__run
$LN87@stbtt__run:

; 2170 : 
; 2171 :          case 0x24: // hflex1
; 2172 :             if (sp < 9) return STBTT__CSERR("hflex1 stack");

	cmp	DWORD PTR sp$[rsp], 9
	jge	SHORT $LN88@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN88@stbtt__run:

; 2173 :             dx1 = s[0];

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx1$4[rsp], xmm0

; 2174 :             dy1 = s[1];

	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy1$8[rsp], xmm0

; 2175 :             dx2 = s[2];

	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx2$3[rsp], xmm0

; 2176 :             dy2 = s[3];

	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy2$1[rsp], xmm0

; 2177 :             dx3 = s[4];

	mov	eax, 4
	imul	rax, rax, 4
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx3$2[rsp], xmm0

; 2178 :             dx4 = s[5];

	mov	eax, 4
	imul	rax, rax, 5
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx4$7[rsp], xmm0

; 2179 :             dx5 = s[6];

	mov	eax, 4
	imul	rax, rax, 6
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx5$6[rsp], xmm0

; 2180 :             dy5 = s[7];

	mov	eax, 4
	imul	rax, rax, 7
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy5$9[rsp], xmm0

; 2181 :             dx6 = s[8];

	mov	eax, 4
	imul	rax, rax, 8
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx6$5[rsp], xmm0

; 2182 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx3$2[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy2$1[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx2$3[rsp]
	movss	xmm2, DWORD PTR dy1$8[rsp]
	movss	xmm1, DWORD PTR dx1$4[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2183 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));

	movss	xmm0, DWORD PTR dy1$8[rsp]
	addss	xmm0, DWORD PTR dy2$1[rsp]
	addss	xmm0, DWORD PTR dy5$9[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx6$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy5$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx5$6[rsp]
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR dx4$7[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1

; 2184 :             break;

	jmp	$LN27@stbtt__run
$LN89@stbtt__run:

; 2185 : 
; 2186 :          case 0x25: // flex1
; 2187 :             if (sp < 11) return STBTT__CSERR("flex1 stack");

	cmp	DWORD PTR sp$[rsp], 11
	jge	SHORT $LN90@stbtt__run
	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN90@stbtt__run:

; 2188 :             dx1 = s[0];

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx1$4[rsp], xmm0

; 2189 :             dy1 = s[1];

	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy1$8[rsp], xmm0

; 2190 :             dx2 = s[2];

	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx2$3[rsp], xmm0

; 2191 :             dy2 = s[3];

	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy2$1[rsp], xmm0

; 2192 :             dx3 = s[4];

	mov	eax, 4
	imul	rax, rax, 4
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx3$2[rsp], xmm0

; 2193 :             dy3 = s[5];

	mov	eax, 4
	imul	rax, rax, 5
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy3$11[rsp], xmm0

; 2194 :             dx4 = s[6];

	mov	eax, 4
	imul	rax, rax, 6
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx4$7[rsp], xmm0

; 2195 :             dy4 = s[7];

	mov	eax, 4
	imul	rax, rax, 7
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy4$12[rsp], xmm0

; 2196 :             dx5 = s[8];

	mov	eax, 4
	imul	rax, rax, 8
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dx5$6[rsp], xmm0

; 2197 :             dy5 = s[9];

	mov	eax, 4
	imul	rax, rax, 9
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy5$9[rsp], xmm0

; 2198 :             dx6 = dy6 = s[10];

	mov	eax, 4
	imul	rax, rax, 10
	movss	xmm0, DWORD PTR s$[rsp+rax]
	movss	DWORD PTR dy6$10[rsp], xmm0
	movss	xmm0, DWORD PTR dy6$10[rsp]
	movss	DWORD PTR dx6$5[rsp], xmm0

; 2199 :             dx = dx1+dx2+dx3+dx4+dx5;

	movss	xmm0, DWORD PTR dx1$4[rsp]
	addss	xmm0, DWORD PTR dx2$3[rsp]
	addss	xmm0, DWORD PTR dx3$2[rsp]
	addss	xmm0, DWORD PTR dx4$7[rsp]
	addss	xmm0, DWORD PTR dx5$6[rsp]
	movss	DWORD PTR dx$14[rsp], xmm0

; 2200 :             dy = dy1+dy2+dy3+dy4+dy5;

	movss	xmm0, DWORD PTR dy1$8[rsp]
	addss	xmm0, DWORD PTR dy2$1[rsp]
	addss	xmm0, DWORD PTR dy3$11[rsp]
	addss	xmm0, DWORD PTR dy4$12[rsp]
	addss	xmm0, DWORD PTR dy5$9[rsp]
	movss	DWORD PTR dy$13[rsp], xmm0

; 2201 :             if (STBTT_fabs(dx) > STBTT_fabs(dy))

	movss	xmm0, DWORD PTR dx$14[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	DWORD PTR tv640[rsp], xmm0
	movss	xmm0, DWORD PTR dy$13[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	movss	xmm1, DWORD PTR tv640[rsp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN91@stbtt__run

; 2202 :                dy6 = -dy;

	movss	xmm0, DWORD PTR dy$13[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR dy6$10[rsp], xmm0
	jmp	SHORT $LN92@stbtt__run
$LN91@stbtt__run:

; 2203 :             else
; 2204 :                dx6 = -dx;

	movss	xmm0, DWORD PTR dx$14[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR dx6$5[rsp], xmm0
$LN92@stbtt__run:

; 2205 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

	movss	xmm0, DWORD PTR dy3$11[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx3$2[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy2$1[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx2$3[rsp]
	movss	xmm2, DWORD PTR dy1$8[rsp]
	movss	xmm1, DWORD PTR dx1$4[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2206 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

	movss	xmm0, DWORD PTR dy6$10[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR dx6$5[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR dy5$9[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR dx5$6[rsp]
	movss	xmm2, DWORD PTR dy4$12[rsp]
	movss	xmm1, DWORD PTR dx4$7[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	npad	1

; 2207 :             break;

	jmp	SHORT $LN27@stbtt__run
$LN93@stbtt__run:

; 2208 : 
; 2209 :          default:
; 2210 :             return STBTT__CSERR("unimplemented");

	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN27@stbtt__run:

; 2211 :          }
; 2212 :       } break;

	jmp	$LN4@stbtt__run
$LN94@stbtt__run:

; 2213 : 
; 2214 :       default:
; 2215 :          if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) //-V560

	cmp	DWORD PTR b0$[rsp], 255			; 000000ffH
	je	SHORT $LN95@stbtt__run
	cmp	DWORD PTR b0$[rsp], 28
	je	SHORT $LN95@stbtt__run
	cmp	DWORD PTR b0$[rsp], 32			; 00000020H
	jl	SHORT $LN96@stbtt__run
	cmp	DWORD PTR b0$[rsp], 254			; 000000feH
	jle	SHORT $LN95@stbtt__run
$LN96@stbtt__run:

; 2216 :             return STBTT__CSERR("reserved operator");

	xor	eax, eax
	jmp	$LN1@stbtt__run
$LN95@stbtt__run:

; 2217 : 
; 2218 :          // push immediate
; 2219 :          if (b0 == 255) {

	cmp	DWORD PTR b0$[rsp], 255			; 000000ffH
	jne	SHORT $LN97@stbtt__run

; 2220 :             f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;

	mov	edx, 4
	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@47800000
	movss	DWORD PTR f$[rsp], xmm0

; 2221 :          } else {

	jmp	SHORT $LN98@stbtt__run
$LN97@stbtt__run:

; 2222 :             stbtt__buf_skip(&b, -1);

	mov	edx, -1
	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 2223 :             f = (float)(stbtt_int16)stbtt__cff_int(&b);

	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	cwde
	cvtsi2ss xmm0, eax
	movss	DWORD PTR f$[rsp], xmm0
$LN98@stbtt__run:

; 2224 :          }
; 2225 :          if (sp >= 48) return STBTT__CSERR("push stack overflow");

	cmp	DWORD PTR sp$[rsp], 48			; 00000030H
	jl	SHORT $LN99@stbtt__run
	xor	eax, eax
	jmp	SHORT $LN1@stbtt__run
$LN99@stbtt__run:

; 2226 :          s[sp++] = f;

	movsxd	rax, DWORD PTR sp$[rsp]
	movss	xmm0, DWORD PTR f$[rsp]
	movss	DWORD PTR s$[rsp+rax*4], xmm0
	mov	eax, DWORD PTR sp$[rsp]
	inc	eax
	mov	DWORD PTR sp$[rsp], eax

; 2227 :          clear_stack = 0;

	mov	DWORD PTR clear_stack$[rsp], 0
$LN4@stbtt__run:

; 2228 :          break;
; 2229 :       }
; 2230 :       if (clear_stack) sp = 0;

	cmp	DWORD PTR clear_stack$[rsp], 0
	je	SHORT $LN100@stbtt__run
	mov	DWORD PTR sp$[rsp], 0
$LN100@stbtt__run:

; 2231 :    }

	jmp	$LN2@stbtt__run
$LN3@stbtt__run:

; 2232 :    return STBTT__CSERR("no endchar");

	xor	eax, eax
$LN1@stbtt__run:

; 2233 : 
; 2234 : #undef STBTT__CSERR
; 2235 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 744				; 000002e8H
	pop	rdi
	pop	rsi
	ret	0
	npad	1
$LN108@stbtt__run:
	DD	$LN32@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN33@stbtt__run
	DD	$LN38@stbtt__run
	DD	$LN42@stbtt__run
	DD	$LN47@stbtt__run
	DD	$LN44@stbtt__run
	DD	$LN58@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN72@stbtt__run
	DD	$LN79@stbtt__run
	DD	$LN82@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN81@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN34@stbtt__run
	DD	$LN29@stbtt__run
	DD	$LN30@stbtt__run
	DD	$LN36@stbtt__run
	DD	$LN40@stbtt__run
	DD	$LN35@stbtt__run
	DD	$LN60@stbtt__run
	DD	$LN63@stbtt__run
	DD	$LN66@stbtt__run
	DD	$LN67@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN75@stbtt__run
	DD	$LN54@stbtt__run
	DD	$LN51@stbtt__run
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ENDP ; stbtt__run_charstring
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
fdselector$ = 32
i$ = 36
fmt$ = 40
end$ = 44
start$ = 48
fdselect$ = 56
nranges$ = 72
v$ = 76
$T1 = 80
$T2 = 96
$T3 = 112
$T4 = 128
$T5 = 144
$T6 = 160
$T7 = 176
$T8 = 192
$T9 = 208
__$ReturnAddress$ = 256
info$ = 264
glyph_index$ = 272
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z PROC ; stbtt__cid_get_glyph_subrs

; 1951 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 1952 :    stbtt__buf fdselect = info->fdselect;

	lea	rax, QWORD PTR fdselect$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+144]
	mov	ecx, 16
	rep movsb

; 1953 :    int nranges, start, end, v, fmt, fdselector = -1, i;

	mov	DWORD PTR fdselector$[rsp], -1

; 1954 : 
; 1955 :    stbtt__buf_seek(&fdselect, 0);

	xor	edx, edx
	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1956 :    fmt = stbtt__buf_get8(&fdselect);

	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR fmt$[rsp], eax

; 1957 :    if (fmt == 0) {

	cmp	DWORD PTR fmt$[rsp], 0
	jne	SHORT $LN5@stbtt__cid

; 1958 :       // untested
; 1959 :       stbtt__buf_skip(&fdselect, glyph_index);

	mov	edx, DWORD PTR glyph_index$[rsp]
	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1960 :       fdselector = stbtt__buf_get8(&fdselect);

	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR fdselector$[rsp], eax
	jmp	$LN6@stbtt__cid
$LN5@stbtt__cid:

; 1961 :    } else if (fmt == 3) {

	cmp	DWORD PTR fmt$[rsp], 3
	jne	$LN7@stbtt__cid

; 1962 :       nranges = stbtt__buf_get16(&fdselect);

	mov	edx, 2
	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR nranges$[rsp], eax

; 1963 :       start = stbtt__buf_get16(&fdselect);

	mov	edx, 2
	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR start$[rsp], eax

; 1964 :       for (i = 0; i < nranges; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt__cid
$LN2@stbtt__cid:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt__cid:
	mov	eax, DWORD PTR nranges$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbtt__cid

; 1965 :          v = stbtt__buf_get8(&fdselect);

	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR v$[rsp], eax

; 1966 :          end = stbtt__buf_get16(&fdselect);

	mov	edx, 2
	lea	rcx, QWORD PTR fdselect$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR end$[rsp], eax

; 1967 :          if (glyph_index >= start && glyph_index < end) {

	mov	eax, DWORD PTR start$[rsp]
	cmp	DWORD PTR glyph_index$[rsp], eax
	jl	SHORT $LN8@stbtt__cid
	mov	eax, DWORD PTR end$[rsp]
	cmp	DWORD PTR glyph_index$[rsp], eax
	jge	SHORT $LN8@stbtt__cid

; 1968 :             fdselector = v;

	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR fdselector$[rsp], eax

; 1969 :             break;

	jmp	SHORT $LN3@stbtt__cid
$LN8@stbtt__cid:

; 1970 :          }
; 1971 :          start = end;

	mov	eax, DWORD PTR end$[rsp]
	mov	DWORD PTR start$[rsp], eax

; 1972 :       }

	jmp	SHORT $LN2@stbtt__cid
$LN3@stbtt__cid:
$LN7@stbtt__cid:
$LN6@stbtt__cid:

; 1973 :    }
; 1974 :    if (fdselector == -1) stbtt__new_buf(NULL, 0);

	cmp	DWORD PTR fdselector$[rsp], -1
	jne	SHORT $LN9@stbtt__cid
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T6[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T7[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN9@stbtt__cid:

; 1975 :    return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));

	lea	rax, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+128]
	mov	ecx, 16
	rep movsb
	mov	r8d, DWORD PTR fdselector$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+64]
	mov	ecx, 16
	rep movsb
	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T5[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 1976 : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ENDP ; stbtt__cid_get_glyph_subrs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
bias$ = 32
count$ = 36
$T1 = 40
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
__$ReturnAddress$ = 160
idx$ = 168
n$ = 176
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z PROC		; stbtt__get_subr

; 1937 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 136				; 00000088H

; 1938 :    int count = stbtt__cff_index_count(&idx);

	mov	rcx, QWORD PTR idx$[rsp]
	call	?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z ; stbtt__cff_index_count
	mov	DWORD PTR count$[rsp], eax

; 1939 :    int bias = 107;

	mov	DWORD PTR bias$[rsp], 107		; 0000006bH

; 1940 :    if (count >= 33900)

	cmp	DWORD PTR count$[rsp], 33900		; 0000846cH
	jl	SHORT $LN2@stbtt__get

; 1941 :       bias = 32768;

	mov	DWORD PTR bias$[rsp], 32768		; 00008000H
	jmp	SHORT $LN3@stbtt__get
$LN2@stbtt__get:

; 1942 :    else if (count >= 1240)

	cmp	DWORD PTR count$[rsp], 1240		; 000004d8H
	jl	SHORT $LN4@stbtt__get

; 1943 :       bias = 1131;

	mov	DWORD PTR bias$[rsp], 1131		; 0000046bH
$LN4@stbtt__get:
$LN3@stbtt__get:

; 1944 :    n += bias;

	mov	eax, DWORD PTR bias$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 1945 :    if (n < 0 || n >= count)

	cmp	DWORD PTR n$[rsp], 0
	jl	SHORT $LN6@stbtt__get
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR n$[rsp], eax
	jl	SHORT $LN5@stbtt__get
$LN6@stbtt__get:

; 1946 :       return stbtt__new_buf(NULL, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T4[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@stbtt__get
$LN5@stbtt__get:

; 1947 :    return stbtt__cff_index_get(idx, n);

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR idx$[rsp]
	mov	ecx, 16
	rep movsb
	mov	r8d, DWORD PTR n$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	lea	rcx, QWORD PTR $T3[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T3[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@stbtt__get:

; 1948 : }

	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ENDP		; stbtt__get_subr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
cy2$ = 64
cx2$ = 68
cy1$ = 72
cx1$ = 76
ctx$ = 96
dx1$ = 104
dy1$ = 112
dx2$ = 120
dy2$ = 128
dx3$ = 136
dy3$ = 144
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z PROC ; stbtt__csctx_rccurve_to

; 1926 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1927 :    float cx1 = ctx->x + dx1;

	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	addss	xmm0, DWORD PTR dx1$[rsp]
	movss	DWORD PTR cx1$[rsp], xmm0

; 1928 :    float cy1 = ctx->y + dy1;

	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	addss	xmm0, DWORD PTR dy1$[rsp]
	movss	DWORD PTR cy1$[rsp], xmm0

; 1929 :    float cx2 = cx1 + dx2;

	movss	xmm0, DWORD PTR cx1$[rsp]
	addss	xmm0, DWORD PTR dx2$[rsp]
	movss	DWORD PTR cx2$[rsp], xmm0

; 1930 :    float cy2 = cy1 + dy2;

	movss	xmm0, DWORD PTR cy1$[rsp]
	addss	xmm0, DWORD PTR dy2$[rsp]
	movss	DWORD PTR cy2$[rsp], xmm0

; 1931 :    ctx->x = cx2 + dx3;

	movss	xmm0, DWORD PTR cx2$[rsp]
	addss	xmm0, DWORD PTR dx3$[rsp]
	mov	rax, QWORD PTR ctx$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 1932 :    ctx->y = cy2 + dy3;

	movss	xmm0, DWORD PTR cy2$[rsp]
	addss	xmm0, DWORD PTR dy3$[rsp]
	mov	rax, QWORD PTR ctx$[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 1933 :    stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

	cvttss2si eax, DWORD PTR cy2$[rsp]
	cvttss2si ecx, DWORD PTR cx2$[rsp]
	cvttss2si edx, DWORD PTR cy1$[rsp]
	cvttss2si r8d, DWORD PTR cx1$[rsp]
	mov	r9, QWORD PTR ctx$[rsp]
	cvttss2si r9d, DWORD PTR [r9+20]
	mov	r10, QWORD PTR ctx$[rsp]
	cvttss2si r10d, DWORD PTR [r10+16]
	mov	DWORD PTR [rsp+56], eax
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], edx
	mov	DWORD PTR [rsp+32], r8d
	mov	r8d, r10d
	mov	dl, 4
	mov	rcx, QWORD PTR ctx$[rsp]
	call	?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	npad	1

; 1934 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ENDP ; stbtt__csctx_rccurve_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
ctx$ = 80
dx$ = 88
dy$ = 96
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rline_to

; 1919 : {

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1920 :    ctx->x += dx;

	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	addss	xmm0, DWORD PTR dx$[rsp]
	mov	rax, QWORD PTR ctx$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 1921 :    ctx->y += dy;

	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	addss	xmm0, DWORD PTR dy$[rsp]
	mov	rax, QWORD PTR ctx$[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 1922 :    stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

	mov	rax, QWORD PTR ctx$[rsp]
	cvttss2si eax, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR ctx$[rsp]
	cvttss2si ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, eax
	mov	r8d, ecx
	mov	dl, 2
	mov	rcx, QWORD PTR ctx$[rsp]
	call	?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	npad	1

; 1923 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rline_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv68 = 64
tv72 = 68
ctx$ = 96
dx$ = 104
dy$ = 112
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rmove_to

; 1911 : {

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1912 :    stbtt__csctx_close_shape(ctx);

	mov	rcx, QWORD PTR ctx$[rsp]
	call	?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 1913 :    ctx->first_x = ctx->x = ctx->x + dx;

	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	addss	xmm0, DWORD PTR dx$[rsp]
	movss	DWORD PTR tv68[rsp], xmm0
	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR tv68[rsp]
	movss	DWORD PTR [rax+16], xmm0
	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR tv68[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 1914 :    ctx->first_y = ctx->y = ctx->y + dy;

	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	addss	xmm0, DWORD PTR dy$[rsp]
	movss	DWORD PTR tv72[rsp], xmm0
	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR tv72[rsp]
	movss	DWORD PTR [rax+20], xmm0
	mov	rax, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR tv72[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 1915 :    stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

	mov	rax, QWORD PTR ctx$[rsp]
	cvttss2si eax, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR ctx$[rsp]
	cvttss2si ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, eax
	mov	r8d, ecx
	mov	dl, 1
	mov	rcx, QWORD PTR ctx$[rsp]
	call	?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	npad	1

; 1916 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rmove_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
ctx$ = 80
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z PROC	; stbtt__csctx_close_shape

; 1905 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1906 :    if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)

	mov	rax, QWORD PTR ctx$[rsp]
	mov	rcx, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	ucomiss	xmm0, DWORD PTR [rcx+16]
	jp	SHORT $LN3@stbtt__csc
	jne	SHORT $LN3@stbtt__csc
	mov	rax, QWORD PTR ctx$[rsp]
	mov	rcx, QWORD PTR ctx$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	ucomiss	xmm0, DWORD PTR [rcx+20]
	jp	SHORT $LN5@stbtt__csc
	je	SHORT $LN2@stbtt__csc
$LN5@stbtt__csc:
$LN3@stbtt__csc:

; 1907 :       stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);

	mov	rax, QWORD PTR ctx$[rsp]
	cvttss2si eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR ctx$[rsp]
	cvttss2si ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, eax
	mov	r8d, ecx
	mov	dl, 2
	mov	rcx, QWORD PTR ctx$[rsp]
	call	?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	npad	1
$LN2@stbtt__csc:

; 1908 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ENDP	; stbtt__csctx_close_shape
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$ = 64
type$ = 72
x$ = 80
y$ = 88
cx$ = 96
cy$ = 104
cx1$ = 112
cy1$ = 120
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z PROC	; stbtt__csctx_v

; 1889 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1890 :    if (c->bounds) {

	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN2@stbtt__csc

; 1891 :       stbtt__track_vertex(c, x, y);

	mov	r8d, DWORD PTR y$[rsp]
	mov	edx, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
	npad	1

; 1892 :       if (type == STBTT_vcubic) {

	movzx	eax, BYTE PTR type$[rsp]
	cmp	eax, 4
	jne	SHORT $LN4@stbtt__csc

; 1893 :          stbtt__track_vertex(c, cx, cy);

	mov	r8d, DWORD PTR cy$[rsp]
	mov	edx, DWORD PTR cx$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ; stbtt__track_vertex

; 1894 :          stbtt__track_vertex(c, cx1, cy1);

	mov	r8d, DWORD PTR cy1$[rsp]
	mov	edx, DWORD PTR cx1$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
	npad	1
$LN4@stbtt__csc:

; 1895 :       }
; 1896 :    } else {

	jmp	SHORT $LN3@stbtt__csc
$LN2@stbtt__csc:

; 1897 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+48]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR c$[rsp]
	add	rax, QWORD PTR [rcx+40]
	mov	ecx, DWORD PTR cy$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR cx$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR y$[rsp]
	mov	r8d, DWORD PTR x$[rsp]
	movzx	edx, BYTE PTR type$[rsp]
	mov	rcx, rax
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex

; 1898 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+48]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	movzx	edx, WORD PTR cx1$[rsp]
	mov	WORD PTR [rcx+rax+8], dx

; 1899 :       c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+48]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	movzx	edx, WORD PTR cy1$[rsp]
	mov	WORD PTR [rcx+rax+10], dx
$LN3@stbtt__csc:

; 1900 :    }
; 1901 :    c->num_vertices++;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+48]
	inc	eax
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1902 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ENDP	; stbtt__csctx_v
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$ = 8
x$ = 16
y$ = 24
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z PROC	; stbtt__track_vertex

; 1880 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 1881 :    if (x > c->max_x || !c->started) c->max_x = x;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+28]
	cmp	DWORD PTR x$[rsp], eax
	jg	SHORT $LN3@stbtt__tra
	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN2@stbtt__tra
$LN3@stbtt__tra:
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax+28], ecx
$LN2@stbtt__tra:

; 1882 :    if (y > c->max_y || !c->started) c->max_y = y;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR y$[rsp], eax
	jg	SHORT $LN5@stbtt__tra
	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN4@stbtt__tra
$LN5@stbtt__tra:
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rax+36], ecx
$LN4@stbtt__tra:

; 1883 :    if (x < c->min_x || !c->started) c->min_x = x;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR x$[rsp], eax
	jl	SHORT $LN7@stbtt__tra
	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN6@stbtt__tra
$LN7@stbtt__tra:
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax+24], ecx
$LN6@stbtt__tra:

; 1884 :    if (y < c->min_y || !c->started) c->min_y = y;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR y$[rsp], eax
	jl	SHORT $LN9@stbtt__tra
	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN8@stbtt__tra
$LN9@stbtt__tra:
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rax+32], ecx
$LN8@stbtt__tra:

; 1885 :    c->started = 1;

	mov	rax, QWORD PTR c$[rsp]
	mov	DWORD PTR [rax+4], 1

; 1886 : }

	ret	0
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ENDP	; stbtt__track_vertex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
flags$1 = 80
i$2 = 84
num_vertices$ = 88
flagcount$3 = 92
comp$4 = 96
numberOfContours$ = 104
vertices$ = 112
flags$5 = 120
off$6 = 124
y$7 = 128
x$8 = 132
x$9 = 136
y$10 = 140
points$11 = 144
tv154 = 152
tv160 = 153
cy$12 = 156
cx$13 = 160
sy$14 = 164
was_off$15 = 168
n$16 = 172
sx$17 = 176
g$ = 180
comp_num_verts$18 = 184
dx$19 = 188
dy$20 = 192
scy$21 = 196
scx$22 = 200
start_off$23 = 204
i$24 = 208
v$25 = 216
j$26 = 224
gidx$27 = 228
tv222 = 232
tv180 = 234
comp_verts$28 = 240
m$29 = 248
tv187 = 252
tv229 = 256
tv318 = 260
next_move$30 = 264
tv487 = 268
m$31 = 272
n$32 = 276
more$33 = 280
data$ = 288
tmp$34 = 296
ins$35 = 304
endPtsOfContours$ = 312
tv371 = 320
tv398 = 328
tv410 = 336
tv421 = 344
mtx$36 = 352
__$ArrayPad$ = 376
info$ = 400
glyph_index$ = 408
pvertices$ = 416
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeTT

; 1640 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 392				; 00000188H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1641 :    stbtt_int16 numberOfContours;
; 1642 :    stbtt_uint8 *endPtsOfContours;
; 1643 :    stbtt_uint8 *data = info->data;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR data$[rsp], rax

; 1644 :    stbtt_vertex *vertices=0;

	mov	QWORD PTR vertices$[rsp], 0

; 1645 :    int num_vertices=0;

	mov	DWORD PTR num_vertices$[rsp], 0

; 1646 :    int g = stbtt__GetGlyfOffset(info, glyph_index);

	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
	mov	DWORD PTR g$[rsp], eax

; 1647 : 
; 1648 :    *pvertices = NULL;

	mov	rax, QWORD PTR pvertices$[rsp]
	mov	QWORD PTR [rax], 0

; 1649 : 
; 1650 :    if (g < 0) return 0;

	cmp	DWORD PTR g$[rsp], 0
	jge	SHORT $LN19@stbtt__Get
	xor	eax, eax
	jmp	$LN1@stbtt__Get
$LN19@stbtt__Get:

; 1651 : 
; 1652 :    numberOfContours = ttSHORT(data + g);

	movsxd	rax, DWORD PTR g$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	mov	WORD PTR numberOfContours$[rsp], ax

; 1653 : 
; 1654 :    if (numberOfContours > 0) {

	movsx	eax, WORD PTR numberOfContours$[rsp]
	test	eax, eax
	jle	$LN20@stbtt__Get

; 1655 :       stbtt_uint8 flags=0,flagcount;

	mov	BYTE PTR flags$1[rsp], 0

; 1656 :       stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;

	mov	DWORD PTR j$26[rsp], 0
	mov	DWORD PTR was_off$15[rsp], 0
	mov	DWORD PTR start_off$23[rsp], 0

; 1657 :       stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
; 1658 :       stbtt_uint8 *points;
; 1659 :       endPtsOfContours = (data + g + 10);

	movsxd	rax, DWORD PTR g$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+10]
	mov	QWORD PTR endPtsOfContours$[rsp], rax

; 1660 :       ins = ttUSHORT(data + g + 10 + numberOfContours * 2);

	movsxd	rax, DWORD PTR g$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	ecx, WORD PTR numberOfContours$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+10]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR ins$35[rsp], eax

; 1661 :       points = data + g + 10 + numberOfContours * 2 + 2 + ins;

	movsxd	rax, DWORD PTR g$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	ecx, WORD PTR numberOfContours$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+10]
	movsxd	rcx, DWORD PTR ins$35[rsp]
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	QWORD PTR points$11[rsp], rax

; 1662 : 
; 1663 :       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

	movsx	eax, WORD PTR numberOfContours$[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR endPtsOfContours$[rsp]
	lea	rax, QWORD PTR [rcx+rax-2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	inc	eax
	mov	DWORD PTR n$16[rsp], eax

; 1664 : 
; 1665 :       m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need

	movsx	eax, WORD PTR numberOfContours$[rsp]
	mov	ecx, DWORD PTR n$16[rsp]
	lea	eax, DWORD PTR [rcx+rax*2]
	mov	DWORD PTR m$29[rsp], eax

; 1666 :       vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);

	movsxd	rax, DWORD PTR m$29[rsp]
	imul	rax, rax, 14
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR vertices$[rsp], rax

; 1667 :       if (vertices == 0)

	cmp	QWORD PTR vertices$[rsp], 0
	jne	SHORT $LN22@stbtt__Get

; 1668 :          return 0;

	xor	eax, eax
	jmp	$LN1@stbtt__Get
$LN22@stbtt__Get:

; 1669 : 
; 1670 :       next_move = 0;

	mov	DWORD PTR next_move$30[rsp], 0

; 1671 :       flagcount=0;

	mov	BYTE PTR flagcount$3[rsp], 0

; 1672 : 
; 1673 :       // in first pass, we load uninterpreted data into the allocated array
; 1674 :       // above, shifted to the end of the array so we won't overwrite it when
; 1675 :       // we create our final data starting from the front
; 1676 : 
; 1677 :       off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

	mov	eax, DWORD PTR n$16[rsp]
	mov	ecx, DWORD PTR m$29[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR off$6[rsp], eax

; 1678 : 
; 1679 :       // first load flags
; 1680 : 
; 1681 :       for (i=0; i < n; ++i) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@stbtt__Get
$LN2@stbtt__Get:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@stbtt__Get:
	mov	eax, DWORD PTR n$16[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN3@stbtt__Get

; 1682 :          if (flagcount == 0) {

	movzx	eax, BYTE PTR flagcount$3[rsp]
	test	eax, eax
	jne	SHORT $LN23@stbtt__Get

; 1683 :             flags = *points++;

	mov	rax, QWORD PTR points$11[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv154[rsp], al
	mov	rax, QWORD PTR points$11[rsp]
	inc	rax
	mov	QWORD PTR points$11[rsp], rax
	movzx	eax, BYTE PTR tv154[rsp]
	mov	BYTE PTR flags$1[rsp], al

; 1684 :             if (flags & 8)

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN25@stbtt__Get

; 1685 :                flagcount = *points++;

	mov	rax, QWORD PTR points$11[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv160[rsp], al
	mov	rax, QWORD PTR points$11[rsp]
	inc	rax
	mov	QWORD PTR points$11[rsp], rax
	movzx	eax, BYTE PTR tv160[rsp]
	mov	BYTE PTR flagcount$3[rsp], al
$LN25@stbtt__Get:

; 1686 :          } else

	jmp	SHORT $LN24@stbtt__Get
$LN23@stbtt__Get:

; 1687 :             --flagcount;

	movzx	eax, BYTE PTR flagcount$3[rsp]
	dec	al
	mov	BYTE PTR flagcount$3[rsp], al
$LN24@stbtt__Get:

; 1688 :          vertices[off+i].type = flags;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	edx, BYTE PTR flags$1[rsp]
	mov	BYTE PTR [rcx+rax+12], dl

; 1689 :       }

	jmp	$LN2@stbtt__Get
$LN3@stbtt__Get:

; 1690 : 
; 1691 :       // now load x coordinates
; 1692 :       x=0;

	mov	DWORD PTR x$8[rsp], 0

; 1693 :       for (i=0; i < n; ++i) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@stbtt__Get
$LN5@stbtt__Get:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@stbtt__Get:
	mov	eax, DWORD PTR n$16[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN6@stbtt__Get

; 1694 :          flags = vertices[off+i].type;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+12]
	mov	BYTE PTR flags$1[rsp], al

; 1695 :          if (flags & 2) {

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN26@stbtt__Get

; 1696 :             stbtt_int16 dx = *points++;

	mov	rax, QWORD PTR points$11[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	WORD PTR tv180[rsp], ax
	mov	rax, QWORD PTR points$11[rsp]
	inc	rax
	mov	QWORD PTR points$11[rsp], rax
	movzx	eax, WORD PTR tv180[rsp]
	mov	WORD PTR dx$19[rsp], ax

; 1697 :             x += (flags & 16) ? dx : -dx; // ???

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN64@stbtt__Get
	movsx	eax, WORD PTR dx$19[rsp]
	mov	DWORD PTR tv187[rsp], eax
	jmp	SHORT $LN65@stbtt__Get
$LN64@stbtt__Get:
	movsx	eax, WORD PTR dx$19[rsp]
	neg	eax
	mov	DWORD PTR tv187[rsp], eax
$LN65@stbtt__Get:
	mov	eax, DWORD PTR tv187[rsp]
	mov	ecx, DWORD PTR x$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$8[rsp], eax

; 1698 :          } else {

	jmp	SHORT $LN27@stbtt__Get
$LN26@stbtt__Get:

; 1699 :             if (!(flags & 16)) {

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN28@stbtt__Get

; 1700 :                x = x + (stbtt_int16) (points[0]*256 + points[1]);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR points$11[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 256				; 00000100H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR points$11[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	cwde
	mov	ecx, DWORD PTR x$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$8[rsp], eax

; 1701 :                points += 2;

	mov	rax, QWORD PTR points$11[rsp]
	add	rax, 2
	mov	QWORD PTR points$11[rsp], rax
$LN28@stbtt__Get:
$LN27@stbtt__Get:

; 1702 :             }
; 1703 :          }
; 1704 :          vertices[off+i].x = (stbtt_int16) x;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	edx, WORD PTR x$8[rsp]
	mov	WORD PTR [rcx+rax], dx

; 1705 :       }

	jmp	$LN5@stbtt__Get
$LN6@stbtt__Get:

; 1706 : 
; 1707 :       // now load y coordinates
; 1708 :       y=0;

	mov	DWORD PTR y$7[rsp], 0

; 1709 :       for (i=0; i < n; ++i) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN10@stbtt__Get
$LN8@stbtt__Get:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN10@stbtt__Get:
	mov	eax, DWORD PTR n$16[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN9@stbtt__Get

; 1710 :          flags = vertices[off+i].type;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+12]
	mov	BYTE PTR flags$1[rsp], al

; 1711 :          if (flags & 4) {

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN29@stbtt__Get

; 1712 :             stbtt_int16 dy = *points++;

	mov	rax, QWORD PTR points$11[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	WORD PTR tv222[rsp], ax
	mov	rax, QWORD PTR points$11[rsp]
	inc	rax
	mov	QWORD PTR points$11[rsp], rax
	movzx	eax, WORD PTR tv222[rsp]
	mov	WORD PTR dy$20[rsp], ax

; 1713 :             y += (flags & 32) ? dy : -dy; // ???

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN66@stbtt__Get
	movsx	eax, WORD PTR dy$20[rsp]
	mov	DWORD PTR tv229[rsp], eax
	jmp	SHORT $LN67@stbtt__Get
$LN66@stbtt__Get:
	movsx	eax, WORD PTR dy$20[rsp]
	neg	eax
	mov	DWORD PTR tv229[rsp], eax
$LN67@stbtt__Get:
	mov	eax, DWORD PTR tv229[rsp]
	mov	ecx, DWORD PTR y$7[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$7[rsp], eax

; 1714 :          } else {

	jmp	SHORT $LN30@stbtt__Get
$LN29@stbtt__Get:

; 1715 :             if (!(flags & 32)) {

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN31@stbtt__Get

; 1716 :                y = y + (stbtt_int16) (points[0]*256 + points[1]);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR points$11[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 256				; 00000100H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR points$11[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	cwde
	mov	ecx, DWORD PTR y$7[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$7[rsp], eax

; 1717 :                points += 2;

	mov	rax, QWORD PTR points$11[rsp]
	add	rax, 2
	mov	QWORD PTR points$11[rsp], rax
$LN31@stbtt__Get:
$LN30@stbtt__Get:

; 1718 :             }
; 1719 :          }
; 1720 :          vertices[off+i].y = (stbtt_int16) y;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	edx, WORD PTR y$7[rsp]
	mov	WORD PTR [rcx+rax+2], dx

; 1721 :       }

	jmp	$LN8@stbtt__Get
$LN9@stbtt__Get:

; 1722 : 
; 1723 :       // now convert them to our format
; 1724 :       num_vertices=0;

	mov	DWORD PTR num_vertices$[rsp], 0

; 1725 :       sx = sy = cx = cy = scx = scy = 0;

	mov	DWORD PTR scy$21[rsp], 0
	mov	eax, DWORD PTR scy$21[rsp]
	mov	DWORD PTR scx$22[rsp], eax
	mov	eax, DWORD PTR scx$22[rsp]
	mov	DWORD PTR cy$12[rsp], eax
	mov	eax, DWORD PTR cy$12[rsp]
	mov	DWORD PTR cx$13[rsp], eax
	mov	eax, DWORD PTR cx$13[rsp]
	mov	DWORD PTR sy$14[rsp], eax
	mov	eax, DWORD PTR sy$14[rsp]
	mov	DWORD PTR sx$17[rsp], eax

; 1726 :       for (i=0; i < n; ++i) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN13@stbtt__Get
$LN11@stbtt__Get:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN13@stbtt__Get:
	mov	eax, DWORD PTR n$16[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN12@stbtt__Get

; 1727 :          flags = vertices[off+i].type;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+12]
	mov	BYTE PTR flags$1[rsp], al

; 1728 :          x     = (stbtt_int16) vertices[off+i].x;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR x$8[rsp], eax

; 1729 :          y     = (stbtt_int16) vertices[off+i].y;

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR off$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	mov	DWORD PTR y$7[rsp], eax

; 1730 : 
; 1731 :          if (next_move == i) {

	mov	eax, DWORD PTR i$2[rsp]
	cmp	DWORD PTR next_move$30[rsp], eax
	jne	$LN32@stbtt__Get

; 1732 :             if (i != 0)

	cmp	DWORD PTR i$2[rsp], 0
	je	SHORT $LN34@stbtt__Get

; 1733 :                num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

	mov	eax, DWORD PTR cy$12[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	eax, DWORD PTR cx$13[rsp]
	mov	DWORD PTR [rsp+64], eax
	mov	eax, DWORD PTR scy$21[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR scx$22[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR sy$14[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR sx$17[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR start_off$23[rsp]
	mov	r8d, DWORD PTR was_off$15[rsp]
	mov	edx, DWORD PTR num_vertices$[rsp]
	mov	rcx, QWORD PTR vertices$[rsp]
	call	?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
	mov	DWORD PTR num_vertices$[rsp], eax
$LN34@stbtt__Get:

; 1734 : 
; 1735 :             // now start the new one               
; 1736 :             start_off = !(flags & 1);

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN68@stbtt__Get
	mov	DWORD PTR tv318[rsp], 1
	jmp	SHORT $LN69@stbtt__Get
$LN68@stbtt__Get:
	mov	DWORD PTR tv318[rsp], 0
$LN69@stbtt__Get:
	mov	eax, DWORD PTR tv318[rsp]
	mov	DWORD PTR start_off$23[rsp], eax

; 1737 :             if (start_off) {

	cmp	DWORD PTR start_off$23[rsp], 0
	je	$LN35@stbtt__Get

; 1738 :                // if we start off with an off-curve point, then when we need to find a point on the curve
; 1739 :                // where we can start, and we need to save some state for when we wraparound.
; 1740 :                scx = x;

	mov	eax, DWORD PTR x$8[rsp]
	mov	DWORD PTR scx$22[rsp], eax

; 1741 :                scy = y;

	mov	eax, DWORD PTR y$7[rsp]
	mov	DWORD PTR scy$21[rsp], eax

; 1742 :                if (!(vertices[off+i+1].type & 1)) {

	mov	eax, DWORD PTR off$6[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+12]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN37@stbtt__Get

; 1743 :                   // next point is also a curve point, so interpolate an on-point curve
; 1744 :                   sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;

	mov	eax, DWORD PTR off$6[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	ecx, DWORD PTR x$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 1
	mov	DWORD PTR sx$17[rsp], eax

; 1745 :                   sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;

	mov	eax, DWORD PTR off$6[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	mov	ecx, DWORD PTR y$7[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 1
	mov	DWORD PTR sy$14[rsp], eax

; 1746 :                } else {

	jmp	SHORT $LN38@stbtt__Get
$LN37@stbtt__Get:

; 1747 :                   // otherwise just use the next point as our start point
; 1748 :                   sx = (stbtt_int32) vertices[off+i+1].x;

	mov	eax, DWORD PTR off$6[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR sx$17[rsp], eax

; 1749 :                   sy = (stbtt_int32) vertices[off+i+1].y;

	mov	eax, DWORD PTR off$6[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdqe
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	movsx	eax, WORD PTR [rcx+rax+2]
	mov	DWORD PTR sy$14[rsp], eax

; 1750 :                   ++i; // we're using point i+1 as the starting point, so skip it

	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN38@stbtt__Get:

; 1751 :                }
; 1752 :             } else {

	jmp	SHORT $LN36@stbtt__Get
$LN35@stbtt__Get:

; 1753 :                sx = x;

	mov	eax, DWORD PTR x$8[rsp]
	mov	DWORD PTR sx$17[rsp], eax

; 1754 :                sy = y;

	mov	eax, DWORD PTR y$7[rsp]
	mov	DWORD PTR sy$14[rsp], eax
$LN36@stbtt__Get:

; 1755 :             }
; 1756 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv371[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR sy$14[rsp]
	mov	r8d, DWORD PTR sx$17[rsp]
	mov	dl, 1
	mov	rcx, QWORD PTR tv371[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex

; 1757 :             was_off = 0;

	mov	DWORD PTR was_off$15[rsp], 0

; 1758 :             next_move = 1 + ttUSHORT(endPtsOfContours+j*2);

	mov	eax, DWORD PTR j$26[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR endPtsOfContours$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	inc	eax
	mov	DWORD PTR next_move$30[rsp], eax

; 1759 :             ++j;

	mov	eax, DWORD PTR j$26[rsp]
	inc	eax
	mov	DWORD PTR j$26[rsp], eax

; 1760 :          } else {

	jmp	$LN33@stbtt__Get
$LN32@stbtt__Get:

; 1761 :             if (!(flags & 1)) { // if it's a curve

	movzx	eax, BYTE PTR flags$1[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN39@stbtt__Get

; 1762 :                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint

	cmp	DWORD PTR was_off$15[rsp], 0
	je	SHORT $LN41@stbtt__Get

; 1763 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv398[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	eax, DWORD PTR y$7[rsp]
	mov	ecx, DWORD PTR cy$12[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 1
	mov	ecx, DWORD PTR x$8[rsp]
	mov	edx, DWORD PTR cx$13[rsp]
	add	edx, ecx
	mov	ecx, edx
	sar	ecx, 1
	mov	edx, DWORD PTR cy$12[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	edx, DWORD PTR cx$13[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, eax
	mov	r8d, ecx
	mov	dl, 3
	mov	rcx, QWORD PTR tv398[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1
$LN41@stbtt__Get:

; 1764 :                cx = x;

	mov	eax, DWORD PTR x$8[rsp]
	mov	DWORD PTR cx$13[rsp], eax

; 1765 :                cy = y;

	mov	eax, DWORD PTR y$7[rsp]
	mov	DWORD PTR cy$12[rsp], eax

; 1766 :                was_off = 1;

	mov	DWORD PTR was_off$15[rsp], 1

; 1767 :             } else {

	jmp	$LN40@stbtt__Get
$LN39@stbtt__Get:

; 1768 :                if (was_off)

	cmp	DWORD PTR was_off$15[rsp], 0
	je	SHORT $LN42@stbtt__Get

; 1769 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv410[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	eax, DWORD PTR cy$12[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cx$13[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR y$7[rsp]
	mov	r8d, DWORD PTR x$8[rsp]
	mov	dl, 3
	mov	rcx, QWORD PTR tv410[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1
	jmp	SHORT $LN43@stbtt__Get
$LN42@stbtt__Get:

; 1770 :                else
; 1771 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv421[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR y$7[rsp]
	mov	r8d, DWORD PTR x$8[rsp]
	mov	dl, 2
	mov	rcx, QWORD PTR tv421[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1
$LN43@stbtt__Get:

; 1772 :                was_off = 0;

	mov	DWORD PTR was_off$15[rsp], 0
$LN40@stbtt__Get:
$LN33@stbtt__Get:

; 1773 :             }
; 1774 :          }
; 1775 :       }

	jmp	$LN11@stbtt__Get
$LN12@stbtt__Get:

; 1776 :       num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

	mov	eax, DWORD PTR cy$12[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	eax, DWORD PTR cx$13[rsp]
	mov	DWORD PTR [rsp+64], eax
	mov	eax, DWORD PTR scy$21[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR scx$22[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR sy$14[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR sx$17[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR start_off$23[rsp]
	mov	r8d, DWORD PTR was_off$15[rsp]
	mov	edx, DWORD PTR num_vertices$[rsp]
	mov	rcx, QWORD PTR vertices$[rsp]
	call	?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
	mov	DWORD PTR num_vertices$[rsp], eax
	jmp	$LN21@stbtt__Get
$LN20@stbtt__Get:

; 1777 :    } else if (numberOfContours == -1) {

	movsx	eax, WORD PTR numberOfContours$[rsp]
	cmp	eax, -1
	jne	$LN44@stbtt__Get

; 1778 :       // Compound shapes.
; 1779 :       int more = 1;

	mov	DWORD PTR more$33[rsp], 1

; 1780 :       stbtt_uint8 *comp = data + g + 10;

	movsxd	rax, DWORD PTR g$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+10]
	mov	QWORD PTR comp$4[rsp], rax

; 1781 :       num_vertices = 0;

	mov	DWORD PTR num_vertices$[rsp], 0

; 1782 :       vertices = 0;

	mov	QWORD PTR vertices$[rsp], 0
$LN14@stbtt__Get:

; 1783 :       while (more) {

	cmp	DWORD PTR more$33[rsp], 0
	je	$LN15@stbtt__Get

; 1784 :          stbtt_uint16 flags, gidx;
; 1785 :          int comp_num_verts = 0, i;

	mov	DWORD PTR comp_num_verts$18[rsp], 0

; 1786 :          stbtt_vertex *comp_verts = 0, *tmp = 0;

	mov	QWORD PTR comp_verts$28[rsp], 0
	mov	QWORD PTR tmp$34[rsp], 0

; 1787 :          float mtx[6] = {1,0,0,1,0,0}, m, n;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR mtx$36[rsp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+4], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR mtx$36[rsp+12], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+16], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+20], xmm0

; 1788 :          
; 1789 :          flags = ttSHORT(comp); comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	mov	WORD PTR flags$5[rsp], ax
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1790 :          gidx = ttSHORT(comp); comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	mov	WORD PTR gidx$27[rsp], ax
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1791 : 
; 1792 :          if (flags & 2) { // XY values

	movzx	eax, WORD PTR flags$5[rsp]
	and	eax, 2
	test	eax, eax
	je	$LN46@stbtt__Get

; 1793 :             if (flags & 1) { // shorts

	movzx	eax, WORD PTR flags$5[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN48@stbtt__Get

; 1794 :                mtx[4] = ttSHORT(comp); comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	mov	eax, 4
	imul	rax, rax, 4
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1795 :                mtx[5] = ttSHORT(comp); comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	mov	eax, 4
	imul	rax, rax, 5
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1796 :             } else {

	jmp	SHORT $LN49@stbtt__Get
$LN48@stbtt__Get:

; 1797 :                mtx[4] = ttCHAR(comp); comp+=1;

	mov	rax, QWORD PTR comp$4[rsp]
	movsx	eax, BYTE PTR [rax]
	cvtsi2ss xmm0, eax
	mov	eax, 4
	imul	rax, rax, 4
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	inc	rax
	mov	QWORD PTR comp$4[rsp], rax

; 1798 :                mtx[5] = ttCHAR(comp); comp+=1;

	mov	rax, QWORD PTR comp$4[rsp]
	movsx	eax, BYTE PTR [rax]
	cvtsi2ss xmm0, eax
	mov	eax, 4
	imul	rax, rax, 5
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	inc	rax
	mov	QWORD PTR comp$4[rsp], rax
$LN49@stbtt__Get:
$LN46@stbtt__Get:

; 1799 :             }
; 1800 :          }
; 1801 :          else {
; 1802 :             // @TODO handle matching point
; 1803 :             STBTT_assert(0);
; 1804 :          }
; 1805 :          if (flags & (1<<3)) { // WE_HAVE_A_SCALE

	movzx	eax, WORD PTR flags$5[rsp]
	and	eax, 8
	test	eax, eax
	je	$LN50@stbtt__Get

; 1806 :             mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	movss	DWORD PTR tv487[rsp], xmm0
	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR tv487[rsp]
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR tv487[rsp]
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1807 :             mtx[1] = mtx[2] = 0;

	mov	eax, 4
	imul	rax, rax, 2
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	jmp	$LN51@stbtt__Get
$LN50@stbtt__Get:

; 1808 :          } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE

	movzx	eax, WORD PTR flags$5[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	$LN52@stbtt__Get

; 1809 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	mov	eax, 4
	imul	rax, rax, 0
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1810 :             mtx[1] = mtx[2] = 0;

	mov	eax, 4
	imul	rax, rax, 2
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR mtx$36[rsp+rax], xmm0

; 1811 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	mov	eax, 4
	imul	rax, rax, 3
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax
	jmp	$LN53@stbtt__Get
$LN52@stbtt__Get:

; 1812 :          } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO

	movzx	eax, WORD PTR flags$5[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN54@stbtt__Get

; 1813 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	mov	eax, 4
	imul	rax, rax, 0
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1814 :             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	mov	eax, 4
	imul	rax, rax, 1
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1815 :             mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	mov	eax, 4
	imul	rax, rax, 2
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax

; 1816 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	mov	rcx, QWORD PTR comp$4[rsp]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46800000
	mov	eax, 4
	imul	rax, rax, 3
	movss	DWORD PTR mtx$36[rsp+rax], xmm0
	mov	rax, QWORD PTR comp$4[rsp]
	add	rax, 2
	mov	QWORD PTR comp$4[rsp], rax
$LN54@stbtt__Get:
$LN53@stbtt__Get:
$LN51@stbtt__Get:

; 1817 :          }
; 1818 :          
; 1819 :          // Find transformation scales.
; 1820 :          m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	xmm0, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm0, DWORD PTR mtx$36[rsp+rcx]
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	xmm1, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm1, DWORD PTR mtx$36[rsp+rcx]
	addss	xmm0, xmm1
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	DWORD PTR m$31[rsp], xmm0

; 1821 :          n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	xmm0, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm0, DWORD PTR mtx$36[rsp+rcx]
	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	xmm1, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm1, DWORD PTR mtx$36[rsp+rcx]
	addss	xmm0, xmm1
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	DWORD PTR n$32[rsp], xmm0

; 1822 : 
; 1823 :          // Get indexed glyph.
; 1824 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

	movzx	eax, WORD PTR gidx$27[rsp]
	lea	r8, QWORD PTR comp_verts$28[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_GetGlyphShape
	mov	DWORD PTR comp_num_verts$18[rsp], eax

; 1825 :          if (comp_num_verts > 0) {

	cmp	DWORD PTR comp_num_verts$18[rsp], 0
	jle	$LN55@stbtt__Get

; 1826 :             // Transform vertices.
; 1827 :             for (i = 0; i < comp_num_verts; ++i) {

	mov	DWORD PTR i$24[rsp], 0
	jmp	SHORT $LN18@stbtt__Get
$LN16@stbtt__Get:
	mov	eax, DWORD PTR i$24[rsp]
	inc	eax
	mov	DWORD PTR i$24[rsp], eax
$LN18@stbtt__Get:
	mov	eax, DWORD PTR comp_num_verts$18[rsp]
	cmp	DWORD PTR i$24[rsp], eax
	jge	$LN17@stbtt__Get

; 1828 :                stbtt_vertex* v = &comp_verts[i];

	movsxd	rax, DWORD PTR i$24[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR comp_verts$28[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v$25[rsp], rax

; 1829 :                stbtt_vertex_type x,y;
; 1830 :                x=v->x; y=v->y;

	mov	rax, QWORD PTR v$25[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR x$9[rsp], ax
	mov	rax, QWORD PTR v$25[rsp]
	movzx	eax, WORD PTR [rax+2]
	mov	WORD PTR y$10[rsp], ax

; 1831 :                v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	mov	eax, 4
	imul	rax, rax, 0
	movsx	ecx, WORD PTR x$9[rsp]
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	movsx	ecx, WORD PTR y$10[rsp]
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 4
	addss	xmm0, DWORD PTR mtx$36[rsp+rax]
	movss	xmm1, DWORD PTR m$31[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR v$25[rsp]
	mov	WORD PTR [rcx], ax

; 1832 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mov	eax, 4
	imul	rax, rax, 1
	movsx	ecx, WORD PTR x$9[rsp]
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 3
	movsx	ecx, WORD PTR y$10[rsp]
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 5
	addss	xmm0, DWORD PTR mtx$36[rsp+rax]
	movss	xmm1, DWORD PTR n$32[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR v$25[rsp]
	mov	WORD PTR [rcx+2], ax

; 1833 :                x=v->cx; y=v->cy;

	mov	rax, QWORD PTR v$25[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	WORD PTR x$9[rsp], ax
	mov	rax, QWORD PTR v$25[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	WORD PTR y$10[rsp], ax

; 1834 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	mov	eax, 4
	imul	rax, rax, 0
	movsx	ecx, WORD PTR x$9[rsp]
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	movsx	ecx, WORD PTR y$10[rsp]
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 4
	addss	xmm0, DWORD PTR mtx$36[rsp+rax]
	movss	xmm1, DWORD PTR m$31[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR v$25[rsp]
	mov	WORD PTR [rcx+4], ax

; 1835 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mov	eax, 4
	imul	rax, rax, 1
	movsx	ecx, WORD PTR x$9[rsp]
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 3
	movsx	ecx, WORD PTR y$10[rsp]
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR mtx$36[rsp+rax]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 5
	addss	xmm0, DWORD PTR mtx$36[rsp+rax]
	movss	xmm1, DWORD PTR n$32[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR v$25[rsp]
	mov	WORD PTR [rcx+6], ax

; 1836 :             }

	jmp	$LN16@stbtt__Get
$LN17@stbtt__Get:

; 1837 :             // Append vertices.
; 1838 :             tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);

	mov	eax, DWORD PTR comp_num_verts$18[rsp]
	mov	ecx, DWORD PTR num_vertices$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	imul	rax, rax, 14
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR tmp$34[rsp], rax

; 1839 :             if (!tmp) {

	cmp	QWORD PTR tmp$34[rsp], 0
	jne	SHORT $LN56@stbtt__Get

; 1840 :                if (vertices) STBTT_free(vertices, info->userdata);

	cmp	QWORD PTR vertices$[rsp], 0
	je	SHORT $LN57@stbtt__Get
	mov	rcx, QWORD PTR vertices$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN57@stbtt__Get:

; 1841 :                if (comp_verts) STBTT_free(comp_verts, info->userdata);

	cmp	QWORD PTR comp_verts$28[rsp], 0
	je	SHORT $LN58@stbtt__Get
	mov	rcx, QWORD PTR comp_verts$28[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN58@stbtt__Get:

; 1842 :                return 0;

	xor	eax, eax
	jmp	$LN1@stbtt__Get
$LN56@stbtt__Get:

; 1843 :             }
; 1844 :             if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex)); //-V595

	cmp	DWORD PTR num_vertices$[rsp], 0
	jle	SHORT $LN59@stbtt__Get
	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	r8, rax
	mov	rdx, QWORD PTR vertices$[rsp]
	mov	rcx, QWORD PTR tmp$34[rsp]
	call	memcpy
	npad	1
$LN59@stbtt__Get:

; 1845 :             STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));

	movsxd	rax, DWORD PTR comp_num_verts$18[rsp]
	imul	rax, rax, 14
	movsxd	rcx, DWORD PTR num_vertices$[rsp]
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR tmp$34[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR comp_verts$28[rsp]
	call	memcpy
	npad	1

; 1846 :             if (vertices) STBTT_free(vertices, info->userdata);

	cmp	QWORD PTR vertices$[rsp], 0
	je	SHORT $LN60@stbtt__Get
	mov	rcx, QWORD PTR vertices$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN60@stbtt__Get:

; 1847 :             vertices = tmp;

	mov	rax, QWORD PTR tmp$34[rsp]
	mov	QWORD PTR vertices$[rsp], rax

; 1848 :             STBTT_free(comp_verts, info->userdata);

	mov	rcx, QWORD PTR comp_verts$28[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 1849 :             num_vertices += comp_num_verts;

	mov	eax, DWORD PTR comp_num_verts$18[rsp]
	mov	ecx, DWORD PTR num_vertices$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR num_vertices$[rsp], eax
$LN55@stbtt__Get:

; 1850 :          }
; 1851 :          // More components ?
; 1852 :          more = flags & (1<<5);

	movzx	eax, WORD PTR flags$5[rsp]
	and	eax, 32					; 00000020H
	mov	DWORD PTR more$33[rsp], eax

; 1853 :       }

	jmp	$LN14@stbtt__Get
$LN15@stbtt__Get:

; 1854 :    } else if (numberOfContours < 0) {

	jmp	SHORT $LN45@stbtt__Get
$LN44@stbtt__Get:
	movsx	eax, WORD PTR numberOfContours$[rsp]
$LN45@stbtt__Get:
$LN21@stbtt__Get:

; 1855 :       // @TODO other compound variations?
; 1856 :       STBTT_assert(0);
; 1857 :    } else {
; 1858 :       // numberOfCounters == 0, do nothing
; 1859 :    }
; 1860 : 
; 1861 :    *pvertices = vertices;

	mov	rax, QWORD PTR pvertices$[rsp]
	mov	rcx, QWORD PTR vertices$[rsp]
	mov	QWORD PTR [rax], rcx

; 1862 :    return num_vertices;

	mov	eax, DWORD PTR num_vertices$[rsp]
$LN1@stbtt__Get:

; 1863 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 392				; 00000188H
	ret	0
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeTT
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv79 = 48
tv90 = 56
tv134 = 64
tv145 = 72
vertices$ = 96
num_vertices$ = 104
was_off$ = 112
start_off$ = 120
sx$ = 128
sy$ = 136
scx$ = 144
scy$ = 152
cx$ = 160
cy$ = 168
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z PROC ; stbtt__close_shape

; 1625 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1626 :    if (start_off) {

	cmp	DWORD PTR start_off$[rsp], 0
	je	$LN2@stbtt__clo

; 1627 :       if (was_off)

	cmp	DWORD PTR was_off$[rsp], 0
	je	SHORT $LN4@stbtt__clo

; 1628 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv79[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	eax, DWORD PTR scy$[rsp]
	mov	ecx, DWORD PTR cy$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 1
	mov	ecx, DWORD PTR scx$[rsp]
	mov	edx, DWORD PTR cx$[rsp]
	add	edx, ecx
	mov	ecx, edx
	sar	ecx, 1
	mov	edx, DWORD PTR cy$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	edx, DWORD PTR cx$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, eax
	mov	r8d, ecx
	mov	dl, 3
	mov	rcx, QWORD PTR tv79[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1
$LN4@stbtt__clo:

; 1629 :       stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv90[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	eax, DWORD PTR scy$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR scx$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR sy$[rsp]
	mov	r8d, DWORD PTR sx$[rsp]
	mov	dl, 3
	mov	rcx, QWORD PTR tv90[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1

; 1630 :    } else {

	jmp	$LN3@stbtt__clo
$LN2@stbtt__clo:

; 1631 :       if (was_off)

	cmp	DWORD PTR was_off$[rsp], 0
	je	SHORT $LN5@stbtt__clo

; 1632 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv134[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	eax, DWORD PTR cy$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cx$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR sy$[rsp]
	mov	r8d, DWORD PTR sx$[rsp]
	mov	dl, 3
	mov	rcx, QWORD PTR tv134[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1
	jmp	SHORT $LN6@stbtt__clo
$LN5@stbtt__clo:

; 1633 :       else
; 1634 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);

	movsxd	rax, DWORD PTR num_vertices$[rsp]
	imul	rax, rax, 14
	mov	rcx, QWORD PTR vertices$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv145[rsp], rcx
	mov	eax, DWORD PTR num_vertices$[rsp]
	inc	eax
	mov	DWORD PTR num_vertices$[rsp], eax
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR sy$[rsp]
	mov	r8d, DWORD PTR sx$[rsp]
	mov	dl, 2
	mov	rcx, QWORD PTR tv145[rsp]
	call	?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	npad	1
$LN6@stbtt__clo:
$LN3@stbtt__clo:

; 1635 :    }
; 1636 :    return num_vertices;

	mov	eax, DWORD PTR num_vertices$[rsp]

; 1637 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ENDP ; stbtt__close_shape
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
r$ = 32
tv70 = 36
tv73 = 40
tv76 = 44
tv79 = 48
tv81 = 52
c$ = 56
info$ = 128
glyph_index$ = 136
x0$ = 144
y0$ = 152
x1$ = 160
y1$ = 168
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z PROC ; stbtt__GetGlyphInfoT2

; 2255 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 2256 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);

	mov	DWORD PTR c$[rsp], 1
	mov	DWORD PTR c$[rsp+4], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR c$[rsp+8], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR c$[rsp+12], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR c$[rsp+16], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR c$[rsp+20], xmm0
	mov	DWORD PTR c$[rsp+24], 0
	mov	DWORD PTR c$[rsp+28], 0
	mov	DWORD PTR c$[rsp+32], 0
	mov	DWORD PTR c$[rsp+36], 0
	mov	QWORD PTR c$[rsp+40], 0
	mov	DWORD PTR c$[rsp+48], 0

; 2257 :    int r = stbtt__run_charstring(info, glyph_index, &c);

	lea	r8, QWORD PTR c$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	mov	DWORD PTR r$[rsp], eax

; 2258 :    if (x0)  *x0 = r ? c.min_x : 0;

	cmp	QWORD PTR x0$[rsp], 0
	je	SHORT $LN2@stbtt__Get
	cmp	DWORD PTR r$[rsp], 0
	je	SHORT $LN7@stbtt__Get
	mov	eax, DWORD PTR c$[rsp+24]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN8@stbtt__Get
$LN7@stbtt__Get:
	mov	DWORD PTR tv70[rsp], 0
$LN8@stbtt__Get:
	mov	rax, QWORD PTR x0$[rsp]
	mov	ecx, DWORD PTR tv70[rsp]
	mov	DWORD PTR [rax], ecx
$LN2@stbtt__Get:

; 2259 :    if (y0)  *y0 = r ? c.min_y : 0;

	cmp	QWORD PTR y0$[rsp], 0
	je	SHORT $LN3@stbtt__Get
	cmp	DWORD PTR r$[rsp], 0
	je	SHORT $LN9@stbtt__Get
	mov	eax, DWORD PTR c$[rsp+32]
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN10@stbtt__Get
$LN9@stbtt__Get:
	mov	DWORD PTR tv73[rsp], 0
$LN10@stbtt__Get:
	mov	rax, QWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR tv73[rsp]
	mov	DWORD PTR [rax], ecx
$LN3@stbtt__Get:

; 2260 :    if (x1)  *x1 = r ? c.max_x : 0;

	cmp	QWORD PTR x1$[rsp], 0
	je	SHORT $LN4@stbtt__Get
	cmp	DWORD PTR r$[rsp], 0
	je	SHORT $LN11@stbtt__Get
	mov	eax, DWORD PTR c$[rsp+28]
	mov	DWORD PTR tv76[rsp], eax
	jmp	SHORT $LN12@stbtt__Get
$LN11@stbtt__Get:
	mov	DWORD PTR tv76[rsp], 0
$LN12@stbtt__Get:
	mov	rax, QWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR tv76[rsp]
	mov	DWORD PTR [rax], ecx
$LN4@stbtt__Get:

; 2261 :    if (y1)  *y1 = r ? c.max_y : 0;

	cmp	QWORD PTR y1$[rsp], 0
	je	SHORT $LN5@stbtt__Get
	cmp	DWORD PTR r$[rsp], 0
	je	SHORT $LN13@stbtt__Get
	mov	eax, DWORD PTR c$[rsp+36]
	mov	DWORD PTR tv79[rsp], eax
	jmp	SHORT $LN14@stbtt__Get
$LN13@stbtt__Get:
	mov	DWORD PTR tv79[rsp], 0
$LN14@stbtt__Get:
	mov	rax, QWORD PTR y1$[rsp]
	mov	ecx, DWORD PTR tv79[rsp]
	mov	DWORD PTR [rax], ecx
$LN5@stbtt__Get:

; 2262 :    return r ? c.num_vertices : 0;

	cmp	DWORD PTR r$[rsp], 0
	je	SHORT $LN15@stbtt__Get
	mov	eax, DWORD PTR c$[rsp+48]
	mov	DWORD PTR tv81[rsp], eax
	jmp	SHORT $LN16@stbtt__Get
$LN15@stbtt__Get:
	mov	DWORD PTR tv81[rsp], 0
$LN16@stbtt__Get:
	mov	eax, DWORD PTR tv81[rsp]

; 2263 : }

	add	rsp, 120				; 00000078H
	ret	0
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ENDP ; stbtt__GetGlyphInfoT2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
g1$ = 32
g2$ = 36
tv153 = 40
info$ = 64
glyph_index$ = 72
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z PROC	; stbtt__GetGlyfOffset

; 1569 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1570 :    int g1,g2;
; 1571 : 
; 1572 :    STBTT_assert(!info->cff.size);
; 1573 : 
; 1574 :    if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+20]
	cmp	DWORD PTR glyph_index$[rsp], eax
	jl	SHORT $LN2@stbtt__Get
	mov	eax, -1
	jmp	$LN1@stbtt__Get
$LN2@stbtt__Get:

; 1575 :    if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+56], 2
	jl	SHORT $LN3@stbtt__Get
	mov	eax, -1
	jmp	$LN1@stbtt__Get
$LN3@stbtt__Get:

; 1576 : 
; 1577 :    if (info->indexToLocFormat == 0) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+56], 0
	jne	$LN4@stbtt__Get

; 1578 :       g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR glyph_index$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	lea	eax, DWORD PTR [rcx+rax*2]
	mov	DWORD PTR g1$[rsp], eax

; 1579 :       g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR glyph_index$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	lea	eax, DWORD PTR [rcx+rax*2]
	mov	DWORD PTR g2$[rsp], eax

; 1580 :    } else {

	jmp	SHORT $LN5@stbtt__Get
$LN4@stbtt__Get:

; 1581 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR glyph_index$[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+32]
	mov	DWORD PTR g1$[rsp], eax

; 1582 :       g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR glyph_index$[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+4]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+32]
	mov	DWORD PTR g2$[rsp], eax
$LN5@stbtt__Get:

; 1583 :    }
; 1584 : 
; 1585 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

	mov	eax, DWORD PTR g2$[rsp]
	cmp	DWORD PTR g1$[rsp], eax
	jne	SHORT $LN7@stbtt__Get
	mov	DWORD PTR tv153[rsp], -1
	jmp	SHORT $LN8@stbtt__Get
$LN7@stbtt__Get:
	mov	eax, DWORD PTR g1$[rsp]
	mov	DWORD PTR tv153[rsp], eax
$LN8@stbtt__Get:
	mov	eax, DWORD PTR tv153[rsp]
$LN1@stbtt__Get:

; 1586 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ENDP	; stbtt__GetGlyfOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
v$ = 8
type$ = 16
x$ = 24
y$ = 32
cx$ = 40
cy$ = 48
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z PROC	; stbtt_setvertex

; 1560 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 1561 :    v->type = type;

	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, BYTE PTR type$[rsp]
	mov	BYTE PTR [rax+12], cl

; 1562 :    v->x = (stbtt_int16) x;

	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, WORD PTR x$[rsp]
	mov	WORD PTR [rax], cx

; 1563 :    v->y = (stbtt_int16) y;

	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, WORD PTR y$[rsp]
	mov	WORD PTR [rax+2], cx

; 1564 :    v->cx = (stbtt_int16) cx;

	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, WORD PTR cx$[rsp]
	mov	WORD PTR [rax+4], cx

; 1565 :    v->cy = (stbtt_int16) cy;

	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, WORD PTR cy$[rsp]
	mov	WORD PTR [rax+6], cx

; 1566 : }

	ret	0
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ENDP	; stbtt_setvertex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
cmap$ = 32
fdselectoff$1 = 36
i$ = 40
encoding_record$2 = 44
fdarrayoff$3 = 48
charstrings$4 = 52
b$5 = 56
cff$6 = 72
cstype$7 = 76
t$ = 80
tv320 = 84
tv327 = 88
numTables$ = 92
topdict$8 = 96
$T9 = 112
$T10 = 128
$T11 = 144
$T12 = 160
$T13 = 176
topdictidx$14 = 192
$T15 = 208
$T16 = 224
$T17 = 240
$T18 = 256
$T19 = 272
$T20 = 288
$T21 = 304
$T22 = 320
$T23 = 336
$T24 = 352
$T25 = 368
$T26 = 384
$T27 = 400
$T28 = 416
$T29 = 432
$T30 = 448
$T31 = 464
$T32 = 480
$T33 = 496
$T34 = 512
$T35 = 528
$T36 = 544
$T37 = 560
$T38 = 576
info$ = 624
data$ = 632
fontstart$ = 640
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z PROC ; stbtt_InitFont_internal

; 1351 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 600				; 00000258H

; 1352 :    stbtt_uint32 cmap, t;
; 1353 :    stbtt_int32 i,numTables;
; 1354 : 
; 1355 :    info->data = data;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1356 :    info->fontstart = fontstart;

	mov	rax, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR fontstart$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 1357 :    info->cff = stbtt__new_buf(NULL, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T24[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T9[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	lea	rdi, QWORD PTR [rax+64]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1358 : 
; 1359 :    cmap = stbtt__find_table(data, fontstart, "cmap");       // required

	lea	r8, OFFSET FLAT:??_C@_04EICJPCEA@cmap@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	DWORD PTR cmap$[rsp], eax

; 1360 :    info->loca = stbtt__find_table(data, fontstart, "loca"); // required

	lea	r8, OFFSET FLAT:??_C@_04DACNFKGE@loca@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 1361 :    info->head = stbtt__find_table(data, fontstart, "head"); // required

	lea	r8, OFFSET FLAT:??_C@_04NEODDMOL@head@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 1362 :    info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required

	lea	r8, OFFSET FLAT:??_C@_04LLIHEPK@glyf@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 1363 :    info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required

	lea	r8, OFFSET FLAT:??_C@_04FMPHLIKP@hhea@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 1364 :    info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required

	lea	r8, OFFSET FLAT:??_C@_04ONMNCIMC@hmtx@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 1365 :    info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

	lea	r8, OFFSET FLAT:??_C@_04HHMMLDJI@kern@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 1366 :    info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

	lea	r8, OFFSET FLAT:??_C@_04PCFDEHHD@GPOS@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1367 : 
; 1368 :    if (!cmap || !info->head || !info->hhea || !info->hmtx)

	cmp	DWORD PTR cmap$[rsp], 0
	je	SHORT $LN10@stbtt_Init
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+28], 0
	je	SHORT $LN10@stbtt_Init
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN10@stbtt_Init
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN9@stbtt_Init
$LN10@stbtt_Init:

; 1369 :       return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Init
$LN9@stbtt_Init:

; 1370 :    if (info->glyf) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN11@stbtt_Init

; 1371 :       // required for truetype
; 1372 :       if (!info->loca) return 0;

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN13@stbtt_Init
	xor	eax, eax
	jmp	$LN1@stbtt_Init
$LN13@stbtt_Init:

; 1373 :    } else {

	jmp	$LN12@stbtt_Init
$LN11@stbtt_Init:

; 1374 :       // initialization for CFF / Type2 fonts (OTF)
; 1375 :       stbtt__buf b, topdict, topdictidx;
; 1376 :       stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;

	mov	DWORD PTR cstype$7[rsp], 2
	mov	DWORD PTR charstrings$4[rsp], 0
	mov	DWORD PTR fdarrayoff$3[rsp], 0
	mov	DWORD PTR fdselectoff$1[rsp], 0

; 1377 :       stbtt_uint32 cff;
; 1378 : 
; 1379 :       cff = stbtt__find_table(data, fontstart, "CFF ");

	lea	r8, OFFSET FLAT:??_C@_04HJGCPIEK@CFF?5@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	DWORD PTR cff$6[rsp], eax

; 1380 :       if (!cff) return 0;

	cmp	DWORD PTR cff$6[rsp], 0
	jne	SHORT $LN14@stbtt_Init
	xor	eax, eax
	jmp	$LN1@stbtt_Init
$LN14@stbtt_Init:

; 1381 : 
; 1382 :       info->fontdicts = stbtt__new_buf(NULL, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T25[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T10[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	lea	rdi, QWORD PTR [rax+128]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1383 :       info->fdselect = stbtt__new_buf(NULL, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T26[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T11[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	lea	rdi, QWORD PTR [rax+144]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1384 : 
; 1385 :       // @TODO this should use size from table (not 512MB)
; 1386 :       info->cff = stbtt__new_buf(data+cff, 512*1024*1024);

	mov	eax, DWORD PTR cff$6[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 536870912				; 20000000H
	mov	rdx, rax
	lea	rcx, QWORD PTR $T27[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T12[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	lea	rdi, QWORD PTR [rax+64]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1387 :       b = info->cff;

	lea	rax, QWORD PTR b$5[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+64]
	mov	ecx, 16
	rep movsb

; 1388 : 
; 1389 :       // read the header
; 1390 :       stbtt__buf_skip(&b, 2);

	mov	edx, 2
	lea	rcx, QWORD PTR b$5[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1391 :       stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

	lea	rcx, QWORD PTR b$5[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	edx, eax
	lea	rcx, QWORD PTR b$5[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
	npad	1

; 1392 : 
; 1393 :       // @TODO the name INDEX could list multiple fonts,
; 1394 :       // but we just use the first one.
; 1395 :       stbtt__cff_get_index(&b);  // name INDEX

	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T28[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T29[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1396 :       topdictidx = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T30[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T13[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR topdictidx$14[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1397 :       topdict = stbtt__cff_index_get(topdictidx, 0);

	lea	rax, QWORD PTR $T15[rsp]
	lea	rcx, QWORD PTR topdictidx$14[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T15[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	lea	rcx, QWORD PTR $T16[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR topdict$8[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1398 :       stbtt__cff_get_index(&b);  // string INDEX

	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T32[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T33[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1399 :       info->gsubrs = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T34[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T17[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	lea	rdi, QWORD PTR [rax+96]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1400 : 
; 1401 :       stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);

	lea	r9, QWORD PTR charstrings$4[rsp]
	mov	r8d, 1
	mov	edx, 17
	lea	rcx, QWORD PTR topdict$8[rsp]
	call	?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1402 :       stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);

	lea	r9, QWORD PTR cstype$7[rsp]
	mov	r8d, 1
	mov	edx, 262				; 00000106H
	lea	rcx, QWORD PTR topdict$8[rsp]
	call	?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1403 :       stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);

	lea	r9, QWORD PTR fdarrayoff$3[rsp]
	mov	r8d, 1
	mov	edx, 292				; 00000124H
	lea	rcx, QWORD PTR topdict$8[rsp]
	call	?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1404 :       stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);

	lea	r9, QWORD PTR fdselectoff$1[rsp]
	mov	r8d, 1
	mov	edx, 293				; 00000125H
	lea	rcx, QWORD PTR topdict$8[rsp]
	call	?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints
	npad	1

; 1405 :       info->subrs = stbtt__get_subrs(b, topdict);

	lea	rax, QWORD PTR $T18[rsp]
	lea	rcx, QWORD PTR topdict$8[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T19[rsp]
	lea	rcx, QWORD PTR b$5[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	r8, QWORD PTR $T18[rsp]
	lea	rdx, QWORD PTR $T19[rsp]
	lea	rcx, QWORD PTR $T35[rsp]
	call	?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
	lea	rcx, QWORD PTR $T20[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	lea	rdi, QWORD PTR [rax+112]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1406 : 
; 1407 :       // we only support Type 2 charstrings
; 1408 :       if (cstype != 2) return 0;

	cmp	DWORD PTR cstype$7[rsp], 2
	je	SHORT $LN15@stbtt_Init
	xor	eax, eax
	jmp	$LN1@stbtt_Init
$LN15@stbtt_Init:

; 1409 :       if (charstrings == 0) return 0;

	cmp	DWORD PTR charstrings$4[rsp], 0
	jne	SHORT $LN16@stbtt_Init
	xor	eax, eax
	jmp	$LN1@stbtt_Init
$LN16@stbtt_Init:

; 1410 : 
; 1411 :       if (fdarrayoff) {

	cmp	DWORD PTR fdarrayoff$3[rsp], 0
	je	$LN17@stbtt_Init

; 1412 :          // looks like a CID font
; 1413 :          if (!fdselectoff) return 0;

	cmp	DWORD PTR fdselectoff$1[rsp], 0
	jne	SHORT $LN18@stbtt_Init
	xor	eax, eax
	jmp	$LN1@stbtt_Init
$LN18@stbtt_Init:

; 1414 :          stbtt__buf_seek(&b, fdarrayoff);

	mov	edx, DWORD PTR fdarrayoff$3[rsp]
	lea	rcx, QWORD PTR b$5[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
	npad	1

; 1415 :          info->fontdicts = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T36[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T21[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	lea	rdi, QWORD PTR [rax+128]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1416 :          info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);

	mov	eax, DWORD PTR fdselectoff$1[rsp]
	mov	ecx, DWORD PTR b$5[rsp+12]
	sub	ecx, eax
	mov	eax, ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR fdselectoff$1[rsp]
	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T37[rsp]
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
	lea	rcx, QWORD PTR $T22[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T22[rsp]
	lea	rdi, QWORD PTR [rax+144]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN17@stbtt_Init:

; 1417 :       }
; 1418 : 
; 1419 :       stbtt__buf_seek(&b, charstrings);

	mov	edx, DWORD PTR charstrings$4[rsp]
	lea	rcx, QWORD PTR b$5[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
	npad	1

; 1420 :       info->charstrings = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$5[rsp]
	lea	rcx, QWORD PTR $T38[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T23[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR info$[rsp]
	lea	rcx, QWORD PTR $T23[rsp]
	lea	rdi, QWORD PTR [rax+80]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN12@stbtt_Init:

; 1421 :    }
; 1422 : 
; 1423 :    t = stbtt__find_table(data, fontstart, "maxp");

	lea	r8, OFFSET FLAT:??_C@_04KODIGLGG@maxp@
	mov	edx, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	DWORD PTR t$[rsp], eax

; 1424 :    if (t)

	cmp	DWORD PTR t$[rsp], 0
	je	SHORT $LN19@stbtt_Init

; 1425 :       info->numGlyphs = ttUSHORT(data+t+4);

	mov	eax, DWORD PTR t$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+20], eax
	jmp	SHORT $LN20@stbtt_Init
$LN19@stbtt_Init:

; 1426 :    else
; 1427 :       info->numGlyphs = 0xffff;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+20], 65535		; 0000ffffH
$LN20@stbtt_Init:

; 1428 : 
; 1429 :    // find a cmap encoding table we understand *now* to avoid searching
; 1430 :    // later. (todo: could make this installable)
; 1431 :    // the same regardless of glyph.
; 1432 :    numTables = ttUSHORT(data + cmap + 2);

	mov	eax, DWORD PTR cmap$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR numTables$[rsp], eax

; 1433 :    info->index_map = 0;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+52], 0

; 1434 :    for (i=0; i < numTables; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt_Init
$LN2@stbtt_Init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt_Init:
	mov	eax, DWORD PTR numTables$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbtt_Init

; 1435 :       stbtt_uint32 encoding_record = cmap + 4 + 8 * i;

	mov	eax, DWORD PTR cmap$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8+4]
	mov	DWORD PTR encoding_record$2[rsp], eax

; 1436 :       // find an encoding we understand:
; 1437 :       switch(ttUSHORT(data+encoding_record)) {

	mov	eax, DWORD PTR encoding_record$2[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR tv320[rsp], eax
	cmp	DWORD PTR tv320[rsp], 0
	je	SHORT $LN24@stbtt_Init
	cmp	DWORD PTR tv320[rsp], 3
	je	SHORT $LN21@stbtt_Init
	jmp	$LN5@stbtt_Init
$LN21@stbtt_Init:

; 1438 :          case STBTT_PLATFORM_ID_MICROSOFT:
; 1439 :             switch (ttUSHORT(data+encoding_record+2)) {

	mov	eax, DWORD PTR encoding_record$2[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR tv327[rsp], eax
	cmp	DWORD PTR tv327[rsp], 1
	je	SHORT $LN22@stbtt_Init
	cmp	DWORD PTR tv327[rsp], 10
	je	SHORT $LN23@stbtt_Init
	jmp	SHORT $LN7@stbtt_Init
$LN22@stbtt_Init:
$LN23@stbtt_Init:

; 1440 :                case STBTT_MS_EID_UNICODE_BMP:
; 1441 :                case STBTT_MS_EID_UNICODE_FULL:
; 1442 :                   // MS/Unicode
; 1443 :                   info->index_map = cmap + ttULONG(data+encoding_record+4);

	mov	eax, DWORD PTR encoding_record$2[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	ecx, DWORD PTR cmap$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+52], eax
$LN7@stbtt_Init:

; 1444 :                   break;
; 1445 :             }
; 1446 :             break;

	jmp	SHORT $LN5@stbtt_Init
$LN24@stbtt_Init:

; 1447 :         case STBTT_PLATFORM_ID_UNICODE:
; 1448 :             // Mac/iOS has these
; 1449 :             // all the encodingIDs are unicode, so we don't bother to check it
; 1450 :             info->index_map = cmap + ttULONG(data+encoding_record+4);

	mov	eax, DWORD PTR encoding_record$2[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	ecx, DWORD PTR cmap$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+52], eax
$LN5@stbtt_Init:

; 1451 :             break;
; 1452 :       }
; 1453 :    }

	jmp	$LN2@stbtt_Init
$LN3@stbtt_Init:

; 1454 :    if (info->index_map == 0)

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+52], 0
	jne	SHORT $LN25@stbtt_Init

; 1455 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbtt_Init
$LN25@stbtt_Init:

; 1456 : 
; 1457 :    info->indexToLocFormat = ttUSHORT(data+info->head + 50);

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+50]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 1458 :    return 1;

	mov	eax, 1
$LN1@stbtt_Init:

; 1459 : }

	add	rsp, 600				; 00000258H
	pop	rdi
	pop	rsi
	ret	0
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ENDP ; stbtt_InitFont_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
subrsoff$ = 32
private_loc$ = 40
$T1 = 48
$T2 = 64
pdict$ = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
$T7 = 160
$T8 = 176
__$ReturnAddress$ = 224
cff$ = 232
fontdict$ = 240
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z PROC		; stbtt__get_subrs

; 1338 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 1339 :    stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };

	mov	DWORD PTR subrsoff$[rsp], 0
	mov	DWORD PTR private_loc$[rsp], 0
	mov	DWORD PTR private_loc$[rsp+4], 0

; 1340 :    stbtt__buf pdict;
; 1341 :    stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);

	lea	r9, QWORD PTR private_loc$[rsp]
	mov	r8d, 2
	mov	edx, 18
	mov	rcx, QWORD PTR fontdict$[rsp]
	call	?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints
	npad	1

; 1342 :    if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

	mov	eax, 4
	imul	rax, rax, 1
	cmp	DWORD PTR private_loc$[rsp+rax], 0
	je	SHORT $LN3@stbtt__get
	mov	eax, 4
	imul	rax, rax, 0
	cmp	DWORD PTR private_loc$[rsp+rax], 0
	jne	SHORT $LN2@stbtt__get
$LN3@stbtt__get:
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T5[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	$LN1@stbtt__get
$LN2@stbtt__get:

; 1343 :    pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	r9d, DWORD PTR private_loc$[rsp+rax]
	mov	r8d, DWORD PTR private_loc$[rsp+rcx]
	mov	rdx, QWORD PTR cff$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR pdict$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1344 :    stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);

	lea	r9, QWORD PTR subrsoff$[rsp]
	mov	r8d, 1
	mov	edx, 19
	lea	rcx, QWORD PTR pdict$[rsp]
	call	?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints
	npad	1

; 1345 :    if (!subrsoff) return stbtt__new_buf(NULL, 0);

	cmp	DWORD PTR subrsoff$[rsp], 0
	jne	SHORT $LN4@stbtt__get
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T7[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR $T3[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T3[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@stbtt__get
$LN4@stbtt__get:

; 1346 :    stbtt__buf_seek(&cff, private_loc[1]+subrsoff);

	mov	eax, 4
	imul	rax, rax, 1
	mov	eax, DWORD PTR private_loc$[rsp+rax]
	add	eax, DWORD PTR subrsoff$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR cff$[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
	npad	1

; 1347 :    return stbtt__cff_get_index(&cff);

	mov	rdx, QWORD PTR cff$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T4[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@stbtt__get:

; 1348 : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ENDP		; stbtt__get_subrs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv68 = 32
n$1 = 36
font_collection$ = 64
index$ = 72
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z PROC	; stbtt_GetFontOffsetForIndex_internal

; 1303 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1304 :    // if it's just a font, there's only one valid index
; 1305 :    if (stbtt__isfont(font_collection))

	mov	rcx, QWORD PTR font_collection$[rsp]
	call	?stbtt__isfont@@YAHPEAE@Z		; stbtt__isfont
	test	eax, eax
	je	SHORT $LN2@stbtt_GetF

; 1306 :       return index == 0 ? 0 : -1;

	cmp	DWORD PTR index$[rsp], 0
	jne	SHORT $LN8@stbtt_GetF
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN9@stbtt_GetF
$LN8@stbtt_GetF:
	mov	DWORD PTR tv68[rsp], -1
$LN9@stbtt_GetF:
	mov	eax, DWORD PTR tv68[rsp]
	jmp	$LN1@stbtt_GetF
$LN2@stbtt_GetF:

; 1307 : 
; 1308 :    // check if it's a TTC
; 1309 :    if (stbtt_tag(font_collection, "ttcf")) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR font_collection$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:??_C@_04KIOEMAHO@ttcf@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN3@stbtt_GetF
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR font_collection$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:??_C@_04KIOEMAHO@ttcf@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN3@stbtt_GetF
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR font_collection$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:??_C@_04KIOEMAHO@ttcf@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN3@stbtt_GetF
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR font_collection$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 3
	lea	rdx, OFFSET FLAT:??_C@_04KIOEMAHO@ttcf@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN3@stbtt_GetF

; 1310 :       // version 1?
; 1311 :       if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {

	mov	rax, QWORD PTR font_collection$[rsp]
	add	rax, 4
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	cmp	eax, 65536				; 00010000H
	je	SHORT $LN5@stbtt_GetF
	mov	rax, QWORD PTR font_collection$[rsp]
	add	rax, 4
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	cmp	eax, 131072				; 00020000H
	jne	SHORT $LN4@stbtt_GetF
$LN5@stbtt_GetF:

; 1312 :          stbtt_int32 n = ttLONG(font_collection+8);

	mov	rax, QWORD PTR font_collection$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?ttLONG@@YAHPEAE@Z			; ttLONG
	mov	DWORD PTR n$1[rsp], eax

; 1313 :          if (index >= n)

	mov	eax, DWORD PTR n$1[rsp]
	cmp	DWORD PTR index$[rsp], eax
	jl	SHORT $LN6@stbtt_GetF

; 1314 :             return -1;

	mov	eax, -1
	jmp	SHORT $LN1@stbtt_GetF
$LN6@stbtt_GetF:

; 1315 :          return ttULONG(font_collection+12+index*4);

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 2
	cdqe
	mov	rcx, QWORD PTR font_collection$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	jmp	SHORT $LN1@stbtt_GetF
$LN4@stbtt_GetF:
$LN3@stbtt_GetF:

; 1316 :       }
; 1317 :    }
; 1318 :    return -1;

	mov	eax, -1
$LN1@stbtt_GetF:

; 1319 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ENDP	; stbtt_GetFontOffsetForIndex_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
loc$1 = 32
i$ = 36
num_tables$ = 40
tabledir$ = 44
data$ = 64
fontstart$ = 72
tag$ = 80
?stbtt__find_table@@YAIPEAEIPEBD@Z PROC			; stbtt__find_table

; 1290 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1291 :    stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);

	mov	eax, DWORD PTR fontstart$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR num_tables$[rsp], eax

; 1292 :    stbtt_uint32 tabledir = fontstart + 12;

	mov	eax, DWORD PTR fontstart$[rsp]
	add	eax, 12
	mov	DWORD PTR tabledir$[rsp], eax

; 1293 :    stbtt_int32 i;
; 1294 :    for (i=0; i < num_tables; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt__fin
$LN2@stbtt__fin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt__fin:
	mov	eax, DWORD PTR num_tables$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbtt__fin

; 1295 :       stbtt_uint32 loc = tabledir + 16*i;

	imul	eax, DWORD PTR i$[rsp], 16
	mov	ecx, DWORD PTR tabledir$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR loc$1[rsp], eax

; 1296 :       if (stbtt_tag(data+loc+0, tag))

	mov	eax, DWORD PTR loc$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 1
	imul	rcx, rcx, 0
	movzx	eax, BYTE PTR [rax+rcx]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tag$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN5@stbtt__fin
	mov	eax, DWORD PTR loc$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 1
	imul	rcx, rcx, 1
	movzx	eax, BYTE PTR [rax+rcx]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tag$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN5@stbtt__fin
	mov	eax, DWORD PTR loc$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 1
	imul	rcx, rcx, 2
	movzx	eax, BYTE PTR [rax+rcx]
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR tag$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN5@stbtt__fin
	mov	eax, DWORD PTR loc$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 1
	imul	rcx, rcx, 3
	movzx	eax, BYTE PTR [rax+rcx]
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR tag$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN5@stbtt__fin

; 1297 :          return ttULONG(data+loc+8);

	mov	eax, DWORD PTR loc$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	jmp	SHORT $LN1@stbtt__fin
$LN5@stbtt__fin:

; 1298 :    }

	jmp	$LN2@stbtt__fin
$LN3@stbtt__fin:

; 1299 :    return 0;

	xor	eax, eax
$LN1@stbtt__fin:

; 1300 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__find_table@@YAIPEAEIPEBD@Z ENDP			; stbtt__find_table
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
font$ = 8
?stbtt__isfont@@YAHPEAE@Z PROC				; stbtt__isfont

; 1278 : {

	mov	QWORD PTR [rsp+8], rcx

; 1279 :    // check the version number
; 1280 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 49					; 00000031H
	jne	SHORT $LN2@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@stbtt__isf
	mov	eax, 1
	jmp	$LN1@stbtt__isf
$LN2@stbtt__isf:

; 1281 :    if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:??_C@_04LBBEMOBJ@typ1@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN3@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:??_C@_04LBBEMOBJ@typ1@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN3@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:??_C@_04LBBEMOBJ@typ1@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN3@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 3
	lea	rdx, OFFSET FLAT:??_C@_04LBBEMOBJ@typ1@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN3@stbtt__isf
	mov	eax, 1
	jmp	$LN1@stbtt__isf
$LN3@stbtt__isf:

; 1282 :    if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:??_C@_04LLEFIKCJ@OTTO@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN4@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:??_C@_04LLEFIKCJ@OTTO@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN4@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:??_C@_04LLEFIKCJ@OTTO@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN4@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 3
	lea	rdx, OFFSET FLAT:??_C@_04LLEFIKCJ@OTTO@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN4@stbtt__isf
	mov	eax, 1
	jmp	$LN1@stbtt__isf
$LN4@stbtt__isf:

; 1283 :    if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN5@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 1
	jne	SHORT $LN5@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN5@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN5@stbtt__isf
	mov	eax, 1
	jmp	$LN1@stbtt__isf
$LN5@stbtt__isf:

; 1284 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	$LN6@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN6@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN6@stbtt__isf
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR font$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 3
	lea	rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN6@stbtt__isf
	mov	eax, 1
	jmp	SHORT $LN1@stbtt__isf
$LN6@stbtt__isf:

; 1285 :    return 0;

	xor	eax, eax
$LN1@stbtt__isf:

; 1286 : }

	ret	0
?stbtt__isfont@@YAHPEAE@Z ENDP				; stbtt__isfont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttLONG@@YAHPEAE@Z PROC					; ttLONG

; 1272 : static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 24
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 8
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	ret	0
?ttLONG@@YAHPEAE@Z ENDP					; ttLONG
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttULONG@@YAIPEAE@Z PROC				; ttULONG

; 1271 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 24
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	shl	ecx, 8
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	ret	0
?ttULONG@@YAIPEAE@Z ENDP				; ttULONG
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttSHORT@@YAFPEAE@Z PROC				; ttSHORT

; 1270 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 256				; 00000100H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	ret	0
?ttSHORT@@YAFPEAE@Z ENDP				; ttSHORT
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttUSHORT@@YAGPEAE@Z PROC				; ttUSHORT

; 1269 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 256				; 00000100H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	ret	0
?ttUSHORT@@YAGPEAE@Z ENDP				; ttUSHORT
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
offsize$ = 32
start$ = 36
end$ = 40
count$ = 44
$T1 = 48
$T2 = 64
__$ReturnAddress$ = 112
b$ = 120
i$ = 128
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z PROC	; stbtt__cff_index_get

; 1244 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 1245 :    int count, offsize, start, end;
; 1246 :    stbtt__buf_seek(&b, 0);

	xor	edx, edx
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1247 :    count = stbtt__buf_get16(&b);

	mov	edx, 2
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR count$[rsp], eax

; 1248 :    offsize = stbtt__buf_get8(&b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR offsize$[rsp], eax

; 1249 :    STBTT_assert(i >= 0 && i < count);
; 1250 :    STBTT_assert(offsize >= 1 && offsize <= 4);
; 1251 :    stbtt__buf_skip(&b, i*offsize);

	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR offsize$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1252 :    start = stbtt__buf_get(&b, offsize);

	mov	edx, DWORD PTR offsize$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR start$[rsp], eax

; 1253 :    end = stbtt__buf_get(&b, offsize);

	mov	edx, DWORD PTR offsize$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR end$[rsp], eax

; 1254 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

	mov	eax, DWORD PTR start$[rsp]
	mov	ecx, DWORD PTR end$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR count$[rsp]
	inc	ecx
	imul	ecx, DWORD PTR offsize$[rsp]
	mov	edx, DWORD PTR start$[rsp]
	lea	ecx, DWORD PTR [rcx+rdx+2]
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 1255 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ENDP	; stbtt__cff_index_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z PROC	; stbtt__cff_index_count

; 1238 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1239 :    stbtt__buf_seek(b, 0);

	xor	edx, edx
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1240 :    return stbtt__buf_get16(b);

	mov	edx, 2
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get

; 1241 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_index_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$ = 32
operands$ = 40
$T1 = 56
b$ = 112
key$ = 120
outcount$ = 128
out$ = 136
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z PROC	; stbtt__dict_get_ints

; 1230 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 1231 :    int i;
; 1232 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	r8d, DWORD PTR key$[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	lea	rcx, QWORD PTR operands$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1233 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt__dic
$LN2@stbtt__dic:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt__dic:
	mov	eax, DWORD PTR outcount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbtt__dic
	mov	eax, DWORD PTR operands$[rsp+12]
	cmp	DWORD PTR operands$[rsp+8], eax
	jge	SHORT $LN3@stbtt__dic

; 1234 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR out$[rsp]
	mov	DWORD PTR [rdx+rcx*4], eax
	jmp	SHORT $LN2@stbtt__dic
$LN3@stbtt__dic:

; 1235 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ENDP	; stbtt__dict_get_ints
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
op$1 = 32
start$2 = 36
end$3 = 40
$T4 = 48
$T5 = 64
$T6 = 80
$T7 = 96
__$ReturnAddress$ = 144
b$ = 152
key$ = 160
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z PROC	; stbtt__dict_get

; 1215 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 1216 :    stbtt__buf_seek(b, 0);

	xor	edx, edx
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
	npad	1
$LN2@stbtt__dic:

; 1217 :    while (b->cursor < b->size) {

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jge	$LN3@stbtt__dic

; 1218 :       int start = b->cursor, end, op;

	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR start$2[rsp], eax
$LN4@stbtt__dic:

; 1219 :       while (stbtt__buf_peek8(b) >= 28)

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
	movzx	eax, al
	cmp	eax, 28
	jl	SHORT $LN5@stbtt__dic

; 1220 :          stbtt__cff_skip_operand(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z ; stbtt__cff_skip_operand
	npad	1
	jmp	SHORT $LN4@stbtt__dic
$LN5@stbtt__dic:

; 1221 :       end = b->cursor;

	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR end$3[rsp], eax

; 1222 :       op = stbtt__buf_get8(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR op$1[rsp], eax

; 1223 :       if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

	cmp	DWORD PTR op$1[rsp], 12
	jne	SHORT $LN6@stbtt__dic
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	bts	eax, 8
	mov	DWORD PTR op$1[rsp], eax
$LN6@stbtt__dic:

; 1224 :       if (op == key) return stbtt__buf_range(b, start, end-start);

	mov	eax, DWORD PTR key$[rsp]
	cmp	DWORD PTR op$1[rsp], eax
	jne	SHORT $LN7@stbtt__dic
	mov	eax, DWORD PTR start$2[rsp]
	mov	ecx, DWORD PTR end$3[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR start$2[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T4[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@stbtt__dic
$LN7@stbtt__dic:

; 1225 :    }

	jmp	$LN2@stbtt__dic
$LN3@stbtt__dic:

; 1226 :    return stbtt__buf_range(b, 0, 0);

	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T5[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@stbtt__dic:

; 1227 : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ENDP	; stbtt__dict_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
v$ = 32
b0$ = 36
b$ = 64
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z PROC	; stbtt__cff_skip_operand

; 1199 : static void stbtt__cff_skip_operand(stbtt__buf *b) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1200 :    int v, b0 = stbtt__buf_peek8(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
	movzx	eax, al
	mov	DWORD PTR b0$[rsp], eax

; 1201 :    STBTT_assert(b0 >= 28);
; 1202 :    if (b0 == 30) {

	cmp	DWORD PTR b0$[rsp], 30
	jne	SHORT $LN4@stbtt__cff

; 1203 :       stbtt__buf_skip(b, 1);

	mov	edx, 1
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip
	npad	1
$LN2@stbtt__cff:

; 1204 :       while (b->cursor < b->size) {

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jge	SHORT $LN3@stbtt__cff

; 1205 :          v = stbtt__buf_get8(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR v$[rsp], eax

; 1206 :          if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

	mov	eax, DWORD PTR v$[rsp]
	and	eax, 15
	cmp	eax, 15
	je	SHORT $LN7@stbtt__cff
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, 4
	cmp	eax, 15
	jne	SHORT $LN6@stbtt__cff
$LN7@stbtt__cff:

; 1207 :             break;

	jmp	SHORT $LN3@stbtt__cff
$LN6@stbtt__cff:

; 1208 :       }

	jmp	SHORT $LN2@stbtt__cff
$LN3@stbtt__cff:

; 1209 :    } else {

	jmp	SHORT $LN5@stbtt__cff
$LN4@stbtt__cff:

; 1210 :       stbtt__cff_int(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	npad	1
$LN5@stbtt__cff:

; 1211 :    }
; 1212 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_skip_operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b0$ = 32
tv73 = 36
tv83 = 40
b$ = 64
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z PROC		; stbtt__cff_int

; 1188 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1189 :    int b0 = stbtt__buf_get8(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR b0$[rsp], eax

; 1190 :    if (b0 >= 32 && b0 <= 246)       return b0 - 139;

	cmp	DWORD PTR b0$[rsp], 32			; 00000020H
	jl	SHORT $LN2@stbtt__cff
	cmp	DWORD PTR b0$[rsp], 246			; 000000f6H
	jg	SHORT $LN2@stbtt__cff
	mov	eax, DWORD PTR b0$[rsp]
	sub	eax, 139				; 0000008bH
	jmp	$LN1@stbtt__cff
	jmp	$LN3@stbtt__cff
$LN2@stbtt__cff:

; 1191 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

	cmp	DWORD PTR b0$[rsp], 247			; 000000f7H
	jl	SHORT $LN4@stbtt__cff
	cmp	DWORD PTR b0$[rsp], 250			; 000000faH
	jg	SHORT $LN4@stbtt__cff
	mov	eax, DWORD PTR b0$[rsp]
	sub	eax, 247				; 000000f7H
	imul	eax, eax, 256				; 00000100H
	mov	DWORD PTR tv73[rsp], eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	ecx, DWORD PTR tv73[rsp]
	lea	eax, DWORD PTR [rcx+rax+108]
	jmp	SHORT $LN1@stbtt__cff
	jmp	SHORT $LN5@stbtt__cff
$LN4@stbtt__cff:

; 1192 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

	cmp	DWORD PTR b0$[rsp], 251			; 000000fbH
	jl	SHORT $LN6@stbtt__cff
	cmp	DWORD PTR b0$[rsp], 254			; 000000feH
	jg	SHORT $LN6@stbtt__cff
	mov	eax, DWORD PTR b0$[rsp]
	sub	eax, 251				; 000000fbH
	neg	eax
	imul	eax, eax, 256				; 00000100H
	mov	DWORD PTR tv83[rsp], eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	ecx, DWORD PTR tv83[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sub	eax, 108				; 0000006cH
	jmp	SHORT $LN1@stbtt__cff
	jmp	SHORT $LN7@stbtt__cff
$LN6@stbtt__cff:

; 1193 :    else if (b0 == 28)               return stbtt__buf_get16(b);

	cmp	DWORD PTR b0$[rsp], 28
	jne	SHORT $LN8@stbtt__cff
	mov	edx, 2
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	jmp	SHORT $LN1@stbtt__cff
	jmp	SHORT $LN9@stbtt__cff
$LN8@stbtt__cff:

; 1194 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	cmp	DWORD PTR b0$[rsp], 29
	jne	SHORT $LN10@stbtt__cff
	mov	edx, 4
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	jmp	SHORT $LN1@stbtt__cff
$LN10@stbtt__cff:
$LN9@stbtt__cff:
$LN7@stbtt__cff:
$LN5@stbtt__cff:
$LN3@stbtt__cff:

; 1195 :    STBTT_assert(0);
; 1196 :    return 0;

	xor	eax, eax
$LN1@stbtt__cff:

; 1197 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ENDP		; stbtt__cff_int
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
count$ = 32
offsize$ = 36
start$ = 40
$T1 = 48
$T2 = 64
__$ReturnAddress$ = 112
b$ = 120
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z PROC	; stbtt__cff_get_index

; 1174 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 1175 :    int count, start, offsize;
; 1176 :    start = b->cursor;

	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR start$[rsp], eax

; 1177 :    count = stbtt__buf_get16(b);

	mov	edx, 2
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	DWORD PTR count$[rsp], eax

; 1178 :    if (count) {

	cmp	DWORD PTR count$[rsp], 0
	je	SHORT $LN2@stbtt__cff

; 1179 :       offsize = stbtt__buf_get8(b);

	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR offsize$[rsp], eax

; 1180 :       STBTT_assert(offsize >= 1 && offsize <= 4);
; 1181 :       stbtt__buf_skip(b, offsize * count);

	mov	eax, DWORD PTR offsize$[rsp]
	imul	eax, DWORD PTR count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1182 :       stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

	mov	edx, DWORD PTR offsize$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z	; stbtt__buf_get
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip
	npad	1
$LN2@stbtt__cff:

; 1183 :    }
; 1184 :    return stbtt__buf_range(b, start, b->cursor - start);

	mov	rax, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR start$[rsp]
	mov	eax, DWORD PTR [rax+8]
	sub	eax, ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR start$[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 1185 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ENDP	; stbtt__cff_get_index
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
r$ = 32
$T1 = 48
__$ReturnAddress$ = 96
b$ = 104
o$ = 112
s$ = 120
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z PROC	; stbtt__buf_range

; 1165 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 1166 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
	lea	rcx, QWORD PTR r$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1167 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	cmp	DWORD PTR o$[rsp], 0
	jl	SHORT $LN3@stbtt__buf
	cmp	DWORD PTR s$[rsp], 0
	jl	SHORT $LN3@stbtt__buf
	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+12]
	cmp	DWORD PTR o$[rsp], eax
	jg	SHORT $LN3@stbtt__buf
	mov	rax, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR o$[rsp]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	cmp	DWORD PTR s$[rsp], eax
	jle	SHORT $LN2@stbtt__buf
$LN3@stbtt__buf:
	lea	rax, QWORD PTR r$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1168 :    r.data = b->data + o;

	movsxd	rax, DWORD PTR o$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR r$[rsp], rax

; 1169 :    r.size = s;

	mov	eax, DWORD PTR s$[rsp]
	mov	DWORD PTR r$[rsp+12], eax

; 1170 :    return r;

	lea	rax, QWORD PTR r$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@stbtt__buf:

; 1171 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ENDP	; stbtt__buf_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
r$ = 0
__$ReturnAddress$ = 48
p$ = 56
size$ = 64
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z PROC		; stbtt__new_buf

; 1152 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 24

; 1153 :    stbtt__buf r;
; 1154 :    STBTT_assert(size < 0x40000000);
; 1155 :    r.data = (stbtt_uint8*) p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR r$[rsp], rax

; 1156 :    r.size = (int) size;

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR r$[rsp+12], eax

; 1157 :    r.cursor = 0;

	mov	DWORD PTR r$[rsp+8], 0

; 1158 :    return r;

	lea	rax, QWORD PTR r$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 1159 : }

	add	rsp, 24
	pop	rdi
	pop	rsi
	ret	0
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ENDP		; stbtt__new_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
i$ = 32
v$ = 36
tv66 = 40
b$ = 64
n$ = 72
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_get

; 1142 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1143 :    stbtt_uint32 v = 0;

	mov	DWORD PTR v$[rsp], 0

; 1144 :    int i;
; 1145 :    STBTT_assert(n >= 1 && n <= 4);
; 1146 :    for (i = 0; i < n; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt__buf
$LN2@stbtt__buf:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt__buf:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbtt__buf

; 1147 :       v = (v << 8) | stbtt__buf_get8(b);

	mov	eax, DWORD PTR v$[rsp]
	shl	eax, 8
	mov	DWORD PTR tv66[rsp], eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	ecx, DWORD PTR tv66[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v$[rsp], eax
	jmp	SHORT $LN2@stbtt__buf
$LN3@stbtt__buf:

; 1148 :    return v;

	mov	eax, DWORD PTR v$[rsp]

; 1149 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
o$ = 56
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_skip

; 1137 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1138 :    stbtt__buf_seek(b, b->cursor + o);

	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	eax, DWORD PTR o$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR b$[rsp]
	call	?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
	npad	1

; 1139 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv69 = 0
b$ = 32
o$ = 40
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_seek

; 1131 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1132 :    STBTT_assert(!(o > b->size || o < 0));
; 1133 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+12]
	cmp	DWORD PTR o$[rsp], eax
	jg	SHORT $LN3@stbtt__buf
	cmp	DWORD PTR o$[rsp], 0
	jl	SHORT $LN3@stbtt__buf
	mov	eax, DWORD PTR o$[rsp]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN4@stbtt__buf
$LN3@stbtt__buf:
	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR tv69[rsp], eax
$LN4@stbtt__buf:
	mov	rax, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR tv69[rsp]
	mov	DWORD PTR [rax+8], ecx

; 1134 : }

	add	rsp, 24
	ret	0
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_seek
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 8
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_peek8

; 1124 : {

	mov	QWORD PTR [rsp+8], rcx

; 1125 :    if (b->cursor >= b->size)

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jl	SHORT $LN2@stbtt__buf

; 1126 :       return 0;

	xor	al, al
	jmp	SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1127 :    return b->data[b->cursor];

	mov	rax, QWORD PTR b$[rsp]
	movsxd	rax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [rcx+rax]
$LN1@stbtt__buf:

; 1128 : }

	ret	0
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_peek8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv75 = 0
b$ = 32
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_get8

; 1117 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1118 :    if (b->cursor >= b->size)

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jl	SHORT $LN2@stbtt__buf

; 1119 :       return 0;

	xor	al, al
	jmp	SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1120 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR b$[rsp]
	movsxd	rax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tv75[rsp], al
	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR b$[rsp]
	mov	DWORD PTR [rcx+8], eax
	movzx	eax, BYTE PTR tv75[rsp]
$LN1@stbtt__buf:

; 1121 : }

	add	rsp, 24
	ret	0
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_get8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv65 = 96
winding_count$ = 100
scale$ = 104
winding_lengths$ = 112
windings$ = 120
result$ = 144
flatness_in_pixels$ = 152
vertices$ = 160
num_verts$ = 168
scale_x$ = 176
scale_y$ = 184
shift_x$ = 192
shift_y$ = 200
x_off$ = 208
y_off$ = 216
invert$ = 224
userdata$ = 232
stbtt_Rasterize PROC

; 3536 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 3537 :    float scale            = scale_x > scale_y ? scale_y : scale_x;

	movss	xmm0, DWORD PTR scale_x$[rsp]
	comiss	xmm0, DWORD PTR scale_y$[rsp]
	jbe	SHORT $LN4@stbtt_Rast
	movss	xmm0, DWORD PTR scale_y$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN5@stbtt_Rast
$LN4@stbtt_Rast:
	movss	xmm0, DWORD PTR scale_x$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN5@stbtt_Rast:
	movss	xmm0, DWORD PTR tv65[rsp]
	movss	DWORD PTR scale$[rsp], xmm0

; 3538 :    int winding_count      = 0;

	mov	DWORD PTR winding_count$[rsp], 0

; 3539 :    int *winding_lengths   = NULL;

	mov	QWORD PTR winding_lengths$[rsp], 0

; 3540 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

	movss	xmm0, DWORD PTR flatness_in_pixels$[rsp]
	divss	xmm0, DWORD PTR scale$[rsp]
	mov	rax, QWORD PTR userdata$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR winding_count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR winding_lengths$[rsp]
	movaps	xmm2, xmm0
	mov	edx, DWORD PTR num_verts$[rsp]
	mov	rcx, QWORD PTR vertices$[rsp]
	call	?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
	mov	QWORD PTR windings$[rsp], rax

; 3541 :    if (windings) {

	cmp	QWORD PTR windings$[rsp], 0
	je	$LN2@stbtt_Rast

; 3542 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

	mov	rax, QWORD PTR userdata$[rsp]
	mov	QWORD PTR [rsp+88], rax
	mov	eax, DWORD PTR invert$[rsp]
	mov	DWORD PTR [rsp+80], eax
	mov	eax, DWORD PTR y_off$[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	eax, DWORD PTR x_off$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR shift_y$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR shift_x$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR scale_y$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR scale_x$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR winding_count$[rsp]
	mov	r8, QWORD PTR winding_lengths$[rsp]
	mov	rdx, QWORD PTR windings$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	call	?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize

; 3543 :       STBTT_free(winding_lengths, userdata);

	mov	rcx, QWORD PTR winding_lengths$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 3544 :       STBTT_free(windings, userdata);

	mov	rcx, QWORD PTR windings$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@stbtt_Rast:

; 3545 :    }
; 3546 : }

	add	rsp, 136				; 00000088H
	ret	0
stbtt_Rasterize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
x0$ = 48
y0$ = 52
y1$ = 56
x1$ = 60
font$ = 80
glyph$ = 88
scale_x$ = 96
scale_y$ = 104
shift_x$ = 112
shift_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetGlyphBitmapBoxSubpixel PROC

; 2630 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2631 :    int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning

	mov	DWORD PTR x0$[rsp], 0
	mov	DWORD PTR y0$[rsp], 0

; 2632 :    if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {

	lea	rax, QWORD PTR y1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR x1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR y0$[rsp]
	lea	r8, QWORD PTR x0$[rsp]
	mov	edx, DWORD PTR glyph$[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	call	stbtt_GetGlyphBox
	test	eax, eax
	jne	SHORT $LN2@stbtt_GetG

; 2633 :       // e.g. space character
; 2634 :       if (ix0) *ix0 = 0;

	cmp	QWORD PTR ix0$[rsp], 0
	je	SHORT $LN4@stbtt_GetG
	mov	rax, QWORD PTR ix0$[rsp]
	mov	DWORD PTR [rax], 0
$LN4@stbtt_GetG:

; 2635 :       if (iy0) *iy0 = 0;

	cmp	QWORD PTR iy0$[rsp], 0
	je	SHORT $LN5@stbtt_GetG
	mov	rax, QWORD PTR iy0$[rsp]
	mov	DWORD PTR [rax], 0
$LN5@stbtt_GetG:

; 2636 :       if (ix1) *ix1 = 0;

	cmp	QWORD PTR ix1$[rsp], 0
	je	SHORT $LN6@stbtt_GetG
	mov	rax, QWORD PTR ix1$[rsp]
	mov	DWORD PTR [rax], 0
$LN6@stbtt_GetG:

; 2637 :       if (iy1) *iy1 = 0;

	cmp	QWORD PTR iy1$[rsp], 0
	je	SHORT $LN7@stbtt_GetG
	mov	rax, QWORD PTR iy1$[rsp]
	mov	DWORD PTR [rax], 0
$LN7@stbtt_GetG:

; 2638 :    } else {

	jmp	$LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2639 :       // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
; 2640 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

	cmp	QWORD PTR ix0$[rsp], 0
	je	SHORT $LN8@stbtt_GetG
	cvtsi2ss xmm0, DWORD PTR x0$[rsp]
	mulss	xmm0, DWORD PTR scale_x$[rsp]
	addss	xmm0, DWORD PTR shift_x$[rsp]
	call	?ImFloorStd@@YAMM@Z			; ImFloorStd
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR ix0$[rsp]
	mov	DWORD PTR [rcx], eax
$LN8@stbtt_GetG:

; 2641 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

	cmp	QWORD PTR iy0$[rsp], 0
	je	SHORT $LN9@stbtt_GetG
	mov	eax, DWORD PTR y1$[rsp]
	neg	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR scale_y$[rsp]
	addss	xmm0, DWORD PTR shift_y$[rsp]
	call	?ImFloorStd@@YAMM@Z			; ImFloorStd
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR iy0$[rsp]
	mov	DWORD PTR [rcx], eax
$LN9@stbtt_GetG:

; 2642 :       if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);

	cmp	QWORD PTR ix1$[rsp], 0
	je	SHORT $LN10@stbtt_GetG
	cvtsi2ss xmm0, DWORD PTR x1$[rsp]
	mulss	xmm0, DWORD PTR scale_x$[rsp]
	addss	xmm0, DWORD PTR shift_x$[rsp]
	call	?ImCeil@@YAMM@Z				; ImCeil
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR ix1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN10@stbtt_GetG:

; 2643 :       if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);

	cmp	QWORD PTR iy1$[rsp], 0
	je	SHORT $LN11@stbtt_GetG
	mov	eax, DWORD PTR y0$[rsp]
	neg	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR scale_y$[rsp]
	addss	xmm0, DWORD PTR shift_y$[rsp]
	call	?ImCeil@@YAMM@Z				; ImCeil
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR iy1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN11@stbtt_GetG:
$LN3@stbtt_GetG:

; 2644 :    }
; 2645 : }

	add	rsp, 72					; 00000048H
	ret	0
stbtt_GetGlyphBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
font$ = 96
glyph$ = 104
scale_x$ = 112
scale_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetGlyphBitmapBox PROC

; 2648 : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2649 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	mov	rax, QWORD PTR iy1$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR ix1$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR iy0$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR ix0$[rsp]
	mov	QWORD PTR [rsp+48], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+40], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR scale_y$[rsp]
	movss	xmm2, DWORD PTR scale_x$[rsp]
	mov	edx, DWORD PTR glyph$[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	call	stbtt_GetGlyphBitmapBoxSubpixel
	npad	1

; 2650 : }

	add	rsp, 88					; 00000058H
	ret	0
stbtt_GetGlyphBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
iy0$ = 96
ix0$ = 100
num_verts$ = 104
vertices$ = 112
gbm$ = 120
info$ = 160
output$ = 168
out_w$ = 176
out_h$ = 184
out_stride$ = 192
scale_x$ = 200
scale_y$ = 208
shift_x$ = 216
shift_y$ = 224
glyph$ = 232
stbtt_MakeGlyphBitmapSubpixel PROC

; 3599 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 3600 :    int ix0,iy0;
; 3601 :    stbtt_vertex *vertices;
; 3602 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	lea	r8, QWORD PTR vertices$[rsp]
	mov	edx, DWORD PTR glyph$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_GetGlyphShape
	mov	DWORD PTR num_verts$[rsp], eax

; 3603 :    stbtt__bitmap gbm;   
; 3604 : 
; 3605 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);

	mov	QWORD PTR [rsp+72], 0
	mov	QWORD PTR [rsp+64], 0
	lea	rax, QWORD PTR iy0$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR ix0$[rsp]
	mov	QWORD PTR [rsp+48], rax
	movss	xmm0, DWORD PTR shift_y$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR shift_x$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR scale_y$[rsp]
	movss	xmm2, DWORD PTR scale_x$[rsp]
	mov	edx, DWORD PTR glyph$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 3606 :    gbm.pixels = output;

	mov	rax, QWORD PTR output$[rsp]
	mov	QWORD PTR gbm$[rsp+16], rax

; 3607 :    gbm.w = out_w;

	mov	eax, DWORD PTR out_w$[rsp]
	mov	DWORD PTR gbm$[rsp], eax

; 3608 :    gbm.h = out_h;

	mov	eax, DWORD PTR out_h$[rsp]
	mov	DWORD PTR gbm$[rsp+4], eax

; 3609 :    gbm.stride = out_stride;

	mov	eax, DWORD PTR out_stride$[rsp]
	mov	DWORD PTR gbm$[rsp+8], eax

; 3610 : 
; 3611 :    if (gbm.w && gbm.h)

	cmp	DWORD PTR gbm$[rsp], 0
	je	$LN2@stbtt_Make
	cmp	DWORD PTR gbm$[rsp+4], 0
	je	$LN2@stbtt_Make

; 3612 :       stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+88], rax
	mov	DWORD PTR [rsp+80], 1
	mov	eax, DWORD PTR iy0$[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	eax, DWORD PTR ix0$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR shift_y$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR shift_x$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR scale_y$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR scale_x$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR num_verts$[rsp]
	mov	r8, QWORD PTR vertices$[rsp]
	movss	xmm1, DWORD PTR __real@3eb33333
	lea	rcx, QWORD PTR gbm$[rsp]
	call	stbtt_Rasterize
	npad	1
$LN2@stbtt_Make:

; 3613 : 
; 3614 :    STBTT_free(vertices, info->userdata);

	mov	rcx, QWORD PTR vertices$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1

; 3615 : }

	add	rsp, 152				; 00000098H
	ret	0
stbtt_MakeGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 48
glyph_index$ = 56
pvertices$ = 64
stbtt_GetGlyphShape PROC

; 2266 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2267 :    if (!info->cff.size)

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+76], 0
	jne	SHORT $LN2@stbtt_GetG

; 2268 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

	mov	r8, QWORD PTR pvertices$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
	jmp	SHORT $LN1@stbtt_GetG
	jmp	SHORT $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2269 :    else
; 2270 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

	mov	r8, QWORD PTR pvertices$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeT2
$LN3@stbtt_GetG:
$LN1@stbtt_GetG:

; 2271 : }

	add	rsp, 40					; 00000028H
	ret	0
stbtt_GetGlyphShape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
g$1 = 48
info$ = 80
glyph_index$ = 88
x0$ = 96
y0$ = 104
x1$ = 112
y1$ = 120
stbtt_GetGlyphBox PROC

; 1591 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1592 :    if (info->cff.size) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+76], 0
	je	SHORT $LN2@stbtt_GetG

; 1593 :       stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);

	mov	rax, QWORD PTR y1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR x1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR y0$[rsp]
	mov	r8, QWORD PTR x0$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ; stbtt__GetGlyphInfoT2
	npad	1

; 1594 :    } else {

	jmp	$LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 1595 :       int g = stbtt__GetGlyfOffset(info, glyph_index);

	mov	edx, DWORD PTR glyph_index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
	mov	DWORD PTR g$1[rsp], eax

; 1596 :       if (g < 0) return 0;

	cmp	DWORD PTR g$1[rsp], 0
	jge	SHORT $LN4@stbtt_GetG
	xor	eax, eax
	jmp	$LN1@stbtt_GetG
$LN4@stbtt_GetG:

; 1597 : 
; 1598 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	cmp	QWORD PTR x0$[rsp], 0
	je	SHORT $LN5@stbtt_GetG
	movsxd	rax, DWORD PTR g$1[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+2]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR x0$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@stbtt_GetG:

; 1599 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

	cmp	QWORD PTR y0$[rsp], 0
	je	SHORT $LN6@stbtt_GetG
	movsxd	rax, DWORD PTR g$1[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR y0$[rsp]
	mov	DWORD PTR [rcx], eax
$LN6@stbtt_GetG:

; 1600 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

	cmp	QWORD PTR x1$[rsp], 0
	je	SHORT $LN7@stbtt_GetG
	movsxd	rax, DWORD PTR g$1[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+6]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR x1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN7@stbtt_GetG:

; 1601 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

	cmp	QWORD PTR y1$[rsp], 0
	je	SHORT $LN8@stbtt_GetG
	movsxd	rax, DWORD PTR g$1[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR y1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN8@stbtt_GetG:
$LN3@stbtt_GetG:

; 1602 :    }
; 1603 :    return 1;

	mov	eax, 1
$LN1@stbtt_GetG:

; 1604 : }

	add	rsp, 72					; 00000048H
	ret	0
stbtt_GetGlyphBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
numOfLongHorMetrics$ = 32
info$ = 64
glyph_index$ = 72
advanceWidth$ = 80
leftSideBearing$ = 88
stbtt_GetGlyphHMetrics PROC

; 2274 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2275 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+34]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	mov	WORD PTR numOfLongHorMetrics$[rsp], ax

; 2276 :    if (glyph_index < numOfLongHorMetrics) {

	movzx	eax, WORD PTR numOfLongHorMetrics$[rsp]
	cmp	DWORD PTR glyph_index$[rsp], eax
	jge	$LN2@stbtt_GetG

; 2277 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

	cmp	QWORD PTR advanceWidth$[rsp], 0
	je	SHORT $LN4@stbtt_GetG
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR glyph_index$[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR advanceWidth$[rsp]
	mov	DWORD PTR [rcx], eax
$LN4@stbtt_GetG:

; 2278 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);

	cmp	QWORD PTR leftSideBearing$[rsp], 0
	je	SHORT $LN5@stbtt_GetG
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR glyph_index$[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR leftSideBearing$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@stbtt_GetG:

; 2279 :    } else {

	jmp	$LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2280 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

	cmp	QWORD PTR advanceWidth$[rsp], 0
	je	SHORT $LN6@stbtt_GetG
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR numOfLongHorMetrics$[rsp]
	lea	ecx, DWORD PTR [rcx*4-4]
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR advanceWidth$[rsp]
	mov	DWORD PTR [rcx], eax
$LN6@stbtt_GetG:

; 2281 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));

	cmp	QWORD PTR leftSideBearing$[rsp], 0
	je	SHORT $LN7@stbtt_GetG
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR numOfLongHorMetrics$[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	add	rax, rcx
	movzx	ecx, WORD PTR numOfLongHorMetrics$[rsp]
	mov	edx, DWORD PTR glyph_index$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	shl	ecx, 1
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR leftSideBearing$[rsp]
	mov	DWORD PTR [rcx], eax
$LN7@stbtt_GetG:
$LN3@stbtt_GetG:

; 2282 :    }
; 2283 : }

	add	rsp, 56					; 00000038H
	ret	0
stbtt_GetGlyphHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 48
ascent$ = 56
descent$ = 64
lineGap$ = 72
stbtt_GetFontVMetrics PROC

; 2582 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2583 :    if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);

	cmp	QWORD PTR ascent$[rsp], 0
	je	SHORT $LN2@stbtt_GetF
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR ascent$[rsp]
	mov	DWORD PTR [rcx], eax
$LN2@stbtt_GetF:

; 2584 :    if (descent) *descent = ttSHORT(info->data+info->hhea + 6);

	cmp	QWORD PTR descent$[rsp], 0
	je	SHORT $LN3@stbtt_GetF
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+6]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR descent$[rsp]
	mov	DWORD PTR [rcx], eax
$LN3@stbtt_GetF:

; 2585 :    if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);

	cmp	QWORD PTR lineGap$[rsp], 0
	je	SHORT $LN4@stbtt_GetF
	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	rcx, QWORD PTR lineGap$[rsp]
	mov	DWORD PTR [rcx], eax
$LN4@stbtt_GetF:

; 2586 : }

	add	rsp, 40					; 00000028H
	ret	0
stbtt_GetFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
unitsPerEm$ = 32
info$ = 64
pixels$ = 72
stbtt_ScaleForMappingEmToPixels PROC

; 2614 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2615 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+18]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR unitsPerEm$[rsp], eax

; 2616 :    return pixels / unitsPerEm;

	cvtsi2ss xmm0, DWORD PTR unitsPerEm$[rsp]
	movss	xmm1, DWORD PTR pixels$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 2617 : }

	add	rsp, 56					; 00000038H
	ret	0
stbtt_ScaleForMappingEmToPixels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv71 = 32
fheight$ = 36
info$ = 64
height$ = 72
stbtt_ScaleForPixelHeight PROC

; 2608 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2609 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	mov	rax, QWORD PTR info$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	DWORD PTR tv71[rsp], eax
	mov	rcx, QWORD PTR info$[rsp]
	movsxd	rcx, DWORD PTR [rcx+36]
	mov	rdx, QWORD PTR info$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rdx+rcx+6]
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	ecx, DWORD PTR tv71[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fheight$[rsp], eax

; 2610 :    return (float) height / fheight;

	cvtsi2ss xmm0, DWORD PTR fheight$[rsp]
	movss	xmm1, DWORD PTR height$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 2611 : }

	add	rsp, 56					; 00000038H
	ret	0
stbtt_ScaleForPixelHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
index_map$ = 32
format$ = 36
search$1 = 40
data$ = 48
searchRange$2 = 56
segcount$3 = 60
item$4 = 64
entrySelector$5 = 68
rangeShift$6 = 72
offset$7 = 76
start$8 = 80
mid$9 = 84
low$10 = 88
end$11 = 92
first$12 = 96
high$13 = 100
endCount$14 = 104
start_char$15 = 108
start_glyph$16 = 112
bytes$17 = 116
count$18 = 120
ngroups$19 = 124
end_char$20 = 128
info$ = 160
unicode_codepoint$ = 168
stbtt_FindGlyphIndex PROC

; 1462 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 1463 :    stbtt_uint8 *data = info->data;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR data$[rsp], rax

; 1464 :    stbtt_uint32 index_map = info->index_map;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+52]
	mov	DWORD PTR index_map$[rsp], eax

; 1465 : 
; 1466 :    stbtt_uint16 format = ttUSHORT(data + index_map + 0);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	mov	WORD PTR format$[rsp], ax

; 1467 :    if (format == 0) { // apple byte encoding

	movzx	eax, WORD PTR format$[rsp]
	test	eax, eax
	jne	SHORT $LN6@stbtt_Find

; 1468 :       stbtt_int32 bytes = ttUSHORT(data + index_map + 2);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR bytes$17[rsp], eax

; 1469 :       if (unicode_codepoint < bytes-6)

	mov	eax, DWORD PTR bytes$17[rsp]
	sub	eax, 6
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jge	SHORT $LN8@stbtt_Find

; 1470 :          return ttBYTE(data + index_map + 6 + unicode_codepoint);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR unicode_codepoint$[rsp]
	movzx	eax, BYTE PTR [rax+rcx+6]
	jmp	$LN1@stbtt_Find
$LN8@stbtt_Find:

; 1471 :       return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Find
	jmp	$LN7@stbtt_Find
$LN6@stbtt_Find:

; 1472 :    } else if (format == 6) {

	movzx	eax, WORD PTR format$[rsp]
	cmp	eax, 6
	jne	$LN9@stbtt_Find

; 1473 :       stbtt_uint32 first = ttUSHORT(data + index_map + 6);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+6]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR first$12[rsp], eax

; 1474 :       stbtt_uint32 count = ttUSHORT(data + index_map + 8);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR count$18[rsp], eax

; 1475 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

	mov	eax, DWORD PTR first$12[rsp]
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jb	SHORT $LN11@stbtt_Find
	mov	eax, DWORD PTR count$18[rsp]
	mov	ecx, DWORD PTR first$12[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jae	SHORT $LN11@stbtt_Find

; 1476 :          return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR first$12[rsp]
	mov	edx, DWORD PTR unicode_codepoint$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	shl	ecx, 1
	mov	ecx, ecx
	lea	rax, QWORD PTR [rax+rcx+10]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	jmp	$LN1@stbtt_Find
$LN11@stbtt_Find:

; 1477 :       return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Find
	jmp	$LN10@stbtt_Find
$LN9@stbtt_Find:

; 1478 :    } else if (format == 2) {

	movzx	eax, WORD PTR format$[rsp]
	cmp	eax, 2
	jne	SHORT $LN12@stbtt_Find

; 1479 :       STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
; 1480 :       return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Find
	jmp	$LN13@stbtt_Find
$LN12@stbtt_Find:

; 1481 :    } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges

	movzx	eax, WORD PTR format$[rsp]
	cmp	eax, 4
	jne	$LN14@stbtt_Find

; 1482 :       stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+6]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	sar	eax, 1
	mov	WORD PTR segcount$3[rsp], ax

; 1483 :       stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	sar	eax, 1
	mov	WORD PTR searchRange$2[rsp], ax

; 1484 :       stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+10]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	mov	WORD PTR entrySelector$5[rsp], ax

; 1485 :       stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	sar	eax, 1
	mov	WORD PTR rangeShift$6[rsp], ax

; 1486 : 
; 1487 :       // do a binary search of the segments
; 1488 :       stbtt_uint32 endCount = index_map + 14;

	mov	eax, DWORD PTR index_map$[rsp]
	add	eax, 14
	mov	DWORD PTR endCount$14[rsp], eax

; 1489 :       stbtt_uint32 search = endCount;

	mov	eax, DWORD PTR endCount$14[rsp]
	mov	DWORD PTR search$1[rsp], eax

; 1490 : 
; 1491 :       if (unicode_codepoint > 0xffff)

	cmp	DWORD PTR unicode_codepoint$[rsp], 65535 ; 0000ffffH
	jle	SHORT $LN16@stbtt_Find

; 1492 :          return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Find
$LN16@stbtt_Find:

; 1493 : 
; 1494 :       // they lie from endCount .. endCount + segCount
; 1495 :       // but searchRange is the nearest power of two, so...
; 1496 :       if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))

	mov	eax, DWORD PTR search$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR rangeShift$6[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jl	SHORT $LN17@stbtt_Find

; 1497 :          search += rangeShift*2;

	movzx	eax, WORD PTR rangeShift$6[rsp]
	mov	ecx, DWORD PTR search$1[rsp]
	lea	eax, DWORD PTR [rcx+rax*2]
	mov	DWORD PTR search$1[rsp], eax
$LN17@stbtt_Find:

; 1498 : 
; 1499 :       // now decrement to bias correctly to find smallest
; 1500 :       search -= 2;

	mov	eax, DWORD PTR search$1[rsp]
	sub	eax, 2
	mov	DWORD PTR search$1[rsp], eax
$LN2@stbtt_Find:

; 1501 :       while (entrySelector) {

	movzx	eax, WORD PTR entrySelector$5[rsp]
	test	eax, eax
	je	SHORT $LN3@stbtt_Find

; 1502 :          stbtt_uint16 end;
; 1503 :          searchRange >>= 1;

	movzx	eax, WORD PTR searchRange$2[rsp]
	shr	ax, 1
	mov	WORD PTR searchRange$2[rsp], ax

; 1504 :          end = ttUSHORT(data + search + searchRange*2);

	mov	eax, DWORD PTR search$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR searchRange$2[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	add	rax, rcx
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	mov	WORD PTR end$11[rsp], ax

; 1505 :          if (unicode_codepoint > end)

	movzx	eax, WORD PTR end$11[rsp]
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jle	SHORT $LN18@stbtt_Find

; 1506 :             search += searchRange*2;

	movzx	eax, WORD PTR searchRange$2[rsp]
	mov	ecx, DWORD PTR search$1[rsp]
	lea	eax, DWORD PTR [rcx+rax*2]
	mov	DWORD PTR search$1[rsp], eax
$LN18@stbtt_Find:

; 1507 :          --entrySelector;

	movzx	eax, WORD PTR entrySelector$5[rsp]
	dec	ax
	mov	WORD PTR entrySelector$5[rsp], ax

; 1508 :       }

	jmp	SHORT $LN2@stbtt_Find
$LN3@stbtt_Find:

; 1509 :       search += 2;

	mov	eax, DWORD PTR search$1[rsp]
	add	eax, 2
	mov	DWORD PTR search$1[rsp], eax

; 1510 : 
; 1511 :       {
; 1512 :          stbtt_uint16 offset, start;
; 1513 :          stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

	mov	eax, DWORD PTR endCount$14[rsp]
	mov	ecx, DWORD PTR search$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	shr	eax, 1
	mov	WORD PTR item$4[rsp], ax

; 1514 : 
; 1515 :          STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
; 1516 :          start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR segcount$3[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+14]
	movzx	ecx, WORD PTR item$4[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	mov	WORD PTR start$8[rsp], ax

; 1517 :          if (unicode_codepoint < start)

	movzx	eax, WORD PTR start$8[rsp]
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jge	SHORT $LN19@stbtt_Find

; 1518 :             return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Find
$LN19@stbtt_Find:

; 1519 : 
; 1520 :          offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR segcount$3[rsp]
	imul	ecx, ecx, 6
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+14]
	movzx	ecx, WORD PTR item$4[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	mov	WORD PTR offset$7[rsp], ax

; 1521 :          if (offset == 0)

	movzx	eax, WORD PTR offset$7[rsp]
	test	eax, eax
	jne	SHORT $LN20@stbtt_Find

; 1522 :             return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR segcount$3[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+14]
	movzx	ecx, WORD PTR item$4[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	rcx, rax
	call	?ttSHORT@@YAFPEAE@Z			; ttSHORT
	cwde
	mov	ecx, DWORD PTR unicode_codepoint$[rsp]
	add	ecx, eax
	mov	eax, ecx
	movzx	eax, ax
	jmp	$LN1@stbtt_Find
$LN20@stbtt_Find:

; 1523 : 
; 1524 :          return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);

	movzx	eax, WORD PTR offset$7[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, WORD PTR start$8[rsp]
	mov	edx, DWORD PTR unicode_codepoint$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	shl	ecx, 1
	movsxd	rcx, ecx
	add	rax, rcx
	mov	ecx, DWORD PTR index_map$[rsp]
	add	rax, rcx
	movzx	ecx, WORD PTR segcount$3[rsp]
	imul	ecx, ecx, 6
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+14]
	movzx	ecx, WORD PTR item$4[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+2]
	mov	rcx, rax
	call	?ttUSHORT@@YAGPEAE@Z			; ttUSHORT
	movzx	eax, ax
	jmp	$LN1@stbtt_Find
	jmp	$LN15@stbtt_Find
$LN14@stbtt_Find:

; 1525 :       }
; 1526 :    } else if (format == 12 || format == 13) {

	movzx	eax, WORD PTR format$[rsp]
	cmp	eax, 12
	je	SHORT $LN22@stbtt_Find
	movzx	eax, WORD PTR format$[rsp]
	cmp	eax, 13
	jne	$LN21@stbtt_Find
$LN22@stbtt_Find:

; 1527 :       stbtt_uint32 ngroups = ttULONG(data+index_map+12);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	DWORD PTR ngroups$19[rsp], eax

; 1528 :       stbtt_int32 low,high;
; 1529 :       low = 0; high = (stbtt_int32)ngroups;

	mov	DWORD PTR low$10[rsp], 0
	mov	eax, DWORD PTR ngroups$19[rsp]
	mov	DWORD PTR high$13[rsp], eax
$LN4@stbtt_Find:

; 1530 :       // Binary search the right group.
; 1531 :       while (low < high) {

	mov	eax, DWORD PTR high$13[rsp]
	cmp	DWORD PTR low$10[rsp], eax
	jge	$LN5@stbtt_Find

; 1532 :          stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high

	mov	eax, DWORD PTR low$10[rsp]
	mov	ecx, DWORD PTR high$13[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 1
	mov	ecx, DWORD PTR low$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR mid$9[rsp], eax

; 1533 :          stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	imul	ecx, DWORD PTR mid$9[rsp], 12
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+16]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	DWORD PTR start_char$15[rsp], eax

; 1534 :          stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	imul	ecx, DWORD PTR mid$9[rsp], 12
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+20]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	DWORD PTR end_char$20[rsp], eax

; 1535 :          if ((stbtt_uint32) unicode_codepoint < start_char)

	mov	eax, DWORD PTR start_char$15[rsp]
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jae	SHORT $LN23@stbtt_Find

; 1536 :             high = mid;

	mov	eax, DWORD PTR mid$9[rsp]
	mov	DWORD PTR high$13[rsp], eax
	jmp	SHORT $LN24@stbtt_Find
$LN23@stbtt_Find:

; 1537 :          else if ((stbtt_uint32) unicode_codepoint > end_char)

	mov	eax, DWORD PTR end_char$20[rsp]
	cmp	DWORD PTR unicode_codepoint$[rsp], eax
	jbe	SHORT $LN25@stbtt_Find

; 1538 :             low = mid+1;

	mov	eax, DWORD PTR mid$9[rsp]
	inc	eax
	mov	DWORD PTR low$10[rsp], eax
	jmp	SHORT $LN26@stbtt_Find
$LN25@stbtt_Find:

; 1539 :          else {
; 1540 :             stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);

	mov	eax, DWORD PTR index_map$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	imul	ecx, DWORD PTR mid$9[rsp], 12
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx+24]
	mov	rcx, rax
	call	?ttULONG@@YAIPEAE@Z			; ttULONG
	mov	DWORD PTR start_glyph$16[rsp], eax

; 1541 :             if (format == 12)

	movzx	eax, WORD PTR format$[rsp]
	cmp	eax, 12
	jne	SHORT $LN27@stbtt_Find

; 1542 :                return start_glyph + unicode_codepoint-start_char;

	mov	eax, DWORD PTR unicode_codepoint$[rsp]
	mov	ecx, DWORD PTR start_glyph$16[rsp]
	add	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR start_char$15[rsp]
	jmp	SHORT $LN1@stbtt_Find
	jmp	SHORT $LN28@stbtt_Find
$LN27@stbtt_Find:

; 1543 :             else // format == 13
; 1544 :                return start_glyph;

	mov	eax, DWORD PTR start_glyph$16[rsp]
	jmp	SHORT $LN1@stbtt_Find
$LN28@stbtt_Find:
$LN26@stbtt_Find:
$LN24@stbtt_Find:

; 1545 :          }
; 1546 :       }

	jmp	$LN4@stbtt_Find
$LN5@stbtt_Find:

; 1547 :       return 0; // not found

	xor	eax, eax
	jmp	SHORT $LN1@stbtt_Find
$LN21@stbtt_Find:
$LN15@stbtt_Find:
$LN13@stbtt_Find:
$LN10@stbtt_Find:
$LN7@stbtt_Find:

; 1548 :    }
; 1549 :    // @TODO
; 1550 :    STBTT_assert(0);
; 1551 :    return 0;

	xor	eax, eax
$LN1@stbtt_Find:

; 1552 : }

	add	rsp, 152				; 00000098H
	ret	0
stbtt_FindGlyphIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 48
data$ = 56
offset$ = 64
stbtt_InitFont PROC

; 4785 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4786 :    return stbtt_InitFont_internal(info, (unsigned char *) data, offset);

	mov	r8d, DWORD PTR offset$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ; stbtt_InitFont_internal

; 4787 : }

	add	rsp, 40					; 00000028H
	ret	0
stbtt_InitFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
data$ = 48
index$ = 56
stbtt_GetFontOffsetForIndex PROC

; 4775 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4776 :    return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   

	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ; stbtt_GetFontOffsetForIndex_internal

; 4777 : }

	add	rsp, 40					; 00000028H
	ret	0
stbtt_GetFontOffsetForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
r$1 = 80
i$ = 88
pad$2 = 92
j$ = 96
scale$3 = 100
bc$4 = 104
fh$5 = 112
glyph$6 = 116
k$ = 120
tv80 = 124
tv178 = 128
x0$7 = 132
recip_h$8 = 136
sub_x$9 = 140
y0$10 = 144
recip_v$11 = 148
sub_y$12 = 152
return_value$ = 156
codepoint$13 = 160
advance$14 = 164
old_h_over$ = 168
old_v_over$ = 172
lsb$15 = 176
y1$16 = 180
x1$17 = 184
tv283 = 192
tv306 = 200
spc$ = 224
info$ = 232
ranges$ = 240
num_ranges$ = 248
rects$ = 256
stbtt_PackFontRangesRenderIntoRects PROC

; 4046 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 4047 :    int i,j,k, return_value = 1;

	mov	DWORD PTR return_value$[rsp], 1

; 4048 : 
; 4049 :    // save current values
; 4050 :    int old_h_over = spc->h_oversample;

	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR old_h_over$[rsp], eax

; 4051 :    int old_v_over = spc->v_oversample;

	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR old_v_over$[rsp], eax

; 4052 : 
; 4053 :    k = 0;

	mov	DWORD PTR k$[rsp], 0

; 4054 :    for (i=0; i < num_ranges; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbtt_Pack
$LN2@stbtt_Pack:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbtt_Pack:
	mov	eax, DWORD PTR num_ranges$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbtt_Pack

; 4055 :       float fh = ranges[i].font_size;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR ranges$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR fh$5[rsp], xmm0

; 4056 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	movss	xmm0, DWORD PTR fh$5[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN13@stbtt_Pack
	movss	xmm1, DWORD PTR fh$5[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_ScaleForPixelHeight
	movss	DWORD PTR tv80[rsp], xmm0
	jmp	SHORT $LN14@stbtt_Pack
$LN13@stbtt_Pack:
	movss	xmm0, DWORD PTR fh$5[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_ScaleForMappingEmToPixels
	movss	DWORD PTR tv80[rsp], xmm0
$LN14@stbtt_Pack:
	movss	xmm0, DWORD PTR tv80[rsp]
	movss	DWORD PTR scale$3[rsp], xmm0

; 4057 :       float recip_h,recip_v,sub_x,sub_y;
; 4058 :       spc->h_oversample = ranges[i].h_oversample;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR ranges$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+32]
	mov	rcx, QWORD PTR spc$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 4059 :       spc->v_oversample = ranges[i].v_oversample;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR ranges$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+33]
	mov	rcx, QWORD PTR spc$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 4060 :       recip_h = 1.0f / spc->h_oversample;

	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR recip_h$8[rsp], xmm0

; 4061 :       recip_v = 1.0f / spc->v_oversample;

	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+40]
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR recip_v$11[rsp], xmm0

; 4062 :       sub_x = stbtt__oversample_shift(spc->h_oversample);

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	?stbtt__oversample_shift@@YAMH@Z	; stbtt__oversample_shift
	movss	DWORD PTR sub_x$9[rsp], xmm0

; 4063 :       sub_y = stbtt__oversample_shift(spc->v_oversample);

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR [rax+40]
	call	?stbtt__oversample_shift@@YAMH@Z	; stbtt__oversample_shift
	movss	DWORD PTR sub_y$12[rsp], xmm0

; 4064 :       for (j=0; j < ranges[i].num_chars; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN7@stbtt_Pack
$LN5@stbtt_Pack:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@stbtt_Pack:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR ranges$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN6@stbtt_Pack

; 4065 :          stbrp_rect *r = &rects[k];

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR r$1[rsp], rax

; 4066 :          if (r->was_packed && r->w != 0 && r->h != 0) {

	mov	rax, QWORD PTR r$1[rsp]
	cmp	DWORD PTR [rax+12], 0
	je	$LN8@stbtt_Pack
	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+4]
	test	eax, eax
	je	$LN8@stbtt_Pack
	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+6]
	test	eax, eax
	je	$LN8@stbtt_Pack

; 4067 :             stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	movsxd	rcx, DWORD PTR j$[rsp]
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR ranges$[rsp]
	add	rcx, QWORD PTR [rdx+rax+24]
	mov	rax, rcx
	mov	QWORD PTR bc$4[rsp], rax

; 4068 :             int advance, lsb, x0,y0,x1,y1;
; 4069 :             int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR ranges$[rsp]
	cmp	QWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN15@stbtt_Pack
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR ranges$[rsp]
	mov	eax, DWORD PTR [rcx+rax+4]
	add	eax, DWORD PTR j$[rsp]
	mov	DWORD PTR tv178[rsp], eax
	jmp	SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR ranges$[rsp]
	mov	rax, QWORD PTR [rdx+rax+8]
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR tv178[rsp], eax
$LN16@stbtt_Pack:
	mov	eax, DWORD PTR tv178[rsp]
	mov	DWORD PTR codepoint$13[rsp], eax

; 4070 :             int glyph = stbtt_FindGlyphIndex(info, codepoint);

	mov	edx, DWORD PTR codepoint$13[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_FindGlyphIndex
	mov	DWORD PTR glyph$6[rsp], eax

; 4071 :             stbrp_coord pad = (stbrp_coord) spc->padding;

	mov	rax, QWORD PTR spc$[rsp]
	movzx	eax, WORD PTR [rax+28]
	mov	WORD PTR pad$2[rsp], ax

; 4072 : 
; 4073 :             // pad on left and top
; 4074 :             r->x += pad;

	movzx	eax, WORD PTR pad$2[rsp]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+8]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR r$1[rsp]
	mov	WORD PTR [rcx+8], ax

; 4075 :             r->y += pad;

	movzx	eax, WORD PTR pad$2[rsp]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+10]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR r$1[rsp]
	mov	WORD PTR [rcx+10], ax

; 4076 :             r->w -= pad;

	movzx	eax, WORD PTR pad$2[rsp]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR r$1[rsp]
	mov	WORD PTR [rcx+4], ax

; 4077 :             r->h -= pad;

	movzx	eax, WORD PTR pad$2[rsp]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR r$1[rsp]
	mov	WORD PTR [rcx+6], ax

; 4078 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);

	lea	r9, QWORD PTR lsb$15[rsp]
	lea	r8, QWORD PTR advance$14[rsp]
	mov	edx, DWORD PTR glyph$6[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_GetGlyphHMetrics

; 4079 :             stbtt_GetGlyphBitmapBox(info, glyph,

	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+40]
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR scale$3[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cvtsi2ss xmm1, rax
	movss	xmm2, DWORD PTR scale$3[rsp]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	lea	rax, QWORD PTR y1$16[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR x1$17[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR y0$10[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR x0$7[rsp]
	mov	QWORD PTR [rsp+32], rax
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	mov	edx, DWORD PTR glyph$6[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_GetGlyphBitmapBox

; 4080 :                                     scale * spc->h_oversample,
; 4081 :                                     scale * spc->v_oversample,
; 4082 :                                     &x0,&y0,&x1,&y1);
; 4083 :             stbtt_MakeGlyphBitmapSubpixel(info,

	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+40]
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR scale$3[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR spc$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cvtsi2ss xmm1, rax
	movss	xmm2, DWORD PTR scale$3[rsp]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR spc$[rsp]
	sub	eax, DWORD PTR [rcx+40]
	inc	eax
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	mov	rdx, QWORD PTR spc$[rsp]
	sub	ecx, DWORD PTR [rdx+36]
	inc	ecx
	mov	rdx, QWORD PTR r$1[rsp]
	movzx	edx, WORD PTR [rdx+8]
	mov	r8, QWORD PTR spc$[rsp]
	mov	r8, QWORD PTR [r8+48]
	add	r8, rdx
	mov	rdx, r8
	mov	r8, QWORD PTR r$1[rsp]
	movzx	r8d, WORD PTR [r8+10]
	mov	r9, QWORD PTR spc$[rsp]
	imul	r8d, DWORD PTR [r9+24]
	movsxd	r8, r8d
	add	rdx, r8
	mov	r8d, DWORD PTR glyph$6[rsp]
	mov	DWORD PTR [rsp+72], r8d
	xorps	xmm2, xmm2
	movss	DWORD PTR [rsp+64], xmm2
	xorps	xmm2, xmm2
	movss	DWORD PTR [rsp+56], xmm2
	movss	DWORD PTR [rsp+48], xmm0
	movss	DWORD PTR [rsp+40], xmm1
	mov	r8, QWORD PTR spc$[rsp]
	mov	r8d, DWORD PTR [r8+24]
	mov	DWORD PTR [rsp+32], r8d
	mov	r9d, eax
	mov	r8d, ecx
	mov	rcx, QWORD PTR info$[rsp]
	call	stbtt_MakeGlyphBitmapSubpixel
	npad	1

; 4084 :                                           spc->pixels + r->x + r->y*spc->stride_in_bytes,
; 4085 :                                           r->w - spc->h_oversample+1,
; 4086 :                                           r->h - spc->v_oversample+1,
; 4087 :                                           spc->stride_in_bytes,
; 4088 :                                           scale * spc->h_oversample,
; 4089 :                                           scale * spc->v_oversample,
; 4090 :                                           0,0,
; 4091 :                                           glyph);
; 4092 : 
; 4093 :             if (spc->h_oversample > 1)

	mov	rax, QWORD PTR spc$[rsp]
	cmp	DWORD PTR [rax+36], 1
	jbe	$LN10@stbtt_Pack

; 4094 :                stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	mov	rdx, QWORD PTR r$1[rsp]
	movzx	edx, WORD PTR [rdx+8]
	mov	r8, QWORD PTR spc$[rsp]
	mov	r8, QWORD PTR [r8+48]
	add	r8, rdx
	mov	rdx, r8
	mov	r8, QWORD PTR r$1[rsp]
	movzx	r8d, WORD PTR [r8+10]
	mov	r9, QWORD PTR spc$[rsp]
	imul	r8d, DWORD PTR [r9+24]
	movsxd	r8, r8d
	add	rdx, r8
	mov	QWORD PTR tv283[rsp], rdx
	mov	r8, QWORD PTR spc$[rsp]
	mov	r8d, DWORD PTR [r8+36]
	mov	DWORD PTR [rsp+32], r8d
	mov	r8, QWORD PTR spc$[rsp]
	mov	r9d, DWORD PTR [r8+24]
	mov	r8d, eax
	mov	edx, ecx
	mov	rax, QWORD PTR tv283[rsp]
	mov	rcx, rax
	call	?stbtt__h_prefilter@@YAXPEAEHHHI@Z	; stbtt__h_prefilter
	npad	1
$LN10@stbtt_Pack:

; 4095 :                                   r->w, r->h, spc->stride_in_bytes,
; 4096 :                                   spc->h_oversample);
; 4097 : 
; 4098 :             if (spc->v_oversample > 1)

	mov	rax, QWORD PTR spc$[rsp]
	cmp	DWORD PTR [rax+40], 1
	jbe	$LN11@stbtt_Pack

; 4099 :                stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	mov	rdx, QWORD PTR r$1[rsp]
	movzx	edx, WORD PTR [rdx+8]
	mov	r8, QWORD PTR spc$[rsp]
	mov	r8, QWORD PTR [r8+48]
	add	r8, rdx
	mov	rdx, r8
	mov	r8, QWORD PTR r$1[rsp]
	movzx	r8d, WORD PTR [r8+10]
	mov	r9, QWORD PTR spc$[rsp]
	imul	r8d, DWORD PTR [r9+24]
	movsxd	r8, r8d
	add	rdx, r8
	mov	QWORD PTR tv306[rsp], rdx
	mov	r8, QWORD PTR spc$[rsp]
	mov	r8d, DWORD PTR [r8+40]
	mov	DWORD PTR [rsp+32], r8d
	mov	r8, QWORD PTR spc$[rsp]
	mov	r9d, DWORD PTR [r8+24]
	mov	r8d, eax
	mov	edx, ecx
	mov	rax, QWORD PTR tv306[rsp]
	mov	rcx, rax
	call	?stbtt__v_prefilter@@YAXPEAEHHHI@Z	; stbtt__v_prefilter
	npad	1
$LN11@stbtt_Pack:

; 4100 :                                   r->w, r->h, spc->stride_in_bytes,
; 4101 :                                   spc->v_oversample);
; 4102 : 
; 4103 :             bc->x0       = (stbtt_int16)  r->x;

	mov	rax, QWORD PTR bc$4[rsp]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+8]
	mov	WORD PTR [rax], cx

; 4104 :             bc->y0       = (stbtt_int16)  r->y;

	mov	rax, QWORD PTR bc$4[rsp]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+10]
	mov	WORD PTR [rax+2], cx

; 4105 :             bc->x1       = (stbtt_int16) (r->x + r->w);

	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+8]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	add	eax, ecx
	mov	rcx, QWORD PTR bc$4[rsp]
	mov	WORD PTR [rcx+4], ax

; 4106 :             bc->y1       = (stbtt_int16) (r->y + r->h);

	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	rcx, QWORD PTR r$1[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	add	eax, ecx
	mov	rcx, QWORD PTR bc$4[rsp]
	mov	WORD PTR [rcx+6], ax

; 4107 :             bc->xadvance =                scale * advance;

	cvtsi2ss xmm0, DWORD PTR advance$14[rsp]
	movss	xmm1, DWORD PTR scale$3[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bc$4[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 4108 :             bc->xoff     =       (float)  x0 * recip_h + sub_x;

	cvtsi2ss xmm0, DWORD PTR x0$7[rsp]
	mulss	xmm0, DWORD PTR recip_h$8[rsp]
	addss	xmm0, DWORD PTR sub_x$9[rsp]
	mov	rax, QWORD PTR bc$4[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 4109 :             bc->yoff     =       (float)  y0 * recip_v + sub_y;

	cvtsi2ss xmm0, DWORD PTR y0$10[rsp]
	mulss	xmm0, DWORD PTR recip_v$11[rsp]
	addss	xmm0, DWORD PTR sub_y$12[rsp]
	mov	rax, QWORD PTR bc$4[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 4110 :             bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;

	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	ecx, DWORD PTR x0$7[rsp]
	add	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR recip_h$8[rsp]
	addss	xmm0, DWORD PTR sub_x$9[rsp]
	mov	rax, QWORD PTR bc$4[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 4111 :             bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;

	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	ecx, DWORD PTR y0$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR recip_v$11[rsp]
	addss	xmm0, DWORD PTR sub_y$12[rsp]
	mov	rax, QWORD PTR bc$4[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 4112 :          } else {

	jmp	SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:

; 4113 :             return_value = 0; // if any fail, report failure

	mov	DWORD PTR return_value$[rsp], 0
$LN9@stbtt_Pack:

; 4114 :          }
; 4115 : 
; 4116 :          ++k;

	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax

; 4117 :       }

	jmp	$LN5@stbtt_Pack
$LN6@stbtt_Pack:

; 4118 :    }

	jmp	$LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 4119 : 
; 4120 :    // restore original values
; 4121 :    spc->h_oversample = old_h_over;

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR old_h_over$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 4122 :    spc->v_oversample = old_v_over;

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR old_v_over$[rsp]
	mov	DWORD PTR [rax+40], ecx

; 4123 : 
; 4124 :    return return_value;

	mov	eax, DWORD PTR return_value$[rsp]

; 4125 : }

	add	rsp, 216				; 000000d8H
	ret	0
stbtt_PackFontRangesRenderIntoRects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
x$1 = 32
y$2 = 36
ipw$ = 40
iph$ = 44
b$ = 48
chardata$ = 80
pw$ = 88
ph$ = 96
char_index$ = 104
xpos$ = 112
ypos$ = 120
q$ = 128
align_to_integer$ = 136
stbtt_GetPackedQuad PROC

; 4194 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4195 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

	cvtsi2ss xmm0, DWORD PTR pw$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR ipw$[rsp], xmm0
	cvtsi2ss xmm0, DWORD PTR ph$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR iph$[rsp], xmm0

; 4196 :    const stbtt_packedchar *b = chardata + char_index;

	movsxd	rax, DWORD PTR char_index$[rsp]
	imul	rax, rax, 28
	mov	rcx, QWORD PTR chardata$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR b$[rsp], rax

; 4197 : 
; 4198 :    if (align_to_integer) {

	cmp	DWORD PTR align_to_integer$[rsp], 0
	je	$LN2@stbtt_GetP

; 4199 :       float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);

	mov	rax, QWORD PTR xpos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+8]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloorStd@@YAMM@Z			; ImFloorStd
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR x$1[rsp], xmm0

; 4200 :       float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);

	mov	rax, QWORD PTR ypos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+12]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloorStd@@YAMM@Z			; ImFloorStd
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR y$2[rsp], xmm0

; 4201 :       q->x0 = x;

	mov	rax, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR x$1[rsp]
	movss	DWORD PTR [rax], xmm0

; 4202 :       q->y0 = y;

	mov	rax, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR y$2[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 4203 :       q->x1 = x + b->xoff2 - b->xoff;

	mov	rax, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR x$1[rsp]
	addss	xmm0, DWORD PTR [rax+20]
	mov	rax, QWORD PTR b$[rsp]
	subss	xmm0, DWORD PTR [rax+8]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 4204 :       q->y1 = y + b->yoff2 - b->yoff;

	mov	rax, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR y$2[rsp]
	addss	xmm0, DWORD PTR [rax+24]
	mov	rax, QWORD PTR b$[rsp]
	subss	xmm0, DWORD PTR [rax+12]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 4205 :    } else {

	jmp	SHORT $LN3@stbtt_GetP
$LN2@stbtt_GetP:

; 4206 :       q->x0 = *xpos + b->xoff;

	mov	rax, QWORD PTR xpos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax], xmm0

; 4207 :       q->y0 = *ypos + b->yoff;

	mov	rax, QWORD PTR ypos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+12]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 4208 :       q->x1 = *xpos + b->xoff2;

	mov	rax, QWORD PTR xpos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+20]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 4209 :       q->y1 = *ypos + b->yoff2;

	mov	rax, QWORD PTR ypos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+24]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+20], xmm0
$LN3@stbtt_GetP:

; 4210 :    }
; 4211 : 
; 4212 :    q->s0 = b->x0 * ipw;

	mov	rax, QWORD PTR b$[rsp]
	movzx	eax, WORD PTR [rax]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR ipw$[rsp]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 4213 :    q->t0 = b->y0 * iph;

	mov	rax, QWORD PTR b$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR iph$[rsp]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 4214 :    q->s1 = b->x1 * ipw;

	mov	rax, QWORD PTR b$[rsp]
	movzx	eax, WORD PTR [rax+4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR ipw$[rsp]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 4215 :    q->t1 = b->y1 * iph;

	mov	rax, QWORD PTR b$[rsp]
	movzx	eax, WORD PTR [rax+6]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR iph$[rsp]
	mov	rax, QWORD PTR q$[rsp]
	movss	DWORD PTR [rax+28], xmm0

; 4216 : 
; 4217 :    *xpos += b->xadvance;

	mov	rax, QWORD PTR xpos$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+16]
	mov	rax, QWORD PTR xpos$[rsp]
	movss	DWORD PTR [rax], xmm0

; 4218 : }

	add	rsp, 72					; 00000048H
	ret	0
stbtt_GetPackedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
spc$ = 48
stbtt_PackEnd PROC

; 3830 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3831 :    STBTT_free(spc->nodes    , spc->user_allocator_context);

	mov	rax, QWORD PTR spc$[rsp]
	mov	rcx, QWORD PTR [rax+56]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 3832 :    STBTT_free(spc->pack_info, spc->user_allocator_context);

	mov	rax, QWORD PTR spc$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1

; 3833 : }

	add	rsp, 40					; 00000028H
	ret	0
stbtt_PackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv86 = 48
num_nodes$ = 52
nodes$ = 56
context$ = 64
spc$ = 96
pixels$ = 104
pw$ = 112
ph$ = 120
stride_in_bytes$ = 128
padding$ = 136
alloc_context$ = 144
stbtt_PackBegin PROC

; 3798 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 3799 :    stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);

	mov	ecx, 72					; 00000048H
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR context$[rsp], rax

; 3800 :    int            num_nodes = pw - padding;

	mov	eax, DWORD PTR padding$[rsp]
	mov	ecx, DWORD PTR pw$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR num_nodes$[rsp], eax

; 3801 :    stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

	movsxd	rax, DWORD PTR num_nodes$[rsp]
	imul	rax, rax, 16
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR nodes$[rsp], rax

; 3802 : 
; 3803 :    if (context == NULL || nodes == NULL) {

	cmp	QWORD PTR context$[rsp], 0
	je	SHORT $LN3@stbtt_Pack
	cmp	QWORD PTR nodes$[rsp], 0
	jne	SHORT $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 3804 :       if (context != NULL) STBTT_free(context, alloc_context);

	cmp	QWORD PTR context$[rsp], 0
	je	SHORT $LN4@stbtt_Pack
	mov	rcx, QWORD PTR context$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN4@stbtt_Pack:

; 3805 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

	cmp	QWORD PTR nodes$[rsp], 0
	je	SHORT $LN5@stbtt_Pack
	mov	rcx, QWORD PTR nodes$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN5@stbtt_Pack:

; 3806 :       return 0;

	xor	eax, eax
	jmp	$LN1@stbtt_Pack
$LN2@stbtt_Pack:

; 3807 :    }
; 3808 : 
; 3809 :    spc->user_allocator_context = alloc_context;

	mov	rax, QWORD PTR spc$[rsp]
	mov	rcx, QWORD PTR alloc_context$[rsp]
	mov	QWORD PTR [rax], rcx

; 3810 :    spc->width = pw;

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR pw$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 3811 :    spc->height = ph;

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR ph$[rsp]
	mov	DWORD PTR [rax+20], ecx

; 3812 :    spc->pixels = pixels;

	mov	rax, QWORD PTR spc$[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 3813 :    spc->pack_info = context;

	mov	rax, QWORD PTR spc$[rsp]
	mov	rcx, QWORD PTR context$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 3814 :    spc->nodes = nodes;

	mov	rax, QWORD PTR spc$[rsp]
	mov	rcx, QWORD PTR nodes$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 3815 :    spc->padding = padding;

	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR padding$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 3816 :    spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;

	cmp	DWORD PTR stride_in_bytes$[rsp], 0
	je	SHORT $LN8@stbtt_Pack
	mov	eax, DWORD PTR stride_in_bytes$[rsp]
	mov	DWORD PTR tv86[rsp], eax
	jmp	SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:
	mov	eax, DWORD PTR pw$[rsp]
	mov	DWORD PTR tv86[rsp], eax
$LN9@stbtt_Pack:
	mov	rax, QWORD PTR spc$[rsp]
	mov	ecx, DWORD PTR tv86[rsp]
	mov	DWORD PTR [rax+24], ecx

; 3817 :    spc->h_oversample = 1;

	mov	rax, QWORD PTR spc$[rsp]
	mov	DWORD PTR [rax+36], 1

; 3818 :    spc->v_oversample = 1;

	mov	rax, QWORD PTR spc$[rsp]
	mov	DWORD PTR [rax+40], 1

; 3819 :    spc->skip_missing = 0;

	mov	rax, QWORD PTR spc$[rsp]
	mov	DWORD PTR [rax+32], 0

; 3820 : 
; 3821 :    stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

	mov	eax, DWORD PTR padding$[rsp]
	mov	ecx, DWORD PTR ph$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR padding$[rsp]
	mov	edx, DWORD PTR pw$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	mov	edx, DWORD PTR num_nodes$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9, QWORD PTR nodes$[rsp]
	mov	r8d, eax
	mov	edx, ecx
	mov	rcx, QWORD PTR context$[rsp]
	call	stbrp_init_target
	npad	1

; 3822 : 
; 3823 :    if (pixels)

	cmp	QWORD PTR pixels$[rsp], 0
	je	SHORT $LN6@stbtt_Pack

; 3824 :       STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

	mov	eax, DWORD PTR pw$[rsp]
	imul	eax, DWORD PTR ph$[rsp]
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR pixels$[rsp]
	call	memset
	npad	1
$LN6@stbtt_Pack:

; 3825 : 
; 3826 :    return 1;

	mov	eax, 1
$LN1@stbtt_Pack:

; 3827 : }

	add	rsp, 88					; 00000058H
	ret	0
stbtt_PackBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
tv70 = 0
tv71 = 4
p$ = 8
q$ = 16
a$ = 48
b$ = 56
?rect_original_order@@YAHPEBX0@Z PROC			; rect_original_order

; 540  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 541  : 	const stbrp_rect* p = (const stbrp_rect*)a;

	mov	rax, QWORD PTR a$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 542  : 	const stbrp_rect* q = (const stbrp_rect*)b;

	mov	rax, QWORD PTR b$[rsp]
	mov	QWORD PTR q$[rsp], rax

; 543  : 	return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+12], ecx
	jge	SHORT $LN5@rect_origi
	mov	DWORD PTR tv71[rsp], -1
	jmp	SHORT $LN6@rect_origi
$LN5@rect_origi:
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+12], ecx
	jle	SHORT $LN3@rect_origi
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@rect_origi
$LN3@rect_origi:
	mov	DWORD PTR tv70[rsp], 0
$LN4@rect_origi:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR tv71[rsp], eax
$LN6@rect_origi:
	mov	eax, DWORD PTR tv71[rsp]

; 544  : }

	add	rsp, 40					; 00000028H
	ret	0
?rect_original_order@@YAHPEBX0@Z ENDP			; rect_original_order
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
tv84 = 0
tv85 = 4
p$ = 8
q$ = 16
a$ = 48
b$ = 56
?rect_height_compare@@YAHPEBX0@Z PROC			; rect_height_compare

; 528  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 529  : 	const stbrp_rect* p = (const stbrp_rect*)a;

	mov	rax, QWORD PTR a$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 530  : 	const stbrp_rect* q = (const stbrp_rect*)b;

	mov	rax, QWORD PTR b$[rsp]
	mov	QWORD PTR q$[rsp], rax

; 531  : 	if (p->h > q->h)

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR q$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	cmp	eax, ecx
	jle	SHORT $LN2@rect_heigh

; 532  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@rect_heigh
$LN2@rect_heigh:

; 533  : 	if (p->h < q->h)

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR q$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	cmp	eax, ecx
	jge	SHORT $LN3@rect_heigh

; 534  : 		return  1;

	mov	eax, 1
	jmp	SHORT $LN1@rect_heigh
$LN3@rect_heigh:

; 535  : 	return (p->w > q->w) ? -1 : (p->w < q->w);

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	rcx, QWORD PTR q$[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	cmp	eax, ecx
	jle	SHORT $LN7@rect_heigh
	mov	DWORD PTR tv85[rsp], -1
	jmp	SHORT $LN8@rect_heigh
$LN7@rect_heigh:
	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	rcx, QWORD PTR q$[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	cmp	eax, ecx
	jge	SHORT $LN5@rect_heigh
	mov	DWORD PTR tv84[rsp], 1
	jmp	SHORT $LN6@rect_heigh
$LN5@rect_heigh:
	mov	DWORD PTR tv84[rsp], 0
$LN6@rect_heigh:
	mov	eax, DWORD PTR tv84[rsp]
	mov	DWORD PTR tv85[rsp], eax
$LN8@rect_heigh:
	mov	eax, DWORD PTR tv85[rsp]
$LN1@rect_heigh:

; 536  : }

	add	rsp, 40					; 00000028H
	ret	0
?rect_height_compare@@YAHPEBX0@Z ENDP			; rect_height_compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
cur$ = 32
node$ = 40
next$1 = 48
next$2 = 56
res$ = 64
$T3 = 80
__$ReturnAddress$ = 128
context$ = 136
width$ = 144
height$ = 152
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z PROC ; stbrp__skyline_pack_rectangle

; 447  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 448  : 	// find best position according to heuristic
; 449  : 	stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

	mov	r9d, DWORD PTR height$[rsp]
	mov	r8d, DWORD PTR width$[rsp]
	mov	rdx, QWORD PTR context$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos
	lea	rcx, QWORD PTR res$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 450  : 	stbrp_node* node, * cur;
; 451  : 
; 452  : 	// bail if:
; 453  : 	//    1. it failed
; 454  : 	//    2. the best node doesn't fit (we don't always check this)
; 455  : 	//    3. we're out of memory
; 456  : 	if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

	cmp	QWORD PTR res$[rsp+8], 0
	je	SHORT $LN5@stbrp__sky
	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR res$[rsp+4]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR context$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jg	SHORT $LN5@stbrp__sky
	mov	rax, QWORD PTR context$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN4@stbrp__sky
$LN5@stbrp__sky:

; 457  : 		res.prev_link = NULL;

	mov	QWORD PTR res$[rsp+8], 0

; 458  : 		return res;

	lea	rax, QWORD PTR res$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	$LN1@stbrp__sky
$LN4@stbrp__sky:

; 459  : 	}
; 460  : 
; 461  : 	// on success, create new node
; 462  : 	node = context->free_head;

	mov	rax, QWORD PTR context$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR node$[rsp], rax

; 463  : 	node->x = (stbrp_coord)res.x;

	mov	rax, QWORD PTR node$[rsp]
	movzx	ecx, WORD PTR res$[rsp]
	mov	WORD PTR [rax], cx

; 464  : 	node->y = (stbrp_coord)(res.y + height);

	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR res$[rsp+4]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR node$[rsp]
	mov	WORD PTR [rcx+2], ax

; 465  : 
; 466  : 	context->free_head = node->next;

	mov	rax, QWORD PTR context$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+32], rcx

; 467  : 
; 468  : 	// insert the new node into the right starting point, and
; 469  : 	// let 'cur' point to the remaining nodes needing to be
; 470  : 	// stiched back in
; 471  : 
; 472  : 	cur = *res.prev_link;

	mov	rax, QWORD PTR res$[rsp+8]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cur$[rsp], rax

; 473  : 	if (cur->x < res.x) {

	mov	rax, QWORD PTR cur$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, DWORD PTR res$[rsp]
	jge	SHORT $LN6@stbrp__sky

; 474  : 		// preserve the existing one, so start testing with the next one
; 475  : 		stbrp_node* next = cur->next;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR next$1[rsp], rax

; 476  : 		cur->next = node;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 477  : 		cur = next;

	mov	rax, QWORD PTR next$1[rsp]
	mov	QWORD PTR cur$[rsp], rax

; 478  : 	}

	jmp	SHORT $LN7@stbrp__sky
$LN6@stbrp__sky:

; 479  : 	else {
; 480  : 		*res.prev_link = node;

	mov	rax, QWORD PTR res$[rsp+8]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], rcx
$LN7@stbrp__sky:
$LN2@stbrp__sky:

; 481  : 	}
; 482  : 
; 483  : 	// from here, traverse cur and free the nodes, until we get to one
; 484  : 	// that shouldn't be freed
; 485  : 	while (cur->next && cur->next->x <= res.x + width) {

	mov	rax, QWORD PTR cur$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@stbrp__sky
	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax]
	mov	ecx, DWORD PTR width$[rsp]
	mov	edx, DWORD PTR res$[rsp]
	add	edx, ecx
	mov	ecx, edx
	cmp	eax, ecx
	jg	SHORT $LN3@stbrp__sky

; 486  : 		stbrp_node* next = cur->next;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR next$2[rsp], rax

; 487  : 		// move the current node to the free list
; 488  : 		cur->next = context->free_head;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rcx, QWORD PTR context$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rax+8], rcx

; 489  : 		context->free_head = cur;

	mov	rax, QWORD PTR context$[rsp]
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 490  : 		cur = next;

	mov	rax, QWORD PTR next$2[rsp]
	mov	QWORD PTR cur$[rsp], rax

; 491  : 	}

	jmp	SHORT $LN2@stbrp__sky
$LN3@stbrp__sky:

; 492  : 
; 493  : 	// stitch the list back in
; 494  : 	node->next = cur;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 495  : 
; 496  : 	if (cur->x < res.x + width)

	mov	rax, QWORD PTR cur$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	ecx, DWORD PTR width$[rsp]
	mov	edx, DWORD PTR res$[rsp]
	add	edx, ecx
	mov	ecx, edx
	cmp	eax, ecx
	jge	SHORT $LN8@stbrp__sky

; 497  : 		cur->x = (stbrp_coord)(res.x + width);

	mov	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR res$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR cur$[rsp]
	mov	WORD PTR [rcx], ax
$LN8@stbrp__sky:

; 498  : 
; 499  : #ifdef _DEBUG
; 500  : 	cur = context->active_head;
; 501  : 	while (cur->x < context->width) {
; 502  : 		STBRP_ASSERT(cur->x < cur->next->x);
; 503  : 		cur = cur->next;
; 504  : 	}
; 505  : 	STBRP_ASSERT(cur->next == NULL);
; 506  : 
; 507  : 	{
; 508  : 		int count = 0;
; 509  : 		cur = context->active_head;
; 510  : 		while (cur) {
; 511  : 			cur = cur->next;
; 512  : 			++count;
; 513  : 		}
; 514  : 		cur = context->free_head;
; 515  : 		while (cur) {
; 516  : 			cur = cur->next;
; 517  : 			++count;
; 518  : 		}
; 519  : 		STBRP_ASSERT(count == context->num_nodes + 2);
; 520  : 	}
; 521  : #endif
; 522  : 
; 523  : 	return res;

	lea	rax, QWORD PTR res$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@stbrp__sky:

; 524  : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_pack_rectangle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
best_y$ = 48
y$1 = 52
node$ = 56
best_waste$ = 64
xpos$2 = 68
y$3 = 72
waste$4 = 76
best_x$ = 80
tail$ = 88
prev$ = 96
best$ = 104
waste$5 = 112
tv131 = 116
fr$ = 120
__$ReturnAddress$ = 176
c$ = 184
width$ = 192
height$ = 200
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z PROC ; stbrp__skyline_find_best_pos

; 351  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H

; 352  : 	int best_waste = (1 << 30), best_x, best_y = (1 << 30);

	mov	DWORD PTR best_waste$[rsp], 1073741824	; 40000000H
	mov	DWORD PTR best_y$[rsp], 1073741824	; 40000000H

; 353  : 	stbrp__findresult fr;
; 354  : 	stbrp_node** prev, * node, * tail, ** best = NULL;

	mov	QWORD PTR best$[rsp], 0

; 355  : 
; 356  : 	// align to multiple of c->align
; 357  : 	width = (width + c->align - 1);

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR width$[rsp]
	lea	eax, DWORD PTR [rcx+rax-1]
	mov	DWORD PTR width$[rsp], eax

; 358  : 	width -= width % c->align;

	mov	eax, DWORD PTR width$[rsp]
	cdq
	mov	rcx, QWORD PTR c$[rsp]
	idiv	DWORD PTR [rcx+8]
	mov	eax, edx
	mov	ecx, DWORD PTR width$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR width$[rsp], eax

; 359  : 	STBRP_ASSERT(width % c->align == 0);
; 360  : 
; 361  : 	node = c->active_head;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR node$[rsp], rax

; 362  : 	prev = &c->active_head;

	mov	rax, QWORD PTR c$[rsp]
	add	rax, 24
	mov	QWORD PTR prev$[rsp], rax
$LN2@stbrp__sky:

; 363  : 	while (node->x + width <= c->width) {

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax]
	add	eax, DWORD PTR width$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	cmp	eax, DWORD PTR [rcx]
	jg	$LN3@stbrp__sky

; 364  : 		int y, waste;
; 365  : 		y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax]
	lea	rcx, QWORD PTR waste$5[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR width$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ; stbrp__skyline_find_min_y
	mov	DWORD PTR y$1[rsp], eax

; 366  : 		if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL

	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN10@stbrp__sky

; 367  : 			// bottom left
; 368  : 			if (y < best_y) {

	mov	eax, DWORD PTR best_y$[rsp]
	cmp	DWORD PTR y$1[rsp], eax
	jge	SHORT $LN12@stbrp__sky

; 369  : 				best_y = y;

	mov	eax, DWORD PTR y$1[rsp]
	mov	DWORD PTR best_y$[rsp], eax

; 370  : 				best = prev;

	mov	rax, QWORD PTR prev$[rsp]
	mov	QWORD PTR best$[rsp], rax
$LN12@stbrp__sky:

; 371  : 			}
; 372  : 		}

	jmp	SHORT $LN11@stbrp__sky
$LN10@stbrp__sky:

; 373  : 		else {
; 374  : 			// best-fit
; 375  : 			if (y + height <= c->height) {

	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR y$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR c$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jg	SHORT $LN13@stbrp__sky

; 376  : 				// can only use it if it first vertically
; 377  : 				if (y < best_y || (y == best_y && waste < best_waste)) {

	mov	eax, DWORD PTR best_y$[rsp]
	cmp	DWORD PTR y$1[rsp], eax
	jl	SHORT $LN15@stbrp__sky
	mov	eax, DWORD PTR best_y$[rsp]
	cmp	DWORD PTR y$1[rsp], eax
	jne	SHORT $LN14@stbrp__sky
	mov	eax, DWORD PTR best_waste$[rsp]
	cmp	DWORD PTR waste$5[rsp], eax
	jge	SHORT $LN14@stbrp__sky
$LN15@stbrp__sky:

; 378  : 					best_y = y;

	mov	eax, DWORD PTR y$1[rsp]
	mov	DWORD PTR best_y$[rsp], eax

; 379  : 					best_waste = waste;

	mov	eax, DWORD PTR waste$5[rsp]
	mov	DWORD PTR best_waste$[rsp], eax

; 380  : 					best = prev;

	mov	rax, QWORD PTR prev$[rsp]
	mov	QWORD PTR best$[rsp], rax
$LN14@stbrp__sky:
$LN13@stbrp__sky:
$LN11@stbrp__sky:

; 381  : 				}
; 382  : 			}
; 383  : 		}
; 384  : 		prev = &node->next;

	mov	rax, QWORD PTR node$[rsp]
	add	rax, 8
	mov	QWORD PTR prev$[rsp], rax

; 385  : 		node = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR node$[rsp], rax

; 386  : 	}

	jmp	$LN2@stbrp__sky
$LN3@stbrp__sky:

; 387  : 
; 388  : 	best_x = (best == NULL) ? 0 : (*best)->x;

	cmp	QWORD PTR best$[rsp], 0
	jne	SHORT $LN22@stbrp__sky
	mov	DWORD PTR tv131[rsp], 0
	jmp	SHORT $LN23@stbrp__sky
$LN22@stbrp__sky:
	mov	rax, QWORD PTR best$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv131[rsp], eax
$LN23@stbrp__sky:
	mov	eax, DWORD PTR tv131[rsp]
	mov	DWORD PTR best_x$[rsp], eax

; 389  : 
; 390  : 	// if doing best-fit (BF), we also have to try aligning right edge to each node position
; 391  : 	//
; 392  : 	// e.g, if fitting
; 393  : 	//
; 394  : 	//     ____________________
; 395  : 	//    |____________________|
; 396  : 	//
; 397  : 	//            into
; 398  : 	//
; 399  : 	//   |                         |
; 400  : 	//   |             ____________|
; 401  : 	//   |____________|
; 402  : 	//
; 403  : 	// then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
; 404  : 	//
; 405  : 	// This makes BF take about 2x the time
; 406  : 
; 407  : 	if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {

	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+16], 1
	jne	$LN16@stbrp__sky

; 408  : 		tail = c->active_head;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tail$[rsp], rax

; 409  : 		node = c->active_head;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR node$[rsp], rax

; 410  : 		prev = &c->active_head;

	mov	rax, QWORD PTR c$[rsp]
	add	rax, 24
	mov	QWORD PTR prev$[rsp], rax
$LN4@stbrp__sky:

; 411  : 		// find first node that's admissible
; 412  : 		while (tail->x < width)

	mov	rax, QWORD PTR tail$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, DWORD PTR width$[rsp]
	jge	SHORT $LN5@stbrp__sky

; 413  : 			tail = tail->next;

	mov	rax, QWORD PTR tail$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tail$[rsp], rax
	jmp	SHORT $LN4@stbrp__sky
$LN5@stbrp__sky:
$LN6@stbrp__sky:

; 414  : 		while (tail) {

	cmp	QWORD PTR tail$[rsp], 0
	je	$LN7@stbrp__sky

; 415  : 			int xpos = tail->x - width;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	eax, WORD PTR [rax]
	sub	eax, DWORD PTR width$[rsp]
	mov	DWORD PTR xpos$2[rsp], eax
$LN8@stbrp__sky:

; 416  : 			int y, waste;
; 417  : 			STBRP_ASSERT(xpos >= 0);
; 418  : 			// find the left position that matches this
; 419  : 			while (node->next->x <= xpos) {

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax]
	cmp	eax, DWORD PTR xpos$2[rsp]
	jg	SHORT $LN9@stbrp__sky

; 420  : 				prev = &node->next;

	mov	rax, QWORD PTR node$[rsp]
	add	rax, 8
	mov	QWORD PTR prev$[rsp], rax

; 421  : 				node = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR node$[rsp], rax

; 422  : 			}

	jmp	SHORT $LN8@stbrp__sky
$LN9@stbrp__sky:

; 423  : 			STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
; 424  : 			y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);

	lea	rax, QWORD PTR waste$4[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR width$[rsp]
	mov	r8d, DWORD PTR xpos$2[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	call	?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ; stbrp__skyline_find_min_y
	mov	DWORD PTR y$3[rsp], eax

; 425  : 			if (y + height < c->height) {

	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR y$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR c$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jge	SHORT $LN17@stbrp__sky

; 426  : 				if (y <= best_y) {

	mov	eax, DWORD PTR best_y$[rsp]
	cmp	DWORD PTR y$3[rsp], eax
	jg	SHORT $LN18@stbrp__sky

; 427  : 					if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {

	mov	eax, DWORD PTR best_y$[rsp]
	cmp	DWORD PTR y$3[rsp], eax
	jl	SHORT $LN20@stbrp__sky
	mov	eax, DWORD PTR best_waste$[rsp]
	cmp	DWORD PTR waste$4[rsp], eax
	jl	SHORT $LN20@stbrp__sky
	mov	eax, DWORD PTR best_waste$[rsp]
	cmp	DWORD PTR waste$4[rsp], eax
	jne	SHORT $LN19@stbrp__sky
	mov	eax, DWORD PTR best_x$[rsp]
	cmp	DWORD PTR xpos$2[rsp], eax
	jge	SHORT $LN19@stbrp__sky
$LN20@stbrp__sky:

; 428  : 						best_x = xpos;

	mov	eax, DWORD PTR xpos$2[rsp]
	mov	DWORD PTR best_x$[rsp], eax

; 429  : 						STBRP_ASSERT(y <= best_y);
; 430  : 						best_y = y;

	mov	eax, DWORD PTR y$3[rsp]
	mov	DWORD PTR best_y$[rsp], eax

; 431  : 						best_waste = waste;

	mov	eax, DWORD PTR waste$4[rsp]
	mov	DWORD PTR best_waste$[rsp], eax

; 432  : 						best = prev;

	mov	rax, QWORD PTR prev$[rsp]
	mov	QWORD PTR best$[rsp], rax
$LN19@stbrp__sky:
$LN18@stbrp__sky:
$LN17@stbrp__sky:

; 433  : 					}
; 434  : 				}
; 435  : 			}
; 436  : 			tail = tail->next;

	mov	rax, QWORD PTR tail$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tail$[rsp], rax

; 437  : 		}

	jmp	$LN6@stbrp__sky
$LN7@stbrp__sky:
$LN16@stbrp__sky:

; 438  : 	}
; 439  : 
; 440  : 	fr.prev_link = best;

	mov	rax, QWORD PTR best$[rsp]
	mov	QWORD PTR fr$[rsp+8], rax

; 441  : 	fr.x = best_x;

	mov	eax, DWORD PTR best_x$[rsp]
	mov	DWORD PTR fr$[rsp], eax

; 442  : 	fr.y = best_y;

	mov	eax, DWORD PTR best_y$[rsp]
	mov	DWORD PTR fr$[rsp+4], eax

; 443  : 	return fr;

	lea	rax, QWORD PTR fr$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 444  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_find_best_pos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
visited_width$ = 0
waste_area$ = 4
min_y$ = 8
under_width$1 = 12
x1$ = 16
node$ = 24
c$ = 48
first$ = 56
x0$ = 64
width$ = 72
pwaste$ = 80
?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z PROC ; stbrp__skyline_find_min_y

; 294  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 295  : 	stbrp_node* node = first;

	mov	rax, QWORD PTR first$[rsp]
	mov	QWORD PTR node$[rsp], rax

; 296  : 	int x1 = x0 + width;

	mov	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x1$[rsp], eax

; 297  : 	int min_y, visited_width, waste_area;
; 298  : 
; 299  : 	STBRP__NOTUSED(c);
; 300  : 
; 301  : 	STBRP_ASSERT(first->x <= x0);
; 302  : 
; 303  : #if 0
; 304  : 	// skip in case we're past the node
; 305  : 	while (node->next->x <= x0)
; 306  : 		++node;
; 307  : #else
; 308  : 	STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
; 309  : #endif
; 310  : 
; 311  : 	STBRP_ASSERT(node->x <= x0);
; 312  : 
; 313  : 	min_y = 0;

	mov	DWORD PTR min_y$[rsp], 0

; 314  : 	waste_area = 0;

	mov	DWORD PTR waste_area$[rsp], 0

; 315  : 	visited_width = 0;

	mov	DWORD PTR visited_width$[rsp], 0
$LN2@stbrp__sky:

; 316  : 	while (node->x < x1) {

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, DWORD PTR x1$[rsp]
	jge	$LN3@stbrp__sky

; 317  : 		if (node->y > min_y) {

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, DWORD PTR min_y$[rsp]
	jle	SHORT $LN4@stbrp__sky

; 318  : 			// raise min_y higher.
; 319  : 			// we've accounted for all waste up to min_y,
; 320  : 			// but we'll now add more waste for everything we've visted
; 321  : 			waste_area += visited_width * (node->y - min_y);

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax+2]
	sub	eax, DWORD PTR min_y$[rsp]
	mov	ecx, DWORD PTR visited_width$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR waste_area$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR waste_area$[rsp], eax

; 322  : 			min_y = node->y;

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax+2]
	mov	DWORD PTR min_y$[rsp], eax

; 323  : 			// the first time through, visited_width might be reduced
; 324  : 			if (node->x < x0)

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, DWORD PTR x0$[rsp]
	jge	SHORT $LN6@stbrp__sky

; 325  : 				visited_width += node->next->x - x0;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax]
	sub	eax, DWORD PTR x0$[rsp]
	mov	ecx, DWORD PTR visited_width$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR visited_width$[rsp], eax
	jmp	SHORT $LN7@stbrp__sky
$LN6@stbrp__sky:

; 326  : 			else
; 327  : 				visited_width += node->next->x - node->x;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR node$[rsp]
	movzx	ecx, WORD PTR [rcx]
	sub	eax, ecx
	mov	ecx, DWORD PTR visited_width$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR visited_width$[rsp], eax
$LN7@stbrp__sky:

; 328  : 		}

	jmp	SHORT $LN5@stbrp__sky
$LN4@stbrp__sky:

; 329  : 		else {
; 330  : 			// add waste area
; 331  : 			int under_width = node->next->x - node->x;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR node$[rsp]
	movzx	ecx, WORD PTR [rcx]
	sub	eax, ecx
	mov	DWORD PTR under_width$1[rsp], eax

; 332  : 			if (under_width + visited_width > width)

	mov	eax, DWORD PTR visited_width$[rsp]
	mov	ecx, DWORD PTR under_width$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR width$[rsp]
	jle	SHORT $LN8@stbrp__sky

; 333  : 				under_width = width - visited_width;

	mov	eax, DWORD PTR visited_width$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR under_width$1[rsp], eax
$LN8@stbrp__sky:

; 334  : 			waste_area += under_width * (min_y - node->y);

	mov	rax, QWORD PTR node$[rsp]
	movzx	eax, WORD PTR [rax+2]
	mov	ecx, DWORD PTR min_y$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR under_width$1[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR waste_area$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR waste_area$[rsp], eax

; 335  : 			visited_width += under_width;

	mov	eax, DWORD PTR under_width$1[rsp]
	mov	ecx, DWORD PTR visited_width$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR visited_width$[rsp], eax
$LN5@stbrp__sky:

; 336  : 		}
; 337  : 		node = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR node$[rsp], rax

; 338  : 	}

	jmp	$LN2@stbrp__sky
$LN3@stbrp__sky:

; 339  : 
; 340  : 	*pwaste = waste_area;

	mov	rax, QWORD PTR pwaste$[rsp]
	mov	ecx, DWORD PTR waste_area$[rsp]
	mov	DWORD PTR [rax], ecx

; 341  : 	return min_y;

	mov	eax, DWORD PTR min_y$[rsp]

; 342  : }

	add	rsp, 40					; 00000028H
	ret	0
?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ENDP ; stbrp__skyline_find_min_y
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
context$ = 8
allow_out_of_mem$ = 16
stbrp_setup_allow_out_of_mem PROC

; 241  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 242  : 	if (allow_out_of_mem)

	cmp	DWORD PTR allow_out_of_mem$[rsp], 0
	je	SHORT $LN2@stbrp_setu

; 243  : 		// if it's ok to run out of memory, then don't bother aligning them;
; 244  : 		// this gives better packing, but may fail due to OOM (even though
; 245  : 		// the rectangles easily fit). @TODO a smarter approach would be to only
; 246  : 		// quantize once we've hit OOM, then we could get rid of this parameter.
; 247  : 		context->align = 1;

	mov	rax, QWORD PTR context$[rsp]
	mov	DWORD PTR [rax+8], 1
	jmp	SHORT $LN3@stbrp_setu
$LN2@stbrp_setu:

; 248  : 	else {
; 249  : 		// if it's not ok to run out of memory, then quantize the widths
; 250  : 		// so that num_nodes is always enough nodes.
; 251  : 		//
; 252  : 		// I.e. num_nodes * align >= width
; 253  : 		//                  align >= width / num_nodes
; 254  : 		//                  align = ceil(width/num_nodes)
; 255  : 
; 256  : 		context->align = (context->width + context->num_nodes - 1) / context->num_nodes;

	mov	rax, QWORD PTR context$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR context$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	lea	eax, DWORD PTR [rax+rcx-1]
	cdq
	mov	rcx, QWORD PTR context$[rsp]
	idiv	DWORD PTR [rcx+20]
	mov	rcx, QWORD PTR context$[rsp]
	mov	DWORD PTR [rcx+8], eax
$LN3@stbrp_setu:

; 257  : 	}
; 258  : }

	ret	0
stbrp_setup_allow_out_of_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
i$ = 32
context$ = 64
width$ = 72
height$ = 80
nodes$ = 88
num_nodes$ = 96
stbrp_init_target PROC

; 261  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 262  : 	int i;
; 263  : #ifndef STBRP_LARGE_RECTS
; 264  : 	STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
; 265  : #endif
; 266  : 
; 267  : 	for (i = 0; i < num_nodes - 1; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbrp_init
$LN2@stbrp_init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbrp_init:
	mov	eax, DWORD PTR num_nodes$[rsp]
	dec	eax
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbrp_init

; 268  : 		nodes[i].next = &nodes[i + 1];

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR nodes$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR nodes$[rsp]
	mov	QWORD PTR [rdx+rcx+8], rax
	jmp	SHORT $LN2@stbrp_init
$LN3@stbrp_init:

; 269  : 	nodes[i].next = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR nodes$[rsp]
	mov	QWORD PTR [rcx+rax+8], 0

; 270  : 	context->init_mode = STBRP__INIT_skyline;

	mov	rax, QWORD PTR context$[rsp]
	mov	DWORD PTR [rax+12], 1

; 271  : 	context->heuristic = STBRP_HEURISTIC_Skyline_default;

	mov	rax, QWORD PTR context$[rsp]
	mov	DWORD PTR [rax+16], 0

; 272  : 	context->free_head = &nodes[0];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nodes$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR context$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 273  : 	context->active_head = &context->extra[0];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR context$[rsp]
	lea	rax, QWORD PTR [rcx+rax+40]
	mov	rcx, QWORD PTR context$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 274  : 	context->width = width;

	mov	rax, QWORD PTR context$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax], ecx

; 275  : 	context->height = height;

	mov	rax, QWORD PTR context$[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 276  : 	context->num_nodes = num_nodes;

	mov	rax, QWORD PTR context$[rsp]
	mov	ecx, DWORD PTR num_nodes$[rsp]
	mov	DWORD PTR [rax+20], ecx

; 277  : 	stbrp_setup_allow_out_of_mem(context, 0);

	xor	edx, edx
	mov	rcx, QWORD PTR context$[rsp]
	call	stbrp_setup_allow_out_of_mem

; 278  : 
; 279  : 	// node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
; 280  : 	context->extra[0].x = 0;

	mov	eax, 16
	imul	rax, rax, 0
	xor	ecx, ecx
	mov	rdx, QWORD PTR context$[rsp]
	mov	WORD PTR [rdx+rax+40], cx

; 281  : 	context->extra[0].y = 0;

	mov	eax, 16
	imul	rax, rax, 0
	xor	ecx, ecx
	mov	rdx, QWORD PTR context$[rsp]
	mov	WORD PTR [rdx+rax+42], cx

; 282  : 	context->extra[0].next = &context->extra[1];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR context$[rsp]
	lea	rax, QWORD PTR [rcx+rax+40]
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR context$[rsp]
	mov	QWORD PTR [rdx+rcx+48], rax

; 283  : 	context->extra[1].x = (stbrp_coord)width;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR context$[rsp]
	movzx	edx, WORD PTR width$[rsp]
	mov	WORD PTR [rcx+rax+40], dx

; 284  : #ifdef STBRP_LARGE_RECTS
; 285  : 	context->extra[1].y = (1 << 30);
; 286  : #else
; 287  : 	context->extra[1].y = 65535;

	mov	eax, 16
	imul	rax, rax, 1
	mov	ecx, 65535				; 0000ffffH
	mov	rdx, QWORD PTR context$[rsp]
	mov	WORD PTR [rdx+rax+42], cx

; 288  : #endif
; 289  : 	context->extra[1].next = NULL;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR context$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 290  : }

	add	rsp, 56					; 00000038H
	ret	0
stbrp_init_target ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
i$ = 32
tv185 = 36
all_rects_packed$ = 40
fr$1 = 48
$T2 = 64
context$ = 112
rects$ = 120
num_rects$ = 128
stbrp_pack_rects PROC

; 553  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 554  : 	int i, all_rects_packed = 1;

	mov	DWORD PTR all_rects_packed$[rsp], 1

; 555  : 
; 556  : 	// we use the 'was_packed' field internally to allow sorting/unsorting
; 557  : 	for (i = 0; i < num_rects; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbrp_pack
$LN2@stbrp_pack:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbrp_pack:
	mov	eax, DWORD PTR num_rects$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbrp_pack

; 558  : 		rects[i].was_packed = i;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rcx+rax+12], edx

; 559  : 	}

	jmp	SHORT $LN2@stbrp_pack
$LN3@stbrp_pack:

; 560  : 
; 561  : 	// sort according to heuristic
; 562  : 	STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

	movsxd	rax, DWORD PTR num_rects$[rsp]
	lea	r9, OFFSET FLAT:?rect_height_compare@@YAHPEBX0@Z ; rect_height_compare
	mov	r8d, 16
	mov	rdx, rax
	mov	rcx, QWORD PTR rects$[rsp]
	call	qsort
	npad	1

; 563  : 
; 564  : 	for (i = 0; i < num_rects; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbrp_pack
$LN5@stbrp_pack:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbrp_pack:
	mov	eax, DWORD PTR num_rects$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN6@stbrp_pack

; 565  : 		if (rects[i].w == 0 || rects[i].h == 0) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	eax, WORD PTR [rcx+rax+4]
	test	eax, eax
	je	SHORT $LN13@stbrp_pack
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	eax, WORD PTR [rcx+rax+6]
	test	eax, eax
	jne	SHORT $LN11@stbrp_pack
$LN13@stbrp_pack:

; 566  : 			rects[i].x = rects[i].y = 0;  // empty rect needs no space

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	xor	ecx, ecx
	mov	rdx, QWORD PTR rects$[rsp]
	mov	WORD PTR [rdx+rax+10], cx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	xor	ecx, ecx
	mov	rdx, QWORD PTR rects$[rsp]
	mov	WORD PTR [rdx+rax+8], cx

; 567  : 		}

	jmp	$LN12@stbrp_pack
$LN11@stbrp_pack:

; 568  : 		else {
; 569  : 			stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	eax, WORD PTR [rcx+rax+6]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR rects$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx+4]
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR context$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ; stbrp__skyline_pack_rectangle
	lea	rcx, QWORD PTR fr$1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 570  : 			if (fr.prev_link) {

	cmp	QWORD PTR fr$1[rsp+8], 0
	je	SHORT $LN14@stbrp_pack

; 571  : 				rects[i].x = (stbrp_coord)fr.x;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	edx, WORD PTR fr$1[rsp]
	mov	WORD PTR [rcx+rax+8], dx

; 572  : 				rects[i].y = (stbrp_coord)fr.y;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	edx, WORD PTR fr$1[rsp+4]
	mov	WORD PTR [rcx+rax+10], dx

; 573  : 			}

	jmp	SHORT $LN15@stbrp_pack
$LN14@stbrp_pack:

; 574  : 			else {
; 575  : 				rects[i].x = rects[i].y = STBRP__MAXVAL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	ecx, 65535				; 0000ffffH
	mov	rdx, QWORD PTR rects$[rsp]
	mov	WORD PTR [rdx+rax+10], cx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	ecx, 65535				; 0000ffffH
	mov	rdx, QWORD PTR rects$[rsp]
	mov	WORD PTR [rdx+rax+8], cx
$LN15@stbrp_pack:
$LN12@stbrp_pack:

; 576  : 			}
; 577  : 		}
; 578  : 	}

	jmp	$LN5@stbrp_pack
$LN6@stbrp_pack:

; 579  : 
; 580  : 	// unsort
; 581  : 	STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

	movsxd	rax, DWORD PTR num_rects$[rsp]
	lea	r9, OFFSET FLAT:?rect_original_order@@YAHPEBX0@Z ; rect_original_order
	mov	r8d, 16
	mov	rdx, rax
	mov	rcx, QWORD PTR rects$[rsp]
	call	qsort
	npad	1

; 582  : 
; 583  : 	// set was_packed flags and all_rects_packed status
; 584  : 	for (i = 0; i < num_rects; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@stbrp_pack
$LN8@stbrp_pack:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbrp_pack:
	mov	eax, DWORD PTR num_rects$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN9@stbrp_pack

; 585  : 		rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	eax, WORD PTR [rcx+rax+8]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $LN18@stbrp_pack
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	movzx	eax, WORD PTR [rcx+rax+10]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $LN18@stbrp_pack
	mov	DWORD PTR tv185[rsp], 0
	jmp	SHORT $LN19@stbrp_pack
$LN18@stbrp_pack:
	mov	DWORD PTR tv185[rsp], 1
$LN19@stbrp_pack:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	mov	edx, DWORD PTR tv185[rsp]
	mov	DWORD PTR [rcx+rax+12], edx

; 586  : 		if (!rects[i].was_packed)

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR rects$[rsp]
	cmp	DWORD PTR [rcx+rax+12], 0
	jne	SHORT $LN16@stbrp_pack

; 587  : 			all_rects_packed = 0;

	mov	DWORD PTR all_rects_packed$[rsp], 0
$LN16@stbrp_pack:

; 588  : 	}

	jmp	$LN8@stbrp_pack
$LN9@stbrp_pack:

; 589  : 
; 590  : 	// return the all_rects_packed status
; 591  : 	return all_rects_packed;

	mov	eax, DWORD PTR all_rects_packed$[rsp]

; 592  : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
stbrp_pack_rects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 0
j$2 = 4
data$ = 8
table$ = 32
pixels$ = 40
x$ = 48
y$ = 56
w$ = 64
h$ = 72
stride$ = 80
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z PROC ; ImFontAtlasBuildMultiplyRectAlpha8

; 1886 : {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1887 :     unsigned char* data = pixels + x + y * stride;

	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR pixels$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR y$[rsp]
	imul	ecx, DWORD PTR stride$[rsp]
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR data$[rsp], rax

; 1888 :     for (int j = h; j > 0; j--, data += stride)

	mov	eax, DWORD PTR h$[rsp]
	mov	DWORD PTR j$2[rsp], eax
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR j$2[rsp]
	dec	eax
	mov	DWORD PTR j$2[rsp], eax
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR data$[rsp], rax
$LN4@ImFontAtla:
	cmp	DWORD PTR j$2[rsp], 0
	jle	SHORT $LN3@ImFontAtla

; 1889 :         for (int i = 0; i < w; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@ImFontAtla:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN6@ImFontAtla

; 1890 :             data[i] = table[data[i]];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	r8, QWORD PTR table$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN5@ImFontAtla
$LN6@ImFontAtla:
	jmp	SHORT $LN2@ImFontAtla
$LN3@ImFontAtla:

; 1891 : }

	add	rsp, 24
	ret	0
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ENDP ; ImFontAtlasBuildMultiplyRectAlpha8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 0
value$2 = 4
tv75 = 8
out_table$ = 32
in_brighten_factor$ = 40
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z PROC ; ImFontAtlasBuildMultiplyCalcLookupTable

; 1877 : {

$LN8:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1878 :     for (unsigned int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ImFontAtla:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jae	SHORT $LN3@ImFontAtla

; 1879 :     {
; 1880 :         unsigned int value = (unsigned int)(i * in_brighten_factor);

	mov	eax, DWORD PTR i$1[rsp]
	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR in_brighten_factor$[rsp]
	cvttss2si rax, xmm0
	mov	DWORD PTR value$2[rsp], eax

; 1881 :         out_table[i] = value > 255 ? 255 : (value & 0xFF);

	cmp	DWORD PTR value$2[rsp], 255		; 000000ffH
	jbe	SHORT $LN6@ImFontAtla
	mov	DWORD PTR tv75[rsp], 255		; 000000ffH
	jmp	SHORT $LN7@ImFontAtla
$LN6@ImFontAtla:
	mov	eax, DWORD PTR value$2[rsp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR tv75[rsp], eax
$LN7@ImFontAtla:
	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR out_table$[rsp]
	movzx	edx, BYTE PTR tv75[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 1882 :     }

	jmp	SHORT $LN2@ImFontAtla
$LN3@ImFontAtla:

; 1883 : }

	add	rsp, 24
	ret	0
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ENDP ; ImFontAtlasBuildMultiplyCalcLookupTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
r$1 = 96
i$2 = 104
i$3 = 108
uv1$4 = 112
uv0$5 = 120
tv74 = 128
tv148 = 136
tv158 = 144
tv167 = 152
atlas$ = 176
?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z PROC	; ImFontAtlasBuildFinish

; 2269 : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 2270 :     // Render into our custom data block
; 2271 :     ImFontAtlasBuildRenderDefaultTexData(atlas);

	mov	rcx, QWORD PTR atlas$[rsp]
	call	?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderDefaultTexData
	npad	1

; 2272 : 
; 2273 :     // Register custom rectangle glyphs
; 2274 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN4@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+88]
	cmp	DWORD PTR i$3[rsp], eax
	jge	$LN3@ImFontAtla

; 2275 :     {
; 2276 :         const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	mov	QWORD PTR r$1[rsp], rax

; 2277 :         if (r.Font == NULL || r.ID > 0x10000)

	mov	rax, QWORD PTR r$1[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN9@ImFontAtla
	mov	rax, QWORD PTR r$1[rsp]
	cmp	DWORD PTR [rax+8], 65536		; 00010000H
	jbe	SHORT $LN8@ImFontAtla
$LN9@ImFontAtla:

; 2278 :             continue;

	jmp	SHORT $LN2@ImFontAtla
$LN8@ImFontAtla:

; 2279 : 
; 2280 :         IM_ASSERT(r.Font->ContainerAtlas == atlas);
; 2281 :         ImVec2 uv0, uv1;

	lea	rcx, QWORD PTR uv0$5[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	lea	rcx, QWORD PTR uv1$4[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 2282 :         atlas->CalcCustomRectUV(&r, &uv0, &uv1);

	lea	r9, QWORD PTR uv1$4[rsp]
	lea	r8, QWORD PTR uv0$5[rsp]
	mov	rdx, QWORD PTR r$1[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	call	?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z ; ImFontAtlas::CalcCustomRectUV

; 2283 :         r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);

	mov	rax, QWORD PTR r$1[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv148[rsp], rax
	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+14]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR r$1[rsp]
	movss	xmm1, DWORD PTR [rax+20]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR r$1[rsp]
	movzx	eax, WORD PTR [rax+12]
	cvtsi2ss xmm1, eax
	mov	rax, QWORD PTR r$1[rsp]
	movss	xmm2, DWORD PTR [rax+16]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR r$1[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movss	DWORD PTR [rsp+80], xmm2
	movss	xmm2, DWORD PTR uv1$4[rsp+4]
	movss	DWORD PTR [rsp+72], xmm2
	movss	xmm2, DWORD PTR uv1$4[rsp]
	movss	DWORD PTR [rsp+64], xmm2
	movss	xmm2, DWORD PTR uv0$5[rsp+4]
	movss	DWORD PTR [rsp+56], xmm2
	movss	xmm2, DWORD PTR uv0$5[rsp]
	movss	DWORD PTR [rsp+48], xmm2
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm1
	mov	rax, QWORD PTR r$1[rsp]
	movss	xmm3, DWORD PTR [rax+20]
	mov	rax, QWORD PTR r$1[rsp]
	movss	xmm2, DWORD PTR [rax+16]
	mov	rax, QWORD PTR r$1[rsp]
	movzx	edx, WORD PTR [rax+8]
	mov	rcx, QWORD PTR tv148[rsp]
	call	?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z	; ImFont::AddGlyph
	npad	1

; 2284 :     }

	jmp	$LN2@ImFontAtla
$LN3@ImFontAtla:

; 2285 : 
; 2286 :     // Build all fonts lookup tables
; 2287 :     for (int i = 0; i < atlas->Fonts.Size; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+72]
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN6@ImFontAtla

; 2288 :         if (atlas->Fonts[i]->DirtyLookupTables)

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv158[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv158[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+112]
	test	eax, eax
	je	SHORT $LN10@ImFontAtla

; 2289 :             atlas->Fonts[i]->BuildLookupTable();

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv167[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv167[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rcx, QWORD PTR [rax]
	call	?BuildLookupTable@ImFont@@QEAAXXZ	; ImFont::BuildLookupTable
	npad	1
$LN10@ImFontAtla:
	jmp	SHORT $LN5@ImFontAtla
$LN6@ImFontAtla:

; 2290 : }

	add	rsp, 168				; 000000a8H
	ret	0
?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z ENDP	; ImFontAtlasBuildFinish
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
tv89 = 40
tv131 = 42
tv154 = 44
tv164 = 46
pack_rects$ = 48
user_rects$ = 64
tv171 = 72
tv184 = 76
tv182 = 80
pack_context$ = 88
atlas$ = 112
stbrp_context_opaque$ = 120
?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z PROC ; ImFontAtlasBuildPackCustomRects

; 2211 : {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2212 :     stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;

	mov	rax, QWORD PTR stbrp_context_opaque$[rsp]
	mov	QWORD PTR pack_context$[rsp], rax

; 2213 :     IM_ASSERT(pack_context != NULL);
; 2214 : 
; 2215 :     ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR user_rects$[rsp], rax

; 2216 :     IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
; 2217 : 
; 2218 :     ImVector<stbrp_rect> pack_rects;

	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::ImVector<stbrp_rect>
	npad	1

; 2219 :     pack_rects.resize(user_rects.Size);

	mov	rax, QWORD PTR user_rects$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ; ImVector<stbrp_rect>::resize

; 2220 :     memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());

	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ; ImVector<stbrp_rect>::size_in_bytes
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR pack_rects$[rsp+8]
	call	memset
	npad	1

; 2221 :     for (int i = 0; i < user_rects.Size; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@ImFontAtla:
	mov	rax, QWORD PTR user_rects$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN3@ImFontAtla

; 2222 :     {
; 2223 :         pack_rects[i].w = user_rects[i].Width;

	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR user_rects$[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	movzx	eax, WORD PTR [rax+12]
	mov	WORD PTR tv89[rsp], ax
	mov	edx, DWORD PTR i$2[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	movzx	ecx, WORD PTR tv89[rsp]
	mov	WORD PTR [rax+4], cx

; 2224 :         pack_rects[i].h = user_rects[i].Height;

	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR user_rects$[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	movzx	eax, WORD PTR [rax+14]
	mov	WORD PTR tv131[rsp], ax
	mov	edx, DWORD PTR i$2[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	movzx	ecx, WORD PTR tv131[rsp]
	mov	WORD PTR [rax+6], cx

; 2225 :     }

	jmp	SHORT $LN2@ImFontAtla
$LN3@ImFontAtla:

; 2226 :     stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);

	xor	edx, edx
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	mov	r8d, DWORD PTR pack_rects$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR pack_context$[rsp]
	call	stbrp_pack_rects
	npad	1

; 2227 :     for (int i = 0; i < pack_rects.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@ImFontAtla:
	mov	eax, DWORD PTR pack_rects$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN6@ImFontAtla

; 2228 :         if (pack_rects[i].was_packed)

	mov	edx, DWORD PTR i$1[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	cmp	DWORD PTR [rax+12], 0
	je	$LN8@ImFontAtla

; 2229 :         {
; 2230 :             user_rects[i].X = pack_rects[i].x;

	mov	edx, DWORD PTR i$1[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	movzx	eax, WORD PTR [rax+8]
	mov	WORD PTR tv154[rsp], ax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR user_rects$[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	movzx	ecx, WORD PTR tv154[rsp]
	mov	WORD PTR [rax], cx

; 2231 :             user_rects[i].Y = pack_rects[i].y;

	mov	edx, DWORD PTR i$1[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	movzx	eax, WORD PTR [rax+10]
	mov	WORD PTR tv164[rsp], ax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR user_rects$[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	movzx	ecx, WORD PTR tv164[rsp]
	mov	WORD PTR [rax+2], cx

; 2232 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
; 2233 :             atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);

	mov	edx, DWORD PTR i$1[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	movzx	eax, WORD PTR [rax+10]
	mov	DWORD PTR tv171[rsp], eax
	mov	edx, DWORD PTR i$1[rsp]
	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	movzx	eax, WORD PTR [rax+6]
	mov	ecx, DWORD PTR tv171[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv184[rsp], eax
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv182[rsp], eax
	mov	edx, DWORD PTR tv184[rsp]
	mov	ecx, DWORD PTR tv182[rsp]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rcx+28], eax
$LN8@ImFontAtla:

; 2234 :         }

	jmp	$LN5@ImFontAtla
$LN6@ImFontAtla:

; 2235 : }

	lea	rcx, QWORD PTR pack_rects$[rsp]
	call	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
	npad	1
	add	rsp, 104				; 00000068H
	ret	0
?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ENDP ; ImFontAtlasBuildPackCustomRects
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
i$2 = 36
tv89 = 40
tv131 = 42
tv154 = 44
tv164 = 46
pack_rects$ = 48
user_rects$ = 64
tv171 = 72
tv184 = 76
tv182 = 80
pack_context$ = 88
atlas$ = 112
stbrp_context_opaque$ = 120
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA PROC ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR pack_rects$[rbp]
	call	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA ENDP ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 48
font$ = 56
font_config$ = 64
ascent$ = 72
descent$ = 80
?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z PROC ; ImFontAtlasBuildSetupFont

; 2197 : {

$LN4:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2198 :     if (!font_config->MergeMode)

	mov	rax, QWORD PTR font_config$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	test	eax, eax
	jne	SHORT $LN2@ImFontAtla

; 2199 :     {
; 2200 :         font->ClearOutputData();

	mov	rcx, QWORD PTR font$[rsp]
	call	?ClearOutputData@ImFont@@QEAAXXZ	; ImFont::ClearOutputData

; 2201 :         font->FontSize = font_config->SizePixels;

	mov	rax, QWORD PTR font$[rsp]
	mov	rcx, QWORD PTR font_config$[rsp]
	movss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR [rax+20], xmm0

; 2202 :         font->ConfigData = font_config;

	mov	rax, QWORD PTR font$[rsp]
	mov	rcx, QWORD PTR font_config$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 2203 :         font->ContainerAtlas = atlas;

	mov	rax, QWORD PTR font$[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 2204 :         font->Ascent = ascent;

	mov	rax, QWORD PTR font$[rsp]
	movss	xmm0, DWORD PTR ascent$[rsp]
	movss	DWORD PTR [rax+84], xmm0

; 2205 :         font->Descent = descent;

	mov	rax, QWORD PTR font$[rsp]
	movss	xmm0, DWORD PTR descent$[rsp]
	movss	DWORD PTR [rax+88], xmm0
$LN2@ImFontAtla:

; 2206 :     }
; 2207 :     font->ConfigDataCount++;

	mov	rax, QWORD PTR font$[rsp]
	movzx	eax, WORD PTR [rax+104]
	inc	ax
	mov	rcx, QWORD PTR font$[rsp]
	mov	WORD PTR [rcx+104], ax

; 2208 : }

	add	rsp, 40					; 00000028H
	ret	0
?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ENDP ; ImFontAtlasBuildSetupFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 48
?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRegisterDefaultCustomRects

; 2187 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2188 :     if (atlas->CustomRectIds[0] >= 0)

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR atlas$[rsp]
	cmp	DWORD PTR [rcx+rax+120], 0
	jl	SHORT $LN2@ImFontAtla

; 2189 :         return;

	jmp	SHORT $LN1@ImFontAtla
$LN2@ImFontAtla:

; 2190 :     if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN3@ImFontAtla

; 2191 :         atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);

	mov	r9d, 27
	mov	r8d, 217				; 000000d9H
	mov	edx, -2147483648			; 80000000H
	mov	rcx, QWORD PTR atlas$[rsp]
	call	?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z ; ImFontAtlas::AddCustomRectRegular
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rdx+rcx+120], eax
	jmp	SHORT $LN4@ImFontAtla
$LN3@ImFontAtla:

; 2192 :     else
; 2193 :         atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);

	mov	r9d, 2
	mov	r8d, 2
	mov	edx, -2147483648			; 80000000H
	mov	rcx, QWORD PTR atlas$[rsp]
	call	?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z ; ImFontAtlas::AddCustomRectRegular
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rdx+rcx+120], eax
$LN4@ImFontAtla:
$LN1@ImFontAtla:

; 2194 : }

	add	rsp, 40					; 00000028H
	ret	0
?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRegisterDefaultCustomRects
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
src_tmp$1 = 96
glyph_i$2 = 104
$T3 = 108
$T4 = 109
$T5 = 110
codepoint$6 = 112
glyph_i$7 = 116
glyph_i$8 = 120
src_i$9 = 124
output_i$10 = 128
src_i$11 = 132
src_i$12 = 136
src_i$13 = 140
src_tmp$14 = 144
cfg$15 = 152
src_tmp_array$ = 160
src_i$16 = 176
src_i$17 = 180
dst_i$18 = 184
total_glyphs_count$ = 188
src_i$19 = 192
src_i$20 = 196
char_off_x$21 = 200
char_advance_x_org$22 = 204
char_advance_x_mod$23 = 208
cfg$24 = 216
src_tmp$25 = 224
buf_rects_out_n$ = 232
buf_packedchars_out_n$ = 236
total_surface$ = 240
surface_sqrt$ = 244
glyph_i$26 = 248
src_tmp$27 = 256
src_tmp$28 = 264
src_tmp$29 = 272
r$30 = 280
dst_tmp$31 = 288
cfg$32 = 296
src_range$33 = 304
tv527 = 312
tv528 = 316
tv529 = 320
tv593 = 324
unscaled_ascent$34 = 328
tv739 = 332
unscaled_descent$35 = 336
font_scale$36 = 340
tv798 = 344
font_off_y$37 = 348
tv748 = 352
tv441 = 356
scale$38 = 360
src_range$39 = 368
src_tmp$40 = 376
padding$41 = 384
dst_tmp_array$ = 392
dst_tmp$42 = 408
ascent$43 = 416
descent$44 = 420
y1$45 = 424
y0$46 = 428
x1$47 = 432
dummy_y$48 = 436
x0$49 = 440
glyph_index_in_font$50 = 444
font_offset$51 = 448
dummy_x$52 = 452
tv823 = 456
codepoint$53 = 460
dst_font$54 = 464
font_off_x$55 = 472
buf_rects$ = 480
cfg$56 = 496
tv192 = 504
buf_packedchars$ = 512
tv236 = 528
tv249 = 536
tv273 = 544
tv294 = 552
tv300 = 560
tv312 = 568
tv405 = 576
tv453 = 584
tv630 = 592
tv722 = 600
tv775 = 608
pc$57 = 616
TEX_HEIGHT_MAX$ = 624
unscaled_line_gap$58 = 628
tv867 = 632
tv151 = 640
tv165 = 648
$T59 = 656
$T60 = 664
$T61 = 672
spc$ = 688
q$62 = 752
multiply_table$63 = 784
__$ArrayPad$ = 1040
atlas$ = 1072
?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildWithStbTruetype

; 1931 : {

$LN94:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 1056				; 00000420H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1932 :     IM_ASSERT(atlas->ConfigData.Size > 0);
; 1933 : 
; 1934 :     ImFontAtlasBuildRegisterDefaultCustomRects(atlas);

	mov	rcx, QWORD PTR atlas$[rsp]
	call	?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRegisterDefaultCustomRects

; 1935 : 
; 1936 :     // Clear atlas
; 1937 :     atlas->TexID = (ImTextureID)NULL;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1938 :     atlas->TexWidth = atlas->TexHeight = 0;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rax+28], 0
	mov	rax, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1939 :     atlas->TexUvScale = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T61[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 1940 :     atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T59[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 1941 :     atlas->ClearTexData();

	mov	rcx, QWORD PTR atlas$[rsp]
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData

; 1942 : 
; 1943 :     // Temporary storage for building
; 1944 :     ImVector<ImFontBuildSrcData> src_tmp_array;

	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
	npad	1

; 1945 :     ImVector<ImFontBuildDstData> dst_tmp_array;

	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
	npad	1

; 1946 :     src_tmp_array.resize(atlas->ConfigData.Size);

	mov	rax, QWORD PTR atlas$[rsp]
	mov	edx, DWORD PTR [rax+104]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::resize

; 1947 :     dst_tmp_array.resize(atlas->Fonts.Size);

	mov	rax, QWORD PTR atlas$[rsp]
	mov	edx, DWORD PTR [rax+72]
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::resize

; 1948 :     memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());

	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ; ImVector<ImFontBuildSrcData>::size_in_bytes
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR src_tmp_array$[rsp+8]
	call	memset

; 1949 :     memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ; ImVector<ImFontBuildDstData>::size_in_bytes
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR dst_tmp_array$[rsp+8]
	call	memset
	npad	1

; 1950 : 
; 1951 :     // 1. Initialize font loading structure, check font data validity
; 1952 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

	mov	DWORD PTR src_i$9[rsp], 0
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR src_i$9[rsp]
	inc	eax
	mov	DWORD PTR src_i$9[rsp], eax
$LN4@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+104]
	cmp	DWORD PTR src_i$9[rsp], eax
	jge	$LN3@ImFontAtla

; 1953 :     {
; 1954 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$9[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$14[rsp], rax

; 1955 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv151[rsp], rax
	mov	edx, DWORD PTR src_i$9[rsp]
	mov	rcx, QWORD PTR tv151[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	mov	QWORD PTR cfg$32[rsp], rax

; 1956 :         IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
; 1957 : 
; 1958 :         // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
; 1959 :         src_tmp.DstIndex = -1;

	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	DWORD PTR [rax+224], -1

; 1960 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

	mov	DWORD PTR output_i$10[rsp], 0
	jmp	SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
	mov	eax, DWORD PTR output_i$10[rsp]
	inc	eax
	mov	DWORD PTR output_i$10[rsp], eax
$LN7@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+72]
	cmp	DWORD PTR output_i$10[rsp], eax
	jge	SHORT $LN6@ImFontAtla
	mov	rax, QWORD PTR src_tmp$14[rsp]
	cmp	DWORD PTR [rax+224], -1
	jne	SHORT $LN6@ImFontAtla

; 1961 :             if (cfg.DstFont == atlas->Fonts[output_i])

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv165[rsp], rax
	mov	edx, DWORD PTR output_i$10[rsp]
	mov	rcx, QWORD PTR tv165[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rcx, QWORD PTR cfg$32[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR [rcx+120], rax
	jne	SHORT $LN53@ImFontAtla

; 1962 :                 src_tmp.DstIndex = output_i;

	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	ecx, DWORD PTR output_i$10[rsp]
	mov	DWORD PTR [rax+224], ecx
$LN53@ImFontAtla:
	jmp	$LN5@ImFontAtla
$LN6@ImFontAtla:

; 1963 :         IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
; 1964 :         if (src_tmp.DstIndex == -1)

	mov	rax, QWORD PTR src_tmp$14[rsp]
	cmp	DWORD PTR [rax+224], -1
	jne	SHORT $LN54@ImFontAtla

; 1965 :             return false;

	mov	BYTE PTR $T3[rsp], 0
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
	npad	1
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
	movzx	eax, BYTE PTR $T3[rsp]
	jmp	$LN1@ImFontAtla
$LN54@ImFontAtla:

; 1966 : 
; 1967 :         // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
; 1968 :         const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);

	mov	rax, QWORD PTR cfg$32[rsp]
	mov	edx, DWORD PTR [rax+44]
	mov	rax, QWORD PTR cfg$32[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	stbtt_GetFontOffsetForIndex
	mov	DWORD PTR font_offset$51[rsp], eax

; 1969 :         IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
; 1970 :         if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	r8d, DWORD PTR font_offset$51[rsp]
	mov	rcx, QWORD PTR cfg$32[rsp]
	mov	rdx, QWORD PTR [rcx+24]
	mov	rcx, rax
	call	stbtt_InitFont
	test	eax, eax
	jne	SHORT $LN55@ImFontAtla

; 1971 :             return false;

	mov	BYTE PTR $T4[rsp], 0
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
	npad	1
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
	movzx	eax, BYTE PTR $T4[rsp]
	jmp	$LN1@ImFontAtla
$LN55@ImFontAtla:

; 1972 : 
; 1973 :         // Measure highest codepoints
; 1974 :         ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];

	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	edx, DWORD PTR [rax+224]
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
	mov	QWORD PTR dst_tmp$42[rsp], rax

; 1975 :         src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();

	mov	rax, QWORD PTR cfg$32[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN70@ImFontAtla
	mov	rax, QWORD PTR cfg$32[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR tv192[rsp], rax
	jmp	SHORT $LN71@ImFontAtla
$LN70@ImFontAtla:
	mov	rcx, QWORD PTR atlas$[rsp]
	call	?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ ; ImFontAtlas::GetGlyphRangesDefault
	mov	QWORD PTR tv192[rsp], rax
$LN71@ImFontAtla:
	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	rcx, QWORD PTR tv192[rsp]
	mov	QWORD PTR [rax+216], rcx

; 1976 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	rax, QWORD PTR [rax+216]
	mov	QWORD PTR src_range$39[rsp], rax
	jmp	SHORT $LN10@ImFontAtla
$LN8@ImFontAtla:
	mov	rax, QWORD PTR src_range$39[rsp]
	add	rax, 4
	mov	QWORD PTR src_range$39[rsp], rax
$LN10@ImFontAtla:
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src_range$39[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@ImFontAtla
	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR src_range$39[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@ImFontAtla

; 1977 :             src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR src_range$39[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	edx, eax
	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	ecx, DWORD PTR [rax+228]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	rcx, QWORD PTR src_tmp$14[rsp]
	mov	DWORD PTR [rcx+228], eax
	jmp	SHORT $LN8@ImFontAtla
$LN9@ImFontAtla:

; 1978 :         dst_tmp.SrcCount++;

	mov	rax, QWORD PTR dst_tmp$42[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR dst_tmp$42[rsp]
	mov	DWORD PTR [rcx], eax

; 1979 :         dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);

	mov	rax, QWORD PTR src_tmp$14[rsp]
	mov	edx, DWORD PTR [rax+228]
	mov	rax, QWORD PTR dst_tmp$42[rsp]
	mov	ecx, DWORD PTR [rax+4]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	rcx, QWORD PTR dst_tmp$42[rsp]
	mov	DWORD PTR [rcx+4], eax

; 1980 :     }

	jmp	$LN2@ImFontAtla
$LN3@ImFontAtla:

; 1981 : 
; 1982 :     // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
; 1983 :     int total_glyphs_count = 0;

	mov	DWORD PTR total_glyphs_count$[rsp], 0

; 1984 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$16[rsp], 0
	jmp	SHORT $LN13@ImFontAtla
$LN11@ImFontAtla:
	mov	eax, DWORD PTR src_i$16[rsp]
	inc	eax
	mov	DWORD PTR src_i$16[rsp], eax
$LN13@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$16[rsp], eax
	jge	$LN12@ImFontAtla

; 1985 :     {
; 1986 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$16[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$25[rsp], rax

; 1987 :         ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];

	mov	rax, QWORD PTR src_tmp$25[rsp]
	mov	edx, DWORD PTR [rax+224]
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
	mov	QWORD PTR dst_tmp$31[rsp], rax

; 1988 :         src_tmp.GlyphsSet.Resize(src_tmp.GlyphsHighest + 1);

	mov	rax, QWORD PTR src_tmp$25[rsp]
	add	rax, 240				; 000000f0H
	mov	QWORD PTR tv236[rsp], rax
	mov	rax, QWORD PTR src_tmp$25[rsp]
	mov	eax, DWORD PTR [rax+228]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv236[rsp]
	call	?Resize@ImBoolVector@@QEAAXH@Z		; ImBoolVector::Resize
	npad	1

; 1989 :         if (dst_tmp.GlyphsSet.Storage.empty())

	mov	rax, QWORD PTR dst_tmp$31[rsp]
	add	rax, 16
	mov	rcx, rax
	call	?empty@?$ImVector@H@@QEBA_NXZ		; ImVector<int>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@ImFontAtla

; 1990 :             dst_tmp.GlyphsSet.Resize(dst_tmp.GlyphsHighest + 1);

	mov	rax, QWORD PTR dst_tmp$31[rsp]
	add	rax, 16
	mov	QWORD PTR tv249[rsp], rax
	mov	rax, QWORD PTR dst_tmp$31[rsp]
	mov	eax, DWORD PTR [rax+4]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv249[rsp]
	call	?Resize@ImBoolVector@@QEAAXH@Z		; ImBoolVector::Resize
	npad	1
$LN56@ImFontAtla:

; 1991 : 
; 1992 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

	mov	rax, QWORD PTR src_tmp$25[rsp]
	mov	rax, QWORD PTR [rax+216]
	mov	QWORD PTR src_range$33[rsp], rax
	jmp	SHORT $LN16@ImFontAtla
$LN14@ImFontAtla:
	mov	rax, QWORD PTR src_range$33[rsp]
	add	rax, 4
	mov	QWORD PTR src_range$33[rsp], rax
$LN16@ImFontAtla:
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src_range$33[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	je	$LN15@ImFontAtla
	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR src_range$33[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	je	$LN15@ImFontAtla

; 1993 :             for (int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src_range$33[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR codepoint$6[rsp], eax
	jmp	SHORT $LN19@ImFontAtla
$LN17@ImFontAtla:
	mov	eax, DWORD PTR codepoint$6[rsp]
	inc	eax
	mov	DWORD PTR codepoint$6[rsp], eax
$LN19@ImFontAtla:
	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR src_range$33[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	cmp	DWORD PTR codepoint$6[rsp], eax
	jg	$LN18@ImFontAtla

; 1994 :             {
; 1995 :                 if (dst_tmp.GlyphsSet.GetBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)

	mov	rax, QWORD PTR dst_tmp$31[rsp]
	add	rax, 16
	mov	QWORD PTR tv273[rsp], rax
	mov	edx, DWORD PTR codepoint$6[rsp]
	mov	rcx, QWORD PTR tv273[rsp]
	call	?GetBit@ImBoolVector@@QEBA_NH@Z		; ImBoolVector::GetBit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@ImFontAtla

; 1996 :                     continue;

	jmp	SHORT $LN17@ImFontAtla
$LN57@ImFontAtla:

; 1997 :                 if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?

	mov	rax, QWORD PTR src_tmp$25[rsp]
	mov	edx, DWORD PTR codepoint$6[rsp]
	mov	rcx, rax
	call	stbtt_FindGlyphIndex
	test	eax, eax
	jne	SHORT $LN58@ImFontAtla

; 1998 :                     continue;

	jmp	SHORT $LN17@ImFontAtla
$LN58@ImFontAtla:

; 1999 : 
; 2000 :                 // Add to avail set/counters
; 2001 :                 src_tmp.GlyphsCount++;

	mov	rax, QWORD PTR src_tmp$25[rsp]
	mov	eax, DWORD PTR [rax+232]
	inc	eax
	mov	rcx, QWORD PTR src_tmp$25[rsp]
	mov	DWORD PTR [rcx+232], eax

; 2002 :                 dst_tmp.GlyphsCount++;

	mov	rax, QWORD PTR dst_tmp$31[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR dst_tmp$31[rsp]
	mov	DWORD PTR [rcx+8], eax

; 2003 :                 src_tmp.GlyphsSet.SetBit(codepoint, true);

	mov	rax, QWORD PTR src_tmp$25[rsp]
	add	rax, 240				; 000000f0H
	mov	QWORD PTR tv294[rsp], rax
	mov	r8b, 1
	mov	edx, DWORD PTR codepoint$6[rsp]
	mov	rcx, QWORD PTR tv294[rsp]
	call	?SetBit@ImBoolVector@@QEAAXH_N@Z	; ImBoolVector::SetBit

; 2004 :                 dst_tmp.GlyphsSet.SetBit(codepoint, true);

	mov	rax, QWORD PTR dst_tmp$31[rsp]
	add	rax, 16
	mov	QWORD PTR tv300[rsp], rax
	mov	r8b, 1
	mov	edx, DWORD PTR codepoint$6[rsp]
	mov	rcx, QWORD PTR tv300[rsp]
	call	?SetBit@ImBoolVector@@QEAAXH_N@Z	; ImBoolVector::SetBit

; 2005 :                 total_glyphs_count++;

	mov	eax, DWORD PTR total_glyphs_count$[rsp]
	inc	eax
	mov	DWORD PTR total_glyphs_count$[rsp], eax

; 2006 :             }

	jmp	$LN17@ImFontAtla
$LN18@ImFontAtla:
	jmp	$LN14@ImFontAtla
$LN15@ImFontAtla:

; 2007 :     }

	jmp	$LN11@ImFontAtla
$LN12@ImFontAtla:

; 2008 : 
; 2009 :     // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
; 2010 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$17[rsp], 0
	jmp	SHORT $LN22@ImFontAtla
$LN20@ImFontAtla:
	mov	eax, DWORD PTR src_i$17[rsp]
	inc	eax
	mov	DWORD PTR src_i$17[rsp], eax
$LN22@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$17[rsp], eax
	jge	$LN21@ImFontAtla

; 2011 :     {
; 2012 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$17[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$40[rsp], rax

; 2013 :         src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);

	mov	rax, QWORD PTR src_tmp$40[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv312[rsp], rax
	mov	rax, QWORD PTR src_tmp$40[rsp]
	mov	edx, DWORD PTR [rax+232]
	mov	rcx, QWORD PTR tv312[rsp]
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve

; 2014 :         UnpackBoolVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);

	mov	rax, QWORD PTR src_tmp$40[rsp]
	add	rax, 256				; 00000100H
	mov	rcx, QWORD PTR src_tmp$40[rsp]
	add	rcx, 240				; 000000f0H
	mov	rdx, rax
	call	?UnpackBoolVectorToFlatIndexList@@YAXPEBUImBoolVector@@PEAU?$ImVector@H@@@Z ; UnpackBoolVectorToFlatIndexList

; 2015 :         src_tmp.GlyphsSet.Clear();

	mov	rax, QWORD PTR src_tmp$40[rsp]
	add	rax, 240				; 000000f0H
	mov	rcx, rax
	call	?Clear@ImBoolVector@@QEAAXXZ		; ImBoolVector::Clear
	npad	1

; 2016 :         IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
; 2017 :     }

	jmp	$LN20@ImFontAtla
$LN21@ImFontAtla:

; 2018 :     for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)

	mov	DWORD PTR dst_i$18[rsp], 0
	jmp	SHORT $LN25@ImFontAtla
$LN23@ImFontAtla:
	mov	eax, DWORD PTR dst_i$18[rsp]
	inc	eax
	mov	DWORD PTR dst_i$18[rsp], eax
$LN25@ImFontAtla:
	mov	eax, DWORD PTR dst_tmp_array$[rsp]
	cmp	DWORD PTR dst_i$18[rsp], eax
	jge	SHORT $LN24@ImFontAtla

; 2019 :         dst_tmp_array[dst_i].GlyphsSet.Clear();

	mov	edx, DWORD PTR dst_i$18[rsp]
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
	add	rax, 16
	mov	rcx, rax
	call	?Clear@ImBoolVector@@QEAAXXZ		; ImBoolVector::Clear
	npad	1
	jmp	SHORT $LN23@ImFontAtla
$LN24@ImFontAtla:

; 2020 :     dst_tmp_array.clear();

	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ; ImVector<ImFontBuildDstData>::clear

; 2021 : 
; 2022 :     // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
; 2023 :     // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
; 2024 :     ImVector<stbrp_rect> buf_rects;

	lea	rcx, QWORD PTR buf_rects$[rsp]
	call	??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::ImVector<stbrp_rect>
	npad	1

; 2025 :     ImVector<stbtt_packedchar> buf_packedchars;

	lea	rcx, QWORD PTR buf_packedchars$[rsp]
	call	??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
	npad	1

; 2026 :     buf_rects.resize(total_glyphs_count);

	mov	edx, DWORD PTR total_glyphs_count$[rsp]
	lea	rcx, QWORD PTR buf_rects$[rsp]
	call	?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ; ImVector<stbrp_rect>::resize

; 2027 :     buf_packedchars.resize(total_glyphs_count);

	mov	edx, DWORD PTR total_glyphs_count$[rsp]
	lea	rcx, QWORD PTR buf_packedchars$[rsp]
	call	?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::resize

; 2028 :     memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());

	lea	rcx, QWORD PTR buf_rects$[rsp]
	call	?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ; ImVector<stbrp_rect>::size_in_bytes
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR buf_rects$[rsp+8]
	call	memset

; 2029 :     memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

	lea	rcx, QWORD PTR buf_packedchars$[rsp]
	call	?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ; ImVector<stbtt_packedchar>::size_in_bytes
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR buf_packedchars$[rsp+8]
	call	memset

; 2030 : 
; 2031 :     // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
; 2032 :     int total_surface = 0;

	mov	DWORD PTR total_surface$[rsp], 0

; 2033 :     int buf_rects_out_n = 0;

	mov	DWORD PTR buf_rects_out_n$[rsp], 0

; 2034 :     int buf_packedchars_out_n = 0;

	mov	DWORD PTR buf_packedchars_out_n$[rsp], 0

; 2035 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$11[rsp], 0
	jmp	SHORT $LN28@ImFontAtla
$LN26@ImFontAtla:
	mov	eax, DWORD PTR src_i$11[rsp]
	inc	eax
	mov	DWORD PTR src_i$11[rsp], eax
$LN28@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$11[rsp], eax
	jge	$LN27@ImFontAtla

; 2036 :     {
; 2037 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$11[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$1[rsp], rax

; 2038 :         if (src_tmp.GlyphsCount == 0)

	mov	rax, QWORD PTR src_tmp$1[rsp]
	cmp	DWORD PTR [rax+232], 0
	jne	SHORT $LN59@ImFontAtla

; 2039 :             continue;

	jmp	SHORT $LN26@ImFontAtla
$LN59@ImFontAtla:

; 2040 : 
; 2041 :         src_tmp.Rects = &buf_rects[buf_rects_out_n];

	mov	edx, DWORD PTR buf_rects_out_n$[rsp]
	lea	rcx, QWORD PTR buf_rects$[rsp]
	call	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	QWORD PTR [rcx+200], rax

; 2042 :         src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];

	mov	edx, DWORD PTR buf_packedchars_out_n$[rsp]
	lea	rcx, QWORD PTR buf_packedchars$[rsp]
	call	??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ; ImVector<stbtt_packedchar>::operator[]
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	QWORD PTR [rcx+208], rax

; 2043 :         buf_rects_out_n += src_tmp.GlyphsCount;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	eax, DWORD PTR [rax+232]
	mov	ecx, DWORD PTR buf_rects_out_n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR buf_rects_out_n$[rsp], eax

; 2044 :         buf_packedchars_out_n += src_tmp.GlyphsCount;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	eax, DWORD PTR [rax+232]
	mov	ecx, DWORD PTR buf_packedchars_out_n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR buf_packedchars_out_n$[rsp], eax

; 2045 : 
; 2046 :         // Convert our ranges in the format stb_truetype wants
; 2047 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv405[rsp], rax
	mov	edx, DWORD PTR src_i$11[rsp]
	mov	rcx, QWORD PTR tv405[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	mov	QWORD PTR cfg$15[rsp], rax

; 2048 :         src_tmp.PackRange.font_size = cfg.SizePixels;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR cfg$15[rsp]
	movss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR [rax+160], xmm0

; 2049 :         src_tmp.PackRange.first_unicode_codepoint_in_range = 0;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	DWORD PTR [rax+164], 0

; 2050 :         src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR [rcx+264]
	mov	QWORD PTR [rax+168], rcx

; 2051 :         src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	ecx, DWORD PTR [rcx+256]
	mov	DWORD PTR [rax+176], ecx

; 2052 :         src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR [rcx+208]
	mov	QWORD PTR [rax+184], rcx

; 2053 :         src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR cfg$15[rsp]
	movzx	ecx, BYTE PTR [rcx+52]
	mov	BYTE PTR [rax+192], cl

; 2054 :         src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR cfg$15[rsp]
	movzx	ecx, BYTE PTR [rcx+4]
	mov	BYTE PTR [rax+193], cl

; 2055 : 
; 2056 :         // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
; 2057 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

	mov	rax, QWORD PTR cfg$15[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN72@ImFontAtla
	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR cfg$15[rsp]
	movss	xmm1, DWORD PTR [rcx+48]
	mov	rcx, rax
	call	stbtt_ScaleForPixelHeight
	movss	DWORD PTR tv441[rsp], xmm0
	jmp	SHORT $LN73@ImFontAtla
$LN72@ImFontAtla:
	mov	rax, QWORD PTR cfg$15[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rax, QWORD PTR src_tmp$1[rsp]
	movaps	xmm1, xmm0
	mov	rcx, rax
	call	stbtt_ScaleForMappingEmToPixels
	movss	DWORD PTR tv441[rsp], xmm0
$LN73@ImFontAtla:
	movss	xmm0, DWORD PTR tv441[rsp]
	movss	DWORD PTR scale$38[rsp], xmm0

; 2058 :         const int padding = atlas->TexGlyphPadding;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR padding$41[rsp], eax

; 2059 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)

	mov	DWORD PTR glyph_i$2[rsp], 0
	jmp	SHORT $LN31@ImFontAtla
$LN29@ImFontAtla:
	mov	eax, DWORD PTR glyph_i$2[rsp]
	inc	eax
	mov	DWORD PTR glyph_i$2[rsp], eax
$LN31@ImFontAtla:
	mov	rax, QWORD PTR src_tmp$1[rsp]
	mov	eax, DWORD PTR [rax+256]
	cmp	DWORD PTR glyph_i$2[rsp], eax
	jge	$LN30@ImFontAtla

; 2060 :         {
; 2061 :             int x0, y0, x1, y1;
; 2062 :             const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);

	mov	rax, QWORD PTR src_tmp$1[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv453[rsp], rax
	mov	edx, DWORD PTR glyph_i$2[rsp]
	mov	rcx, QWORD PTR tv453[rsp]
	call	??A?$ImVector@H@@QEAAAEAHH@Z		; ImVector<int>::operator[]
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	edx, DWORD PTR [rax]
	call	stbtt_FindGlyphIndex
	mov	DWORD PTR glyph_index_in_font$50[rsp], eax

; 2063 :             IM_ASSERT(glyph_index_in_font != 0);
; 2064 :             stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);

	mov	rax, QWORD PTR cfg$15[rsp]
	cvtsi2ss xmm0, DWORD PTR [rax+4]
	movss	xmm1, DWORD PTR scale$38[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR cfg$15[rsp]
	cvtsi2ss xmm1, DWORD PTR [rax+52]
	movss	xmm2, DWORD PTR scale$38[rsp]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR src_tmp$1[rsp]
	lea	rcx, QWORD PTR y1$45[rsp]
	mov	QWORD PTR [rsp+72], rcx
	lea	rcx, QWORD PTR x1$47[rsp]
	mov	QWORD PTR [rsp+64], rcx
	lea	rcx, QWORD PTR y0$46[rsp]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR x0$49[rsp]
	mov	QWORD PTR [rsp+48], rcx
	xorps	xmm2, xmm2
	movss	DWORD PTR [rsp+40], xmm2
	xorps	xmm2, xmm2
	movss	DWORD PTR [rsp+32], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	mov	edx, DWORD PTR glyph_index_in_font$50[rsp]
	mov	rcx, rax
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 2065 :             src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);

	mov	eax, DWORD PTR x0$49[rsp]
	mov	ecx, DWORD PTR x1$47[rsp]
	sub	ecx, eax
	mov	eax, ecx
	add	eax, DWORD PTR padding$41[rsp]
	mov	rcx, QWORD PTR cfg$15[rsp]
	mov	ecx, DWORD PTR [rcx+52]
	lea	eax, DWORD PTR [rax+rcx-1]
	movsxd	rcx, DWORD PTR glyph_i$2[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR src_tmp$1[rsp]
	mov	rdx, QWORD PTR [rdx+200]
	mov	WORD PTR [rdx+rcx+4], ax

; 2066 :             src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);

	mov	eax, DWORD PTR y0$46[rsp]
	mov	ecx, DWORD PTR y1$45[rsp]
	sub	ecx, eax
	mov	eax, ecx
	add	eax, DWORD PTR padding$41[rsp]
	mov	rcx, QWORD PTR cfg$15[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	lea	eax, DWORD PTR [rax+rcx-1]
	movsxd	rcx, DWORD PTR glyph_i$2[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR src_tmp$1[rsp]
	mov	rdx, QWORD PTR [rdx+200]
	mov	WORD PTR [rdx+rcx+6], ax

; 2067 :             total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;

	movsxd	rax, DWORD PTR glyph_i$2[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR src_tmp$1[rsp]
	mov	rcx, QWORD PTR [rcx+200]
	movzx	eax, WORD PTR [rcx+rax+4]
	movsxd	rcx, DWORD PTR glyph_i$2[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR src_tmp$1[rsp]
	mov	rdx, QWORD PTR [rdx+200]
	movzx	ecx, WORD PTR [rdx+rcx+6]
	imul	eax, ecx
	mov	ecx, DWORD PTR total_surface$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total_surface$[rsp], eax

; 2068 :         }

	jmp	$LN29@ImFontAtla
$LN30@ImFontAtla:

; 2069 :     }

	jmp	$LN26@ImFontAtla
$LN27@ImFontAtla:

; 2070 : 
; 2071 :     // We need a width for the skyline algorithm, any width!
; 2072 :     // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 2073 :     // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
; 2074 :     const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;

	cvtsi2ss xmm0, DWORD PTR total_surface$[rsp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	cvttss2si eax, xmm0
	inc	eax
	mov	DWORD PTR surface_sqrt$[rsp], eax

; 2075 :     atlas->TexHeight = 0;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rax+28], 0

; 2076 :     if (atlas->TexDesiredWidth > 0)

	mov	rax, QWORD PTR atlas$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jle	SHORT $LN60@ImFontAtla

; 2077 :         atlas->TexWidth = atlas->TexDesiredWidth;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+64], ecx
	jmp	$LN61@ImFontAtla
$LN60@ImFontAtla:

; 2078 :     else
; 2079 :         atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;

	cvtsi2ss xmm0, DWORD PTR surface_sqrt$[rsp]
	comiss	xmm0, DWORD PTR __real@45333333
	jb	SHORT $LN78@ImFontAtla
	mov	DWORD PTR tv529[rsp], 4096		; 00001000H
	jmp	SHORT $LN79@ImFontAtla
$LN78@ImFontAtla:
	cvtsi2ss xmm0, DWORD PTR surface_sqrt$[rsp]
	comiss	xmm0, DWORD PTR __real@44b33333
	jb	SHORT $LN76@ImFontAtla
	mov	DWORD PTR tv528[rsp], 2048		; 00000800H
	jmp	SHORT $LN77@ImFontAtla
$LN76@ImFontAtla:
	cvtsi2ss xmm0, DWORD PTR surface_sqrt$[rsp]
	comiss	xmm0, DWORD PTR __real@44333333
	jb	SHORT $LN74@ImFontAtla
	mov	DWORD PTR tv527[rsp], 1024		; 00000400H
	jmp	SHORT $LN75@ImFontAtla
$LN74@ImFontAtla:
	mov	DWORD PTR tv527[rsp], 512		; 00000200H
$LN75@ImFontAtla:
	mov	eax, DWORD PTR tv527[rsp]
	mov	DWORD PTR tv528[rsp], eax
$LN77@ImFontAtla:
	mov	eax, DWORD PTR tv528[rsp]
	mov	DWORD PTR tv529[rsp], eax
$LN79@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	ecx, DWORD PTR tv529[rsp]
	mov	DWORD PTR [rax+64], ecx
$LN61@ImFontAtla:

; 2080 : 
; 2081 :     // 5. Start packing
; 2082 :     // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
; 2083 :     const int TEX_HEIGHT_MAX = 1024 * 32;

	mov	DWORD PTR TEX_HEIGHT_MAX$[rsp], 32768	; 00008000H

; 2084 :     stbtt_pack_context spc = {};

	lea	rax, QWORD PTR spc$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 64					; 00000040H
	rep stosb

; 2085 :     stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);

	mov	QWORD PTR [rsp+48], 0
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 32768				; 00008000H
	mov	rax, QWORD PTR atlas$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	xor	edx, edx
	lea	rcx, QWORD PTR spc$[rsp]
	call	stbtt_PackBegin

; 2086 :     ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

	mov	rdx, QWORD PTR spc$[rsp+8]
	mov	rcx, QWORD PTR atlas$[rsp]
	call	?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ; ImFontAtlasBuildPackCustomRects
	npad	1

; 2087 : 
; 2088 :     // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
; 2089 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$19[rsp], 0
	jmp	SHORT $LN34@ImFontAtla
$LN32@ImFontAtla:
	mov	eax, DWORD PTR src_i$19[rsp]
	inc	eax
	mov	DWORD PTR src_i$19[rsp], eax
$LN34@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$19[rsp], eax
	jge	$LN33@ImFontAtla

; 2090 :     {
; 2091 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$19[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$27[rsp], rax

; 2092 :         if (src_tmp.GlyphsCount == 0)

	mov	rax, QWORD PTR src_tmp$27[rsp]
	cmp	DWORD PTR [rax+232], 0
	jne	SHORT $LN62@ImFontAtla

; 2093 :             continue;

	jmp	SHORT $LN32@ImFontAtla
$LN62@ImFontAtla:

; 2094 : 
; 2095 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

	mov	rax, QWORD PTR src_tmp$27[rsp]
	mov	r8d, DWORD PTR [rax+232]
	mov	rax, QWORD PTR src_tmp$27[rsp]
	mov	rdx, QWORD PTR [rax+200]
	mov	rcx, QWORD PTR spc$[rsp+8]
	call	stbrp_pack_rects
	npad	1

; 2096 : 
; 2097 :         // Extend texture height and mark missing glyphs as non-packed so we won't render them.
; 2098 :         // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
; 2099 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

	mov	DWORD PTR glyph_i$7[rsp], 0
	jmp	SHORT $LN37@ImFontAtla
$LN35@ImFontAtla:
	mov	eax, DWORD PTR glyph_i$7[rsp]
	inc	eax
	mov	DWORD PTR glyph_i$7[rsp], eax
$LN37@ImFontAtla:
	mov	rax, QWORD PTR src_tmp$27[rsp]
	mov	eax, DWORD PTR [rax+232]
	cmp	DWORD PTR glyph_i$7[rsp], eax
	jge	SHORT $LN36@ImFontAtla

; 2100 :             if (src_tmp.Rects[glyph_i].was_packed)

	movsxd	rax, DWORD PTR glyph_i$7[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR src_tmp$27[rsp]
	mov	rcx, QWORD PTR [rcx+200]
	cmp	DWORD PTR [rcx+rax+12], 0
	je	SHORT $LN63@ImFontAtla

; 2101 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

	movsxd	rax, DWORD PTR glyph_i$7[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR src_tmp$27[rsp]
	mov	rcx, QWORD PTR [rcx+200]
	movzx	eax, WORD PTR [rcx+rax+10]
	movsxd	rcx, DWORD PTR glyph_i$7[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR src_tmp$27[rsp]
	mov	rdx, QWORD PTR [rdx+200]
	movzx	ecx, WORD PTR [rdx+rcx+6]
	add	eax, ecx
	mov	edx, eax
	mov	rax, QWORD PTR atlas$[rsp]
	mov	ecx, DWORD PTR [rax+28]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	DWORD PTR [rcx+28], eax
$LN63@ImFontAtla:
	jmp	$LN35@ImFontAtla
$LN36@ImFontAtla:

; 2102 :     }

	jmp	$LN32@ImFontAtla
$LN33@ImFontAtla:

; 2103 : 
; 2104 :     // 7. Allocate texture
; 2105 :     atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);

	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN80@ImFontAtla
	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+28]
	inc	eax
	mov	DWORD PTR tv593[rsp], eax
	jmp	SHORT $LN81@ImFontAtla
$LN80@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	ecx, DWORD PTR [rax+28]
	call	?ImUpperPowerOfTwo@@YAHH@Z		; ImUpperPowerOfTwo
	mov	DWORD PTR tv593[rsp], eax
$LN81@ImFontAtla:
	mov	rax, QWORD PTR atlas$[rsp]
	mov	ecx, DWORD PTR tv593[rsp]
	mov	DWORD PTR [rax+28], ecx

; 2106 :     atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);

	mov	rax, QWORD PTR atlas$[rsp]
	cvtsi2ss xmm0, DWORD PTR [rax+28]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR atlas$[rsp]
	cvtsi2ss xmm1, DWORD PTR [rax+64]
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T60[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 2107 :     atlas->TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(atlas->TexWidth * atlas->TexHeight);

	mov	rax, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+64]
	imul	eax, DWORD PTR [rcx+28]
	cdqe
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 2108 :     memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);

	mov	rax, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+64]
	imul	eax, DWORD PTR [rcx+28]
	cdqe
	mov	r8, rax
	xor	edx, edx
	mov	rax, QWORD PTR atlas$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	memset

; 2109 :     spc.pixels = atlas->TexPixelsAlpha8;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR spc$[rsp+48], rax

; 2110 :     spc.height = atlas->TexHeight;

	mov	rax, QWORD PTR atlas$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR spc$[rsp+20], eax

; 2111 : 
; 2112 :     // 8. Render/rasterize font characters into the texture
; 2113 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$12[rsp], 0
	jmp	SHORT $LN40@ImFontAtla
$LN38@ImFontAtla:
	mov	eax, DWORD PTR src_i$12[rsp]
	inc	eax
	mov	DWORD PTR src_i$12[rsp], eax
$LN40@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$12[rsp], eax
	jge	$LN39@ImFontAtla

; 2114 :     {
; 2115 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv630[rsp], rax
	mov	edx, DWORD PTR src_i$12[rsp]
	mov	rcx, QWORD PTR tv630[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	mov	QWORD PTR cfg$56[rsp], rax

; 2116 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$12[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$29[rsp], rax

; 2117 :         if (src_tmp.GlyphsCount == 0)

	mov	rax, QWORD PTR src_tmp$29[rsp]
	cmp	DWORD PTR [rax+232], 0
	jne	SHORT $LN64@ImFontAtla

; 2118 :             continue;

	jmp	$LN38@ImFontAtla
$LN64@ImFontAtla:

; 2119 : 
; 2120 :         stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

	mov	rax, QWORD PTR src_tmp$29[rsp]
	add	rax, 160				; 000000a0H
	mov	rcx, QWORD PTR src_tmp$29[rsp]
	mov	rdx, QWORD PTR src_tmp$29[rsp]
	mov	rdx, QWORD PTR [rdx+200]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, 1
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR spc$[rsp]
	call	stbtt_PackFontRangesRenderIntoRects
	npad	1

; 2121 : 
; 2122 :         // Apply multiply operator
; 2123 :         if (cfg.RasterizerMultiply != 1.0f)

	mov	rax, QWORD PTR cfg$56[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN93@ImFontAtla
	je	$LN65@ImFontAtla
$LN93@ImFontAtla:

; 2124 :         {
; 2125 :             unsigned char multiply_table[256];
; 2126 :             ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);

	mov	rax, QWORD PTR cfg$56[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	lea	rcx, QWORD PTR multiply_table$63[rsp]
	call	?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ; ImFontAtlasBuildMultiplyCalcLookupTable

; 2127 :             stbrp_rect* r = &src_tmp.Rects[0];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src_tmp$29[rsp]
	add	rax, QWORD PTR [rcx+200]
	mov	QWORD PTR r$30[rsp], rax

; 2128 :             for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)

	mov	DWORD PTR glyph_i$26[rsp], 0
	jmp	SHORT $LN43@ImFontAtla
$LN41@ImFontAtla:
	mov	eax, DWORD PTR glyph_i$26[rsp]
	inc	eax
	mov	DWORD PTR glyph_i$26[rsp], eax
	mov	rax, QWORD PTR r$30[rsp]
	add	rax, 16
	mov	QWORD PTR r$30[rsp], rax
$LN43@ImFontAtla:
	mov	rax, QWORD PTR src_tmp$29[rsp]
	mov	eax, DWORD PTR [rax+232]
	cmp	DWORD PTR glyph_i$26[rsp], eax
	jge	SHORT $LN65@ImFontAtla

; 2129 :                 if (r->was_packed)

	mov	rax, QWORD PTR r$30[rsp]
	cmp	DWORD PTR [rax+12], 0
	je	SHORT $LN66@ImFontAtla

; 2130 :                     ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);

	mov	rax, QWORD PTR r$30[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR r$30[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	mov	rdx, QWORD PTR r$30[rsp]
	movzx	edx, WORD PTR [rdx+10]
	mov	rdi, QWORD PTR r$30[rsp]
	movzx	edi, WORD PTR [rdi+8]
	mov	r8, QWORD PTR atlas$[rsp]
	mov	r8d, DWORD PTR [r8+64]
	mov	DWORD PTR [rsp+48], r8d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, edx
	mov	r8d, edi
	mov	rax, QWORD PTR atlas$[rsp]
	mov	rdx, QWORD PTR [rax+48]
	lea	rcx, QWORD PTR multiply_table$63[rsp]
	call	?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ; ImFontAtlasBuildMultiplyRectAlpha8
	npad	1
$LN66@ImFontAtla:
	jmp	$LN41@ImFontAtla
$LN65@ImFontAtla:

; 2131 :         }
; 2132 :         src_tmp.Rects = NULL;

	mov	rax, QWORD PTR src_tmp$29[rsp]
	mov	QWORD PTR [rax+200], 0

; 2133 :     }

	jmp	$LN38@ImFontAtla
$LN39@ImFontAtla:

; 2134 : 
; 2135 :     // End packing
; 2136 :     stbtt_PackEnd(&spc);

	lea	rcx, QWORD PTR spc$[rsp]
	call	stbtt_PackEnd

; 2137 :     buf_rects.clear();

	lea	rcx, QWORD PTR buf_rects$[rsp]
	call	?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ ; ImVector<stbrp_rect>::clear
	npad	1

; 2138 : 
; 2139 :     // 9. Setup ImFont and glyphs for runtime
; 2140 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$13[rsp], 0
	jmp	SHORT $LN46@ImFontAtla
$LN44@ImFontAtla:
	mov	eax, DWORD PTR src_i$13[rsp]
	inc	eax
	mov	DWORD PTR src_i$13[rsp], eax
$LN46@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$13[rsp], eax
	jge	$LN45@ImFontAtla

; 2141 :     {
; 2142 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

	mov	edx, DWORD PTR src_i$13[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR src_tmp$28[rsp], rax

; 2143 :         if (src_tmp.GlyphsCount == 0)

	mov	rax, QWORD PTR src_tmp$28[rsp]
	cmp	DWORD PTR [rax+232], 0
	jne	SHORT $LN67@ImFontAtla

; 2144 :             continue;

	jmp	SHORT $LN44@ImFontAtla
$LN67@ImFontAtla:

; 2145 : 
; 2146 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

	mov	rax, QWORD PTR atlas$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv722[rsp], rax
	mov	edx, DWORD PTR src_i$13[rsp]
	mov	rcx, QWORD PTR tv722[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	mov	QWORD PTR cfg$24[rsp], rax

; 2147 :         ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)

	mov	rax, QWORD PTR cfg$24[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR dst_font$54[rsp], rax

; 2148 : 
; 2149 :         const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);

	mov	rax, QWORD PTR src_tmp$28[rsp]
	mov	rcx, QWORD PTR cfg$24[rsp]
	movss	xmm1, DWORD PTR [rcx+48]
	mov	rcx, rax
	call	stbtt_ScaleForPixelHeight
	movss	DWORD PTR font_scale$36[rsp], xmm0

; 2150 :         int unscaled_ascent, unscaled_descent, unscaled_line_gap;
; 2151 :         stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

	mov	rax, QWORD PTR src_tmp$28[rsp]
	lea	r9, QWORD PTR unscaled_line_gap$58[rsp]
	lea	r8, QWORD PTR unscaled_descent$35[rsp]
	lea	rdx, QWORD PTR unscaled_ascent$34[rsp]
	mov	rcx, rax
	call	stbtt_GetFontVMetrics

; 2152 : 
; 2153 :         const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));

	cvtsi2ss xmm0, DWORD PTR unscaled_ascent$34[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN82@ImFontAtla
	mov	DWORD PTR tv739[rsp], 1
	jmp	SHORT $LN83@ImFontAtla
$LN82@ImFontAtla:
	mov	DWORD PTR tv739[rsp], -1
$LN83@ImFontAtla:
	cvtsi2ss xmm0, DWORD PTR unscaled_ascent$34[rsp]
	mulss	xmm0, DWORD PTR font_scale$36[rsp]
	cvtsi2ss xmm1, DWORD PTR tv739[rsp]
	addss	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR ascent$43[rsp], xmm0

; 2154 :         const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));

	cvtsi2ss xmm0, DWORD PTR unscaled_descent$35[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN84@ImFontAtla
	mov	DWORD PTR tv748[rsp], 1
	jmp	SHORT $LN85@ImFontAtla
$LN84@ImFontAtla:
	mov	DWORD PTR tv748[rsp], -1
$LN85@ImFontAtla:
	cvtsi2ss xmm0, DWORD PTR unscaled_descent$35[rsp]
	mulss	xmm0, DWORD PTR font_scale$36[rsp]
	cvtsi2ss xmm1, DWORD PTR tv748[rsp]
	addss	xmm0, xmm1
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR descent$44[rsp], xmm0

; 2155 :         ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);

	movss	xmm0, DWORD PTR descent$44[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR ascent$43[rsp]
	mov	r8, QWORD PTR cfg$24[rsp]
	mov	rdx, QWORD PTR dst_font$54[rsp]
	mov	rcx, QWORD PTR atlas$[rsp]
	call	?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ; ImFontAtlasBuildSetupFont

; 2156 :         const float font_off_x = cfg.GlyphOffset.x;

	mov	rax, QWORD PTR cfg$24[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	movss	DWORD PTR font_off_x$55[rsp], xmm0

; 2157 :         const float font_off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);

	mov	rax, QWORD PTR dst_font$54[rsp]
	movss	xmm0, DWORD PTR [rax+84]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR cfg$24[rsp]
	movss	xmm1, DWORD PTR [rax+40]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR font_off_y$37[rsp], xmm0

; 2158 : 
; 2159 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

	mov	DWORD PTR glyph_i$8[rsp], 0
	jmp	SHORT $LN49@ImFontAtla
$LN47@ImFontAtla:
	mov	eax, DWORD PTR glyph_i$8[rsp]
	inc	eax
	mov	DWORD PTR glyph_i$8[rsp], eax
$LN49@ImFontAtla:
	mov	rax, QWORD PTR src_tmp$28[rsp]
	mov	eax, DWORD PTR [rax+232]
	cmp	DWORD PTR glyph_i$8[rsp], eax
	jge	$LN48@ImFontAtla

; 2160 :         {
; 2161 :             const int codepoint = src_tmp.GlyphsList[glyph_i];

	mov	rax, QWORD PTR src_tmp$28[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv775[rsp], rax
	mov	edx, DWORD PTR glyph_i$8[rsp]
	mov	rcx, QWORD PTR tv775[rsp]
	call	??A?$ImVector@H@@QEAAAEAHH@Z		; ImVector<int>::operator[]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR codepoint$53[rsp], eax

; 2162 :             const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];

	movsxd	rax, DWORD PTR glyph_i$8[rsp]
	imul	rax, rax, 28
	mov	rcx, QWORD PTR src_tmp$28[rsp]
	add	rax, QWORD PTR [rcx+208]
	mov	QWORD PTR pc$57[rsp], rax

; 2163 : 
; 2164 :             const float char_advance_x_org = pc.xadvance;

	mov	rax, QWORD PTR pc$57[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR char_advance_x_org$22[rsp], xmm0

; 2165 :             const float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);

	mov	rax, QWORD PTR cfg$24[rsp]
	movss	xmm2, DWORD PTR [rax+68]
	mov	rax, QWORD PTR cfg$24[rsp]
	movss	xmm1, DWORD PTR [rax+64]
	movss	xmm0, DWORD PTR char_advance_x_org$22[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR char_advance_x_mod$23[rsp], xmm0

; 2166 :             float char_off_x = font_off_x;

	movss	xmm0, DWORD PTR font_off_x$55[rsp]
	movss	DWORD PTR char_off_x$21[rsp], xmm0

; 2167 :             if (char_advance_x_org != char_advance_x_mod)

	movss	xmm0, DWORD PTR char_advance_x_org$22[rsp]
	ucomiss	xmm0, DWORD PTR char_advance_x_mod$23[rsp]
	jp	SHORT $LN92@ImFontAtla
	je	SHORT $LN68@ImFontAtla
$LN92@ImFontAtla:

; 2168 :                 char_off_x += cfg.PixelSnapH ? (float)(int)((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;

	mov	rax, QWORD PTR cfg$24[rsp]
	movzx	eax, BYTE PTR [rax+12]
	test	eax, eax
	je	SHORT $LN86@ImFontAtla
	movss	xmm0, DWORD PTR char_advance_x_mod$23[rsp]
	subss	xmm0, DWORD PTR char_advance_x_org$22[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv798[rsp], xmm0
	jmp	SHORT $LN87@ImFontAtla
$LN86@ImFontAtla:
	movss	xmm0, DWORD PTR char_advance_x_mod$23[rsp]
	subss	xmm0, DWORD PTR char_advance_x_org$22[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv798[rsp], xmm0
$LN87@ImFontAtla:
	movss	xmm0, DWORD PTR char_off_x$21[rsp]
	addss	xmm0, DWORD PTR tv798[rsp]
	movss	DWORD PTR char_off_x$21[rsp], xmm0
$LN68@ImFontAtla:

; 2169 : 
; 2170 :             // Register glyph
; 2171 :             stbtt_aligned_quad q;
; 2172 :             float dummy_x = 0.0f, dummy_y = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR dummy_x$52[rsp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR dummy_y$48[rsp], xmm0

; 2173 :             stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &dummy_x, &dummy_y, &q, 0);

	mov	DWORD PTR [rsp+56], 0
	lea	rax, QWORD PTR q$62[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR dummy_y$48[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dummy_x$52[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR glyph_i$8[rsp]
	mov	rax, QWORD PTR atlas$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	mov	rax, QWORD PTR atlas$[rsp]
	mov	edx, DWORD PTR [rax+64]
	mov	rax, QWORD PTR src_tmp$28[rsp]
	mov	rcx, QWORD PTR [rax+208]
	call	stbtt_GetPackedQuad

; 2174 :             dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);

	movss	xmm0, DWORD PTR q$62[rsp+20]
	addss	xmm0, DWORD PTR font_off_y$37[rsp]
	movss	xmm1, DWORD PTR q$62[rsp+16]
	addss	xmm1, DWORD PTR char_off_x$21[rsp]
	movss	xmm2, DWORD PTR q$62[rsp+4]
	addss	xmm2, DWORD PTR font_off_y$37[rsp]
	movss	xmm3, DWORD PTR q$62[rsp]
	addss	xmm3, DWORD PTR char_off_x$21[rsp]
	movss	DWORD PTR tv823[rsp], xmm3
	movss	xmm4, DWORD PTR char_advance_x_mod$23[rsp]
	movss	DWORD PTR [rsp+80], xmm4
	movss	xmm4, DWORD PTR q$62[rsp+28]
	movss	DWORD PTR [rsp+72], xmm4
	movss	xmm4, DWORD PTR q$62[rsp+24]
	movss	DWORD PTR [rsp+64], xmm4
	movss	xmm4, DWORD PTR q$62[rsp+12]
	movss	DWORD PTR [rsp+56], xmm4
	movss	xmm4, DWORD PTR q$62[rsp+8]
	movss	DWORD PTR [rsp+48], xmm4
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm1
	movaps	xmm3, xmm2
	movss	xmm0, DWORD PTR tv823[rsp]
	movaps	xmm2, xmm0
	movzx	edx, WORD PTR codepoint$53[rsp]
	mov	rcx, QWORD PTR dst_font$54[rsp]
	call	?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z	; ImFont::AddGlyph
	npad	1

; 2175 :         }

	jmp	$LN47@ImFontAtla
$LN48@ImFontAtla:

; 2176 :     }

	jmp	$LN44@ImFontAtla
$LN45@ImFontAtla:

; 2177 : 
; 2178 :     // Cleanup temporary (ImVector doesn't honor destructor)
; 2179 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	DWORD PTR src_i$20[rsp], 0
	jmp	SHORT $LN52@ImFontAtla
$LN50@ImFontAtla:
	mov	eax, DWORD PTR src_i$20[rsp]
	inc	eax
	mov	DWORD PTR src_i$20[rsp], eax
$LN52@ImFontAtla:
	mov	eax, DWORD PTR src_tmp_array$[rsp]
	cmp	DWORD PTR src_i$20[rsp], eax
	jge	SHORT $LN51@ImFontAtla

; 2180 :         src_tmp_array[src_i].~ImFontBuildSrcData();

	mov	edx, DWORD PTR src_i$20[rsp]
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
	mov	QWORD PTR tv867[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv867[rsp]
	call	??_GImFontBuildSrcData@@QEAAPEAXI@Z
	npad	1
	jmp	SHORT $LN50@ImFontAtla
$LN51@ImFontAtla:

; 2181 : 
; 2182 :     ImFontAtlasBuildFinish(atlas);

	mov	rcx, QWORD PTR atlas$[rsp]
	call	?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildFinish
	npad	1

; 2183 :     return true;

	mov	BYTE PTR $T5[rsp], 1
	lea	rcx, QWORD PTR buf_packedchars$[rsp]
	call	??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
	npad	1
	lea	rcx, QWORD PTR buf_rects$[rsp]
	call	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
	npad	1
	lea	rcx, QWORD PTR dst_tmp_array$[rsp]
	call	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
	npad	1
	lea	rcx, QWORD PTR src_tmp_array$[rsp]
	call	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
	movzx	eax, BYTE PTR $T5[rsp]
$LN1@ImFontAtla:

; 2184 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1056				; 00000420H
	pop	rdi
	ret	0
?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildWithStbTruetype
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
src_tmp$1 = 96
glyph_i$2 = 104
$T3 = 108
$T4 = 109
$T5 = 110
codepoint$6 = 112
glyph_i$7 = 116
glyph_i$8 = 120
src_i$9 = 124
output_i$10 = 128
src_i$11 = 132
src_i$12 = 136
src_i$13 = 140
src_tmp$14 = 144
cfg$15 = 152
src_tmp_array$ = 160
src_i$16 = 176
src_i$17 = 180
dst_i$18 = 184
total_glyphs_count$ = 188
src_i$19 = 192
src_i$20 = 196
char_off_x$21 = 200
char_advance_x_org$22 = 204
char_advance_x_mod$23 = 208
cfg$24 = 216
src_tmp$25 = 224
buf_rects_out_n$ = 232
buf_packedchars_out_n$ = 236
total_surface$ = 240
surface_sqrt$ = 244
glyph_i$26 = 248
src_tmp$27 = 256
src_tmp$28 = 264
src_tmp$29 = 272
r$30 = 280
dst_tmp$31 = 288
cfg$32 = 296
src_range$33 = 304
tv527 = 312
tv528 = 316
tv529 = 320
tv593 = 324
unscaled_ascent$34 = 328
tv739 = 332
unscaled_descent$35 = 336
font_scale$36 = 340
tv798 = 344
font_off_y$37 = 348
tv748 = 352
tv441 = 356
scale$38 = 360
src_range$39 = 368
src_tmp$40 = 376
padding$41 = 384
dst_tmp_array$ = 392
dst_tmp$42 = 408
ascent$43 = 416
descent$44 = 420
y1$45 = 424
y0$46 = 428
x1$47 = 432
dummy_y$48 = 436
x0$49 = 440
glyph_index_in_font$50 = 444
font_offset$51 = 448
dummy_x$52 = 452
tv823 = 456
codepoint$53 = 460
dst_font$54 = 464
font_off_x$55 = 472
buf_rects$ = 480
cfg$56 = 496
tv192 = 504
buf_packedchars$ = 512
tv236 = 528
tv249 = 536
tv273 = 544
tv294 = 552
tv300 = 560
tv312 = 568
tv405 = 576
tv453 = 584
tv630 = 592
tv722 = 600
tv775 = 608
pc$57 = 616
TEX_HEIGHT_MAX$ = 624
unscaled_line_gap$58 = 628
tv867 = 632
tv151 = 640
tv165 = 648
$T59 = 656
$T60 = 664
$T61 = 672
spc$ = 688
q$62 = 752
multiply_table$63 = 784
__$ArrayPad$ = 1040
atlas$ = 1072
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR src_tmp_array$[rbp]
	call	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
src_tmp$1 = 96
glyph_i$2 = 104
$T3 = 108
$T4 = 109
$T5 = 110
codepoint$6 = 112
glyph_i$7 = 116
glyph_i$8 = 120
src_i$9 = 124
output_i$10 = 128
src_i$11 = 132
src_i$12 = 136
src_i$13 = 140
src_tmp$14 = 144
cfg$15 = 152
src_tmp_array$ = 160
src_i$16 = 176
src_i$17 = 180
dst_i$18 = 184
total_glyphs_count$ = 188
src_i$19 = 192
src_i$20 = 196
char_off_x$21 = 200
char_advance_x_org$22 = 204
char_advance_x_mod$23 = 208
cfg$24 = 216
src_tmp$25 = 224
buf_rects_out_n$ = 232
buf_packedchars_out_n$ = 236
total_surface$ = 240
surface_sqrt$ = 244
glyph_i$26 = 248
src_tmp$27 = 256
src_tmp$28 = 264
src_tmp$29 = 272
r$30 = 280
dst_tmp$31 = 288
cfg$32 = 296
src_range$33 = 304
tv527 = 312
tv528 = 316
tv529 = 320
tv593 = 324
unscaled_ascent$34 = 328
tv739 = 332
unscaled_descent$35 = 336
font_scale$36 = 340
tv798 = 344
font_off_y$37 = 348
tv748 = 352
tv441 = 356
scale$38 = 360
src_range$39 = 368
src_tmp$40 = 376
padding$41 = 384
dst_tmp_array$ = 392
dst_tmp$42 = 408
ascent$43 = 416
descent$44 = 420
y1$45 = 424
y0$46 = 428
x1$47 = 432
dummy_y$48 = 436
x0$49 = 440
glyph_index_in_font$50 = 444
font_offset$51 = 448
dummy_x$52 = 452
tv823 = 456
codepoint$53 = 460
dst_font$54 = 464
font_off_x$55 = 472
buf_rects$ = 480
cfg$56 = 496
tv192 = 504
buf_packedchars$ = 512
tv236 = 528
tv249 = 536
tv273 = 544
tv294 = 552
tv300 = 560
tv312 = 568
tv405 = 576
tv453 = 584
tv630 = 592
tv722 = 600
tv775 = 608
pc$57 = 616
TEX_HEIGHT_MAX$ = 624
unscaled_line_gap$58 = 628
tv867 = 632
tv151 = 640
tv165 = 648
$T59 = 656
$T60 = 664
$T61 = 672
spc$ = 688
q$62 = 752
multiply_table$63 = 784
__$ArrayPad$ = 1040
atlas$ = 1072
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR dst_tmp_array$[rbp]
	call	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
src_tmp$1 = 96
glyph_i$2 = 104
$T3 = 108
$T4 = 109
$T5 = 110
codepoint$6 = 112
glyph_i$7 = 116
glyph_i$8 = 120
src_i$9 = 124
output_i$10 = 128
src_i$11 = 132
src_i$12 = 136
src_i$13 = 140
src_tmp$14 = 144
cfg$15 = 152
src_tmp_array$ = 160
src_i$16 = 176
src_i$17 = 180
dst_i$18 = 184
total_glyphs_count$ = 188
src_i$19 = 192
src_i$20 = 196
char_off_x$21 = 200
char_advance_x_org$22 = 204
char_advance_x_mod$23 = 208
cfg$24 = 216
src_tmp$25 = 224
buf_rects_out_n$ = 232
buf_packedchars_out_n$ = 236
total_surface$ = 240
surface_sqrt$ = 244
glyph_i$26 = 248
src_tmp$27 = 256
src_tmp$28 = 264
src_tmp$29 = 272
r$30 = 280
dst_tmp$31 = 288
cfg$32 = 296
src_range$33 = 304
tv527 = 312
tv528 = 316
tv529 = 320
tv593 = 324
unscaled_ascent$34 = 328
tv739 = 332
unscaled_descent$35 = 336
font_scale$36 = 340
tv798 = 344
font_off_y$37 = 348
tv748 = 352
tv441 = 356
scale$38 = 360
src_range$39 = 368
src_tmp$40 = 376
padding$41 = 384
dst_tmp_array$ = 392
dst_tmp$42 = 408
ascent$43 = 416
descent$44 = 420
y1$45 = 424
y0$46 = 428
x1$47 = 432
dummy_y$48 = 436
x0$49 = 440
glyph_index_in_font$50 = 444
font_offset$51 = 448
dummy_x$52 = 452
tv823 = 456
codepoint$53 = 460
dst_font$54 = 464
font_off_x$55 = 472
buf_rects$ = 480
cfg$56 = 496
tv192 = 504
buf_packedchars$ = 512
tv236 = 528
tv249 = 536
tv273 = 544
tv294 = 552
tv300 = 560
tv312 = 568
tv405 = 576
tv453 = 584
tv630 = 592
tv722 = 600
tv775 = 608
pc$57 = 616
TEX_HEIGHT_MAX$ = 624
unscaled_line_gap$58 = 628
tv867 = 632
tv151 = 640
tv165 = 648
$T59 = 656
$T60 = 664
$T61 = 672
spc$ = 688
q$62 = 752
multiply_table$63 = 784
__$ArrayPad$ = 1040
atlas$ = 1072
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR buf_rects$[rbp]
	call	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
src_tmp$1 = 96
glyph_i$2 = 104
$T3 = 108
$T4 = 109
$T5 = 110
codepoint$6 = 112
glyph_i$7 = 116
glyph_i$8 = 120
src_i$9 = 124
output_i$10 = 128
src_i$11 = 132
src_i$12 = 136
src_i$13 = 140
src_tmp$14 = 144
cfg$15 = 152
src_tmp_array$ = 160
src_i$16 = 176
src_i$17 = 180
dst_i$18 = 184
total_glyphs_count$ = 188
src_i$19 = 192
src_i$20 = 196
char_off_x$21 = 200
char_advance_x_org$22 = 204
char_advance_x_mod$23 = 208
cfg$24 = 216
src_tmp$25 = 224
buf_rects_out_n$ = 232
buf_packedchars_out_n$ = 236
total_surface$ = 240
surface_sqrt$ = 244
glyph_i$26 = 248
src_tmp$27 = 256
src_tmp$28 = 264
src_tmp$29 = 272
r$30 = 280
dst_tmp$31 = 288
cfg$32 = 296
src_range$33 = 304
tv527 = 312
tv528 = 316
tv529 = 320
tv593 = 324
unscaled_ascent$34 = 328
tv739 = 332
unscaled_descent$35 = 336
font_scale$36 = 340
tv798 = 344
font_off_y$37 = 348
tv748 = 352
tv441 = 356
scale$38 = 360
src_range$39 = 368
src_tmp$40 = 376
padding$41 = 384
dst_tmp_array$ = 392
dst_tmp$42 = 408
ascent$43 = 416
descent$44 = 420
y1$45 = 424
y0$46 = 428
x1$47 = 432
dummy_y$48 = 436
x0$49 = 440
glyph_index_in_font$50 = 444
font_offset$51 = 448
dummy_x$52 = 452
tv823 = 456
codepoint$53 = 460
dst_font$54 = 464
font_off_x$55 = 472
buf_rects$ = 480
cfg$56 = 496
tv192 = 504
buf_packedchars$ = 512
tv236 = 528
tv249 = 536
tv273 = 544
tv294 = 552
tv300 = 560
tv312 = 568
tv405 = 576
tv453 = 584
tv630 = 592
tv722 = 600
tv775 = 608
pc$57 = 616
TEX_HEIGHT_MAX$ = 624
unscaled_line_gap$58 = 628
tv867 = 632
tv151 = 640
tv165 = 648
$T59 = 656
$T60 = 664
$T61 = 672
spc$ = 688
q$62 = 752
multiply_table$63 = 784
__$ArrayPad$ = 1040
atlas$ = 1072
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR buf_packedchars$[rbp]
	call	??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
vertex$1 = 32
vertex$2 = 40
tv74 = 48
tv78 = 52
size$ = 56
uv_size$ = 64
vert_start$ = 72
vert_end$ = 80
scale$ = 88
max$3 = 96
$T4 = 104
min$5 = 112
tv158 = 120
$T6 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 176
$T13 = 184
$T14 = 192
draw_list$ = 224
vert_start_idx$ = 232
vert_end_idx$ = 240
a$ = 248
b$ = 256
uv_a$ = 264
uv_b$ = 272
clamp$ = 280
?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z PROC ; ImGui::ShadeVertsLinearUV

; 1474 : {

$LN17:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 1475 :     const ImVec2 size = b - a;

	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR size$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 1476 :     const ImVec2 uv_size = uv_b - uv_a;

	mov	r8, QWORD PTR uv_a$[rsp]
	mov	rdx, QWORD PTR uv_b$[rsp]
	lea	rcx, QWORD PTR uv_size$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 1477 :     const ImVec2 scale = ImVec2(

	movss	xmm0, DWORD PTR size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN16@ShadeVerts
	je	SHORT $LN11@ShadeVerts
$LN16@ShadeVerts:
	movss	xmm0, DWORD PTR uv_size$[rsp+4]
	divss	xmm0, DWORD PTR size$[rsp+4]
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN12@ShadeVerts
$LN11@ShadeVerts:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv74[rsp], xmm0
$LN12@ShadeVerts:
	movss	xmm0, DWORD PTR size$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN15@ShadeVerts
	je	SHORT $LN13@ShadeVerts
$LN15@ShadeVerts:
	movss	xmm0, DWORD PTR uv_size$[rsp]
	divss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN14@ShadeVerts
$LN13@ShadeVerts:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv78[rsp], xmm0
$LN14@ShadeVerts:
	movss	xmm2, DWORD PTR tv74[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	lea	rcx, QWORD PTR scale$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1478 :         size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
; 1479 :         size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);
; 1480 : 
; 1481 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

	movsxd	rax, DWORD PTR vert_start_idx$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR draw_list$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR vert_start$[rsp], rax

; 1482 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

	movsxd	rax, DWORD PTR vert_end_idx$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR draw_list$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR vert_end$[rsp], rax

; 1483 :     if (clamp)

	movzx	eax, BYTE PTR clamp$[rsp]
	test	eax, eax
	je	$LN8@ShadeVerts

; 1484 :     {
; 1485 :         const ImVec2 min = ImMin(uv_a, uv_b);

	mov	r8, QWORD PTR uv_b$[rsp]
	mov	rdx, QWORD PTR uv_a$[rsp]
	lea	rcx, QWORD PTR min$5[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin

; 1486 :         const ImVec2 max = ImMax(uv_a, uv_b);

	mov	r8, QWORD PTR uv_b$[rsp]
	mov	rdx, QWORD PTR uv_a$[rsp]
	lea	rcx, QWORD PTR max$3[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	npad	1

; 1487 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)

	mov	rax, QWORD PTR vert_start$[rsp]
	mov	QWORD PTR vertex$1[rsp], rax
	jmp	SHORT $LN4@ShadeVerts
$LN2@ShadeVerts:
	mov	rax, QWORD PTR vertex$1[rsp]
	add	rax, 20
	mov	QWORD PTR vertex$1[rsp], rax
$LN4@ShadeVerts:
	mov	rax, QWORD PTR vert_end$[rsp]
	cmp	QWORD PTR vertex$1[rsp], rax
	jae	$LN3@ShadeVerts

; 1488 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	mov	rax, QWORD PTR max$3[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR vertex$1[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR vertex$1[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	lea	r8, QWORD PTR scale$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	?ImMul@@YA?AUImVec2@@AEBU1@0@Z		; ImMul
	mov	r8, rax
	mov	rdx, QWORD PTR uv_a$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv158[rsp], rax
	mov	r9, QWORD PTR $T4[rsp]
	lea	r8, QWORD PTR min$5[rsp]
	mov	rdx, QWORD PTR tv158[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z	; ImClamp
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR vertex$1[rsp]
	mov	QWORD PTR [rcx+8], rax
	jmp	$LN2@ShadeVerts
$LN3@ShadeVerts:

; 1489 :     }

	jmp	$LN9@ShadeVerts
$LN8@ShadeVerts:

; 1490 :     else
; 1491 :     {
; 1492 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)

	mov	rax, QWORD PTR vert_start$[rsp]
	mov	QWORD PTR vertex$2[rsp], rax
	jmp	SHORT $LN7@ShadeVerts
$LN5@ShadeVerts:
	mov	rax, QWORD PTR vertex$2[rsp]
	add	rax, 20
	mov	QWORD PTR vertex$2[rsp], rax
$LN7@ShadeVerts:
	mov	rax, QWORD PTR vert_end$[rsp]
	cmp	QWORD PTR vertex$2[rsp], rax
	jae	SHORT $LN6@ShadeVerts

; 1493 :             vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);

	mov	rax, QWORD PTR vertex$2[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR vertex$2[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T12[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	lea	r8, QWORD PTR scale$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T13[rsp]
	call	?ImMul@@YA?AUImVec2@@AEBU1@0@Z		; ImMul
	mov	r8, rax
	mov	rdx, QWORD PTR uv_a$[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR vertex$2[rsp]
	mov	QWORD PTR [rcx+8], rax
	jmp	$LN5@ShadeVerts
$LN6@ShadeVerts:
$LN9@ShadeVerts:

; 1494 :     }
; 1495 : }

	add	rsp, 216				; 000000d8H
	ret	0
?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z ENDP ; ImGui::ShadeVertsLinearUV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
t$1 = 32
vert$2 = 40
d$3 = 48
gradient_inv_length2$ = 52
g$4 = 56
r$5 = 60
b$6 = 64
gradient_extent$ = 72
vert_start$ = 80
vert_end$ = 88
$T7 = 96
draw_list$ = 128
vert_start_idx$ = 136
vert_end_idx$ = 144
gradient_p0$ = 152
gradient_p1$ = 160
col0$ = 168
col1$ = 176
?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z PROC ; ImGui::ShadeVertsLinearColorGradientKeepAlpha

; 1456 : {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1457 :     ImVec2 gradient_extent = gradient_p1 - gradient_p0;

	lea	r8, QWORD PTR gradient_p0$[rsp]
	lea	rdx, QWORD PTR gradient_p1$[rsp]
	lea	rcx, QWORD PTR gradient_extent$[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 1458 :     float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);

	lea	rcx, QWORD PTR gradient_extent$[rsp]
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR gradient_inv_length2$[rsp], xmm0

; 1459 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

	movsxd	rax, DWORD PTR vert_start_idx$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR draw_list$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR vert_start$[rsp], rax

; 1460 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

	movsxd	rax, DWORD PTR vert_end_idx$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR draw_list$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR vert_end$[rsp], rax

; 1461 :     for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)

	mov	rax, QWORD PTR vert_start$[rsp]
	mov	QWORD PTR vert$2[rsp], rax
	jmp	SHORT $LN4@ShadeVerts
$LN2@ShadeVerts:
	mov	rax, QWORD PTR vert$2[rsp]
	add	rax, 20
	mov	QWORD PTR vert$2[rsp], rax
$LN4@ShadeVerts:
	mov	rax, QWORD PTR vert_end$[rsp]
	cmp	QWORD PTR vert$2[rsp], rax
	jae	$LN3@ShadeVerts

; 1462 :     {
; 1463 :         float d = ImDot(vert->pos - gradient_p0, gradient_extent);

	mov	rax, QWORD PTR vert$2[rsp]
	lea	r8, QWORD PTR gradient_p0$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	lea	rdx, QWORD PTR gradient_extent$[rsp]
	mov	rcx, rax
	call	?ImDot@@YAMAEBUImVec2@@0@Z		; ImDot
	movss	DWORD PTR d$3[rsp], xmm0

; 1464 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

	movss	xmm0, DWORD PTR d$3[rsp]
	mulss	xmm0, DWORD PTR gradient_inv_length2$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR t$1[rsp], xmm0

; 1465 :         int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);

	mov	eax, DWORD PTR col1$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR col0$[rsp]
	and	ecx, 255				; 000000ffH
	movss	xmm2, DWORD PTR t$1[rsp]
	mov	edx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR r$5[rsp], eax

; 1466 :         int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);

	mov	eax, DWORD PTR col1$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR col0$[rsp]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	movss	xmm2, DWORD PTR t$1[rsp]
	mov	edx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR g$4[rsp], eax

; 1467 :         int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);

	mov	eax, DWORD PTR col1$[rsp]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR col0$[rsp]
	shr	ecx, 16
	and	ecx, 255				; 000000ffH
	movss	xmm2, DWORD PTR t$1[rsp]
	mov	edx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR b$6[rsp], eax

; 1468 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

	mov	eax, DWORD PTR g$4[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR r$5[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR b$6[rsp]
	shl	ecx, 16
	or	eax, ecx
	mov	rcx, QWORD PTR vert$2[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	and	ecx, -16777216				; ff000000H
	or	eax, ecx
	mov	rcx, QWORD PTR vert$2[rsp]
	mov	DWORD PTR [rcx+16], eax

; 1469 :     }

	jmp	$LN2@ShadeVerts
$LN3@ShadeVerts:

; 1470 : }

	add	rsp, 120				; 00000078H
	ret	0
?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z ENDP ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
dot_n$1 = 48
font_scale$ = 52
font$ = 56
tv140 = 64
tv138 = 72
$T2 = 80
$T3 = 88
draw_list$ = 112
pos$ = 120
count$ = 128
col$ = 136
?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z PROC ; ImGui::RenderPixelEllipsis

; 3206 : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3207 :     ImFont* font = draw_list->_Data->Font;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR font$[rsp], rax

; 3208 :     const float font_scale = draw_list->_Data->FontSize / font->FontSize;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR font$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	divss	xmm0, DWORD PTR [rcx+20]
	movss	DWORD PTR font_scale$[rsp], xmm0

; 3209 :     pos.y += (float)(int)(font->DisplayOffset.y + font->Ascent * font_scale + 0.5f - 1.0f);

	mov	rax, QWORD PTR font$[rsp]
	movss	xmm0, DWORD PTR [rax+84]
	mulss	xmm0, DWORD PTR font_scale$[rsp]
	mov	rax, QWORD PTR font$[rsp]
	movss	xmm1, DWORD PTR [rax+68]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	subss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$[rsp+4], xmm0

; 3210 :     for (int dot_n = 0; dot_n < count; dot_n++)

	mov	DWORD PTR dot_n$1[rsp], 0
	jmp	SHORT $LN4@RenderPixe
$LN2@RenderPixe:
	mov	eax, DWORD PTR dot_n$1[rsp]
	inc	eax
	mov	DWORD PTR dot_n$1[rsp], eax
$LN4@RenderPixe:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR dot_n$1[rsp], eax
	jge	$LN3@RenderPixe

; 3211 :         draw_list->AddRectFilled(ImVec2(pos.x + dot_n * 2.0f, pos.y), ImVec2(pos.x + dot_n * 2.0f + 1.0f, pos.y + 1.0f), col);

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR __real@3f800000
	cvtsi2ss xmm1, DWORD PTR dot_n$1[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv140[rsp], rax
	cvtsi2ss xmm0, DWORD PTR dot_n$1[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR pos$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv138[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col$[rsp]
	mov	r8, QWORD PTR tv140[rsp]
	mov	rdx, QWORD PTR tv138[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
	jmp	$LN2@RenderPixe
$LN3@RenderPixe:

; 3212 : }

	add	rsp, 104				; 00000068H
	ret	0
?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z ENDP ; ImGui::RenderPixelEllipsis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
x0$ = 48
x1$1 = 52
p1$ = 56
p0$ = 64
arc0_e$ = 72
arc0_b$ = 76
inv_rounding$ = 80
arc1_e$2 = 84
arc1_b$3 = 88
tv134 = 92
tv132 = 96
tv157 = 100
tv219 = 104
tv221 = 108
tv232 = 112
tv234 = 116
tv304 = 120
tv306 = 124
tv85 = 128
tv83 = 132
half_pi$ = 136
$T4 = 140
$T5 = 148
$T6 = 156
$T7 = 164
$T8 = 172
$T9 = 180
$T10 = 188
$T11 = 196
$T12 = 204
$T13 = 212
$T14 = 220
$T15 = 228
draw_list$ = 256
rect$ = 264
col$ = 272
x_start_norm$ = 280
x_end_norm$ = 288
rounding$ = 296
?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z PROC ; ImGui::RenderRectFilledRangeH

; 3143 : {

$LN15:
	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 248				; 000000f8H

; 3144 :     if (x_end_norm == x_start_norm)

	movss	xmm0, DWORD PTR x_end_norm$[rsp]
	ucomiss	xmm0, DWORD PTR x_start_norm$[rsp]
	jp	SHORT $LN2@RenderRect
	jne	SHORT $LN2@RenderRect

; 3145 :         return;

	jmp	$LN1@RenderRect
$LN2@RenderRect:

; 3146 :     if (x_start_norm > x_end_norm)

	movss	xmm0, DWORD PTR x_start_norm$[rsp]
	comiss	xmm0, DWORD PTR x_end_norm$[rsp]
	jbe	SHORT $LN3@RenderRect

; 3147 :         ImSwap(x_start_norm, x_end_norm);

	lea	rdx, QWORD PTR x_end_norm$[rsp]
	lea	rcx, QWORD PTR x_start_norm$[rsp]
	call	??$ImSwap@M@@YAXAEAM0@Z			; ImSwap<float>
	npad	1
$LN3@RenderRect:

; 3148 : 
; 3149 :     ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv85[rsp], xmm0
	movss	xmm2, DWORD PTR x_start_norm$[rsp]
	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv83[rsp], xmm0
	movss	xmm2, DWORD PTR tv85[rsp]
	movss	xmm1, DWORD PTR tv83[rsp]
	lea	rcx, QWORD PTR p0$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 3150 :     ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv134[rsp], xmm0
	movss	xmm2, DWORD PTR x_end_norm$[rsp]
	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv132[rsp], xmm0
	movss	xmm2, DWORD PTR tv134[rsp]
	movss	xmm1, DWORD PTR tv132[rsp]
	lea	rcx, QWORD PTR p1$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 3151 :     if (rounding == 0.0f)

	movss	xmm0, DWORD PTR rounding$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN4@RenderRect
	jne	SHORT $LN4@RenderRect

; 3152 :     {
; 3153 :         draw_list->AddRectFilled(p0, p1, col, 0.0f);

	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col$[rsp]
	lea	r8, QWORD PTR p1$[rsp]
	lea	rdx, QWORD PTR p0$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 3154 :         return;

	jmp	$LN1@RenderRect
$LN4@RenderRect:

; 3155 :     }
; 3156 : 
; 3157 :     rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);

	mov	rax, QWORD PTR rect$[rsp]
	mov	rcx, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR rect$[rsp]
	mov	rcx, QWORD PTR rect$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR tv157[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv157[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR rounding$[rsp]
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR rounding$[rsp], xmm0

; 3158 :     const float inv_rounding = 1.0f / rounding;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR inv_rounding$[rsp], xmm0

; 3159 :     const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR p0$[rsp]
	subss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR inv_rounding$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImAcos01@@YAMM@Z			; ImAcos01
	movss	DWORD PTR arc0_b$[rsp], xmm0

; 3160 :     const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR p1$[rsp]
	subss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR inv_rounding$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImAcos01@@YAMM@Z			; ImAcos01
	movss	DWORD PTR arc0_e$[rsp], xmm0

; 3161 :     const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.

	movss	xmm0, DWORD PTR __real@3fc90fdb
	movss	DWORD PTR half_pi$[rsp], xmm0

; 3162 :     const float x0 = ImMax(p0.x, rect.Min.x + rounding);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR p0$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR x0$[rsp], xmm0

; 3163 :     if (arc0_b == arc0_e)

	movss	xmm0, DWORD PTR arc0_b$[rsp]
	ucomiss	xmm0, DWORD PTR arc0_e$[rsp]
	jp	SHORT $LN5@RenderRect
	jne	SHORT $LN5@RenderRect

; 3164 :     {
; 3165 :         draw_list->PathLineTo(ImVec2(x0, p1.y));

	movss	xmm2, DWORD PTR p1$[rsp+4]
	movss	xmm1, DWORD PTR x0$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 3166 :         draw_list->PathLineTo(ImVec2(x0, p0.y));

	movss	xmm2, DWORD PTR p0$[rsp+4]
	movss	xmm1, DWORD PTR x0$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 3167 :     }

	jmp	$LN6@RenderRect
$LN5@RenderRect:

; 3168 :     else if (arc0_b == 0.0f && arc0_e == half_pi)

	movss	xmm0, DWORD PTR arc0_b$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	$LN7@RenderRect
	jne	$LN7@RenderRect
	movss	xmm0, DWORD PTR arc0_e$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3fc90fdb
	jp	$LN7@RenderRect
	jne	$LN7@RenderRect

; 3169 :     {
; 3170 :         draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL

	movss	xmm0, DWORD PTR p1$[rsp+4]
	subss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR x0$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 6
	mov	r9d, 3
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 3171 :         draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR

	movss	xmm0, DWORD PTR p0$[rsp+4]
	addss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR x0$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 9
	mov	r9d, 6
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 3172 :     }

	jmp	$LN8@RenderRect
$LN7@RenderRect:

; 3173 :     else
; 3174 :     {
; 3175 :         draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL

	movss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR arc0_b$[rsp]
	movss	DWORD PTR tv219[rsp], xmm0
	movss	xmm1, DWORD PTR __real@40490fdb
	subss	xmm1, DWORD PTR arc0_e$[rsp]
	movss	DWORD PTR tv221[rsp], xmm1
	movss	xmm2, DWORD PTR p1$[rsp+4]
	subss	xmm2, DWORD PTR rounding$[rsp]
	movss	xmm1, DWORD PTR x0$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+40], 3
	movss	xmm0, DWORD PTR tv219[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm0, DWORD PTR tv221[rsp]
	movaps	xmm3, xmm0
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
	npad	1

; 3176 :         draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR

	movss	xmm0, DWORD PTR __real@40490fdb
	addss	xmm0, DWORD PTR arc0_e$[rsp]
	movss	DWORD PTR tv232[rsp], xmm0
	movss	xmm1, DWORD PTR __real@40490fdb
	addss	xmm1, DWORD PTR arc0_b$[rsp]
	movss	DWORD PTR tv234[rsp], xmm1
	movss	xmm2, DWORD PTR p0$[rsp+4]
	addss	xmm2, DWORD PTR rounding$[rsp]
	movss	xmm1, DWORD PTR x0$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+40], 3
	movss	xmm0, DWORD PTR tv232[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm0, DWORD PTR tv234[rsp]
	movaps	xmm3, xmm0
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
	npad	1
$LN8@RenderRect:
$LN6@RenderRect:

; 3177 :     }
; 3178 :     if (p1.x > rect.Min.x + rounding)

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR rounding$[rsp]
	movss	xmm1, DWORD PTR p1$[rsp]
	comiss	xmm1, xmm0
	jbe	$LN9@RenderRect

; 3179 :     {
; 3180 :         const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR p1$[rsp]
	mulss	xmm0, DWORD PTR inv_rounding$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImAcos01@@YAMM@Z			; ImAcos01
	movss	DWORD PTR arc1_b$3[rsp], xmm0

; 3181 :         const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR p0$[rsp]
	mulss	xmm0, DWORD PTR inv_rounding$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?ImAcos01@@YAMM@Z			; ImAcos01
	movss	DWORD PTR arc1_e$2[rsp], xmm0

; 3182 :         const float x1 = ImMin(p1.x, rect.Max.x - rounding);

	mov	rax, QWORD PTR rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR p1$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR x1$1[rsp], xmm0

; 3183 :         if (arc1_b == arc1_e)

	movss	xmm0, DWORD PTR arc1_b$3[rsp]
	ucomiss	xmm0, DWORD PTR arc1_e$2[rsp]
	jp	SHORT $LN10@RenderRect
	jne	SHORT $LN10@RenderRect

; 3184 :         {
; 3185 :             draw_list->PathLineTo(ImVec2(x1, p0.y));

	movss	xmm2, DWORD PTR p0$[rsp+4]
	movss	xmm1, DWORD PTR x1$1[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 3186 :             draw_list->PathLineTo(ImVec2(x1, p1.y));

	movss	xmm2, DWORD PTR p1$[rsp+4]
	movss	xmm1, DWORD PTR x1$1[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 3187 :         }

	jmp	$LN11@RenderRect
$LN10@RenderRect:

; 3188 :         else if (arc1_b == 0.0f && arc1_e == half_pi)

	movss	xmm0, DWORD PTR arc1_b$3[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	$LN12@RenderRect
	jne	$LN12@RenderRect
	movss	xmm0, DWORD PTR arc1_e$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@3fc90fdb
	jp	$LN12@RenderRect
	jne	$LN12@RenderRect

; 3189 :         {
; 3190 :             draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR

	movss	xmm0, DWORD PTR p0$[rsp+4]
	addss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR x1$1[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, 9
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 3191 :             draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR

	movss	xmm0, DWORD PTR p1$[rsp+4]
	subss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR x1$1[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 3192 :         }

	jmp	$LN13@RenderRect
$LN12@RenderRect:

; 3193 :         else
; 3194 :         {
; 3195 :             draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR

	movss	xmm0, DWORD PTR arc1_b$3[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv304[rsp], xmm0
	movss	xmm1, DWORD PTR arc1_e$2[rsp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv306[rsp], xmm1
	movss	xmm2, DWORD PTR p0$[rsp+4]
	addss	xmm2, DWORD PTR rounding$[rsp]
	movss	xmm1, DWORD PTR x1$1[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+40], 3
	movss	xmm0, DWORD PTR tv304[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm0, DWORD PTR tv306[rsp]
	movaps	xmm3, xmm0
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
	npad	1

; 3196 :             draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR

	movss	xmm0, DWORD PTR p1$[rsp+4]
	subss	xmm0, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR x1$1[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+40], 3
	movss	xmm0, DWORD PTR arc1_e$2[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR arc1_b$3[rsp]
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
	npad	1
$LN13@RenderRect:
$LN11@RenderRect:
$LN9@RenderRect:

; 3197 :         }
; 3198 :     }
; 3199 :     draw_list->PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1
$LN1@RenderRect:

; 3200 : }

	add	rsp, 248				; 000000f8H
	ret	0
?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z ENDP ; ImGui::RenderRectFilledRangeH
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv64 = 48
tv85 = 56
tv83 = 64
tv138 = 72
tv136 = 80
tv159 = 88
tv157 = 96
tv180 = 104
tv178 = 112
$T1 = 120
$T2 = 128
$T3 = 136
$T4 = 144
$T5 = 152
$T6 = 160
$T7 = 168
$T8 = 176
draw_list$ = 208
pos$ = 216
half_sz$ = 224
direction$ = 232
col$ = 240
?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z PROC ; ImGui::RenderArrowPointingAt

; 3122 : {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 3123 :     switch (direction)

	mov	eax, DWORD PTR direction$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 0
	je	SHORT $LN4@RenderArro
	cmp	DWORD PTR tv64[rsp], 1
	je	$LN5@RenderArro
	cmp	DWORD PTR tv64[rsp], 2
	je	$LN6@RenderArro
	cmp	DWORD PTR tv64[rsp], 3
	je	$LN7@RenderArro
	jmp	$LN2@RenderArro
$LN4@RenderArro:

; 3124 :     {
; 3125 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv85[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv83[rsp], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	mov	r8, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	npad	1
	jmp	$LN1@RenderArro
$LN5@RenderArro:

; 3126 :     case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;

	movss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	subss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv138[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	subss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv136[rsp], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	mov	r8, QWORD PTR tv138[rsp]
	mov	rdx, QWORD PTR tv136[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	npad	1
	jmp	$LN1@RenderArro
$LN6@RenderArro:

; 3127 :     case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	subss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv159[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv157[rsp], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	mov	r8, QWORD PTR tv159[rsp]
	mov	rdx, QWORD PTR tv157[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	npad	1
	jmp	$LN1@RenderArro
$LN7@RenderArro:

; 3128 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	movss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv180[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	subss	xmm1, DWORD PTR half_sz$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv178[rsp], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	mov	r8, QWORD PTR tv180[rsp]
	mov	rdx, QWORD PTR tv178[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	npad	1
$LN2@RenderArro:
$LN1@RenderArro:

; 3129 :     case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
; 3130 :     }
; 3131 : }

	add	rsp, 200				; 000000c8H
	ret	0
?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ENDP ; ImGui::RenderArrowPointingAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
size$ = 64
tex_id$1 = 72
offset$ = 80
font_atlas$ = 88
col_shadow$ = 96
col_border$ = 100
col_fill$ = 104
tv155 = 112
tv153 = 120
tv174 = 128
tv172 = 136
tv206 = 144
tv204 = 152
tv225 = 160
tv223 = 168
tv229 = 176
tv232 = 184
tv248 = 192
tv251 = 200
$T2 = 208
$T3 = 216
$T4 = 224
$T5 = 232
$T6 = 240
$T7 = 248
$T8 = 256
$T9 = 264
$T10 = 272
$T11 = 280
$T12 = 288
$T13 = 296
$T14 = 304
$T15 = 312
$T16 = 320
$T17 = 328
$T18 = 336
$T19 = 344
$T20 = 352
$T21 = 360
uv$ = 368
__$ArrayPad$ = 400
draw_list$ = 432
pos$ = 440
scale$ = 448
mouse_cursor$ = 456
?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z PROC ; ImGui::RenderMouseCursor

; 3096 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 424				; 000001a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3097 :     if (mouse_cursor == ImGuiMouseCursor_None)

	cmp	DWORD PTR mouse_cursor$[rsp], -1
	jne	SHORT $LN2@RenderMous

; 3098 :         return;

	jmp	$LN1@RenderMous
$LN2@RenderMous:

; 3099 :     IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);
; 3100 : 
; 3101 :     const ImU32 col_shadow = IM_COL32(0, 0, 0, 48);

	mov	DWORD PTR col_shadow$[rsp], 805306368	; 30000000H

; 3102 :     const ImU32 col_border = IM_COL32(0, 0, 0, 255);          // Black

	mov	DWORD PTR col_border$[rsp], -16777216	; ff000000H

; 3103 :     const ImU32 col_fill = IM_COL32(255, 255, 255, 255);    // White

	mov	DWORD PTR col_fill$[rsp], -1		; ffffffffH

; 3104 : 
; 3105 :     ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR font_atlas$[rsp], rax

; 3106 :     ImVec2 offset, size, uv[4];

	lea	rcx, QWORD PTR offset$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	lea	rcx, QWORD PTR size$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	lea	r9, OFFSET FLAT:??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
	mov	r8d, 4
	mov	edx, 8
	lea	rcx, QWORD PTR uv$[rsp]
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z
	npad	1

; 3107 :     if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))

	mov	eax, 8
	imul	rax, rax, 2
	lea	rax, QWORD PTR uv$[rsp+rax]
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rcx, QWORD PTR uv$[rsp+rcx]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	r9, QWORD PTR size$[rsp]
	lea	r8, QWORD PTR offset$[rsp]
	mov	edx, DWORD PTR mouse_cursor$[rsp]
	mov	rcx, QWORD PTR font_atlas$[rsp]
	call	?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ; ImFontAtlas::GetMouseCursorTexData
	movzx	eax, al
	test	eax, eax
	je	$LN3@RenderMous

; 3108 :     {
; 3109 :         pos -= offset;

	lea	rdx, QWORD PTR offset$[rsp]
	lea	rcx, QWORD PTR pos$[rsp]
	call	??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator-=

; 3110 :         const ImTextureID tex_id = font_atlas->TexID;

	mov	rax, QWORD PTR font_atlas$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tex_id$1[rsp], rax

; 3111 :         draw_list->PushTextureID(tex_id);

	mov	rdx, QWORD PTR tex_id$1[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
	npad	1

; 3112 :         draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + ImVec2(1, 0) * scale + size * scale, uv[2], uv[3], col_shadow);

	movss	xmm2, DWORD PTR scale$[rsp]
	lea	rdx, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv155[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR scale$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv153[rsp], rax
	mov	r8, QWORD PTR tv155[rsp]
	mov	rdx, QWORD PTR tv153[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv174[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR scale$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv172[rsp], rax
	mov	eax, 8
	imul	rax, rax, 3
	lea	rax, QWORD PTR uv$[rsp+rax]
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rcx, QWORD PTR uv$[rsp+rcx]
	mov	DWORD PTR [rsp+48], 805306368		; 30000000H
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR tv174[rsp]
	mov	r8, QWORD PTR tv172[rsp]
	mov	rdx, QWORD PTR tex_id$1[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1

; 3113 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + ImVec2(2, 0) * scale + size * scale, uv[2], uv[3], col_shadow);

	movss	xmm2, DWORD PTR scale$[rsp]
	lea	rdx, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv206[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR scale$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T12[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv204[rsp], rax
	mov	r8, QWORD PTR tv206[rsp]
	mov	rdx, QWORD PTR tv204[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv225[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR scale$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T16[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv223[rsp], rax
	mov	eax, 8
	imul	rax, rax, 3
	lea	rax, QWORD PTR uv$[rsp+rax]
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rcx, QWORD PTR uv$[rsp+rcx]
	mov	DWORD PTR [rsp+48], 805306368		; 30000000H
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR tv225[rsp]
	mov	r8, QWORD PTR tv223[rsp]
	mov	rdx, QWORD PTR tex_id$1[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1

; 3114 :         draw_list->AddImage(tex_id, pos, pos + size * scale, uv[2], uv[3], col_border);

	mov	eax, 8
	imul	rax, rax, 3
	lea	rax, QWORD PTR uv$[rsp+rax]
	mov	QWORD PTR tv229[rsp], rax
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rcx, QWORD PTR uv$[rsp+rcx]
	mov	QWORD PTR tv232[rsp], rcx
	movss	xmm2, DWORD PTR scale$[rsp]
	lea	rdx, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	DWORD PTR [rsp+48], -16777216		; ff000000H
	mov	rcx, QWORD PTR tv229[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR tv232[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR tex_id$1[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1

; 3115 :         draw_list->AddImage(tex_id, pos, pos + size * scale, uv[0], uv[1], col_fill);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rax, QWORD PTR uv$[rsp+rax]
	mov	QWORD PTR tv248[rsp], rax
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rcx, QWORD PTR uv$[rsp+rcx]
	mov	QWORD PTR tv251[rsp], rcx
	movss	xmm2, DWORD PTR scale$[rsp]
	lea	rdx, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	DWORD PTR [rsp+48], -1			; ffffffffH
	mov	rcx, QWORD PTR tv248[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR tv251[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR tex_id$1[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1

; 3116 :         draw_list->PopTextureID();

	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PopTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::PopTextureID
	npad	1
$LN3@RenderMous:
$LN1@RenderMous:

; 3117 :     }
; 3118 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 424				; 000001a8H
	ret	0
?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MH@Z ENDP ; ImGui::RenderMouseCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 48
a$2 = 52
tv137 = 56
tv135 = 60
$T3 = 64
$T4 = 72
this$ = 128
??0ImDrawListSharedData@@QEAA@XZ PROC			; ImDrawListSharedData::ImDrawListSharedData

; 346  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	lea	r9, OFFSET FLAT:??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
	mov	r8d, 12
	mov	edx, 8
	mov	rcx, rax
	call	??_H@YAXPEAX_K1P6APEAX0@Z@Z

; 347  :     Font = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 348  :     FontSize = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0

; 349  :     CurveTessellationTol = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0

; 350  :     ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);

	movss	xmm0, DWORD PTR __real@46000000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@46000000
	movss	xmm2, DWORD PTR __real@c6000000
	movss	xmm1, DWORD PTR __real@c6000000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+24]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 351  : 
; 352  :     // Const data
; 353  :     for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ImDrawList
$LN2@ImDrawList:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ImDrawList:
	cmp	DWORD PTR i$1[rsp], 12
	jge	SHORT $LN3@ImDrawList

; 354  :     {
; 355  :         const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);

	cvtsi2ss xmm0, DWORD PTR i$1[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR a$2[rsp], xmm0

; 356  :         CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));

	movss	xmm0, DWORD PTR a$2[rsp]
	call	?ImSin@@YAMM@Z				; ImSin
	movss	DWORD PTR tv137[rsp], xmm0
	movss	xmm0, DWORD PTR a$2[rsp]
	call	?ImCos@@YAMM@Z				; ImCos
	movss	DWORD PTR tv135[rsp], xmm0
	movss	xmm2, DWORD PTR tv137[rsp]
	movss	xmm1, DWORD PTR tv135[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rdx+rcx*8+40], rax

; 357  :     }

	jmp	$LN2@ImDrawList
$LN3@ImDrawList:

; 358  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
??0ImDrawListSharedData@@QEAA@XZ ENDP			; ImDrawListSharedData::ImDrawListSharedData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImBoolVector@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImBoolVector@@QEAA@XZ PROC				; ImBoolVector::~ImBoolVector, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImBoolVector@@QEAA@XZ ENDP				; ImBoolVector::~ImBoolVector
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA PROC		; `ImBoolVector::~ImBoolVector'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@H@@QEAA@XZ		; ImVector<int>::~ImVector<int>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImBoolVector@@QEAA@XZ@4HA ENDP		; `ImBoolVector::~ImBoolVector'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?SetBit@ImBoolVector@@QEAAXH_N@Z
_TEXT	SEGMENT
off$ = 32
mask$ = 36
tv92 = 40
tv75 = 48
tv84 = 56
tv74 = 64
tv82 = 72
this$ = 96
n$ = 104
v$ = 112
?SetBit@ImBoolVector@@QEAAXH_N@Z PROC			; ImBoolVector::SetBit, COMDAT

; 259  :     void            SetBit(int n, bool v) { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	eax, DWORD PTR n$[rsp]
	sar	eax, 5
	mov	DWORD PTR off$[rsp], eax
	mov	eax, DWORD PTR n$[rsp]
	and	eax, 31
	mov	ecx, 1
	mov	DWORD PTR tv92[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv92[rsp]
	shl	eax, cl
	mov	DWORD PTR mask$[rsp], eax
	movzx	eax, BYTE PTR v$[rsp]
	test	eax, eax
	je	SHORT $LN2@SetBit
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR off$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@H@@QEAAAEAHH@Z		; ImVector<int>::operator[]
	mov	QWORD PTR tv75[rsp], rax
	mov	rax, QWORD PTR tv75[rsp]
	mov	ecx, DWORD PTR mask$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, ecx
	mov	rcx, QWORD PTR tv75[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN3@SetBit
$LN2@SetBit:
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv82[rsp], rax
	mov	edx, DWORD PTR off$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??A?$ImVector@H@@QEAAAEAHH@Z		; ImVector<int>::operator[]
	mov	QWORD PTR tv84[rsp], rax
	mov	eax, DWORD PTR mask$[rsp]
	not	eax
	mov	rcx, QWORD PTR tv84[rsp]
	mov	ecx, DWORD PTR [rcx]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR tv84[rsp]
	mov	DWORD PTR [rcx], eax
$LN3@SetBit:
	add	rsp, 88					; 00000058H
	ret	0
?SetBit@ImBoolVector@@QEAAXH_N@Z ENDP			; ImBoolVector::SetBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetBit@ImBoolVector@@QEBA_NH@Z
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
off$ = 40
mask$ = 44
tv72 = 48
this$ = 80
n$ = 88
?GetBit@ImBoolVector@@QEBA_NH@Z PROC			; ImBoolVector::GetBit, COMDAT

; 258  :     bool            GetBit(int n) const { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	eax, DWORD PTR n$[rsp]
	sar	eax, 5
	mov	DWORD PTR off$[rsp], eax
	mov	eax, DWORD PTR n$[rsp]
	and	eax, 31
	mov	ecx, 1
	mov	DWORD PTR tv82[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv82[rsp]
	shl	eax, cl
	mov	DWORD PTR mask$[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	mov	edx, DWORD PTR off$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??A?$ImVector@H@@QEBAAEBHH@Z		; ImVector<int>::operator[]
	mov	ecx, DWORD PTR mask$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN3@GetBit
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@GetBit
$LN3@GetBit:
	mov	DWORD PTR tv75[rsp], 0
$LN4@GetBit:
	movzx	eax, BYTE PTR tv75[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?GetBit@ImBoolVector@@QEBA_NH@Z ENDP			; ImBoolVector::GetBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Clear@ImBoolVector@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImBoolVector@@QEAAXXZ PROC			; ImBoolVector::Clear, COMDAT

; 257  :     void            Clear() { Storage.clear(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$ImVector@H@@QEAAXXZ		; ImVector<int>::clear
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?Clear@ImBoolVector@@QEAAXXZ ENDP			; ImBoolVector::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Resize@ImBoolVector@@QEAAXH@Z
_TEXT	SEGMENT
tv70 = 32
this$ = 64
sz$ = 72
?Resize@ImBoolVector@@QEAAXH@Z PROC			; ImBoolVector::Resize, COMDAT

; 256  :     void            Resize(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	eax, DWORD PTR sz$[rsp]
	add	eax, 31
	sar	eax, 5
	mov	edx, eax
	mov	rcx, QWORD PTR tv70[rsp]
	call	?resize@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::resize
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	xor	edx, edx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memset
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
?Resize@ImBoolVector@@QEAAXH@Z ENDP			; ImBoolVector::Resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
?ImMul@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMul

; 248  : static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?ImMul@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMul
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR lhs$[rsp]
	comiss	xmm0, DWORD PTR rhs$[rsp]
	jb	SHORT $LN3@ImMax
	movss	xmm0, DWORD PTR lhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	movss	xmm0, DWORD PTR rhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@ImMax:
	movss	xmm0, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR rhs$[rsp]
	comiss	xmm0, DWORD PTR lhs$[rsp]
	jbe	SHORT $LN3@ImMin
	movss	xmm0, DWORD PTR lhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	movss	xmm0, DWORD PTR rhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@ImMin:
	movss	xmm0, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
?ImDot@@YAMAEBUImVec2@@0@Z PROC				; ImDot

; 245  : static inline float  ImDot(const ImVec2& a, const ImVec2& b) { return a.x * b.x + a.y * b.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	ret	0
?ImDot@@YAMAEBUImVec2@@0@Z ENDP				; ImDot
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor

; 243  : static inline float  ImFloor(float f) { return (float)(int)f; }

	movss	DWORD PTR [rsp+8], xmm0
	cvttss2si eax, DWORD PTR f$[rsp]
	cvtsi2ss xmm0, eax
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
?ImLengthSqr@@YAMAEBUImVec2@@@Z PROC			; ImLengthSqr

; 240  : static inline float  ImLengthSqr(const ImVec2& lhs) { return lhs.x * lhs.x + lhs.y * lhs.y; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	ret	0
?ImLengthSqr@@YAMAEBUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv92 = 48
__$ReturnUdt$ = 80
a$ = 88
b$ = 96
t$ = 104
?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z PROC			; ImLerp

; 238  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+12]
	mulss	xmm0, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm1, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	subss	xmm2, DWORD PTR [rcx+4]
	mulss	xmm2, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm3, DWORD PTR [rax+4]
	addss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm3, DWORD PTR [rax]
	subss	xmm3, DWORD PTR [rcx]
	mulss	xmm3, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm4, DWORD PTR [rax]
	addss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv92[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv92[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv73 = 32
tv83 = 36
tv74 = 40
tv84 = 44
__$ReturnUdt$ = 64
v$ = 72
mn$ = 80
mx$ = 88
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z PROC		; ImClamp

; 235  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx) { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR mn$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN5@ImClamp
	mov	rax, QWORD PTR mn$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR mx$[rsp+4]
	jbe	SHORT $LN3@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp+4]
	movss	DWORD PTR tv73[rsp], xmm0
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv73[rsp], xmm0
$LN4@ImClamp:
	movss	xmm0, DWORD PTR tv73[rsp]
	movss	DWORD PTR tv74[rsp], xmm0
$LN6@ImClamp:
	mov	rax, QWORD PTR mn$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN9@ImClamp
	mov	rax, QWORD PTR mn$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv84[rsp], xmm0
	jmp	SHORT $LN10@ImClamp
$LN9@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR mx$[rsp]
	jbe	SHORT $LN7@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp]
	movss	DWORD PTR tv83[rsp], xmm0
	jmp	SHORT $LN8@ImClamp
$LN7@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv83[rsp], xmm0
$LN8@ImClamp:
	movss	xmm0, DWORD PTR tv83[rsp]
	movss	DWORD PTR tv84[rsp], xmm0
$LN10@ImClamp:
	movss	xmm2, DWORD PTR tv74[rsp]
	movss	xmm1, DWORD PTR tv84[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z ENDP		; ImClamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv71 = 32
tv78 = 36
__$ReturnUdt$ = 64
lhs$ = 72
rhs$ = 80
?ImMax@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMax

; 234  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@ImMax:
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN5@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN6@ImMax
$LN5@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
$LN6@ImMax:
	movss	xmm2, DWORD PTR tv71[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImMax@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv71 = 32
tv78 = 36
__$ReturnUdt$ = 64
lhs$ = 72
rhs$ = 80
?ImMin@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMin

; 233  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN5@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN6@ImMin
$LN5@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
$LN6@ImMin:
	movss	xmm2, DWORD PTR tv71[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImMin@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImCeil@@YAMM@Z PROC					; ImCeil

; 224  : static inline float  ImCeil(float x) { return ceilf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	ceilf
	add	rsp, 40					; 00000028H
	ret	0
?ImCeil@@YAMM@Z ENDP					; ImCeil
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImFloorStd@@YAMM@Z PROC				; ImFloorStd

; 223  : static inline float  ImFloorStd(float x) { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	floorf
	add	rsp, 40					; 00000028H
	ret	0
?ImFloorStd@@YAMM@Z ENDP				; ImFloorStd
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImAcos@@YAMM@Z PROC					; ImAcos

; 220  : static inline float  ImAcos(float x) { return acosf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	acosf
	add	rsp, 40					; 00000028H
	ret	0
?ImAcos@@YAMM@Z ENDP					; ImAcos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImSin@@YAMM@Z PROC					; ImSin

; 219  : static inline float  ImSin(float x) { return sinf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	sinf
	add	rsp, 40					; 00000028H
	ret	0
?ImSin@@YAMM@Z ENDP					; ImSin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImCos@@YAMM@Z PROC					; ImCos

; 218  : static inline float  ImCos(float x) { return cosf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	cosf
	add	rsp, 40					; 00000028H
	ret	0
?ImCos@@YAMM@Z ENDP					; ImCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImSqrt@@YAMM@Z PROC					; ImSqrt

; 213  : static inline float  ImSqrt(float x) { return sqrtf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	sqrtf
	add	rsp, 40					; 00000028H
	ret	0
?ImSqrt@@YAMM@Z ENDP					; ImSqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImFabs@@YAMM@Z PROC					; ImFabs

; 212  : static inline float  ImFabs(float x) { return fabsf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	fabsf
	add	rsp, 40					; 00000028H
	ret	0
?ImFabs@@YAMM@Z ENDP					; ImFabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator-=

; 201  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	ret	0
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??D@YA?AUImVec2@@AEBU0@0@Z PROC				; operator*

; 198  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??D@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-

; 197  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+

; 196  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*

; 194  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR rhs$[rsp]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
v$ = 8
?ImUpperPowerOfTwo@@YAHH@Z PROC				; ImUpperPowerOfTwo

; 158  : static inline int       ImUpperPowerOfTwo(int v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

	mov	DWORD PTR [rsp+8], ecx
	mov	eax, DWORD PTR v$[rsp]
	dec	eax
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, 1
	mov	ecx, DWORD PTR v$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, 2
	mov	ecx, DWORD PTR v$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, 4
	mov	ecx, DWORD PTR v$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, 8
	mov	ecx, DWORD PTR v$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, 16
	mov	ecx, DWORD PTR v$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	inc	eax
	mov	DWORD PTR v$[rsp], eax
	mov	eax, DWORD PTR v$[rsp]
	ret	0
?ImUpperPowerOfTwo@@YAHH@Z ENDP				; ImUpperPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv67 = 0
c$ = 32
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW

; 156  : static inline bool      ImCharIsBlankW(unsigned int c) { return c == ' ' || c == '\t' || c == 0x3000; }

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	cmp	DWORD PTR c$[rsp], 32			; 00000020H
	je	SHORT $LN3@ImCharIsBl
	cmp	DWORD PTR c$[rsp], 9
	je	SHORT $LN3@ImCharIsBl
	cmp	DWORD PTR c$[rsp], 12288		; 00003000H
	je	SHORT $LN3@ImCharIsBl
	mov	DWORD PTR tv67[rsp], 0
	jmp	SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
	mov	DWORD PTR tv67[rsp], 1
$LN4@ImCharIsBl:
	movzx	eax, BYTE PTR tv67[rsp]
	add	rsp, 24
	ret	0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv68 = 0
c$ = 32
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA

; 155  : static inline bool      ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 9
	je	SHORT $LN3@ImCharIsBl
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
	mov	DWORD PTR tv68[rsp], 1
$LN4@ImCharIsBl:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GImFont@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImFont@@QEAAPEAXI@Z PROC				; ImFont::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 120				; 00000078H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GImFont@@QEAAPEAXI@Z ENDP				; ImFont::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
c$ = 56
?SetFallbackChar@ImFont@@QEAAXG@Z PROC			; ImFont::SetFallbackChar

; 2611 : {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2612 :     FallbackChar = c;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR c$[rsp]
	mov	WORD PTR [rax+106], cx

; 2613 :     BuildLookupTable();

	mov	rcx, QWORD PTR this$[rsp]
	call	?BuildLookupTable@ImFont@@QEAAXXZ	; ImFont::BuildLookupTable
	npad	1

; 2614 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetFallbackChar@ImFont@@QEAAXG@Z ENDP			; ImFont::SetFallbackChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv131 = 32
index_size$ = 36
tv146 = 40
tv91 = 48
tv138 = 56
this$ = 80
dst$ = 88
src$ = 96
overwrite_dst$ = 104
?AddRemapChar@ImFont@@QEAAXGG_N@Z PROC			; ImFont::AddRemapChar

; 2651 : {

$LN9:
	mov	BYTE PTR [rsp+32], r9b
	mov	WORD PTR [rsp+24], r8w
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2652 :     IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
; 2653 :     int index_size = IndexLookup.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR index_size$[rsp], eax

; 2654 : 
; 2655 :     if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists

	movzx	eax, WORD PTR dst$[rsp]
	cmp	eax, DWORD PTR index_size$[rsp]
	jge	SHORT $LN2@AddRemapCh
	movzx	eax, WORD PTR dst$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	movzx	eax, WORD PTR [rcx+rax*2]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $LN2@AddRemapCh
	movzx	eax, BYTE PTR overwrite_dst$[rsp]
	test	eax, eax
	jne	SHORT $LN2@AddRemapCh

; 2656 :         return;

	jmp	$LN1@AddRemapCh
$LN2@AddRemapCh:

; 2657 :     if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op

	movzx	eax, WORD PTR src$[rsp]
	cmp	eax, DWORD PTR index_size$[rsp]
	jl	SHORT $LN3@AddRemapCh
	movzx	eax, WORD PTR dst$[rsp]
	cmp	eax, DWORD PTR index_size$[rsp]
	jl	SHORT $LN3@AddRemapCh

; 2658 :         return;

	jmp	$LN1@AddRemapCh
$LN3@AddRemapCh:

; 2659 : 
; 2660 :     GrowIndex(dst + 1);

	movzx	eax, WORD PTR dst$[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GrowIndex@ImFont@@QEAAXH@Z		; ImFont::GrowIndex

; 2661 :     IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;

	movzx	eax, WORD PTR src$[rsp]
	cmp	eax, DWORD PTR index_size$[rsp]
	jge	SHORT $LN5@AddRemapCh
	movzx	eax, WORD PTR src$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR tv131[rsp], ax
	jmp	SHORT $LN6@AddRemapCh
$LN5@AddRemapCh:
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR tv131[rsp], ax
$LN6@AddRemapCh:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv91[rsp], rax
	movzx	eax, WORD PTR dst$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv91[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	ecx, WORD PTR tv131[rsp]
	mov	WORD PTR [rax], cx

; 2662 :     IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;

	movzx	eax, WORD PTR src$[rsp]
	cmp	eax, DWORD PTR index_size$[rsp]
	jge	SHORT $LN7@AddRemapCh
	movzx	eax, WORD PTR src$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR tv146[rsp], xmm0
	jmp	SHORT $LN8@AddRemapCh
$LN7@AddRemapCh:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[rsp], xmm0
$LN8@AddRemapCh:
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv138[rsp], rax
	movzx	eax, WORD PTR dst$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv138[rsp]
	call	??A?$ImVector@M@@QEAAAEAMH@Z		; ImVector<float>::operator[]
	movss	xmm0, DWORD PTR tv146[rsp]
	movss	DWORD PTR [rax], xmm0
$LN1@AddRemapCh:

; 2663 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddRemapChar@ImFont@@QEAAXGG_N@Z ENDP			; ImFont::AddRemapChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
glyph$ = 32
tv71 = 40
this$ = 64
codepoint$ = 72
x0$ = 80
y0$ = 88
x1$ = 96
y1$ = 104
u0$ = 112
v0$ = 120
u1$ = 128
v1$ = 136
advance_x$ = 144
?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z PROC		; ImFont::AddGlyph

; 2628 : {

$LN4:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2629 :     Glyphs.resize(Glyphs.Size + 1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv71[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv71[rsp]
	call	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::resize

; 2630 :     ImFontGlyph& glyph = Glyphs.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
	mov	QWORD PTR glyph$[rsp], rax

; 2631 :     glyph.Codepoint = (ImWchar)codepoint;

	mov	rax, QWORD PTR glyph$[rsp]
	movzx	ecx, WORD PTR codepoint$[rsp]
	mov	WORD PTR [rax+4], cx

; 2632 :     glyph.X0 = x0;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR x0$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 2633 :     glyph.Y0 = y0;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR y0$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 2634 :     glyph.X1 = x1;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR x1$[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 2635 :     glyph.Y1 = y1;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR y1$[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 2636 :     glyph.U0 = u0;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR u0$[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 2637 :     glyph.V0 = v0;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR v0$[rsp]
	movss	DWORD PTR [rax+28], xmm0

; 2638 :     glyph.U1 = u1;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR u1$[rsp]
	movss	DWORD PTR [rax+32], xmm0

; 2639 :     glyph.V1 = v1;

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR v1$[rsp]
	movss	DWORD PTR [rax+36], xmm0

; 2640 :     glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movss	xmm0, DWORD PTR advance_x$[rsp]
	addss	xmm0, DWORD PTR [rax+16]
	mov	rax, QWORD PTR glyph$[rsp]
	movss	DWORD PTR [rax], xmm0

; 2641 : 
; 2642 :     if (ConfigData->PixelSnapH)

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+12]
	test	eax, eax
	je	SHORT $LN2@AddGlyph

; 2643 :         glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);

	mov	rax, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR glyph$[rsp]
	movss	DWORD PTR [rax], xmm0
$LN2@AddGlyph:

; 2644 : 
; 2645 :     // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
; 2646 :     DirtyLookupTables = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+112], 1

; 2647 :     MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);

	mov	rax, QWORD PTR glyph$[rsp]
	mov	rcx, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	subss	xmm0, DWORD PTR [rcx+24]
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	cvtsi2ss xmm1, DWORD PTR [rax+64]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3ffeb852
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR glyph$[rsp]
	mov	rdx, QWORD PTR glyph$[rsp]
	movss	xmm0, DWORD PTR [rcx+36]
	subss	xmm0, DWORD PTR [rdx+28]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	cvtsi2ss xmm1, DWORD PTR [rcx+28]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3ffeb852
	cvttss2si ecx, xmm0
	imul	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+108]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+108], eax

; 2648 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddGlyph@ImFont@@QEAAXGMMMMMMMMM@Z ENDP		; ImFont::AddGlyph
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv72 = 40
tv78 = 48
this$ = 80
new_size$ = 88
?GrowIndex@ImFont@@QEAAXH@Z PROC			; ImFont::GrowIndex

; 2617 : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2618 :     IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
; 2619 :     if (new_size <= IndexLookup.Size)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR new_size$[rsp], eax
	jg	SHORT $LN2@GrowIndex

; 2620 :         return;

	jmp	SHORT $LN1@GrowIndex
$LN2@GrowIndex:

; 2621 :     IndexAdvanceX.resize(new_size, -1.0f);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR $T2[rsp], xmm0
	lea	r8, QWORD PTR $T2[rsp]
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?resize@?$ImVector@M@@QEAAXHAEBM@Z	; ImVector<float>::resize
	npad	1

; 2622 :     IndexLookup.resize(new_size, (ImWchar)-1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv78[rsp], rax
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR $T1[rsp], ax
	lea	r8, QWORD PTR $T1[rsp]
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?resize@?$ImVector@G@@QEAAXHAEBG@Z	; ImVector<unsigned short>::resize
	npad	1
$LN1@GrowIndex:

; 2623 : }

	add	rsp, 72					; 00000048H
	ret	0
?GrowIndex@ImFont@@QEAAXH@Z ENDP			; ImFont::GrowIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearOutputData@ImFont@@QEAAXXZ PROC			; ImFont::ClearOutputData

; 2558 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2559 :     FontSize = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0

; 2560 :     FallbackAdvanceX = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0

; 2561 :     Glyphs.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ ; ImVector<ImFontGlyph>::clear

; 2562 :     IndexAdvanceX.clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$ImVector@M@@QEAAXXZ		; ImVector<float>::clear

; 2563 :     IndexLookup.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	?clear@?$ImVector@G@@QEAAXXZ		; ImVector<unsigned short>::clear

; 2564 :     FallbackGlyph = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0

; 2565 :     ContainerAtlas = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 2566 :     DirtyLookupTables = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+112], 1

; 2567 :     Ascent = Descent = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+88], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+84], xmm0

; 2568 :     MetricsTotalSurface = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+108], 0

; 2569 : }

	add	rsp, 40					; 00000028H
	ret	0
?ClearOutputData@ImFont@@QEAAXXZ ENDP			; ImFont::ClearOutputData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
i$3 = 40
max_codepoint$ = 44
tv205 = 48
tab_glyph$4 = 56
codepoint$5 = 64
tv216 = 68
tv145 = 72
tv191 = 76
tv235 = 80
tv74 = 88
tv128 = 96
tv142 = 104
tv136 = 112
tv151 = 120
tv169 = 128
tv188 = 136
tv199 = 144
tv225 = 152
tv232 = 160
this$ = 208
?BuildLookupTable@ImFont@@QEAAXXZ PROC			; ImFont::BuildLookupTable

; 2572 : {

$LN17:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 2573 :     int max_codepoint = 0;

	mov	DWORD PTR max_codepoint$[rsp], 0

; 2574 :     for (int i = 0; i != Glyphs.Size; i++)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN4@BuildLooku
$LN2@BuildLooku:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN4@BuildLooku:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR i$3[rsp], eax
	je	SHORT $LN3@BuildLooku

; 2575 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
	movzx	eax, WORD PTR [rax+4]
	mov	edx, eax
	mov	ecx, DWORD PTR max_codepoint$[rsp]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	DWORD PTR max_codepoint$[rsp], eax
	jmp	SHORT $LN2@BuildLooku
$LN3@BuildLooku:

; 2576 : 
; 2577 :     IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
; 2578 :     IndexAdvanceX.clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$ImVector@M@@QEAAXXZ		; ImVector<float>::clear

; 2579 :     IndexLookup.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	?clear@?$ImVector@G@@QEAAXXZ		; ImVector<unsigned short>::clear

; 2580 :     DirtyLookupTables = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+112], 0

; 2581 :     GrowIndex(max_codepoint + 1);

	mov	eax, DWORD PTR max_codepoint$[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GrowIndex@ImFont@@QEAAXH@Z		; ImFont::GrowIndex
	npad	1

; 2582 :     for (int i = 0; i < Glyphs.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@BuildLooku
$LN5@BuildLooku:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@BuildLooku:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN6@BuildLooku

; 2583 :     {
; 2584 :         int codepoint = (int)Glyphs[i].Codepoint;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv128[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
	movzx	eax, WORD PTR [rax+4]
	mov	DWORD PTR codepoint$5[rsp], eax

; 2585 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv142[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv142[rsp]
	call	??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv145[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv136[rsp], rax
	mov	edx, DWORD PTR codepoint$5[rsp]
	mov	rcx, QWORD PTR tv136[rsp]
	call	??A?$ImVector@M@@QEAAAEAMH@Z		; ImVector<float>::operator[]
	movss	xmm0, DWORD PTR tv145[rsp]
	movss	DWORD PTR [rax], xmm0

; 2586 :         IndexLookup[codepoint] = (ImWchar)i;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv151[rsp], rax
	mov	edx, DWORD PTR codepoint$5[rsp]
	mov	rcx, QWORD PTR tv151[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	ecx, WORD PTR i$1[rsp]
	mov	WORD PTR [rax], cx

; 2587 :     }

	jmp	$LN5@BuildLooku
$LN6@BuildLooku:

; 2588 : 
; 2589 :     // Create a glyph to handle TAB
; 2590 :     // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
; 2591 :     if (FindGlyph((ImWchar)' '))

	mov	dx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyph
	test	rax, rax
	je	$LN11@BuildLooku

; 2592 :     {
; 2593 :         if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
	movzx	eax, WORD PTR [rax+4]
	cmp	eax, 9
	je	SHORT $LN12@BuildLooku

; 2594 :             Glyphs.resize(Glyphs.Size + 1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv169[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv169[rsp]
	call	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::resize
	npad	1
$LN12@BuildLooku:

; 2595 :         ImFontGlyph& tab_glyph = Glyphs.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
	mov	QWORD PTR tab_glyph$4[rsp], rax

; 2596 :         tab_glyph = *FindGlyph((ImWchar)' ');

	mov	dx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyph
	mov	rdi, QWORD PTR tab_glyph$4[rsp]
	mov	rsi, rax
	mov	ecx, 40					; 00000028H
	rep movsb

; 2597 :         tab_glyph.Codepoint = '\t';

	mov	eax, 9
	mov	rcx, QWORD PTR tab_glyph$4[rsp]
	mov	WORD PTR [rcx+4], ax

; 2598 :         tab_glyph.AdvanceX *= 4;

	mov	rax, QWORD PTR tab_glyph$4[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	rax, QWORD PTR tab_glyph$4[rsp]
	movss	DWORD PTR [rax], xmm0

; 2599 :         IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;

	mov	rax, QWORD PTR tab_glyph$4[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv191[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv188[rsp], rax
	mov	rax, QWORD PTR tab_glyph$4[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	edx, eax
	mov	rcx, QWORD PTR tv188[rsp]
	call	??A?$ImVector@M@@QEAAAEAMH@Z		; ImVector<float>::operator[]
	movss	xmm0, DWORD PTR tv191[rsp]
	movss	DWORD PTR [rax], xmm0

; 2600 :         IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	dec	eax
	mov	WORD PTR tv205[rsp], ax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR tv199[rsp], rax
	mov	rax, QWORD PTR tab_glyph$4[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	edx, eax
	mov	rcx, QWORD PTR tv199[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	ecx, WORD PTR tv205[rsp]
	mov	WORD PTR [rax], cx
$LN11@BuildLooku:

; 2601 :     }
; 2602 : 
; 2603 :     FallbackGlyph = FindGlyphNoFallback(FallbackChar);

	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, WORD PTR [rax+106]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2604 :     FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN15@BuildLooku
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv216[rsp], xmm0
	jmp	SHORT $LN16@BuildLooku
$LN15@BuildLooku:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv216[rsp], xmm0
$LN16@BuildLooku:
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR tv216[rsp]
	movss	DWORD PTR [rax+16], xmm0

; 2605 :     for (int i = 0; i < max_codepoint + 1; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN10@BuildLooku
$LN8@BuildLooku:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN10@BuildLooku:
	mov	eax, DWORD PTR max_codepoint$[rsp]
	inc	eax
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN9@BuildLooku

; 2606 :         if (IndexAdvanceX[i] < 0.0f)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv225[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv225[rsp]
	call	??A?$ImVector@M@@QEAAAEAMH@Z		; ImVector<float>::operator[]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	jbe	SHORT $LN13@BuildLooku

; 2607 :             IndexAdvanceX[i] = FallbackAdvanceX;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR tv235[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv232[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv232[rsp]
	call	??A?$ImVector@M@@QEAAAEAMH@Z		; ImVector<float>::operator[]
	movss	xmm0, DWORD PTR tv235[rsp]
	movss	DWORD PTR [rax], xmm0
$LN13@BuildLooku:
	jmp	SHORT $LN8@BuildLooku
$LN9@BuildLooku:

; 2608 : }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?BuildLookupTable@ImFont@@QEAAXXZ ENDP			; ImFont::BuildLookupTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
word_wrap_enabled$ = 48
s$ = 56
y$ = 64
vtx_write$ = 72
tv85 = 80
c$1 = 81
c$2 = 84
x$ = 88
y1$3 = 92
x2$4 = 96
x1$5 = 100
y2$6 = 104
vtx_current_idx$ = 108
scale$ = 112
v1$7 = 116
u1$8 = 120
line_height$ = 124
u2$9 = 128
v2$10 = 132
glyph$11 = 136
idx_write$ = 144
s_end$12 = 152
char_width$13 = 160
y_end$14 = 164
word_wrap_eol$ = 168
idx_count_max$ = 176
vtx_count_max$ = 180
idx_expected_size$ = 184
tv452 = 188
tv450 = 192
tv134 = 200
tv150 = 208
tv448 = 216
tv424 = 224
tv434 = 232
tv443 = 240
this$ = 272
draw_list$ = 280
size$ = 288
pos$ = 296
col$ = 304
clip_rect$ = 312
text_begin$ = 320
text_end$ = 328
wrap_width$ = 336
cpu_fine_clip$ = 344
?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z PROC ; ImFont::RenderText

; 2895 : {

$LN50:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 264				; 00000108H

; 2896 :     if (!text_end)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN10@RenderText

; 2897 :         text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.

	mov	rcx, QWORD PTR text_begin$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text_begin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN10@RenderText:

; 2898 : 
; 2899 :     // Align to be pixel perfect
; 2900 :     pos.x = (float)(int)pos.x + DisplayOffset.x;

	cvttss2si eax, DWORD PTR pos$[rsp]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	addss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR pos$[rsp], xmm0

; 2901 :     pos.y = (float)(int)pos.y + DisplayOffset.y;

	cvttss2si eax, DWORD PTR pos$[rsp+4]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	addss	xmm0, DWORD PTR [rax+68]
	movss	DWORD PTR pos$[rsp+4], xmm0

; 2902 :     float x = pos.x;

	movss	xmm0, DWORD PTR pos$[rsp]
	movss	DWORD PTR x$[rsp], xmm0

; 2903 :     float y = pos.y;

	movss	xmm0, DWORD PTR pos$[rsp+4]
	movss	DWORD PTR y$[rsp], xmm0

; 2904 :     if (y > clip_rect.w)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	comiss	xmm0, DWORD PTR [rax+12]
	jbe	SHORT $LN11@RenderText

; 2905 :         return;

	jmp	$LN1@RenderText
$LN11@RenderText:

; 2906 : 
; 2907 :     const float scale = size / FontSize;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	divss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR scale$[rsp], xmm0

; 2908 :     const float line_height = FontSize * scale;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR line_height$[rsp], xmm0

; 2909 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	movss	xmm0, DWORD PTR wrap_width$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN40@RenderText
	mov	BYTE PTR tv85[rsp], 1
	jmp	SHORT $LN41@RenderText
$LN40@RenderText:
	mov	BYTE PTR tv85[rsp], 0
$LN41@RenderText:
	movzx	eax, BYTE PTR tv85[rsp]
	mov	BYTE PTR word_wrap_enabled$[rsp], al

; 2910 :     const char* word_wrap_eol = NULL;

	mov	QWORD PTR word_wrap_eol$[rsp], 0

; 2911 : 
; 2912 :     // Fast-forward to first visible line
; 2913 :     const char* s = text_begin;

	mov	rax, QWORD PTR text_begin$[rsp]
	mov	QWORD PTR s$[rsp], rax

; 2914 :     if (y + line_height < clip_rect.y && !word_wrap_enabled)

	movss	xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR line_height$[rsp]
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	comiss	xmm1, xmm0
	jbe	$LN12@RenderText
	movzx	eax, BYTE PTR word_wrap_enabled$[rsp]
	test	eax, eax
	jne	$LN12@RenderText
$LN2@RenderText:

; 2915 :         while (y + line_height < clip_rect.y && s < text_end)

	movss	xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR line_height$[rsp]
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	comiss	xmm1, xmm0
	jbe	$LN3@RenderText
	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	SHORT $LN3@RenderText

; 2916 :         {
; 2917 :             s = (const char*)memchr(s, '\n', text_end - s);

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR s$[rsp]
	call	memchr
	mov	QWORD PTR s$[rsp], rax

; 2918 :             s = s ? s + 1 : text_end;

	cmp	QWORD PTR s$[rsp], 0
	je	SHORT $LN42@RenderText
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR tv134[rsp], rax
	jmp	SHORT $LN43@RenderText
$LN42@RenderText:
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR tv134[rsp], rax
$LN43@RenderText:
	mov	rax, QWORD PTR tv134[rsp]
	mov	QWORD PTR s$[rsp], rax

; 2919 :             y += line_height;

	movss	xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR y$[rsp], xmm0

; 2920 :         }

	jmp	$LN2@RenderText
$LN3@RenderText:
$LN12@RenderText:

; 2921 : 
; 2922 :     // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
; 2923 :     // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
; 2924 :     if (text_end - s > 10000 && !word_wrap_enabled)

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 10000				; 00002710H
	jle	$LN13@RenderText
	movzx	eax, BYTE PTR word_wrap_enabled$[rsp]
	test	eax, eax
	jne	$LN13@RenderText

; 2925 :     {
; 2926 :         const char* s_end = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR s_end$12[rsp], rax

; 2927 :         float y_end = y;

	movss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR y_end$14[rsp], xmm0
$LN4@RenderText:

; 2928 :         while (y_end < clip_rect.w && s_end < text_end)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR y_end$14[rsp]
	jbe	$LN5@RenderText
	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s_end$12[rsp], rax
	jae	$LN5@RenderText

; 2929 :         {
; 2930 :             s_end = (const char*)memchr(s_end, '\n', text_end - s_end);

	mov	rax, QWORD PTR s_end$12[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR s_end$12[rsp]
	call	memchr
	mov	QWORD PTR s_end$12[rsp], rax

; 2931 :             s_end = s_end ? s_end + 1 : text_end;

	cmp	QWORD PTR s_end$12[rsp], 0
	je	SHORT $LN44@RenderText
	mov	rax, QWORD PTR s_end$12[rsp]
	inc	rax
	mov	QWORD PTR tv150[rsp], rax
	jmp	SHORT $LN45@RenderText
$LN44@RenderText:
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR tv150[rsp], rax
$LN45@RenderText:
	mov	rax, QWORD PTR tv150[rsp]
	mov	QWORD PTR s_end$12[rsp], rax

; 2932 :             y_end += line_height;

	movss	xmm0, DWORD PTR y_end$14[rsp]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR y_end$14[rsp], xmm0

; 2933 :         }

	jmp	$LN4@RenderText
$LN5@RenderText:

; 2934 :         text_end = s_end;

	mov	rax, QWORD PTR s_end$12[rsp]
	mov	QWORD PTR text_end$[rsp], rax
$LN13@RenderText:

; 2935 :     }
; 2936 :     if (s == text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jne	SHORT $LN14@RenderText

; 2937 :         return;

	jmp	$LN1@RenderText
$LN14@RenderText:

; 2938 : 
; 2939 :     // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
; 2940 :     const int vtx_count_max = (int)(text_end - s) * 4;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	shl	eax, 2
	mov	DWORD PTR vtx_count_max$[rsp], eax

; 2941 :     const int idx_count_max = (int)(text_end - s) * 6;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	imul	eax, eax, 6
	mov	DWORD PTR idx_count_max$[rsp], eax

; 2942 :     const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax+40]
	add	eax, DWORD PTR idx_count_max$[rsp]
	mov	DWORD PTR idx_expected_size$[rsp], eax

; 2943 :     draw_list->PrimReserve(idx_count_max, vtx_count_max);

	mov	r8d, DWORD PTR vtx_count_max$[rsp]
	mov	edx, DWORD PTR idx_count_max$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 2944 : 
; 2945 :     ImDrawVert* vtx_write = draw_list->_VtxWritePtr;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR vtx_write$[rsp], rax

; 2946 :     ImDrawIdx* idx_write = draw_list->_IdxWritePtr;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR idx_write$[rsp], rax

; 2947 :     unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR vtx_current_idx$[rsp], eax
$LN49@RenderText:
$LN48@RenderText:
$LN47@RenderText:
$LN46@RenderText:
$LN6@RenderText:

; 2948 : 
; 2949 :     while (s < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	$LN7@RenderText

; 2950 :     {
; 2951 :         if (word_wrap_enabled)

	movzx	eax, BYTE PTR word_wrap_enabled$[rsp]
	test	eax, eax
	je	$LN15@RenderText

; 2952 :         {
; 2953 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 2954 :             if (!word_wrap_eol)

	cmp	QWORD PTR word_wrap_eol$[rsp], 0
	jne	SHORT $LN16@RenderText

; 2955 :             {
; 2956 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));

	movss	xmm0, DWORD PTR x$[rsp]
	subss	xmm0, DWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR wrap_width$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR text_end$[rsp]
	mov	r8, QWORD PTR s$[rsp]
	movss	xmm1, DWORD PTR scale$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
	mov	QWORD PTR word_wrap_eol$[rsp], rax

; 2957 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

	mov	rax, QWORD PTR s$[rsp]
	cmp	QWORD PTR word_wrap_eol$[rsp], rax
	jne	SHORT $LN17@RenderText

; 2958 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

	mov	rax, QWORD PTR word_wrap_eol$[rsp]
	inc	rax
	mov	QWORD PTR word_wrap_eol$[rsp], rax
$LN17@RenderText:
$LN16@RenderText:

; 2959 :             }
; 2960 : 
; 2961 :             if (s >= word_wrap_eol)

	mov	rax, QWORD PTR word_wrap_eol$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jb	$LN18@RenderText

; 2962 :             {
; 2963 :                 x = pos.x;

	movss	xmm0, DWORD PTR pos$[rsp]
	movss	DWORD PTR x$[rsp], xmm0

; 2964 :                 y += line_height;

	movss	xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR y$[rsp], xmm0

; 2965 :                 word_wrap_eol = NULL;

	mov	QWORD PTR word_wrap_eol$[rsp], 0
$LN8@RenderText:

; 2966 : 
; 2967 :                 // Wrapping skips upcoming blanks
; 2968 :                 while (s < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	SHORT $LN9@RenderText

; 2969 :                 {
; 2970 :                     const char c = *s;

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$1[rsp], al

; 2971 :                     if (ImCharIsBlankA(c)) { s++; }

	movzx	ecx, BYTE PTR c$1[rsp]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@RenderText
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
	jmp	SHORT $LN20@RenderText
$LN19@RenderText:

; 2972 :                     else if (c == '\n') { s++; break; }

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 10
	jne	SHORT $LN21@RenderText
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
	jmp	SHORT $LN9@RenderText
	jmp	SHORT $LN22@RenderText
$LN21@RenderText:

; 2973 :                     else { break; }

	jmp	SHORT $LN9@RenderText
$LN22@RenderText:
$LN20@RenderText:

; 2974 :                 }

	jmp	SHORT $LN8@RenderText
$LN9@RenderText:

; 2975 :                 continue;

	jmp	$LN6@RenderText
$LN18@RenderText:
$LN15@RenderText:

; 2976 :             }
; 2977 :         }
; 2978 : 
; 2979 :         // Decode and advance source
; 2980 :         unsigned int c = (unsigned int)*s;

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$2[rsp], eax

; 2981 :         if (c < 0x80)

	cmp	DWORD PTR c$2[rsp], 128			; 00000080H
	jae	SHORT $LN23@RenderText

; 2982 :         {
; 2983 :             s += 1;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax

; 2984 :         }

	jmp	SHORT $LN24@RenderText
$LN23@RenderText:

; 2985 :         else
; 2986 :         {
; 2987 :             s += ImTextCharFromUtf8(&c, s, text_end);

	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR s$[rsp]
	lea	rcx, QWORD PTR c$2[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR s$[rsp], rax

; 2988 :             if (c == 0) // Malformed UTF-8?

	cmp	DWORD PTR c$2[rsp], 0
	jne	SHORT $LN25@RenderText

; 2989 :                 break;

	jmp	$LN7@RenderText
$LN25@RenderText:
$LN24@RenderText:

; 2990 :         }
; 2991 : 
; 2992 :         if (c < 32)

	cmp	DWORD PTR c$2[rsp], 32			; 00000020H
	jae	SHORT $LN26@RenderText

; 2993 :         {
; 2994 :             if (c == '\n')

	cmp	DWORD PTR c$2[rsp], 10
	jne	SHORT $LN27@RenderText

; 2995 :             {
; 2996 :                 x = pos.x;

	movss	xmm0, DWORD PTR pos$[rsp]
	movss	DWORD PTR x$[rsp], xmm0

; 2997 :                 y += line_height;

	movss	xmm0, DWORD PTR y$[rsp]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR y$[rsp], xmm0

; 2998 :                 if (y > clip_rect.w)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	comiss	xmm0, DWORD PTR [rax+12]
	jbe	SHORT $LN28@RenderText

; 2999 :                     break; // break out of main loop

	jmp	$LN7@RenderText
$LN28@RenderText:

; 3000 :                 continue;

	jmp	$LN46@RenderText
$LN27@RenderText:

; 3001 :             }
; 3002 :             if (c == '\r')

	cmp	DWORD PTR c$2[rsp], 13
	jne	SHORT $LN29@RenderText

; 3003 :                 continue;

	jmp	$LN47@RenderText
$LN29@RenderText:
$LN26@RenderText:

; 3004 :         }
; 3005 : 
; 3006 :         float char_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR char_width$13[rsp], xmm0

; 3007 :         if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))

	movzx	edx, WORD PTR c$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyph
	mov	QWORD PTR glyph$11[rsp], rax
	cmp	QWORD PTR glyph$11[rsp], 0
	je	$LN30@RenderText

; 3008 :         {
; 3009 :             char_width = glyph->AdvanceX * scale;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR char_width$13[rsp], xmm0

; 3010 : 
; 3011 :             // Arbitrarily assume that both space and tabs are empty glyphs as an optimization
; 3012 :             if (c != ' ' && c != '\t')

	cmp	DWORD PTR c$2[rsp], 32			; 00000020H
	je	$LN31@RenderText
	cmp	DWORD PTR c$2[rsp], 9
	je	$LN31@RenderText

; 3013 :             {
; 3014 :                 // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
; 3015 :                 float x1 = x + glyph->X0 * scale;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	xmm1, DWORD PTR x$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x1$5[rsp], xmm0

; 3016 :                 float x2 = x + glyph->X1 * scale;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	xmm1, DWORD PTR x$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x2$4[rsp], xmm0

; 3017 :                 float y1 = y + glyph->Y0 * scale;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	xmm1, DWORD PTR y$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR y1$3[rsp], xmm0

; 3018 :                 float y2 = y + glyph->Y1 * scale;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	xmm1, DWORD PTR y$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR y2$6[rsp], xmm0

; 3019 :                 if (x1 <= clip_rect.z && x2 >= clip_rect.x)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR x1$5[rsp]
	jb	$LN32@RenderText
	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR x2$4[rsp]
	comiss	xmm0, DWORD PTR [rax]
	jb	$LN32@RenderText

; 3020 :                 {
; 3021 :                     // Render a character
; 3022 :                     float u1 = glyph->U0;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR u1$8[rsp], xmm0

; 3023 :                     float v1 = glyph->V0;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	movss	DWORD PTR v1$7[rsp], xmm0

; 3024 :                     float u2 = glyph->U1;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	movss	DWORD PTR u2$9[rsp], xmm0

; 3025 :                     float v2 = glyph->V1;

	mov	rax, QWORD PTR glyph$11[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	movss	DWORD PTR v2$10[rsp], xmm0

; 3026 : 
; 3027 :                     // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
; 3028 :                     if (cpu_fine_clip)

	movzx	eax, BYTE PTR cpu_fine_clip$[rsp]
	test	eax, eax
	je	$LN33@RenderText

; 3029 :                     {
; 3030 :                         if (x1 < clip_rect.x)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR x1$5[rsp]
	jbe	SHORT $LN34@RenderText

; 3031 :                         {
; 3032 :                             u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR x2$4[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	xmm1, DWORD PTR x2$4[rsp]
	subss	xmm1, DWORD PTR x1$5[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR u2$9[rsp]
	subss	xmm1, DWORD PTR u1$8[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR u1$8[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR u1$8[rsp], xmm0

; 3033 :                             x1 = clip_rect.x;

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR x1$5[rsp], xmm0
$LN34@RenderText:

; 3034 :                         }
; 3035 :                         if (y1 < clip_rect.y)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR y1$3[rsp]
	jbe	SHORT $LN35@RenderText

; 3036 :                         {
; 3037 :                             v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR y2$6[rsp]
	subss	xmm0, DWORD PTR [rax+4]
	movss	xmm1, DWORD PTR y2$6[rsp]
	subss	xmm1, DWORD PTR y1$3[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR v2$10[rsp]
	subss	xmm1, DWORD PTR v1$7[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR v1$7[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR v1$7[rsp], xmm0

; 3038 :                             y1 = clip_rect.y;

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR y1$3[rsp], xmm0
$LN35@RenderText:

; 3039 :                         }
; 3040 :                         if (x2 > clip_rect.z)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR x2$4[rsp]
	comiss	xmm0, DWORD PTR [rax+8]
	jbe	SHORT $LN36@RenderText

; 3041 :                         {
; 3042 :                             u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR x1$5[rsp]
	movss	xmm1, DWORD PTR x2$4[rsp]
	subss	xmm1, DWORD PTR x1$5[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR u2$9[rsp]
	subss	xmm1, DWORD PTR u1$8[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR u1$8[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR u2$9[rsp], xmm0

; 3043 :                             x2 = clip_rect.z;

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR x2$4[rsp], xmm0
$LN36@RenderText:

; 3044 :                         }
; 3045 :                         if (y2 > clip_rect.w)

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR y2$6[rsp]
	comiss	xmm0, DWORD PTR [rax+12]
	jbe	SHORT $LN37@RenderText

; 3046 :                         {
; 3047 :                             v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR y1$3[rsp]
	movss	xmm1, DWORD PTR y2$6[rsp]
	subss	xmm1, DWORD PTR y1$3[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR v2$10[rsp]
	subss	xmm1, DWORD PTR v1$7[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR v1$7[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR v2$10[rsp], xmm0

; 3048 :                             y2 = clip_rect.w;

	mov	rax, QWORD PTR clip_rect$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR y2$6[rsp], xmm0
$LN37@RenderText:

; 3049 :                         }
; 3050 :                         if (y1 >= y2)

	movss	xmm0, DWORD PTR y1$3[rsp]
	comiss	xmm0, DWORD PTR y2$6[rsp]
	jb	SHORT $LN38@RenderText

; 3051 :                         {
; 3052 :                             x += char_width;

	movss	xmm0, DWORD PTR x$[rsp]
	addss	xmm0, DWORD PTR char_width$13[rsp]
	movss	DWORD PTR x$[rsp], xmm0

; 3053 :                             continue;

	jmp	$LN48@RenderText
$LN38@RenderText:
$LN33@RenderText:

; 3054 :                         }
; 3055 :                     }
; 3056 : 
; 3057 :                     // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
; 3058 :                     {
; 3059 :                         idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx + 1); idx_write[2] = (ImDrawIdx)(vtx_current_idx + 2);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR idx_write$[rsp]
	movzx	edx, WORD PTR vtx_current_idx$[rsp]
	mov	WORD PTR [rcx+rax], dx
	mov	eax, DWORD PTR vtx_current_idx$[rsp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR idx_write$[rsp]
	mov	WORD PTR [rdx+rcx], ax
	mov	eax, DWORD PTR vtx_current_idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR idx_write$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 3060 :                         idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx + 2); idx_write[5] = (ImDrawIdx)(vtx_current_idx + 3);

	mov	eax, 2
	imul	rax, rax, 3
	mov	rcx, QWORD PTR idx_write$[rsp]
	movzx	edx, WORD PTR vtx_current_idx$[rsp]
	mov	WORD PTR [rcx+rax], dx
	mov	eax, DWORD PTR vtx_current_idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR idx_write$[rsp]
	mov	WORD PTR [rdx+rcx], ax
	mov	eax, DWORD PTR vtx_current_idx$[rsp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR idx_write$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 3061 :                         vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;

	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR x1$5[rsp]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR y1$3[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR vtx_write$[rsp]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR u1$8[rsp]
	movss	DWORD PTR [rcx+rax+8], xmm0
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR v1$7[rsp]
	movss	DWORD PTR [rcx+rax+12], xmm0

; 3062 :                         vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;

	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR x2$4[rsp]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR y1$3[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR vtx_write$[rsp]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR u2$9[rsp]
	movss	DWORD PTR [rcx+rax+8], xmm0
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR v1$7[rsp]
	movss	DWORD PTR [rcx+rax+12], xmm0

; 3063 :                         vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;

	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR x2$4[rsp]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR y2$6[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR vtx_write$[rsp]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR u2$9[rsp]
	movss	DWORD PTR [rcx+rax+8], xmm0
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR v2$10[rsp]
	movss	DWORD PTR [rcx+rax+12], xmm0

; 3064 :                         vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;

	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR x1$5[rsp]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR y2$6[rsp]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR vtx_write$[rsp]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR u1$8[rsp]
	movss	DWORD PTR [rcx+rax+8], xmm0
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR vtx_write$[rsp]
	movss	xmm0, DWORD PTR v2$10[rsp]
	movss	DWORD PTR [rcx+rax+12], xmm0

; 3065 :                         vtx_write += 4;

	mov	rax, QWORD PTR vtx_write$[rsp]
	add	rax, 80					; 00000050H
	mov	QWORD PTR vtx_write$[rsp], rax

; 3066 :                         vtx_current_idx += 4;

	mov	eax, DWORD PTR vtx_current_idx$[rsp]
	add	eax, 4
	mov	DWORD PTR vtx_current_idx$[rsp], eax

; 3067 :                         idx_write += 6;

	mov	rax, QWORD PTR idx_write$[rsp]
	add	rax, 12
	mov	QWORD PTR idx_write$[rsp], rax
$LN32@RenderText:
$LN31@RenderText:
$LN30@RenderText:

; 3068 :                     }
; 3069 :                 }
; 3070 :             }
; 3071 :         }
; 3072 : 
; 3073 :         x += char_width;

	movss	xmm0, DWORD PTR x$[rsp]
	addss	xmm0, DWORD PTR char_width$13[rsp]
	movss	DWORD PTR x$[rsp], xmm0

; 3074 :     }

	jmp	$LN49@RenderText
$LN7@RenderText:

; 3075 : 
; 3076 :     // Give back unused vertices
; 3077 :     draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	QWORD PTR tv424[rsp], rax
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR vtx_write$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 20
	idiv	rcx
	mov	edx, eax
	mov	rcx, QWORD PTR tv424[rsp]
	call	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::resize

; 3078 :     draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));

	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv434[rsp], rax
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR idx_write$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	edx, eax
	mov	rcx, QWORD PTR tv434[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 3079 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	ecx, DWORD PTR idx_expected_size$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv452[rsp], eax
	mov	rax, QWORD PTR draw_list$[rsp]
	add	rax, 24
	mov	QWORD PTR tv443[rsp], rax
	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax+24]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv443[rsp]
	call	??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
	add	rax, 8
	mov	QWORD PTR tv448[rsp], rax
	mov	rax, QWORD PTR tv448[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv450[rsp], eax
	mov	eax, DWORD PTR tv452[rsp]
	mov	ecx, DWORD PTR tv450[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR tv448[rsp]
	mov	DWORD PTR [rcx], eax

; 3080 :     draw_list->_VtxWritePtr = vtx_write;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rcx, QWORD PTR vtx_write$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 3081 :     draw_list->_IdxWritePtr = idx_write;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rcx, QWORD PTR idx_write$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 3082 :     draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+64], ecx
$LN1@RenderText:

; 3083 : }

	add	rsp, 264				; 00000108H
	ret	0
?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ENDP ; ImFont::RenderText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
scale$1 = 48
glyph$2 = 56
tv79 = 64
tv170 = 72
tv168 = 80
tv166 = 88
tv164 = 96
$T3 = 104
$T4 = 112
$T5 = 120
$T6 = 128
this$ = 160
draw_list$ = 168
size$ = 176
pos$ = 184
col$ = 192
c$ = 200
?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z PROC ; ImFont::RenderChar

; 2881 : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 2882 :     if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.

	movzx	eax, WORD PTR c$[rsp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@RenderChar
	movzx	eax, WORD PTR c$[rsp]
	cmp	eax, 9
	je	SHORT $LN3@RenderChar
	movzx	eax, WORD PTR c$[rsp]
	cmp	eax, 10
	je	SHORT $LN3@RenderChar
	movzx	eax, WORD PTR c$[rsp]
	cmp	eax, 13
	jne	SHORT $LN2@RenderChar
$LN3@RenderChar:

; 2883 :         return;

	jmp	$LN1@RenderChar
$LN2@RenderChar:

; 2884 :     if (const ImFontGlyph* glyph = FindGlyph(c))

	movzx	edx, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyph
	mov	QWORD PTR glyph$2[rsp], rax
	cmp	QWORD PTR glyph$2[rsp], 0
	je	$LN4@RenderChar

; 2885 :     {
; 2886 :         float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;

	movss	xmm0, DWORD PTR size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@RenderChar
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	divss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR tv79[rsp], xmm0
	jmp	SHORT $LN7@RenderChar
$LN6@RenderChar:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv79[rsp], xmm0
$LN7@RenderChar:
	movss	xmm0, DWORD PTR tv79[rsp]
	movss	DWORD PTR scale$1[rsp], xmm0

; 2887 :         pos.x = (float)(int)pos.x + DisplayOffset.x;

	cvttss2si eax, DWORD PTR pos$[rsp]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	addss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR pos$[rsp], xmm0

; 2888 :         pos.y = (float)(int)pos.y + DisplayOffset.y;

	cvttss2si eax, DWORD PTR pos$[rsp+4]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	addss	xmm0, DWORD PTR [rax+68]
	movss	DWORD PTR pos$[rsp+4], xmm0

; 2889 :         draw_list->PrimReserve(6, 4);

	mov	r8d, 4
	mov	edx, 6
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	npad	1

; 2890 :         draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm2, DWORD PTR [rax+36]
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm1, DWORD PTR [rax+32]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv170[rsp], rax
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm2, DWORD PTR [rax+28]
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm1, DWORD PTR [rax+24]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv168[rsp], rax
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	mulss	xmm0, DWORD PTR scale$1[rsp]
	movss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm1, DWORD PTR [rax+16]
	mulss	xmm1, DWORD PTR scale$1[rsp]
	movss	xmm2, DWORD PTR pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv166[rsp], rax
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR scale$1[rsp]
	movss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR glyph$2[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR scale$1[rsp]
	movss	xmm2, DWORD PTR pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv164[rsp], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv170[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv168[rsp]
	mov	r8, QWORD PTR tv166[rsp]
	mov	rdx, QWORD PTR tv164[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV
	npad	1
$LN4@RenderChar:
$LN1@RenderChar:

; 2891 :     }
; 2892 : }

	add	rsp, 152				; 00000098H
	ret	0
?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z ENDP ; ImFont::RenderChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
inside_word$ = 32
c$1 = 36
blank_width$ = 40
word_width$ = 44
line_width$ = 48
s$ = 56
tv88 = 64
char_width$2 = 68
tv140 = 72
next_s$3 = 80
word_end$ = 88
prev_word_end$ = 96
tv146 = 104
this$ = 128
scale$ = 136
text$ = 144
text_end$ = 152
wrap_width$ = 160
?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z PROC	; ImFont::CalcWordWrapPositionA

; 2686 : {

$LN26:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 2687 :     // Simple word-wrapping for English, not full-featured. Please submit failing cases!
; 2688 :     // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
; 2689 : 
; 2690 :     // For references, possible wrap point marked with ^
; 2691 :     //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
; 2692 :     //      ^    ^    ^   ^   ^__    ^    ^
; 2693 : 
; 2694 :     // List of hardcoded separators: .,;!?'"
; 2695 : 
; 2696 :     // Skip extra blanks after a line returns (that includes not counting them in width computation)
; 2697 :     // e.g. "Hello    world" --> "Hello" "World"
; 2698 : 
; 2699 :     // Cut words that cannot possibly fit within one line.
; 2700 :     // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
; 2701 : 
; 2702 :     float line_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR line_width$[rsp], xmm0

; 2703 :     float word_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR word_width$[rsp], xmm0

; 2704 :     float blank_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR blank_width$[rsp], xmm0

; 2705 :     wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

	movss	xmm0, DWORD PTR wrap_width$[rsp]
	divss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR wrap_width$[rsp], xmm0

; 2706 : 
; 2707 :     const char* word_end = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR word_end$[rsp], rax

; 2708 :     const char* prev_word_end = NULL;

	mov	QWORD PTR prev_word_end$[rsp], 0

; 2709 :     bool inside_word = true;

	mov	BYTE PTR inside_word$[rsp], 1

; 2710 : 
; 2711 :     const char* s = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR s$[rsp], rax
$LN25@CalcWordWr:
$LN24@CalcWordWr:
$LN2@CalcWordWr:

; 2712 :     while (s < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	$LN3@CalcWordWr

; 2713 :     {
; 2714 :         unsigned int c = (unsigned int)*s;

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$1[rsp], eax

; 2715 :         const char* next_s;
; 2716 :         if (c < 0x80)

	cmp	DWORD PTR c$1[rsp], 128			; 00000080H
	jae	SHORT $LN4@CalcWordWr

; 2717 :             next_s = s + 1;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR next_s$3[rsp], rax
	jmp	SHORT $LN5@CalcWordWr
$LN4@CalcWordWr:

; 2718 :         else
; 2719 :             next_s = s + ImTextCharFromUtf8(&c, s, text_end);

	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR s$[rsp]
	lea	rcx, QWORD PTR c$1[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR next_s$3[rsp], rax
$LN5@CalcWordWr:

; 2720 :         if (c == 0)

	cmp	DWORD PTR c$1[rsp], 0
	jne	SHORT $LN6@CalcWordWr

; 2721 :             break;

	jmp	$LN3@CalcWordWr
$LN6@CalcWordWr:

; 2722 : 
; 2723 :         if (c < 32)

	cmp	DWORD PTR c$1[rsp], 32			; 00000020H
	jae	SHORT $LN7@CalcWordWr

; 2724 :         {
; 2725 :             if (c == '\n')

	cmp	DWORD PTR c$1[rsp], 10
	jne	SHORT $LN8@CalcWordWr

; 2726 :             {
; 2727 :                 line_width = word_width = blank_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR blank_width$[rsp], xmm0
	movss	xmm0, DWORD PTR blank_width$[rsp]
	movss	DWORD PTR word_width$[rsp], xmm0
	movss	xmm0, DWORD PTR word_width$[rsp]
	movss	DWORD PTR line_width$[rsp], xmm0

; 2728 :                 inside_word = true;

	mov	BYTE PTR inside_word$[rsp], 1

; 2729 :                 s = next_s;

	mov	rax, QWORD PTR next_s$3[rsp]
	mov	QWORD PTR s$[rsp], rax

; 2730 :                 continue;

	jmp	$LN2@CalcWordWr
$LN8@CalcWordWr:

; 2731 :             }
; 2732 :             if (c == '\r')

	cmp	DWORD PTR c$1[rsp], 13
	jne	SHORT $LN9@CalcWordWr

; 2733 :             {
; 2734 :                 s = next_s;

	mov	rax, QWORD PTR next_s$3[rsp]
	mov	QWORD PTR s$[rsp], rax

; 2735 :                 continue;

	jmp	$LN24@CalcWordWr
$LN9@CalcWordWr:
$LN7@CalcWordWr:

; 2736 :             }
; 2737 :         }
; 2738 : 
; 2739 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR c$1[rsp], eax
	jge	SHORT $LN18@CalcWordWr
	mov	eax, DWORD PTR c$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR tv88[rsp], xmm0
	jmp	SHORT $LN19@CalcWordWr
$LN18@CalcWordWr:
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR tv88[rsp], xmm0
$LN19@CalcWordWr:
	movss	xmm0, DWORD PTR tv88[rsp]
	movss	DWORD PTR char_width$2[rsp], xmm0

; 2740 :         if (ImCharIsBlankW(c))

	mov	ecx, DWORD PTR c$1[rsp]
	call	?ImCharIsBlankW@@YA_NI@Z		; ImCharIsBlankW
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@CalcWordWr

; 2741 :         {
; 2742 :             if (inside_word)

	movzx	eax, BYTE PTR inside_word$[rsp]
	test	eax, eax
	je	SHORT $LN12@CalcWordWr

; 2743 :             {
; 2744 :                 line_width += blank_width;

	movss	xmm0, DWORD PTR line_width$[rsp]
	addss	xmm0, DWORD PTR blank_width$[rsp]
	movss	DWORD PTR line_width$[rsp], xmm0

; 2745 :                 blank_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR blank_width$[rsp], xmm0

; 2746 :                 word_end = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR word_end$[rsp], rax
$LN12@CalcWordWr:

; 2747 :             }
; 2748 :             blank_width += char_width;

	movss	xmm0, DWORD PTR blank_width$[rsp]
	addss	xmm0, DWORD PTR char_width$2[rsp]
	movss	DWORD PTR blank_width$[rsp], xmm0

; 2749 :             inside_word = false;

	mov	BYTE PTR inside_word$[rsp], 0

; 2750 :         }

	jmp	$LN11@CalcWordWr
$LN10@CalcWordWr:

; 2751 :         else
; 2752 :         {
; 2753 :             word_width += char_width;

	movss	xmm0, DWORD PTR word_width$[rsp]
	addss	xmm0, DWORD PTR char_width$2[rsp]
	movss	DWORD PTR word_width$[rsp], xmm0

; 2754 :             if (inside_word)

	movzx	eax, BYTE PTR inside_word$[rsp]
	test	eax, eax
	je	SHORT $LN13@CalcWordWr

; 2755 :             {
; 2756 :                 word_end = next_s;

	mov	rax, QWORD PTR next_s$3[rsp]
	mov	QWORD PTR word_end$[rsp], rax

; 2757 :             }

	jmp	SHORT $LN14@CalcWordWr
$LN13@CalcWordWr:

; 2758 :             else
; 2759 :             {
; 2760 :                 prev_word_end = word_end;

	mov	rax, QWORD PTR word_end$[rsp]
	mov	QWORD PTR prev_word_end$[rsp], rax

; 2761 :                 line_width += word_width + blank_width;

	movss	xmm0, DWORD PTR word_width$[rsp]
	addss	xmm0, DWORD PTR blank_width$[rsp]
	movss	xmm1, DWORD PTR line_width$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR line_width$[rsp], xmm0

; 2762 :                 word_width = blank_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR blank_width$[rsp], xmm0
	movss	xmm0, DWORD PTR blank_width$[rsp]
	movss	DWORD PTR word_width$[rsp], xmm0
$LN14@CalcWordWr:

; 2763 :             }
; 2764 : 
; 2765 :             // Allow wrapping after punctuation.
; 2766 :             inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');

	cmp	DWORD PTR c$1[rsp], 46			; 0000002eH
	je	SHORT $LN20@CalcWordWr
	cmp	DWORD PTR c$1[rsp], 44			; 0000002cH
	je	SHORT $LN20@CalcWordWr
	cmp	DWORD PTR c$1[rsp], 59			; 0000003bH
	je	SHORT $LN20@CalcWordWr
	cmp	DWORD PTR c$1[rsp], 33			; 00000021H
	je	SHORT $LN20@CalcWordWr
	cmp	DWORD PTR c$1[rsp], 63			; 0000003fH
	je	SHORT $LN20@CalcWordWr
	cmp	DWORD PTR c$1[rsp], 34			; 00000022H
	je	SHORT $LN20@CalcWordWr
	mov	DWORD PTR tv140[rsp], 1
	jmp	SHORT $LN21@CalcWordWr
$LN20@CalcWordWr:
	mov	DWORD PTR tv140[rsp], 0
$LN21@CalcWordWr:
	movzx	eax, BYTE PTR tv140[rsp]
	mov	BYTE PTR inside_word$[rsp], al
$LN11@CalcWordWr:

; 2767 :         }
; 2768 : 
; 2769 :         // We ignore blank width at the end of the line (they can be skipped)
; 2770 :         if (line_width + word_width >= wrap_width)

	movss	xmm0, DWORD PTR line_width$[rsp]
	addss	xmm0, DWORD PTR word_width$[rsp]
	comiss	xmm0, DWORD PTR wrap_width$[rsp]
	jb	SHORT $LN15@CalcWordWr

; 2771 :         {
; 2772 :             // Words that cannot possibly fit within an entire line will be cut anywhere.
; 2773 :             if (word_width < wrap_width)

	movss	xmm0, DWORD PTR wrap_width$[rsp]
	comiss	xmm0, DWORD PTR word_width$[rsp]
	jbe	SHORT $LN16@CalcWordWr

; 2774 :                 s = prev_word_end ? prev_word_end : word_end;

	cmp	QWORD PTR prev_word_end$[rsp], 0
	je	SHORT $LN22@CalcWordWr
	mov	rax, QWORD PTR prev_word_end$[rsp]
	mov	QWORD PTR tv146[rsp], rax
	jmp	SHORT $LN23@CalcWordWr
$LN22@CalcWordWr:
	mov	rax, QWORD PTR word_end$[rsp]
	mov	QWORD PTR tv146[rsp], rax
$LN23@CalcWordWr:
	mov	rax, QWORD PTR tv146[rsp]
	mov	QWORD PTR s$[rsp], rax
$LN16@CalcWordWr:

; 2775 :             break;

	jmp	SHORT $LN3@CalcWordWr
$LN15@CalcWordWr:

; 2776 :         }
; 2777 : 
; 2778 :         s = next_s;

	mov	rax, QWORD PTR next_s$3[rsp]
	mov	QWORD PTR s$[rsp], rax

; 2779 :     }

	jmp	$LN25@CalcWordWr
$LN3@CalcWordWr:

; 2780 : 
; 2781 :     return s;

	mov	rax, QWORD PTR s$[rsp]

; 2782 : }

	add	rsp, 120				; 00000078H
	ret	0
?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ENDP	; ImFont::CalcWordWrapPositionA
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
line_width$ = 48
tv74 = 52
c$1 = 53
s$ = 56
c$2 = 64
word_wrap_enabled$ = 68
text_size$ = 72
line_height$ = 80
word_wrap_eol$ = 88
tv158 = 96
scale$ = 100
char_width$3 = 104
prev_s$4 = 112
this$ = 144
__$ReturnUdt$ = 152
size$ = 160
max_width$ = 168
wrap_width$ = 176
text_begin$ = 184
text_end$ = 192
remaining$ = 200
?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z PROC ; ImFont::CalcTextSizeA

; 2785 : {

$LN35:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2786 :     if (!text_end)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN6@CalcTextSi

; 2787 :         text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

	mov	rcx, QWORD PTR text_begin$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text_begin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN6@CalcTextSi:

; 2788 : 
; 2789 :     const float line_height = size;

	movss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR line_height$[rsp], xmm0

; 2790 :     const float scale = size / FontSize;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	divss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR scale$[rsp], xmm0

; 2791 : 
; 2792 :     ImVec2 text_size = ImVec2(0, 0);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 2793 :     float line_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR line_width$[rsp], xmm0

; 2794 : 
; 2795 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	movss	xmm0, DWORD PTR wrap_width$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN28@CalcTextSi
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN29@CalcTextSi
$LN28@CalcTextSi:
	mov	BYTE PTR tv74[rsp], 0
$LN29@CalcTextSi:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR word_wrap_enabled$[rsp], al

; 2796 :     const char* word_wrap_eol = NULL;

	mov	QWORD PTR word_wrap_eol$[rsp], 0

; 2797 : 
; 2798 :     const char* s = text_begin;

	mov	rax, QWORD PTR text_begin$[rsp]
	mov	QWORD PTR s$[rsp], rax
$LN34@CalcTextSi:
$LN33@CalcTextSi:
$LN32@CalcTextSi:
$LN2@CalcTextSi:

; 2799 :     while (s < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	$LN3@CalcTextSi

; 2800 :     {
; 2801 :         if (word_wrap_enabled)

	movzx	eax, BYTE PTR word_wrap_enabled$[rsp]
	test	eax, eax
	je	$LN7@CalcTextSi

; 2802 :         {
; 2803 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 2804 :             if (!word_wrap_eol)

	cmp	QWORD PTR word_wrap_eol$[rsp], 0
	jne	SHORT $LN8@CalcTextSi

; 2805 :             {
; 2806 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

	movss	xmm0, DWORD PTR wrap_width$[rsp]
	subss	xmm0, DWORD PTR line_width$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR text_end$[rsp]
	mov	r8, QWORD PTR s$[rsp]
	movss	xmm1, DWORD PTR scale$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
	mov	QWORD PTR word_wrap_eol$[rsp], rax

; 2807 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

	mov	rax, QWORD PTR s$[rsp]
	cmp	QWORD PTR word_wrap_eol$[rsp], rax
	jne	SHORT $LN9@CalcTextSi

; 2808 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

	mov	rax, QWORD PTR word_wrap_eol$[rsp]
	inc	rax
	mov	QWORD PTR word_wrap_eol$[rsp], rax
$LN9@CalcTextSi:
$LN8@CalcTextSi:

; 2809 :             }
; 2810 : 
; 2811 :             if (s >= word_wrap_eol)

	mov	rax, QWORD PTR word_wrap_eol$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jb	$LN10@CalcTextSi

; 2812 :             {
; 2813 :                 if (text_size.x < line_width)

	movss	xmm0, DWORD PTR line_width$[rsp]
	comiss	xmm0, DWORD PTR text_size$[rsp]
	jbe	SHORT $LN11@CalcTextSi

; 2814 :                     text_size.x = line_width;

	movss	xmm0, DWORD PTR line_width$[rsp]
	movss	DWORD PTR text_size$[rsp], xmm0
$LN11@CalcTextSi:

; 2815 :                 text_size.y += line_height;

	movss	xmm0, DWORD PTR text_size$[rsp+4]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR text_size$[rsp+4], xmm0

; 2816 :                 line_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR line_width$[rsp], xmm0

; 2817 :                 word_wrap_eol = NULL;

	mov	QWORD PTR word_wrap_eol$[rsp], 0
$LN4@CalcTextSi:

; 2818 : 
; 2819 :                 // Wrapping skips upcoming blanks
; 2820 :                 while (s < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	SHORT $LN5@CalcTextSi

; 2821 :                 {
; 2822 :                     const char c = *s;

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$1[rsp], al

; 2823 :                     if (ImCharIsBlankA(c)) { s++; }

	movzx	ecx, BYTE PTR c$1[rsp]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@CalcTextSi
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
	jmp	SHORT $LN13@CalcTextSi
$LN12@CalcTextSi:

; 2824 :                     else if (c == '\n') { s++; break; }

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 10
	jne	SHORT $LN14@CalcTextSi
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
	jmp	SHORT $LN5@CalcTextSi
	jmp	SHORT $LN15@CalcTextSi
$LN14@CalcTextSi:

; 2825 :                     else { break; }

	jmp	SHORT $LN5@CalcTextSi
$LN15@CalcTextSi:
$LN13@CalcTextSi:

; 2826 :                 }

	jmp	SHORT $LN4@CalcTextSi
$LN5@CalcTextSi:

; 2827 :                 continue;

	jmp	$LN2@CalcTextSi
$LN10@CalcTextSi:
$LN7@CalcTextSi:

; 2828 :             }
; 2829 :         }
; 2830 : 
; 2831 :         // Decode and advance source
; 2832 :         const char* prev_s = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR prev_s$4[rsp], rax

; 2833 :         unsigned int c = (unsigned int)*s;

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$2[rsp], eax

; 2834 :         if (c < 0x80)

	cmp	DWORD PTR c$2[rsp], 128			; 00000080H
	jae	SHORT $LN16@CalcTextSi

; 2835 :         {
; 2836 :             s += 1;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax

; 2837 :         }

	jmp	SHORT $LN17@CalcTextSi
$LN16@CalcTextSi:

; 2838 :         else
; 2839 :         {
; 2840 :             s += ImTextCharFromUtf8(&c, s, text_end);

	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR s$[rsp]
	lea	rcx, QWORD PTR c$2[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR s$[rsp], rax

; 2841 :             if (c == 0) // Malformed UTF-8?

	cmp	DWORD PTR c$2[rsp], 0
	jne	SHORT $LN18@CalcTextSi

; 2842 :                 break;

	jmp	$LN3@CalcTextSi
$LN18@CalcTextSi:
$LN17@CalcTextSi:

; 2843 :         }
; 2844 : 
; 2845 :         if (c < 32)

	cmp	DWORD PTR c$2[rsp], 32			; 00000020H
	jae	SHORT $LN19@CalcTextSi

; 2846 :         {
; 2847 :             if (c == '\n')

	cmp	DWORD PTR c$2[rsp], 10
	jne	SHORT $LN20@CalcTextSi

; 2848 :             {
; 2849 :                 text_size.x = ImMax(text_size.x, line_width);

	movss	xmm1, DWORD PTR line_width$[rsp]
	movss	xmm0, DWORD PTR text_size$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_size$[rsp], xmm0

; 2850 :                 text_size.y += line_height;

	movss	xmm0, DWORD PTR text_size$[rsp+4]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR text_size$[rsp+4], xmm0

; 2851 :                 line_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR line_width$[rsp], xmm0

; 2852 :                 continue;

	jmp	$LN32@CalcTextSi
$LN20@CalcTextSi:

; 2853 :             }
; 2854 :             if (c == '\r')

	cmp	DWORD PTR c$2[rsp], 13
	jne	SHORT $LN21@CalcTextSi

; 2855 :                 continue;

	jmp	$LN33@CalcTextSi
$LN21@CalcTextSi:
$LN19@CalcTextSi:

; 2856 :         }
; 2857 : 
; 2858 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR c$2[rsp], eax
	jge	SHORT $LN30@CalcTextSi
	mov	eax, DWORD PTR c$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR tv158[rsp], xmm0
	jmp	SHORT $LN31@CalcTextSi
$LN30@CalcTextSi:
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR tv158[rsp], xmm0
$LN31@CalcTextSi:
	movss	xmm0, DWORD PTR tv158[rsp]
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR char_width$3[rsp], xmm0

; 2859 :         if (line_width + char_width >= max_width)

	movss	xmm0, DWORD PTR line_width$[rsp]
	addss	xmm0, DWORD PTR char_width$3[rsp]
	comiss	xmm0, DWORD PTR max_width$[rsp]
	jb	SHORT $LN22@CalcTextSi

; 2860 :         {
; 2861 :             s = prev_s;

	mov	rax, QWORD PTR prev_s$4[rsp]
	mov	QWORD PTR s$[rsp], rax

; 2862 :             break;

	jmp	SHORT $LN3@CalcTextSi
$LN22@CalcTextSi:

; 2863 :         }
; 2864 : 
; 2865 :         line_width += char_width;

	movss	xmm0, DWORD PTR line_width$[rsp]
	addss	xmm0, DWORD PTR char_width$3[rsp]
	movss	DWORD PTR line_width$[rsp], xmm0

; 2866 :     }

	jmp	$LN34@CalcTextSi
$LN3@CalcTextSi:

; 2867 : 
; 2868 :     if (text_size.x < line_width)

	movss	xmm0, DWORD PTR line_width$[rsp]
	comiss	xmm0, DWORD PTR text_size$[rsp]
	jbe	SHORT $LN23@CalcTextSi

; 2869 :         text_size.x = line_width;

	movss	xmm0, DWORD PTR line_width$[rsp]
	movss	DWORD PTR text_size$[rsp], xmm0
$LN23@CalcTextSi:

; 2870 : 
; 2871 :     if (line_width > 0 || text_size.y == 0.0f)

	movss	xmm0, DWORD PTR line_width$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN25@CalcTextSi
	movss	xmm0, DWORD PTR text_size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN24@CalcTextSi
	jne	SHORT $LN24@CalcTextSi
$LN25@CalcTextSi:

; 2872 :         text_size.y += line_height;

	movss	xmm0, DWORD PTR text_size$[rsp+4]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR text_size$[rsp+4], xmm0
$LN24@CalcTextSi:

; 2873 : 
; 2874 :     if (remaining)

	cmp	QWORD PTR remaining$[rsp], 0
	je	SHORT $LN26@CalcTextSi

; 2875 :         *remaining = s;

	mov	rax, QWORD PTR remaining$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rax], rcx
$LN26@CalcTextSi:

; 2876 : 
; 2877 :     return text_size;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR text_size$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2878 : }

	add	rsp, 136				; 00000088H
	ret	0
?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ENDP ; ImFont::CalcTextSizeA
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$ = 0
this$ = 32
c$ = 40
?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z PROC ; ImFont::FindGlyphNoFallback

; 2676 : {

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2677 :     if (c >= IndexLookup.Size)

	movzx	eax, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx+48]
	jl	SHORT $LN2@FindGlyphN

; 2678 :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@FindGlyphN
$LN2@FindGlyphN:

; 2679 :     const ImWchar i = IndexLookup.Data[c];

	movzx	eax, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR i$[rsp], ax

; 2680 :     if (i == (ImWchar)-1)

	movzx	eax, WORD PTR i$[rsp]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $LN3@FindGlyphN

; 2681 :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@FindGlyphN
$LN3@FindGlyphN:

; 2682 :     return &Glyphs.Data[i];

	movzx	eax, WORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+32]
$LN1@FindGlyphN:

; 2683 : }

	add	rsp, 24
	ret	0
?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ENDP ; ImFont::FindGlyphNoFallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$ = 0
this$ = 32
c$ = 40
?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z PROC	; ImFont::FindGlyph

; 2666 : {

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2667 :     if (c >= IndexLookup.Size)

	movzx	eax, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx+48]
	jl	SHORT $LN2@FindGlyph

; 2668 :         return FallbackGlyph;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	jmp	SHORT $LN1@FindGlyph
$LN2@FindGlyph:

; 2669 :     const ImWchar i = IndexLookup.Data[c];

	movzx	eax, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR i$[rsp], ax

; 2670 :     if (i == (ImWchar)-1)

	movzx	eax, WORD PTR i$[rsp]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $LN3@FindGlyph

; 2671 :         return FallbackGlyph;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	jmp	SHORT $LN1@FindGlyph
$LN3@FindGlyph:

; 2672 :     return &Glyphs.Data[i];

	movzx	eax, WORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+32]
$LN1@FindGlyph:

; 2673 : }

	add	rsp, 24
	ret	0
?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ENDP	; ImFont::FindGlyph
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
??1ImFont@@QEAA@XZ PROC					; ImFont::~ImFont

; 2553 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2554 :     ClearOutputData();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearOutputData@ImFont@@QEAAXXZ	; ImFont::ClearOutputData
	npad	1

; 2555 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$ImVector@UImFontGlyph@@@@QEAA@XZ	; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImFont@@QEAA@XZ ENDP					; ImFont::~ImFont
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImFont@@QEAA@XZ@4HA PROC			; `ImFont::~ImFont'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImFont@@QEAA@XZ@4HA ENDP			; `ImFont::~ImFont'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImFont@@QEAA@XZ@4HA PROC			; `ImFont::~ImFont'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$ImVector@UImFontGlyph@@@@QEAA@XZ	; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImFont@@QEAA@XZ@4HA ENDP			; `ImFont::~ImFont'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1ImFont@@QEAA@XZ@4HA PROC			; `ImFont::~ImFont'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 48					; 00000030H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImFont@@QEAA@XZ@4HA ENDP			; `ImFont::~ImFont'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0ImFont@@QEAA@XZ PROC					; ImFont::ImFont

; 2537 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@M@@QEAA@XZ		; ImVector<float>::ImVector<float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0?$ImVector@UImFontGlyph@@@@QEAA@XZ	; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 2538 :     FontSize = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0

; 2539 :     FallbackAdvanceX = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0

; 2540 :     FallbackChar = (ImWchar)'?';

	mov	eax, 63					; 0000003fH
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+106], ax

; 2541 :     DisplayOffset = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 2542 :     FallbackGlyph = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0

; 2543 :     ContainerAtlas = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 2544 :     ConfigData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+96], 0

; 2545 :     ConfigDataCount = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+104], ax

; 2546 :     DirtyLookupTables = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+112], 0

; 2547 :     Scale = 1.0f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+80], xmm0

; 2548 :     Ascent = Descent = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+88], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+84], xmm0

; 2549 :     MetricsTotalSurface = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+108], 0

; 2550 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImFont@@QEAA@XZ ENDP					; ImFont::ImFont
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0ImFont@@QEAA@XZ@4HA PROC			; `ImFont::ImFont'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@M@@QEAA@XZ		; ImVector<float>::~ImVector<float>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImFont@@QEAA@XZ@4HA ENDP			; `ImFont::ImFont'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???0ImFont@@QEAA@XZ@4HA PROC			; `ImFont::ImFont'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$ImVector@UImFontGlyph@@@@QEAA@XZ	; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImFont@@QEAA@XZ@4HA ENDP			; `ImFont::ImFont'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$2@?0???0ImFont@@QEAA@XZ@4HA PROC			; `ImFont::ImFont'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 48					; 00000030H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImFont@@QEAA@XZ@4HA ENDP			; `ImFont::ImFont'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z PROC	; ImVector<ImFontGlyph>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 40				; 00000028H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ENDP	; ImVector<ImFontGlyph>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z PROC	; ImVector<ImFontGlyph>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ; ImVector<ImFontGlyph>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ENDP	; ImVector<ImFontGlyph>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z PROC ; ImVector<ImFontGlyph>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ENDP ; ImVector<ImFontGlyph>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ PROC ; ImVector<ImFontGlyph>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ENDP ; ImVector<ImFontGlyph>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ PROC		; ImVector<ImFontGlyph>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ ENDP		; ImVector<ImFontGlyph>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z PROC ; ImVector<ImFontGlyph>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ENDP ; ImVector<ImFontGlyph>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImFontGlyph@@@@QEAA@XZ PROC		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImFontGlyph@@@@QEAA@XZ ENDP		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontGlyph@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontGlyph@@@@QEAA@XZ PROC		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImFontGlyph@@@@QEAA@XZ ENDP		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@M@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@M@@QEAAXH@Z PROC			; ImVector<float>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@M@@QEAAXH@Z ENDP			; ImVector<float>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QEAAXHAEBM@Z
_TEXT	SEGMENT
n$1 = 32
this$ = 64
new_size$ = 72
v$ = 80
?resize@?$ImVector@M@@QEAAXHAEBM@Z PROC			; ImVector<float>::resize, COMDAT

; 1244 : 	inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN5@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@M@@QEBAHH@Z	; ImVector<float>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::reserve
	npad	1
$LN5@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN6@resize
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR n$1[rsp], eax
	jmp	SHORT $LN4@resize
$LN2@resize:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@resize:
	mov	eax, DWORD PTR new_size$[rsp]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@resize
	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	r8d, 4
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	npad	1
	jmp	SHORT $LN2@resize
$LN3@resize:
$LN6@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 56					; 00000038H
	ret	0
?resize@?$ImVector@M@@QEAAXHAEBM@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@M@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@M@@QEBAHH@Z PROC		; ImVector<float>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@M@@QEBAHH@Z ENDP		; ImVector<float>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@M@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@M@@QEAAXXZ PROC			; ImVector<float>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@M@@QEAAXXZ ENDP			; ImVector<float>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@M@@QEAAAEAMH@Z PROC			; ImVector<float>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
??A?$ImVector@M@@QEAAAEAMH@Z ENDP			; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@M@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@M@@QEAA@XZ PROC				; ImVector<float>::~ImVector<float>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@M@@QEAA@XZ ENDP				; ImVector<float>::~ImVector<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@M@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@M@@QEAA@XZ PROC				; ImVector<float>::ImVector<float>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@M@@QEAA@XZ ENDP				; ImVector<float>::ImVector<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z PROC ; ImVector<ImFontConfig>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ; ImVector<ImFontConfig>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z ; ImVector<ImFontConfig>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 128				; 00000080H
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ENDP ; ImVector<ImFontConfig>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z PROC	; ImVector<ImFontConfig>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 128				; 00000080H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z ENDP	; ImVector<ImFontConfig>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z PROC ; ImVector<ImFontConfig>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ENDP ; ImVector<ImFontConfig>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ PROC ; ImVector<ImFontConfig>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ENDP ; ImVector<ImFontConfig>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ PROC		; ImVector<ImFontConfig>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ ENDP		; ImVector<ImFontConfig>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z PROC ; ImVector<ImFontConfig>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ENDP ; ImVector<ImFontConfig>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontConfig@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImFontConfig@@@@QEAA@XZ PROC		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImFontConfig@@@@QEAA@XZ ENDP		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontConfig@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontConfig@@@@QEAA@XZ PROC		; ImVector<ImFontConfig>::ImVector<ImFontConfig>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImFontConfig@@@@QEAA@XZ ENDP		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z PROC ; ImVector<ImFontAtlas::CustomRect>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z ; ImVector<ImFontAtlas::CustomRect>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z ; ImVector<ImFontAtlas::CustomRect>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z ENDP ; ImVector<ImFontAtlas::CustomRect>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z PROC ; ImVector<ImFontAtlas::CustomRect>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXH@Z ENDP ; ImVector<ImFontAtlas::CustomRect>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z PROC ; ImVector<ImFontAtlas::CustomRect>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UCustomRect@ImFontAtlas@@@@QEBAHH@Z ENDP ; ImVector<ImFontAtlas::CustomRect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ PROC ; ImVector<ImFontAtlas::CustomRect>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ ENDP ; ImVector<ImFontAtlas::CustomRect>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z PROC ; ImVector<ImFontAtlas::CustomRect>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ENDP ; ImVector<ImFontAtlas::CustomRect>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ PROC	; ImVector<ImFontAtlas::CustomRect>::~ImVector<ImFontAtlas::CustomRect>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ENDP	; ImVector<ImFontAtlas::CustomRect>::~ImVector<ImFontAtlas::CustomRect>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ PROC	; ImVector<ImFontAtlas::CustomRect>::ImVector<ImFontAtlas::CustomRect>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ENDP	; ImVector<ImFontAtlas::CustomRect>::ImVector<ImFontAtlas::CustomRect>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z PROC ; ImVector<ImFont *>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z ; ImVector<ImFont *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z ; ImVector<ImFont *>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ENDP ; ImVector<ImFont *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z PROC		; ImVector<ImFont *>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@PEAUImFont@@@@QEAAXH@Z ENDP		; ImVector<ImFont *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z PROC	; ImVector<ImFont *>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@PEAUImFont@@@@QEBAHH@Z ENDP	; ImVector<ImFont *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ PROC ; ImVector<ImFont *>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ ENDP ; ImVector<ImFont *>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ PROC		; ImVector<ImFont *>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ ENDP		; ImVector<ImFont *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z PROC	; ImVector<ImFont *>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ENDP	; ImVector<ImFont *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAUImFont@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAUImFont@@@@QEAA@XZ PROC		; ImVector<ImFont *>::~ImVector<ImFont *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAUImFont@@@@QEAA@XZ ENDP		; ImVector<ImFont *>::~ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAUImFont@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAUImFont@@@@QEAA@XZ PROC		; ImVector<ImFont *>::ImVector<ImFont *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAUImFont@@@@QEAA@XZ ENDP		; ImVector<ImFont *>::ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
pos$ = 32
size$ = 40
r$ = 48
tv77 = 56
tv151 = 64
tv172 = 72
$T1 = 80
$T2 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
this$ = 160
cursor_type$ = 168
out_offset$ = 176
out_size$ = 184
out_uv_border$ = 192
out_uv_fill$ = 200
?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z PROC ; ImFontAtlas::GetMouseCursorTexData

; 1849 : {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 1850 :     if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)

	cmp	DWORD PTR cursor_type$[rsp], -1
	jle	SHORT $LN3@GetMouseCu
	cmp	DWORD PTR cursor_type$[rsp], 8
	jl	SHORT $LN2@GetMouseCu
$LN3@GetMouseCu:

; 1851 :         return false;

	xor	al, al
	jmp	$LN1@GetMouseCu
$LN2@GetMouseCu:

; 1852 :     if (Flags & ImFontAtlasFlags_NoMouseCursors)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN4@GetMouseCu

; 1853 :         return false;

	xor	al, al
	jmp	$LN1@GetMouseCu
$LN4@GetMouseCu:

; 1854 : 
; 1855 :     IM_ASSERT(CustomRectIds[0] != -1);
; 1856 :     ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR tv77[rsp], rax
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rcx+rax+120]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??A?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAAEAUCustomRect@ImFontAtlas@@H@Z ; ImVector<ImFontAtlas::CustomRect>::operator[]
	mov	QWORD PTR r$[rsp], rax

; 1857 :     IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
; 1858 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax]
	cvtsi2ss xmm1, eax
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movsxd	rcx, DWORD PTR cursor_type$[rsp]
	imul	rcx, rcx, 24
	lea	rdx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, 8
	imul	rdx, rdx, 0
	add	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR pos$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 1859 :     ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];

	movsxd	rax, DWORD PTR cursor_type$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR size$[rsp], rax

; 1860 :     *out_size = size;

	mov	rax, QWORD PTR out_size$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	mov	QWORD PTR [rax], rcx

; 1861 :     *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];

	movsxd	rax, DWORD PTR cursor_type$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rax, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR out_offset$[rsp]
	mov	QWORD PTR [rcx], rax

; 1862 :     out_uv_border[0] = (pos)*TexUvScale;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR out_uv_border$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 1863 :     out_uv_border[1] = (pos + size) * TexUvScale;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv151[rsp], rax
	lea	r8, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR tv151[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR out_uv_border$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 1864 :     pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;

	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR __real@42da0000
	movss	DWORD PTR pos$[rsp], xmm0

; 1865 :     out_uv_fill[0] = (pos)*TexUvScale;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR out_uv_fill$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 1866 :     out_uv_fill[1] = (pos + size) * TexUvScale;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv172[rsp], rax
	lea	r8, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR tv172[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??D@YA?AUImVec2@@AEBU0@0@Z		; operator*
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR out_uv_fill$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 1867 :     return true;

	mov	al, 1
$LN1@GetMouseCu:

; 1868 : }

	add	rsp, 152				; 00000098H
	ret	0
?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ENDP ; ImFontAtlas::GetMouseCursorTexData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
rect$ = 72
out_uv_min$ = 80
out_uv_max$ = 88
?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z PROC ; ImFontAtlas::CalcCustomRectUV

; 1841 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1842 :     IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
; 1843 :     IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
; 1844 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	mov	rax, QWORD PTR rect$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	rax, QWORD PTR rect$[rsp]
	movzx	eax, WORD PTR [rax]
	cvtsi2ss xmm1, eax
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm1, DWORD PTR [rax+32]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR out_uv_min$[rsp]
	mov	QWORD PTR [rcx], rax

; 1845 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	mov	rax, QWORD PTR rect$[rsp]
	movzx	eax, WORD PTR [rax+2]
	mov	rcx, QWORD PTR rect$[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	add	eax, ecx
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	rax, QWORD PTR rect$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR rect$[rsp]
	movzx	ecx, WORD PTR [rcx+12]
	add	eax, ecx
	cvtsi2ss xmm1, eax
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm1, DWORD PTR [rax+32]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR out_uv_max$[rsp]
	mov	QWORD PTR [rcx], rax

; 1846 : }

	add	rsp, 56					; 00000038H
	ret	0
?CalcCustomRectUV@ImFontAtlas@@QEAAXPEBUCustomRect@1@PEAUImVec2@@1@Z ENDP ; ImFontAtlas::CalcCustomRectUV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv71 = 32
r$ = 40
this$ = 96
font$ = 104
id$ = 112
width$ = 120
height$ = 128
advance_x$ = 136
offset$ = 144
?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z PROC ; ImFontAtlas::AddCustomRectFontGlyph

; 1825 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	WORD PTR [rsp+24], r8w
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1826 :     IM_ASSERT(font != NULL);
; 1827 :     IM_ASSERT(width > 0 && width <= 0xFFFF);
; 1828 :     IM_ASSERT(height > 0 && height <= 0xFFFF);
; 1829 :     CustomRect r;

	lea	rcx, QWORD PTR r$[rsp]
	call	??0CustomRect@ImFontAtlas@@QEAA@XZ	; ImFontAtlas::CustomRect::CustomRect

; 1830 :     r.ID = id;

	movzx	eax, WORD PTR id$[rsp]
	mov	DWORD PTR r$[rsp+8], eax

; 1831 :     r.Width = (unsigned short)width;

	movzx	eax, WORD PTR width$[rsp]
	mov	WORD PTR r$[rsp+12], ax

; 1832 :     r.Height = (unsigned short)height;

	movzx	eax, WORD PTR height$[rsp]
	mov	WORD PTR r$[rsp+14], ax

; 1833 :     r.GlyphAdvanceX = advance_x;

	movss	xmm0, DWORD PTR advance_x$[rsp]
	movss	DWORD PTR r$[rsp+4], xmm0

; 1834 :     r.GlyphOffset = offset;

	mov	rax, QWORD PTR offset$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR r$[rsp+16], rax

; 1835 :     r.Font = font;

	mov	rax, QWORD PTR font$[rsp]
	mov	QWORD PTR r$[rsp+24], rax

; 1836 :     CustomRects.push_back(r);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR tv71[rsp], rax
	lea	rdx, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z ; ImVector<ImFontAtlas::CustomRect>::push_back

; 1837 :     return CustomRects.Size - 1; // Return index

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+88]
	dec	eax

; 1838 : }

	add	rsp, 88					; 00000058H
	ret	0
?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z ENDP ; ImFontAtlas::AddCustomRectFontGlyph
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv69 = 32
r$ = 40
this$ = 96
id$ = 104
width$ = 112
height$ = 120
?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z PROC	; ImFontAtlas::AddCustomRectRegular

; 1812 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1813 :     IM_ASSERT(id >= 0x10000);
; 1814 :     IM_ASSERT(width > 0 && width <= 0xFFFF);
; 1815 :     IM_ASSERT(height > 0 && height <= 0xFFFF);
; 1816 :     CustomRect r;

	lea	rcx, QWORD PTR r$[rsp]
	call	??0CustomRect@ImFontAtlas@@QEAA@XZ	; ImFontAtlas::CustomRect::CustomRect

; 1817 :     r.ID = id;

	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR r$[rsp+8], eax

; 1818 :     r.Width = (unsigned short)width;

	movzx	eax, WORD PTR width$[rsp]
	mov	WORD PTR r$[rsp+12], ax

; 1819 :     r.Height = (unsigned short)height;

	movzx	eax, WORD PTR height$[rsp]
	mov	WORD PTR r$[rsp+14], ax

; 1820 :     CustomRects.push_back(r);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	QWORD PTR tv69[rsp], rax
	lea	rdx, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?push_back@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXAEBUCustomRect@ImFontAtlas@@@Z ; ImVector<ImFontAtlas::CustomRect>::push_back

; 1821 :     return CustomRects.Size - 1; // Return index

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+88]
	dec	eax

; 1822 : }

	add	rsp, 88					; 00000058H
	ret	0
?AddCustomRectRegular@ImFontAtlas@@QEAAHIHH@Z ENDP	; ImFontAtlas::AddCustomRectRegular
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0CustomRect@ImFontAtlas@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0CustomRect@ImFontAtlas@@QEAA@XZ PROC			; ImFontAtlas::CustomRect::CustomRect, COMDAT

; 2080 : 		CustomRect() { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH
	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+14], ax
	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+12], ax
	mov	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+2], ax
	mov	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0CustomRect@ImFontAtlas@@QEAA@XZ ENDP			; ImFontAtlas::CustomRect::CustomRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
?GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesThai

; 2483 : {

	mov	QWORD PTR [rsp+8], rcx

; 2484 :     static const ImWchar ranges[] =
; 2485 :     {
; 2486 :         0x0020, 0x00FF, // Basic Latin
; 2487 :         0x2010, 0x205E, // Punctuations
; 2488 :         0x0E00, 0x0E7F, // Thai
; 2489 :         0,
; 2490 :     };
; 2491 :     return &ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	add	rcx, rax
	mov	rax, rcx

; 2492 : }

	ret	0
?GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesThai
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesCyrillic

; 2470 : {

	mov	QWORD PTR [rsp+8], rcx

; 2471 :     static const ImWchar ranges[] =
; 2472 :     {
; 2473 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2474 :         0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
; 2475 :         0x2DE0, 0x2DFF, // Cyrillic Extended-A
; 2476 :         0xA640, 0xA69F, // Cyrillic Extended-B
; 2477 :         0,
; 2478 :     };
; 2479 :     return &ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	add	rcx, rax
	mov	rax, rcx

; 2480 : }

	ret	0
?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesCyrillic
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ PROC ; ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon

; 2345 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2346 :     // Store 2500 regularly used characters for Simplified Chinese.
; 2347 :     // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
; 2348 :     // This table covers 97.97% of all characters used during the month in July, 1987.
; 2349 :     // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
; 2350 :     // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
; 2351 :     static const short accumulative_offsets_from_0x4E00[] =
; 2352 :     {
; 2353 :         0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
; 2354 :         1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
; 2355 :         2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
; 2356 :         1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
; 2357 :         3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
; 2358 :         1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
; 2359 :         1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
; 2360 :         2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
; 2361 :         27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
; 2362 :         3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
; 2363 :         1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
; 2364 :         176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
; 2365 :         5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
; 2366 :         1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
; 2367 :         6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
; 2368 :         2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
; 2369 :         2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
; 2370 :         2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
; 2371 :         3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
; 2372 :         3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
; 2373 :         3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
; 2374 :         1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
; 2375 :         140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
; 2376 :         5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
; 2377 :         2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
; 2378 :         4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
; 2379 :         2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
; 2380 :         4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
; 2381 :         3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
; 2382 :         3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
; 2383 :         2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
; 2384 :         5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
; 2385 :         3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
; 2386 :         1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
; 2387 :         4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
; 2388 :         4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
; 2389 :         26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
; 2390 :         3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
; 2391 :         2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
; 2392 :         10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
; 2393 :     };
; 2394 :     static ImWchar base_ranges[] = // not zero-terminated
; 2395 :     {
; 2396 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2397 :         0x2000, 0x206F, // General Punctuation
; 2398 :         0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
; 2399 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 2400 :         0xFF00, 0xFFEF  // Half-width characters
; 2401 :     };
; 2402 :     static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
; 2403 :     if (!full_ranges[0])

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@GetGlyphRa

; 2404 :     {
; 2405 :         memcpy(full_ranges, base_ranges, sizeof(base_ranges));

	mov	r8d, 20
	lea	rdx, OFFSET FLAT:?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	lea	rcx, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	call	memcpy

; 2406 :         UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));

	lea	rax, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	add	rax, 20
	mov	r9, rax
	mov	r8d, 2500				; 000009c4H
	lea	rdx, OFFSET FLAT:?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB
	mov	ecx, 19968				; 00004e00H
	call	?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z ; UnpackAccumulativeOffsetsIntoRanges
	npad	1
$LN2@GetGlyphRa:

; 2407 :     }
; 2408 :     return &full_ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	add	rcx, rax
	mov	rax, rcx

; 2409 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ ENDP ; ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesChineseFull

; 2316 : {

	mov	QWORD PTR [rsp+8], rcx

; 2317 :     static const ImWchar ranges[] =
; 2318 :     {
; 2319 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2320 :         0x2000, 0x206F, // General Punctuation
; 2321 :         0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
; 2322 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 2323 :         0xFF00, 0xFFEF, // Half-width characters
; 2324 :         0x4e00, 0x9FAF, // CJK Ideograms
; 2325 :         0,
; 2326 :     };
; 2327 :     return &ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	add	rcx, rax
	mov	rax, rcx

; 2328 : }

	ret	0
?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesChineseFull
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesJapanese

; 2412 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2413 :     // 1946 common ideograms code points for Japanese
; 2414 :     // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering
; 2415 :     // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.
; 2416 :     // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
; 2417 :     // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
; 2418 :     static const short accumulative_offsets_from_0x4E00[] =
; 2419 :     {
; 2420 :         0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,
; 2421 :         5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,
; 2422 :         2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,
; 2423 :         2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,
; 2424 :         20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,
; 2425 :         4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,
; 2426 :         3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,
; 2427 :         8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,
; 2428 :         3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,
; 2429 :         15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,
; 2430 :         1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,
; 2431 :         12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,
; 2432 :         22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,
; 2433 :         5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,
; 2434 :         1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,
; 2435 :         1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,
; 2436 :         11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,
; 2437 :         15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,
; 2438 :         5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,
; 2439 :         3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,
; 2440 :         18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,
; 2441 :         27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,
; 2442 :         1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,
; 2443 :         1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,
; 2444 :         10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,
; 2445 :         179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,
; 2446 :         3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,
; 2447 :         3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,
; 2448 :         3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,
; 2449 :         4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,
; 2450 :         1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,
; 2451 :         51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39,
; 2452 :     };
; 2453 :     static ImWchar base_ranges[] = // not zero-terminated
; 2454 :     {
; 2455 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2456 :         0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
; 2457 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 2458 :         0xFF00, 0xFFEF  // Half-width characters
; 2459 :     };
; 2460 :     static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
; 2461 :     if (!full_ranges[0])

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@GetGlyphRa

; 2462 :     {
; 2463 :         memcpy(full_ranges, base_ranges, sizeof(base_ranges));

	mov	r8d, 16
	lea	rdx, OFFSET FLAT:?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	lea	rcx, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	call	memcpy

; 2464 :         UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));

	lea	rax, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	add	rax, 16
	mov	r9, rax
	mov	r8d, 1946				; 0000079aH
	lea	rdx, OFFSET FLAT:?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB
	mov	ecx, 19968				; 00004e00H
	call	?UnpackAccumulativeOffsetsIntoRanges@@YAXHPEBFHPEAG@Z ; UnpackAccumulativeOffsetsIntoRanges
	npad	1
$LN2@GetGlyphRa:

; 2465 :     }
; 2466 :     return &full_ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
	add	rcx, rax
	mov	rax, rcx

; 2467 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesJapanese
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesKorean

; 2304 : {

	mov	QWORD PTR [rsp+8], rcx

; 2305 :     static const ImWchar ranges[] =
; 2306 :     {
; 2307 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2308 :         0x3131, 0x3163, // Korean alphabets
; 2309 :         0xAC00, 0xD79D, // Korean characters
; 2310 :         0,
; 2311 :     };
; 2312 :     return &ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	add	rcx, rax
	mov	rax, rcx

; 2313 : }

	ret	0
?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesKorean
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesDefault

; 2294 : {

	mov	QWORD PTR [rsp+8], rcx

; 2295 :     static const ImWchar ranges[] =
; 2296 :     {
; 2297 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2298 :         0,
; 2299 :     };
; 2300 :     return &ranges[0];

	mov	eax, 2
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	add	rcx, rax
	mov	rax, rcx

; 2301 : }

	ret	0
?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesDefault
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
n$1 = 48
tv91 = 52
pixels$2 = 56
src$3 = 64
dst$4 = 72
this$ = 96
out_pixels$ = 104
out_width$ = 112
out_height$ = 120
out_bytes_per_pixel$ = 128
?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z PROC ; ImFontAtlas::GetTexDataAsRGBA32

; 1665 : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1666 :     // Convert to RGBA32 format on demand
; 1667 :     // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
; 1668 :     if (!TexPixelsRGBA32)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+56], 0
	jne	$LN5@GetTexData

; 1669 :     {
; 1670 :         unsigned char* pixels = NULL;

	mov	QWORD PTR pixels$2[rsp], 0

; 1671 :         GetTexDataAsAlpha8(&pixels, NULL, NULL);

	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR pixels$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8
	npad	1

; 1672 :         if (pixels)

	cmp	QWORD PTR pixels$2[rsp], 0
	je	$LN6@GetTexData

; 1673 :         {
; 1674 :             TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)TexWidth * (size_t)TexHeight * 4);

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR [rcx+28]
	imul	rax, rcx
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 1675 :             const unsigned char* src = pixels;

	mov	rax, QWORD PTR pixels$2[rsp]
	mov	QWORD PTR src$3[rsp], rax

; 1676 :             unsigned int* dst = TexPixelsRGBA32;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR dst$4[rsp], rax

; 1677 :             for (int n = TexWidth * TexHeight; n > 0; n--)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	imul	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR n$1[rsp], eax
	jmp	SHORT $LN4@GetTexData
$LN2@GetTexData:
	mov	eax, DWORD PTR n$1[rsp]
	dec	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@GetTexData:
	cmp	DWORD PTR n$1[rsp], 0
	jle	SHORT $LN3@GetTexData

; 1678 :                 *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));

	mov	rax, QWORD PTR src$3[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv91[rsp], eax
	mov	rax, QWORD PTR src$3[rsp]
	inc	rax
	mov	QWORD PTR src$3[rsp], rax
	mov	eax, DWORD PTR tv91[rsp]
	shl	eax, 24
	or	eax, 16711680				; 00ff0000H
	or	eax, 65280				; 0000ff00H
	or	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR dst$4[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR dst$4[rsp]
	add	rax, 4
	mov	QWORD PTR dst$4[rsp], rax
	jmp	SHORT $LN2@GetTexData
$LN3@GetTexData:
$LN6@GetTexData:
$LN5@GetTexData:

; 1679 :         }
; 1680 :     }
; 1681 : 
; 1682 :     *out_pixels = (unsigned char*)TexPixelsRGBA32;

	mov	rax, QWORD PTR out_pixels$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax], rcx

; 1683 :     if (out_width) *out_width = TexWidth;

	cmp	QWORD PTR out_width$[rsp], 0
	je	SHORT $LN7@GetTexData
	mov	rax, QWORD PTR out_width$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax], ecx
$LN7@GetTexData:

; 1684 :     if (out_height) *out_height = TexHeight;

	cmp	QWORD PTR out_height$[rsp], 0
	je	SHORT $LN8@GetTexData
	mov	rax, QWORD PTR out_height$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax], ecx
$LN8@GetTexData:

; 1685 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;

	cmp	QWORD PTR out_bytes_per_pixel$[rsp], 0
	je	SHORT $LN9@GetTexData
	mov	rax, QWORD PTR out_bytes_per_pixel$[rsp]
	mov	DWORD PTR [rax], 4
$LN9@GetTexData:

; 1686 : }

	add	rsp, 88					; 00000058H
	ret	0
?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ENDP ; ImFontAtlas::GetTexDataAsRGBA32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
out_pixels$ = 56
out_width$ = 64
out_height$ = 72
out_bytes_per_pixel$ = 80
?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z PROC ; ImFontAtlas::GetTexDataAsAlpha8

; 1649 : {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1650 :     // Build atlas on demand
; 1651 :     if (TexPixelsAlpha8 == NULL)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN2@GetTexData

; 1652 :     {
; 1653 :         //if (ConfigData.empty())
; 1654 :             //AddFontDefault();
; 1655 :         Build();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Build@ImFontAtlas@@QEAA_NXZ		; ImFontAtlas::Build
	npad	1
$LN2@GetTexData:

; 1656 :     }
; 1657 : 
; 1658 :     *out_pixels = TexPixelsAlpha8;

	mov	rax, QWORD PTR out_pixels$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax], rcx

; 1659 :     if (out_width) *out_width = TexWidth;

	cmp	QWORD PTR out_width$[rsp], 0
	je	SHORT $LN3@GetTexData
	mov	rax, QWORD PTR out_width$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax], ecx
$LN3@GetTexData:

; 1660 :     if (out_height) *out_height = TexHeight;

	cmp	QWORD PTR out_height$[rsp], 0
	je	SHORT $LN4@GetTexData
	mov	rax, QWORD PTR out_height$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax], ecx
$LN4@GetTexData:

; 1661 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;

	cmp	QWORD PTR out_bytes_per_pixel$[rsp], 0
	je	SHORT $LN5@GetTexData
	mov	rax, QWORD PTR out_bytes_per_pixel$[rsp]
	mov	DWORD PTR [rax], 1
$LN5@GetTexData:

; 1662 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ENDP ; ImFontAtlas::GetTexDataAsAlpha8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?Build@ImFontAtlas@@QEAA_NXZ PROC			; ImFontAtlas::Build

; 1871 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1872 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1873 :     return ImFontAtlasBuildWithStbTruetype(this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype

; 1874 : }

	add	rsp, 40					; 00000028H
	ret	0
?Build@ImFontAtlas@@QEAA_NXZ ENDP			; ImFontAtlas::Build
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?Clear@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::Clear

; 1642 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1643 :     ClearInputData();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearInputData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearInputData

; 1644 :     ClearTexData();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData

; 1645 :     ClearFonts();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearFonts@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearFonts
	npad	1

; 1646 : }

	add	rsp, 40					; 00000028H
	ret	0
?Clear@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
tv73 = 40
this$ = 64
?ClearFonts@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::ClearFonts

; 1634 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1635 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1636 :     for (int i = 0; i < Fonts.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ClearFonts
$LN2@ClearFonts:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ClearFonts:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+72]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@ClearFonts

; 1637 :         IM_DELETE(Fonts[i]);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rcx, QWORD PTR [rax]
	call	??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z ; IM_DELETE<ImFont>
	npad	1
	jmp	SHORT $LN2@ClearFonts
$LN3@ClearFonts:

; 1638 :     Fonts.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAUImFont@@@@QEAAXXZ	; ImVector<ImFont *>::clear
	npad	1

; 1639 : }

	add	rsp, 56					; 00000038H
	ret	0
?ClearFonts@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::ClearFonts
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearTexData@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::ClearTexData

; 1623 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1624 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1625 :     if (TexPixelsAlpha8)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN2@ClearTexDa

; 1626 :         ImGui::MemFree(TexPixelsAlpha8);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ClearTexDa:

; 1627 :     if (TexPixelsRGBA32)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN3@ClearTexDa

; 1628 :         ImGui::MemFree(TexPixelsRGBA32);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+56]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@ClearTexDa:

; 1629 :     TexPixelsAlpha8 = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 0

; 1630 :     TexPixelsRGBA32 = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1631 : }

	add	rsp, 40					; 00000028H
	ret	0
?ClearTexData@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::ClearTexData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
n$3 = 40
tv73 = 48
tv81 = 56
tv90 = 64
tv130 = 72
tv141 = 80
tv151 = 88
tv166 = 96
tv173 = 104
this$ = 128
?ClearInputData@ImFontAtlas@@QEAAXXZ PROC		; ImFontAtlas::ClearInputData

; 1600 : {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1601 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1602 :     for (int i = 0; i < ConfigData.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ClearInput
$LN2@ClearInput:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ClearInput:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+104]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@ClearInput

; 1603 :         if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN11@ClearInput
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv81[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN11@ClearInput

; 1604 :         {
; 1605 :             ImGui::MemFree(ConfigData[i].FontData);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv90[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	mov	rcx, QWORD PTR [rax+24]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 1606 :             ConfigData[i].FontData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv130[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
	mov	QWORD PTR [rax+24], 0
$LN11@ClearInput:

; 1607 :         }

	jmp	$LN2@ClearInput
$LN3@ClearInput:

; 1608 : 
; 1609 :     // When clearing this we lose access to the font name and other information used to build the font.
; 1610 :     for (int i = 0; i < Fonts.Size; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@ClearInput
$LN5@ClearInput:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@ClearInput:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+72]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN6@ClearInput

; 1611 :         if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv141[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv141[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	cmp	QWORD PTR [rax+96], rcx
	jb	$LN12@ClearInput
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv151[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv151[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR [rcx+104]
	imul	rcx, rcx, 128				; 00000080H
	mov	rdx, QWORD PTR this$[rsp]
	add	rcx, QWORD PTR [rdx+112]
	cmp	QWORD PTR [rax+96], rcx
	jae	SHORT $LN12@ClearInput

; 1612 :         {
; 1613 :             Fonts[i]->ConfigData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv166[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv166[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rax+96], 0

; 1614 :             Fonts[i]->ConfigDataCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv173[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv173[rsp]
	call	??A?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+104], cx
$LN12@ClearInput:

; 1615 :         }

	jmp	$LN5@ClearInput
$LN6@ClearInput:

; 1616 :     ConfigData.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ ; ImVector<ImFontConfig>::clear

; 1617 :     CustomRects.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	?clear@?$ImVector@UCustomRect@ImFontAtlas@@@@QEAAXXZ ; ImVector<ImFontAtlas::CustomRect>::clear
	npad	1

; 1618 :     for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)

	mov	DWORD PTR n$3[rsp], 0
	jmp	SHORT $LN10@ClearInput
$LN8@ClearInput:
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN10@ClearInput:
	cmp	DWORD PTR n$3[rsp], 1
	jge	SHORT $LN9@ClearInput

; 1619 :         CustomRectIds[n] = -1;

	movsxd	rax, DWORD PTR n$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+rax*4+120], -1
	jmp	SHORT $LN8@ClearInput
$LN9@ClearInput:

; 1620 : }

	add	rsp, 120				; 00000078H
	ret	0
?ClearInputData@ImFontAtlas@@QEAAXXZ ENDP		; ImFontAtlas::ClearInputData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
compressed_ttf_size$ = 48
compressed_ttf$ = 56
font$ = 64
this$ = 96
compressed_ttf_data_base85$ = 104
size_pixels$ = 112
font_cfg$ = 120
glyph_ranges$ = 128
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF

; 1802 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1803 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

	mov	rcx, QWORD PTR compressed_ttf_data_base85$[rsp]
	call	strlen
	add	eax, 4
	cdq
	mov	ecx, 5
	idiv	ecx
	shl	eax, 2
	mov	DWORD PTR compressed_ttf_size$[rsp], eax

; 1804 :     void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);

	movsxd	rax, DWORD PTR compressed_ttf_size$[rsp]
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR compressed_ttf$[rsp], rax

; 1805 :     Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);

	mov	rdx, QWORD PTR compressed_ttf$[rsp]
	mov	rcx, QWORD PTR compressed_ttf_data_base85$[rsp]
	call	?Decode85@@YAXPEBEPEAE@Z		; Decode85

; 1806 :     ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);

	mov	rax, QWORD PTR glyph_ranges$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR font_cfg$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR size_pixels$[rsp]
	mov	r8d, DWORD PTR compressed_ttf_size$[rsp]
	mov	rdx, QWORD PTR compressed_ttf$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
	mov	QWORD PTR font$[rsp], rax

; 1807 :     ImGui::MemFree(compressed_ttf);

	mov	rcx, QWORD PTR compressed_ttf$[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree

; 1808 :     return font;

	mov	rax, QWORD PTR font$[rsp]

; 1809 : }

	add	rsp, 88					; 00000058H
	ret	0
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
buf_decompressed_size$ = 48
tv76 = 56
buf_decompressed_data$ = 64
$T1 = 72
font_cfg$ = 80
$T2 = 208
$T3 = 336
__$ArrayPad$ = 464
this$ = 512
compressed_ttf_data$ = 520
compressed_ttf_size$ = 528
size_pixels$ = 536
font_cfg_template$ = 544
glyph_ranges$ = 552
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedTTF

; 1790 : {

$LN5:
	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 488				; 000001e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1791 :     const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);

	mov	rcx, QWORD PTR compressed_ttf_data$[rsp]
	call	?stb_decompress_length@@YAIPEBE@Z	; stb_decompress_length
	mov	DWORD PTR buf_decompressed_size$[rsp], eax

; 1792 :     unsigned char* buf_decompressed_data = (unsigned char*)ImGui::MemAlloc(buf_decompressed_size);

	mov	eax, DWORD PTR buf_decompressed_size$[rsp]
	mov	ecx, eax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR buf_decompressed_data$[rsp], rax

; 1793 :     stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

	mov	r8d, DWORD PTR compressed_ttf_size$[rsp]
	mov	rdx, QWORD PTR compressed_ttf_data$[rsp]
	mov	rcx, QWORD PTR buf_decompressed_data$[rsp]
	call	?stb_decompress@@YAIPEAEPEBEI@Z		; stb_decompress
	npad	1

; 1794 : 
; 1795 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	cmp	QWORD PTR font_cfg_template$[rsp], 0
	je	SHORT $LN3@AddFontFro
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR font_cfg_template$[rsp]
	mov	ecx, 128				; 00000080H
	rep movsb
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN4@AddFontFro
$LN3@AddFontFro:
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImFontConfig@@QEAA@XZ		; ImFontConfig::ImFontConfig
	mov	QWORD PTR tv76[rsp], rax
$LN4@AddFontFro:
	mov	rax, QWORD PTR tv76[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rax, QWORD PTR font_cfg$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T1[rsp]
	mov	ecx, 128				; 00000080H
	rep movsb

; 1796 :     IM_ASSERT(font_cfg.FontData == NULL);
; 1797 :     font_cfg.FontDataOwnedByAtlas = true;

	mov	BYTE PTR font_cfg$[rsp], 1

; 1798 :     return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);

	mov	rax, QWORD PTR glyph_ranges$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR font_cfg$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR size_pixels$[rsp]
	mov	r8d, DWORD PTR buf_decompressed_size$[rsp]
	mov	rdx, QWORD PTR buf_decompressed_data$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF

; 1799 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 488				; 000001e8H
	pop	rdi
	pop	rsi
	ret	0
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedTTF
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv68 = 32
$T1 = 40
font_cfg$ = 48
$T2 = 176
$T3 = 304
__$ArrayPad$ = 432
this$ = 480
ttf_data$ = 488
ttf_size$ = 496
size_pixels$ = 504
font_cfg_template$ = 512
glyph_ranges$ = 520
?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryTTF

; 1777 : {

$LN6:
	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 456				; 000001c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1778 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1779 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	cmp	QWORD PTR font_cfg_template$[rsp], 0
	je	SHORT $LN4@AddFontFro
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR font_cfg_template$[rsp]
	mov	ecx, 128				; 00000080H
	rep movsb
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN5@AddFontFro
$LN4@AddFontFro:
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImFontConfig@@QEAA@XZ		; ImFontConfig::ImFontConfig
	mov	QWORD PTR tv68[rsp], rax
$LN5@AddFontFro:
	mov	rax, QWORD PTR tv68[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rax, QWORD PTR font_cfg$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T1[rsp]
	mov	ecx, 128				; 00000080H
	rep movsb

; 1780 :     IM_ASSERT(font_cfg.FontData == NULL);
; 1781 :     font_cfg.FontData = ttf_data;

	mov	rax, QWORD PTR ttf_data$[rsp]
	mov	QWORD PTR font_cfg$[rsp+24], rax

; 1782 :     font_cfg.FontDataSize = ttf_size;

	mov	eax, DWORD PTR ttf_size$[rsp]
	mov	DWORD PTR font_cfg$[rsp+32], eax

; 1783 :     font_cfg.SizePixels = size_pixels;

	movss	xmm0, DWORD PTR size_pixels$[rsp]
	movss	DWORD PTR font_cfg$[rsp+48], xmm0

; 1784 :     if (glyph_ranges)

	cmp	QWORD PTR glyph_ranges$[rsp], 0
	je	SHORT $LN2@AddFontFro

; 1785 :         font_cfg.GlyphRanges = glyph_ranges;

	mov	rax, QWORD PTR glyph_ranges$[rsp]
	mov	QWORD PTR font_cfg$[rsp+56], rax
$LN2@AddFontFro:

; 1786 :     return AddFont(&font_cfg);

	lea	rdx, QWORD PTR font_cfg$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont

; 1787 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 456				; 000001c8H
	pop	rdi
	pop	rsi
	ret	0
?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryTTF
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
p$1 = 48
tv74 = 56
data_size$ = 64
data$ = 72
$T2 = 80
font_cfg$ = 96
$T3 = 224
$T4 = 352
__$ArrayPad$ = 480
this$ = 528
filename$ = 536
size_pixels$ = 544
font_cfg_template$ = 552
glyph_ranges$ = 560
?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromFileTTF

; 1755 : {

$LN10:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1756 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1757 :     size_t data_size = 0;

	mov	QWORD PTR data_size$[rsp], 0

; 1758 :     void* data = ImFileLoadToMemory(filename, ("rb"), &data_size, 0);

	xor	r9d, r9d
	lea	r8, QWORD PTR data_size$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, QWORD PTR filename$[rsp]
	call	?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z ; ImFileLoadToMemory
	mov	QWORD PTR data$[rsp], rax

; 1759 :     if (!data)

	cmp	QWORD PTR data$[rsp], 0
	jne	SHORT $LN5@AddFontFro

; 1760 :     {
; 1761 :         IM_ASSERT(0); // Could not load file.
; 1762 :         return NULL;

	xor	eax, eax
	jmp	$LN1@AddFontFro
$LN5@AddFontFro:

; 1763 :     }
; 1764 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	cmp	QWORD PTR font_cfg_template$[rsp], 0
	je	SHORT $LN8@AddFontFro
	lea	rax, QWORD PTR $T3[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR font_cfg_template$[rsp]
	mov	ecx, 128				; 00000080H
	rep movsb
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN9@AddFontFro
$LN8@AddFontFro:
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImFontConfig@@QEAA@XZ		; ImFontConfig::ImFontConfig
	mov	QWORD PTR tv74[rsp], rax
$LN9@AddFontFro:
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rax, QWORD PTR font_cfg$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T2[rsp]
	mov	ecx, 128				; 00000080H
	rep movsb

; 1765 :     if (font_cfg.Name[0] == '\0')

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR font_cfg$[rsp+rax+80]
	test	eax, eax
	jne	$LN6@AddFontFro

; 1766 :     {
; 1767 :         // Store a short copy of filename into into the font name for convenience
; 1768 :         const char* p;
; 1769 :         for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}

	mov	rcx, QWORD PTR filename$[rsp]
	call	strlen
	mov	rcx, QWORD PTR filename$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$1[rsp], rax
	jmp	SHORT $LN4@AddFontFro
$LN2@AddFontFro:
	mov	rax, QWORD PTR p$1[rsp]
	dec	rax
	mov	QWORD PTR p$1[rsp], rax
$LN4@AddFontFro:
	mov	rax, QWORD PTR filename$[rsp]
	cmp	QWORD PTR p$1[rsp], rax
	jbe	SHORT $LN3@AddFontFro
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR p$1[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN3@AddFontFro
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR p$1[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN3@AddFontFro
	jmp	SHORT $LN2@AddFontFro
$LN3@AddFontFro:

; 1770 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), ("%s, %.0fpx"), p, size_pixels);

	cvtss2sd xmm0, DWORD PTR size_pixels$[rsp]
	movsd	QWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR p$1[rsp]
	lea	r8, OFFSET FLAT:??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
	mov	edx, 40					; 00000028H
	lea	rcx, QWORD PTR font_cfg$[rsp+80]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN6@AddFontFro:

; 1771 :     }
; 1772 :     return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);

	mov	rax, QWORD PTR glyph_ranges$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR font_cfg$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR size_pixels$[rsp]
	mov	r8d, DWORD PTR data_size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
$LN1@AddFontFro:

; 1773 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	pop	rdi
	pop	rsi
	ret	0
?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromFileTTF
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
new_font_cfg$ = 32
$T1 = 40
$T2 = 48
tv85 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
tv87 = 96
tv92 = 104
this$ = 128
font_cfg$ = 136
?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFont

; 1689 : {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1690 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1691 :     IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
; 1692 :     IM_ASSERT(font_cfg->SizePixels > 0.0f);
; 1693 : 
; 1694 :     // Create new font
; 1695 :     if (!font_cfg->MergeMode)

	mov	rax, QWORD PTR font_cfg$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	test	eax, eax
	jne	$LN2@AddFont

; 1696 :         Fonts.push_back(IM_NEW(ImFont));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	QWORD PTR tv87[rsp], rax
	mov	ecx, 120				; 00000078H
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	r8, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR $T4[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 120				; 00000078H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN7@AddFont
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0ImFont@@QEAA@XZ			; ImFont::ImFont
	mov	QWORD PTR tv85[rsp], rax
	jmp	SHORT $LN8@AddFont
$LN7@AddFont:
	mov	QWORD PTR tv85[rsp], 0
$LN8@AddFont:
	mov	rax, QWORD PTR tv85[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ; ImVector<ImFont *>::push_back
	npad	1
$LN2@AddFont:

; 1697 :     else
; 1698 :         IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
; 1699 : 
; 1700 :     ConfigData.push_back(*font_cfg);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv92[rsp], rax
	mov	rdx, QWORD PTR font_cfg$[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back

; 1701 :     ImFontConfig& new_font_cfg = ConfigData.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
	mov	QWORD PTR new_font_cfg$[rsp], rax

; 1702 :     if (new_font_cfg.DstFont == NULL)

	mov	rax, QWORD PTR new_font_cfg$[rsp]
	cmp	QWORD PTR [rax+120], 0
	jne	SHORT $LN4@AddFont

; 1703 :         new_font_cfg.DstFont = Fonts.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImFont@@@@QEAAAEAPEAUImFont@@XZ ; ImVector<ImFont *>::back
	mov	rcx, QWORD PTR new_font_cfg$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+120], rax
$LN4@AddFont:

; 1704 :     if (!new_font_cfg.FontDataOwnedByAtlas)

	mov	rax, QWORD PTR new_font_cfg$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN5@AddFont

; 1705 :     {
; 1706 :         new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);

	mov	rax, QWORD PTR new_font_cfg$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	rcx, QWORD PTR new_font_cfg$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 1707 :         new_font_cfg.FontDataOwnedByAtlas = true;

	mov	rax, QWORD PTR new_font_cfg$[rsp]
	mov	BYTE PTR [rax], 1

; 1708 :         memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);

	mov	rax, QWORD PTR new_font_cfg$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	r8, rax
	mov	rax, QWORD PTR font_cfg$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rax, QWORD PTR new_font_cfg$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	memcpy
	npad	1
$LN5@AddFont:

; 1709 :     }
; 1710 : 
; 1711 :     // Invalidate texture
; 1712 :     ClearTexData();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData

; 1713 :     return new_font_cfg.DstFont;

	mov	rax, QWORD PTR new_font_cfg$[rsp]
	mov	rax, QWORD PTR [rax+120]

; 1714 : }

	add	rsp, 120				; 00000078H
	ret	0
?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFont
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
new_font_cfg$ = 32
$T1 = 40
$T2 = 48
tv85 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
tv87 = 96
tv92 = 104
this$ = 128
font_cfg$ = 136
?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA PROC ; `ImFontAtlas::AddFont'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z@4HA ENDP ; `ImFontAtlas::AddFont'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
??1ImFontAtlas@@QEAA@XZ PROC				; ImFontAtlas::~ImFontAtlas

; 1594 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1595 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 1596 :     Clear();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::Clear
	npad	1

; 1597 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??1?$ImVector@UImFontConfig@@@@QEAA@XZ	; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ; ImVector<ImFontAtlas::CustomRect>::~ImVector<ImFontAtlas::CustomRect>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImFontAtlas@@QEAA@XZ ENDP				; ImFontAtlas::~ImFontAtlas
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::~ImFontAtlas'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 72					; 00000048H
	call	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::~ImFontAtlas'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::~ImFontAtlas'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 88					; 00000058H
	call	??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ; ImVector<ImFontAtlas::CustomRect>::~ImVector<ImFontAtlas::CustomRect>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::~ImFontAtlas'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::~ImFontAtlas'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1?$ImVector@UImFontConfig@@@@QEAA@XZ	; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::~ImFontAtlas'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
n$1 = 32
$T2 = 36
$T3 = 44
this$ = 80
??0ImFontAtlas@@QEAA@XZ PROC				; ImFontAtlas::ImFontAtlas

; 1577 : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??0?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::ImVector<ImFont *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??0?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ; ImVector<ImFontAtlas::CustomRect>::ImVector<ImFontAtlas::CustomRect>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??0?$ImVector@UImFontConfig@@@@QEAA@XZ	; ImVector<ImFontConfig>::ImVector<ImFontConfig>
	npad	1

; 1578 :     Locked = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 1579 :     Flags = ImFontAtlasFlags_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0

; 1580 :     TexID = (ImTextureID)NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1581 :     TexDesiredWidth = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0

; 1582 :     TexGlyphPadding = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 1

; 1583 : 
; 1584 :     TexPixelsAlpha8 = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 0

; 1585 :     TexPixelsRGBA32 = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1586 :     TexWidth = TexHeight = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1587 :     TexUvScale = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 1588 :     TexUvWhitePixel = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 1589 :     for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@ImFontAtla:
	cmp	DWORD PTR n$1[rsp], 1
	jge	SHORT $LN3@ImFontAtla

; 1590 :         CustomRectIds[n] = -1;

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+rax*4+120], -1
	jmp	SHORT $LN2@ImFontAtla
$LN3@ImFontAtla:

; 1591 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0ImFontAtlas@@QEAA@XZ ENDP				; ImFontAtlas::ImFontAtlas
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
n$1 = 32
$T2 = 36
$T3 = 44
this$ = 80
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 72					; 00000048H
	call	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
n$1 = 32
$T2 = 36
$T3 = 44
this$ = 80
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 88					; 00000058H
	call	??1?$ImVector@UCustomRect@ImFontAtlas@@@@QEAA@XZ ; ImVector<ImFontAtlas::CustomRect>::~ImVector<ImFontAtlas::CustomRect>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
n$1 = 32
$T2 = 36
$T3 = 44
this$ = 80
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1?$ImVector@UImFontConfig@@@@QEAA@XZ	; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 34
$T3 = 36
n$4 = 40
this$ = 64
out_ranges$ = 72
?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z PROC ; ImFontGlyphRangesBuilder::BuildRanges

; 2520 : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2521 :     for (int n = 0; n < 0x10000; n++)

	mov	DWORD PTR n$4[rsp], 0
	jmp	SHORT $LN4@BuildRange
$LN2@BuildRange:
	mov	eax, DWORD PTR n$4[rsp]
	inc	eax
	mov	DWORD PTR n$4[rsp], eax
$LN4@BuildRange:
	cmp	DWORD PTR n$4[rsp], 65536		; 00010000H
	jge	SHORT $LN3@BuildRange

; 2522 :         if (GetBit(n))

	mov	edx, DWORD PTR n$4[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z ; ImFontGlyphRangesBuilder::GetBit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@BuildRange

; 2523 :         {
; 2524 :             out_ranges->push_back((ImWchar)n);

	movzx	eax, WORD PTR n$4[rsp]
	mov	WORD PTR $T1[rsp], ax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR out_ranges$[rsp]
	call	?push_back@?$ImVector@G@@QEAAXAEBG@Z	; ImVector<unsigned short>::push_back
	npad	1
$LN5@BuildRange:

; 2525 :             while (n < 0x10000 && GetBit(n + 1))

	cmp	DWORD PTR n$4[rsp], 65536		; 00010000H
	jge	SHORT $LN6@BuildRange
	mov	eax, DWORD PTR n$4[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z ; ImFontGlyphRangesBuilder::GetBit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@BuildRange

; 2526 :                 n++;

	mov	eax, DWORD PTR n$4[rsp]
	inc	eax
	mov	DWORD PTR n$4[rsp], eax
	jmp	SHORT $LN5@BuildRange
$LN6@BuildRange:

; 2527 :             out_ranges->push_back((ImWchar)n);

	movzx	eax, WORD PTR n$4[rsp]
	mov	WORD PTR $T2[rsp], ax
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR out_ranges$[rsp]
	call	?push_back@?$ImVector@G@@QEAAXAEBG@Z	; ImVector<unsigned short>::push_back
	npad	1
$LN7@BuildRange:

; 2528 :         }

	jmp	$LN2@BuildRange
$LN3@BuildRange:

; 2529 :     out_ranges->push_back(0);

	xor	eax, eax
	mov	WORD PTR $T3[rsp], ax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR out_ranges$[rsp]
	call	?push_back@?$ImVector@G@@QEAAXAEBG@Z	; ImVector<unsigned short>::push_back
	npad	1

; 2530 : }

	add	rsp, 56					; 00000038H
	ret	0
?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z ENDP ; ImFontGlyphRangesBuilder::BuildRanges
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
c$1 = 32
this$ = 64
ranges$ = 72
?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z PROC	; ImFontGlyphRangesBuilder::AddRanges

; 2513 : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2514 :     for (; ranges[0]; ranges += 2)

	jmp	SHORT $LN4@AddRanges
$LN2@AddRanges:
	mov	rax, QWORD PTR ranges$[rsp]
	add	rax, 4
	mov	QWORD PTR ranges$[rsp], rax
$LN4@AddRanges:
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ranges$[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@AddRanges

; 2515 :         for (ImWchar c = ranges[0]; c <= ranges[1]; c++)

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ranges$[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	WORD PTR c$1[rsp], ax
	jmp	SHORT $LN7@AddRanges
$LN5@AddRanges:
	movzx	eax, WORD PTR c$1[rsp]
	inc	ax
	mov	WORD PTR c$1[rsp], ax
$LN7@AddRanges:
	movzx	eax, WORD PTR c$1[rsp]
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR ranges$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx]
	cmp	eax, ecx
	jg	SHORT $LN6@AddRanges

; 2516 :             AddChar(c);

	movzx	edx, WORD PTR c$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z ; ImFontGlyphRangesBuilder::AddChar
	npad	1
	jmp	SHORT $LN5@AddRanges
$LN6@AddRanges:
	jmp	SHORT $LN2@AddRanges
$LN3@AddRanges:

; 2517 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z ENDP	; ImFontGlyphRangesBuilder::AddRanges
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
c$1 = 32
tv65 = 36
tv68 = 40
c_len$2 = 44
this$ = 64
text$ = 72
text_end$ = 80
?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z PROC	; ImFontGlyphRangesBuilder::AddText

; 2499 : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@AddText:

; 2500 :     while (text_end ? (text < text_end) : *text)

	cmp	QWORD PTR text_end$[rsp], 0
	je	SHORT $LN9@AddText
	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR text$[rsp], rax
	jae	SHORT $LN7@AddText
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN8@AddText
$LN7@AddText:
	mov	DWORD PTR tv65[rsp], 0
$LN8@AddText:
	mov	eax, DWORD PTR tv65[rsp]
	mov	DWORD PTR tv68[rsp], eax
	jmp	SHORT $LN10@AddText
$LN9@AddText:
	mov	rax, QWORD PTR text$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv68[rsp], eax
$LN10@AddText:
	cmp	DWORD PTR tv68[rsp], 0
	je	SHORT $LN3@AddText

; 2501 :     {
; 2502 :         unsigned int c = 0;

	mov	DWORD PTR c$1[rsp], 0

; 2503 :         int c_len = ImTextCharFromUtf8(&c, text, text_end);

	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text$[rsp]
	lea	rcx, QWORD PTR c$1[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	mov	DWORD PTR c_len$2[rsp], eax

; 2504 :         text += c_len;

	movsxd	rax, DWORD PTR c_len$2[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text$[rsp], rax

; 2505 :         if (c_len == 0)

	cmp	DWORD PTR c_len$2[rsp], 0
	jne	SHORT $LN4@AddText

; 2506 :             break;

	jmp	SHORT $LN3@AddText
$LN4@AddText:

; 2507 :         if (c < 0x10000)

	cmp	DWORD PTR c$1[rsp], 65536		; 00010000H
	jae	SHORT $LN5@AddText

; 2508 :             AddChar((ImWchar)c);

	movzx	edx, WORD PTR c$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z ; ImFontGlyphRangesBuilder::AddChar
	npad	1
$LN5@AddText:

; 2509 :     }

	jmp	$LN2@AddText
$LN3@AddText:

; 2510 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z ENDP	; ImFontGlyphRangesBuilder::AddText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z
_TEXT	SEGMENT
this$ = 48
c$ = 56
?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z PROC	; ImFontGlyphRangesBuilder::AddChar, COMDAT

; 1995 : 	void            AddChar(ImWchar c) { SetBit(c); }                          // Add character

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	movzx	eax, WORD PTR c$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z ; ImFontGlyphRangesBuilder::SetBit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z ENDP	; ImFontGlyphRangesBuilder::AddChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z
_TEXT	SEGMENT
tv80 = 32
off$ = 36
mask$ = 40
tv73 = 48
tv72 = 56
this$ = 80
n$ = 88
?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z PROC		; ImFontGlyphRangesBuilder::SetBit, COMDAT

; 1994 : 	void            SetBit(int n) { int off = (n >> 5); int mask = 1 << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	eax, DWORD PTR n$[rsp]
	sar	eax, 5
	mov	DWORD PTR off$[rsp], eax
	mov	eax, DWORD PTR n$[rsp]
	and	eax, 31
	mov	ecx, 1
	mov	DWORD PTR tv80[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv80[rsp]
	shl	eax, cl
	mov	DWORD PTR mask$[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	mov	edx, DWORD PTR off$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??A?$ImVector@H@@QEAAAEAHH@Z		; ImVector<int>::operator[]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR tv73[rsp]
	mov	ecx, DWORD PTR mask$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, ecx
	mov	rcx, QWORD PTR tv73[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 72					; 00000048H
	ret	0
?SetBit@ImFontGlyphRangesBuilder@@QEAAXH@Z ENDP		; ImFontGlyphRangesBuilder::SetBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
off$ = 40
mask$ = 44
tv72 = 48
this$ = 80
n$ = 88
?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z PROC	; ImFontGlyphRangesBuilder::GetBit, COMDAT

; 1993 : 	bool            GetBit(int n) const { int off = (n >> 5); int mask = 1 << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	eax, DWORD PTR n$[rsp]
	sar	eax, 5
	mov	DWORD PTR off$[rsp], eax
	mov	eax, DWORD PTR n$[rsp]
	and	eax, 31
	mov	ecx, 1
	mov	DWORD PTR tv82[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv82[rsp]
	shl	eax, cl
	mov	DWORD PTR mask$[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	mov	edx, DWORD PTR off$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??A?$ImVector@H@@QEBAAEBHH@Z		; ImVector<int>::operator[]
	mov	ecx, DWORD PTR mask$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN3@GetBit
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@GetBit
$LN3@GetBit:
	mov	DWORD PTR tv75[rsp], 0
$LN4@GetBit:
	movzx	eax, BYTE PTR tv75[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?GetBit@ImFontGlyphRangesBuilder@@QEBA_NH@Z ENDP	; ImFontGlyphRangesBuilder::GetBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@H@@QEAAXAEBH@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@H@@QEAAXAEBH@Z PROC		; ImVector<int>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@H@@QEBAHH@Z	; ImVector<int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	r8d, 4
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@H@@QEAAXAEBH@Z ENDP		; ImVector<int>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@H@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@H@@QEAAXH@Z PROC			; ImVector<int>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@H@@QEAAXH@Z ENDP			; ImVector<int>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@H@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@H@@QEAAXH@Z PROC			; ImVector<int>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@H@@QEBAHH@Z	; ImVector<int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@H@@QEAAXH@Z ENDP			; ImVector<int>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@H@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@H@@QEBAHH@Z PROC		; ImVector<int>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@H@@QEBAHH@Z ENDP		; ImVector<int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?end@?$ImVector@H@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?end@?$ImVector@H@@QEBAPEBHXZ PROC			; ImVector<int>::end, COMDAT

; 1235 : 	inline const T* end() const { return Data + Size; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
?end@?$ImVector@H@@QEBAPEBHXZ ENDP			; ImVector<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?begin@?$ImVector@H@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$ImVector@H@@QEBAPEBHXZ PROC			; ImVector<int>::begin, COMDAT

; 1233 : 	inline const T* begin() const { return Data; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?begin@?$ImVector@H@@QEBAPEBHXZ ENDP			; ImVector<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@H@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@H@@QEAAXXZ PROC			; ImVector<int>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@H@@QEAAXXZ ENDP			; ImVector<int>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@H@@QEBAAEBHH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@H@@QEBAAEBHH@Z PROC			; ImVector<int>::operator[], COMDAT

; 1229 : 	inline const T& operator[](int i) const { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
??A?$ImVector@H@@QEBAAEBHH@Z ENDP			; ImVector<int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@H@@QEAAAEAHH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@H@@QEAAAEAHH@Z PROC			; ImVector<int>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
??A?$ImVector@H@@QEAAAEAHH@Z ENDP			; ImVector<int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@H@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@H@@QEBA_NXZ PROC			; ImVector<int>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@H@@QEBA_NXZ ENDP			; ImVector<int>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@H@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@H@@QEAA@XZ PROC				; ImVector<int>::~ImVector<int>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@H@@QEAA@XZ ENDP				; ImVector<int>::~ImVector<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
??0ImFontConfig@@QEAA@XZ PROC				; ImFontConfig::ImFontConfig

; 1502 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 1503 :     FontData = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 1504 :     FontDataSize = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0

; 1505 :     FontDataOwnedByAtlas = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1

; 1506 :     FontNo = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+44], 0

; 1507 :     SizePixels = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+48], xmm0

; 1508 :     OversampleH = 2; // FIXME: 2 may be a better default?

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+52], 2

; 1509 :     OversampleV = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 1

; 1510 :     PixelSnapH = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+12], 0

; 1511 :     GlyphExtraSpacing = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1512 :     GlyphOffset = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+36], rax

; 1513 :     GlyphRanges = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1514 :     GlyphMinAdvanceX = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+64], xmm0

; 1515 :     GlyphMaxAdvanceX = FLT_MAX;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [rax+68], xmm0

; 1516 :     MergeMode = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+72], 0

; 1517 :     RasterizerFlags = 0x00;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0

; 1518 :     RasterizerMultiply = 1.5f;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [rax+76], xmm0

; 1519 :     memset(Name, 0, sizeof(Name));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	r8d, 40					; 00000028H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1520 :     DstFont = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+120], 0

; 1521 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImFontConfig@@QEAA@XZ ENDP				; ImFontConfig::ImFontConfig
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 48
cmd_i$2 = 52
tv134 = 56
cmd$3 = 64
cmd_list$4 = 72
tv80 = 80
$T5 = 88
this$ = 144
fb_scale$ = 152
?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z PROC	; ImDrawData::ScaleClipRects

; 1438 : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 1439 :     for (int i = 0; i < CmdListsCount; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ScaleClipR
$LN2@ScaleClipR:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ScaleClipR:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@ScaleClipR

; 1440 :     {
; 1441 :         ImDrawList* cmd_list = CmdLists[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR cmd_list$4[rsp], rax

; 1442 :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	DWORD PTR cmd_i$2[rsp], 0
	jmp	SHORT $LN7@ScaleClipR
$LN5@ScaleClipR:
	mov	eax, DWORD PTR cmd_i$2[rsp]
	inc	eax
	mov	DWORD PTR cmd_i$2[rsp], eax
$LN7@ScaleClipR:
	mov	rax, QWORD PTR cmd_list$4[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR cmd_i$2[rsp], eax
	jge	$LN6@ScaleClipR

; 1443 :         {
; 1444 :             ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];

	mov	rax, QWORD PTR cmd_list$4[rsp]
	add	rax, 24
	mov	QWORD PTR tv80[rsp], rax
	mov	edx, DWORD PTR cmd_i$2[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
	mov	QWORD PTR cmd$3[rsp], rax

; 1445 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * fb_scale.x, cmd->ClipRect.y * fb_scale.y, cmd->ClipRect.z * fb_scale.x, cmd->ClipRect.w * fb_scale.y);

	mov	rax, QWORD PTR cmd$3[rsp]
	mov	rcx, QWORD PTR fb_scale$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	mulss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR cmd$3[rsp]
	mov	rcx, QWORD PTR fb_scale$[rsp]
	movss	xmm1, DWORD PTR [rax+20]
	mulss	xmm1, DWORD PTR [rcx]
	mov	rax, QWORD PTR cmd$3[rsp]
	mov	rcx, QWORD PTR fb_scale$[rsp]
	movss	xmm2, DWORD PTR [rax+16]
	mulss	xmm2, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR cmd$3[rsp]
	mov	rcx, QWORD PTR fb_scale$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	mulss	xmm3, DWORD PTR [rcx]
	movss	DWORD PTR tv134[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv134[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, QWORD PTR cmd$3[rsp]
	lea	rdi, QWORD PTR [rcx+12]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1446 :         }

	jmp	$LN5@ScaleClipR
$LN6@ScaleClipR:

; 1447 :     }

	jmp	$LN2@ScaleClipR
$LN3@ScaleClipR:

; 1448 : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z ENDP	; ImDrawData::ScaleClipRects
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
j$1 = 32
i$2 = 36
cmd_list$3 = 40
new_vtx_buffer$ = 48
tv132 = 64
tv136 = 72
tv143 = 80
tv148 = 88
$T4 = 96
this$ = 160
?DeIndexAllBuffers@ImDrawData@@QEAAXXZ PROC		; ImDrawData::DeIndexAllBuffers

; 1417 : {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 136				; 00000088H

; 1418 :     ImVector<ImDrawVert> new_vtx_buffer;

	lea	rcx, QWORD PTR new_vtx_buffer$[rsp]
	call	??0?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::ImVector<ImDrawVert>
	npad	1

; 1419 :     TotalVtxCount = TotalIdxCount = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+28], 0

; 1420 :     for (int i = 0; i < CmdListsCount; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@DeIndexAll
$LN2@DeIndexAll:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@DeIndexAll:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN3@DeIndexAll

; 1421 :     {
; 1422 :         ImDrawList* cmd_list = CmdLists[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR cmd_list$3[rsp], rax

; 1423 :         if (cmd_list->IdxBuffer.empty())

	mov	rax, QWORD PTR cmd_list$3[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	?empty@?$ImVector@G@@QEBA_NXZ		; ImVector<unsigned short>::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DeIndexAll

; 1424 :             continue;

	jmp	SHORT $LN2@DeIndexAll
$LN8@DeIndexAll:

; 1425 :         new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);

	mov	rax, QWORD PTR cmd_list$3[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, QWORD PTR new_vtx_buffer$[rsp]
	call	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::resize
	npad	1

; 1426 :         for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN7@DeIndexAll
$LN5@DeIndexAll:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN7@DeIndexAll:
	mov	rax, QWORD PTR cmd_list$3[rsp]
	mov	eax, DWORD PTR [rax+40]
	cmp	DWORD PTR j$1[rsp], eax
	jge	SHORT $LN6@DeIndexAll

; 1427 :             new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];

	mov	rax, QWORD PTR cmd_list$3[rsp]
	mov	QWORD PTR tv136[rsp], rax
	mov	rax, QWORD PTR cmd_list$3[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv132[rsp], rax
	mov	edx, DWORD PTR j$1[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	mov	rcx, QWORD PTR tv136[rsp]
	call	??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 20
	rep movsb
	mov	edx, DWORD PTR j$1[rsp]
	lea	rcx, QWORD PTR new_vtx_buffer$[rsp]
	call	??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 20
	rep movsb
	jmp	$LN5@DeIndexAll
$LN6@DeIndexAll:

; 1428 :         cmd_list->VtxBuffer.swap(new_vtx_buffer);

	mov	rax, QWORD PTR cmd_list$3[rsp]
	mov	QWORD PTR tv143[rsp], rax
	lea	rdx, QWORD PTR new_vtx_buffer$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z ; ImVector<ImDrawVert>::swap

; 1429 :         cmd_list->IdxBuffer.resize(0);

	mov	rax, QWORD PTR cmd_list$3[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv148[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv148[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 1430 :         TotalVtxCount += cmd_list->VtxBuffer.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR cmd_list$3[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 1431 :     }

	jmp	$LN2@DeIndexAll
$LN3@DeIndexAll:

; 1432 : }

	lea	rcx, QWORD PTR new_vtx_buffer$[rsp]
	call	??1?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
	npad	1
	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rsi
	ret	0
?DeIndexAllBuffers@ImDrawData@@QEAAXXZ ENDP		; ImDrawData::DeIndexAllBuffers
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
j$1 = 32
i$2 = 36
cmd_list$3 = 40
new_vtx_buffer$ = 48
tv132 = 64
tv136 = 72
tv143 = 80
tv148 = 88
$T4 = 96
this$ = 160
?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA PROC ; `ImDrawData::DeIndexAllBuffers'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR new_vtx_buffer$[rbp]
	call	??1?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??DeIndexAllBuffers@ImDrawData@@QEAAXXZ@4HA ENDP ; `ImDrawData::DeIndexAllBuffers'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
curr_cmd$ = 32
prev_cmd$ = 40
curr_texture_id$ = 48
tv76 = 56
tv83 = 64
tv128 = 72
tv150 = 80
$T1 = 88
this$ = 112
?UpdateTextureID@ImDrawList@@QEAAXXZ PROC		; ImDrawList::UpdateTextureID

; 459  : {

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 460  :     // If current command is used with different settings we need to add a new command
; 461  :     const ImTextureID curr_texture_id = GetCurrentTextureId();

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+136], 0
	je	SHORT $LN8@UpdateText
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+136]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+144]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN9@UpdateText
$LN8@UpdateText:
	mov	QWORD PTR tv76[rsp], 0
$LN9@UpdateText:
	mov	rax, QWORD PTR tv76[rsp]
	mov	QWORD PTR curr_texture_id$[rsp], rax

; 462  :     ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN10@UpdateText
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
	mov	QWORD PTR tv83[rsp], rax
	jmp	SHORT $LN11@UpdateText
$LN10@UpdateText:
	mov	QWORD PTR tv83[rsp], 0
$LN11@UpdateText:
	mov	rax, QWORD PTR tv83[rsp]
	mov	QWORD PTR curr_cmd$[rsp], rax

; 463  :     if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)

	cmp	QWORD PTR curr_cmd$[rsp], 0
	je	SHORT $LN3@UpdateText
	mov	rax, QWORD PTR curr_cmd$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN4@UpdateText
	mov	rax, QWORD PTR curr_cmd$[rsp]
	mov	rcx, QWORD PTR curr_texture_id$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@UpdateText
$LN4@UpdateText:
	mov	rax, QWORD PTR curr_cmd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN2@UpdateText
$LN3@UpdateText:

; 464  :     {
; 465  :         AddDrawCmd();

	mov	rcx, QWORD PTR this$[rsp]
	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
	npad	1

; 466  :         return;

	jmp	$LN1@UpdateText
$LN2@UpdateText:

; 467  :     }
; 468  : 
; 469  :     // Try to merge with previous command if it matches, else use current command
; 470  :     ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+24], 1
	jle	SHORT $LN12@UpdateText
	mov	rax, QWORD PTR curr_cmd$[rsp]
	sub	rax, 48					; 00000030H
	mov	QWORD PTR tv128[rsp], rax
	jmp	SHORT $LN13@UpdateText
$LN12@UpdateText:
	mov	QWORD PTR tv128[rsp], 0
$LN13@UpdateText:
	mov	rax, QWORD PTR tv128[rsp]
	mov	QWORD PTR prev_cmd$[rsp], rax

; 471  :     if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)

	mov	rax, QWORD PTR curr_cmd$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	$LN5@UpdateText
	cmp	QWORD PTR prev_cmd$[rsp], 0
	je	$LN5@UpdateText
	mov	rax, QWORD PTR prev_cmd$[rsp]
	mov	rcx, QWORD PTR curr_texture_id$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	$LN5@UpdateText
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+120], 0
	je	SHORT $LN14@UpdateText
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+120]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+128]
	mov	QWORD PTR tv150[rsp], rax
	jmp	SHORT $LN15@UpdateText
$LN14@UpdateText:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, 24
	mov	QWORD PTR tv150[rsp], rax
$LN15@UpdateText:
	mov	rax, QWORD PTR tv150[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR prev_cmd$[rsp]
	add	rax, 12
	mov	r8d, 16
	mov	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	memcmp
	test	eax, eax
	jne	SHORT $LN5@UpdateText
	mov	rax, QWORD PTR prev_cmd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN5@UpdateText

; 472  :         CmdBuffer.pop_back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
	npad	1
	jmp	SHORT $LN6@UpdateText
$LN5@UpdateText:

; 473  :     else
; 474  :         curr_cmd->TextureId = curr_texture_id;

	mov	rax, QWORD PTR curr_cmd$[rsp]
	mov	rcx, QWORD PTR curr_texture_id$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@UpdateText:
$LN1@UpdateText:

; 475  : }

	add	rsp, 104				; 00000068H
	ret	0
?UpdateTextureID@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::UpdateTextureID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
curr_cmd$ = 32
prev_cmd$ = 40
tv78 = 48
tv92 = 56
tv141 = 64
tv164 = 72
$T1 = 80
curr_clip_rect$ = 88
this$ = 144
?UpdateClipRect@ImDrawList@@QEAAXXZ PROC		; ImDrawList::UpdateClipRect

; 440  : {

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 441  :     // If current command is used with different settings we need to add a new command
; 442  :     const ImVec4 curr_clip_rect = GetCurrentClipRect();

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+120], 0
	je	SHORT $LN8@UpdateClip
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+120]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+128]
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN9@UpdateClip
$LN8@UpdateClip:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, 24
	mov	QWORD PTR tv78[rsp], rax
$LN9@UpdateClip:
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rax, QWORD PTR curr_clip_rect$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T1[rsp]
	mov	ecx, 16
	rep movsb

; 443  :     ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size - 1] : NULL;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+24], 0
	jle	SHORT $LN10@UpdateClip
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN11@UpdateClip
$LN10@UpdateClip:
	mov	QWORD PTR tv92[rsp], 0
$LN11@UpdateClip:
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR curr_cmd$[rsp], rax

; 444  :     if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)

	cmp	QWORD PTR curr_cmd$[rsp], 0
	je	SHORT $LN3@UpdateClip
	mov	rax, QWORD PTR curr_cmd$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN4@UpdateClip
	mov	rax, QWORD PTR curr_cmd$[rsp]
	add	rax, 12
	mov	r8d, 16
	lea	rdx, QWORD PTR curr_clip_rect$[rsp]
	mov	rcx, rax
	call	memcmp
	test	eax, eax
	jne	SHORT $LN3@UpdateClip
$LN4@UpdateClip:
	mov	rax, QWORD PTR curr_cmd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN2@UpdateClip
$LN3@UpdateClip:

; 445  :     {
; 446  :         AddDrawCmd();

	mov	rcx, QWORD PTR this$[rsp]
	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
	npad	1

; 447  :         return;

	jmp	$LN1@UpdateClip
$LN2@UpdateClip:

; 448  :     }
; 449  : 
; 450  :     // Try to merge with previous command if it matches, else use current command
; 451  :     ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+24], 1
	jle	SHORT $LN12@UpdateClip
	mov	rax, QWORD PTR curr_cmd$[rsp]
	sub	rax, 48					; 00000030H
	mov	QWORD PTR tv141[rsp], rax
	jmp	SHORT $LN13@UpdateClip
$LN12@UpdateClip:
	mov	QWORD PTR tv141[rsp], 0
$LN13@UpdateClip:
	mov	rax, QWORD PTR tv141[rsp]
	mov	QWORD PTR prev_cmd$[rsp], rax

; 452  :     if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)

	mov	rax, QWORD PTR curr_cmd$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	$LN5@UpdateClip
	cmp	QWORD PTR prev_cmd$[rsp], 0
	je	$LN5@UpdateClip
	mov	rax, QWORD PTR prev_cmd$[rsp]
	add	rax, 12
	mov	r8d, 16
	lea	rdx, QWORD PTR curr_clip_rect$[rsp]
	mov	rcx, rax
	call	memcmp
	test	eax, eax
	jne	SHORT $LN5@UpdateClip
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+136], 0
	je	SHORT $LN14@UpdateClip
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+136]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+144]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv164[rsp], rax
	jmp	SHORT $LN15@UpdateClip
$LN14@UpdateClip:
	mov	QWORD PTR tv164[rsp], 0
$LN15@UpdateClip:
	mov	rax, QWORD PTR prev_cmd$[rsp]
	mov	rcx, QWORD PTR tv164[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN5@UpdateClip
	mov	rax, QWORD PTR prev_cmd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN5@UpdateClip

; 453  :         CmdBuffer.pop_back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
	npad	1
	jmp	SHORT $LN6@UpdateClip
$LN5@UpdateClip:

; 454  :     else
; 455  :         curr_cmd->ClipRect = curr_clip_rect;

	mov	rax, QWORD PTR curr_cmd$[rsp]
	lea	rcx, QWORD PTR curr_clip_rect$[rsp]
	lea	rdi, QWORD PTR [rax+12]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN6@UpdateClip:
$LN1@UpdateClip:

; 456  : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?UpdateClipRect@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::UpdateClipRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PrimWriteIdx@ImDrawList@@QEAAXG@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
?PrimWriteIdx@ImDrawList@@QEAAXG@Z PROC			; ImDrawList::PrimWriteIdx, COMDAT

; 1921 : 	inline    void  PrimWriteIdx(ImDrawIdx idx) { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	movzx	ecx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax
	ret	0
?PrimWriteIdx@ImDrawList@@QEAAXG@Z ENDP			; ImDrawList::PrimWriteIdx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
uv$ = 24
col$ = 32
?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC	; ImDrawList::PrimWriteVtx, COMDAT

; 1920 : 	inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR pos$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR uv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	ecx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rax+16], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+64], eax
	ret	0
?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP	; ImDrawList::PrimWriteVtx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
idx$ = 0
this$ = 32
a$ = 40
b$ = 48
c$ = 56
d$ = 64
uv_a$ = 72
uv_b$ = 80
uv_c$ = 88
uv_d$ = 96
col$ = 104
?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z PROC ; ImDrawList::PrimQuadUV

; 650  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 651  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR idx$[rsp], ax

; 652  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax+rcx], dx
	movzx	eax, WORD PTR idx$[rsp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 653  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);

	mov	eax, 2
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax+rcx], dx
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 654  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rax, QWORD PTR uv_a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx+8], rax
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 655  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

	mov	rax, QWORD PTR b$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rax, QWORD PTR uv_b$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx+8], rax
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 656  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rax, QWORD PTR uv_c$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx+8], rax
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 657  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

	mov	rax, QWORD PTR d$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rax, QWORD PTR uv_d$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx+8], rax
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 658  :     _VtxWritePtr += 4;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 659  :     _VtxCurrentIdx += 4;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 4
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 660  :     _IdxWritePtr += 6;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 12
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 661  : }

	add	rsp, 24
	ret	0
?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z ENDP ; ImDrawList::PrimQuadUV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
idx$ = 32
b$ = 40
uv_b$ = 48
d$ = 56
uv_d$ = 64
this$ = 96
a$ = 104
c$ = 112
uv_a$ = 120
uv_c$ = 128
col$ = 136
?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z PROC	; ImDrawList::PrimRectUV

; 635  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 636  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR c$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR b$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR c$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR d$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR uv_a$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR uv_c$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR uv_b$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR uv_c$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR uv_a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR uv_d$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 637  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR idx$[rsp], ax

; 638  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax+rcx], dx
	movzx	eax, WORD PTR idx$[rsp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 639  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);

	mov	eax, 2
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax+rcx], dx
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 640  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rax, QWORD PTR uv_a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx+8], rax
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 641  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR b$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv_b$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 642  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rax, QWORD PTR uv_c$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx+8], rax
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 643  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR d$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv_d$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 644  :     _VtxWritePtr += 4;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 645  :     _VtxCurrentIdx += 4;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 4
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 646  :     _IdxWritePtr += 6;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 12
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 647  : }

	add	rsp, 88					; 00000058H
	ret	0
?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ENDP	; ImDrawList::PrimRectUV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
idx$ = 32
uv$ = 40
b$ = 48
d$ = 56
this$ = 80
a$ = 88
c$ = 96
col$ = 104
?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC	; ImDrawList::PrimRect

; 620  : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 621  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR c$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR b$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR c$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR d$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR uv$[rsp], rax

; 622  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR idx$[rsp], ax

; 623  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax+rcx], dx
	movzx	eax, WORD PTR idx$[rsp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 624  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);

	mov	eax, 2
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax+rcx], dx
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	movzx	eax, WORD PTR idx$[rsp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 625  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 626  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR b$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 627  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 628  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR d$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rcx+rax+16], edx

; 629  :     _VtxWritePtr += 4;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 630  :     _VtxCurrentIdx += 4;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 4
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 631  :     _IdxWritePtr += 6;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 12
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 632  : }

	add	rsp, 72					; 00000048H
	ret	0
?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP	; ImDrawList::PrimRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
vtx_buffer_old_size$ = 32
idx_buffer_old_size$ = 36
draw_cmd$ = 40
tv83 = 48
tv129 = 56
this$ = 80
idx_count$ = 88
vtx_count$ = 96
?PrimReserve@ImDrawList@@QEAAXHH@Z PROC			; ImDrawList::PrimReserve

; 605  : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 606  :     ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size - 1];

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR draw_cmd$[rsp], rax

; 607  :     draw_cmd.ElemCount += idx_count;

	mov	rax, QWORD PTR draw_cmd$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	eax, DWORD PTR idx_count$[rsp]
	mov	rcx, QWORD PTR draw_cmd$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 608  : 
; 609  :     int vtx_buffer_old_size = VtxBuffer.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR vtx_buffer_old_size$[rsp], eax

; 610  :     VtxBuffer.resize(vtx_buffer_old_size + vtx_count);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	eax, DWORD PTR vtx_count$[rsp]
	mov	ecx, DWORD PTR vtx_buffer_old_size$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR tv83[rsp]
	call	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::resize

; 611  :     _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

	movsxd	rax, DWORD PTR vtx_buffer_old_size$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 612  : 
; 613  :     int idx_buffer_old_size = IdxBuffer.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR idx_buffer_old_size$[rsp], eax

; 614  :     IdxBuffer.resize(idx_buffer_old_size + idx_count);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv129[rsp], rax
	mov	eax, DWORD PTR idx_count$[rsp]
	mov	ecx, DWORD PTR idx_buffer_old_size$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR tv129[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 615  :     _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;

	movsxd	rax, DWORD PTR idx_buffer_old_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 616  : }

	add	rsp, 72					; 00000048H
	ret	0
?PrimReserve@ImDrawList@@QEAAXHH@Z ENDP			; ImDrawList::PrimReserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
tv94 = 40
tv132 = 48
tv140 = 56
this$ = 80
?ClearFreeMemory@ImDrawList@@QEAAXXZ PROC		; ImDrawList::ClearFreeMemory

; 378  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 379  :     CmdBuffer.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ	; ImVector<ImDrawCmd>::clear

; 380  :     IdxBuffer.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	?clear@?$ImVector@G@@QEAAXXZ		; ImVector<unsigned short>::clear

; 381  :     VtxBuffer.clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ ; ImVector<ImDrawVert>::clear

; 382  :     _VtxCurrentIdx = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+64], 0

; 383  :     _VtxWritePtr = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 384  :     _IdxWritePtr = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+88], 0

; 385  :     _ClipRectStack.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?clear@?$ImVector@UImVec4@@@@QEAAXXZ	; ImVector<ImVec4>::clear

; 386  :     _TextureIdStack.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?clear@?$ImVector@PEAX@@QEAAXXZ		; ImVector<void *>::clear

; 387  :     _Path.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	?clear@?$ImVector@UImVec2@@@@QEAAXXZ	; ImVector<ImVec2>::clear

; 388  :     _ChannelsCurrent = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+96], 0

; 389  :     _ChannelsCount = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+100], 1

; 390  :     for (int i = 0; i < _Channels.Size; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ClearFreeM
$LN2@ClearFreeM:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ClearFreeM:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+104]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@ClearFreeM

; 391  :     {
; 392  :         if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again

	cmp	DWORD PTR i$1[rsp], 0
	jne	SHORT $LN5@ClearFreeM
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv94[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv94[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1
$LN5@ClearFreeM:

; 393  :         _Channels[i].CmdBuffer.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv132[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	rcx, rax
	call	?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ	; ImVector<ImDrawCmd>::clear

; 394  :         _Channels[i].IdxBuffer.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv140[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv140[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	add	rax, 16
	mov	rcx, rax
	call	?clear@?$ImVector@G@@QEAAXXZ		; ImVector<unsigned short>::clear
	npad	1

; 395  :     }

	jmp	$LN2@ClearFreeM
$LN3@ClearFreeM:

; 396  :     _Channels.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ ; ImVector<ImDrawChannel>::clear
	npad	1

; 397  : }

	add	rsp, 72					; 00000048H
	ret	0
?ClearFreeMemory@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv68 = 32
tv73 = 40
tv78 = 48
tv87 = 56
tv92 = 64
tv129 = 72
this$ = 96
?Clear@ImDrawList@@QEAAXXZ PROC				; ImDrawList::Clear

; 361  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 362  :     CmdBuffer.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv68[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv68[rsp]
	call	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::resize

; 363  :     IdxBuffer.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv73[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv73[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 364  :     VtxBuffer.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv78[rsp]
	call	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::resize

; 365  :     Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], 3

; 366  :     _VtxCurrentIdx = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+64], 0

; 367  :     _VtxWritePtr = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 368  :     _IdxWritePtr = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+88], 0

; 369  :     _ClipRectStack.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv87[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv87[rsp]
	call	?resize@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::resize

; 370  :     _TextureIdStack.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	QWORD PTR tv92[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv92[rsp]
	call	?resize@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::resize

; 371  :     _Path.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv129[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv129[rsp]
	call	?resize@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::resize

; 372  :     _ChannelsCurrent = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+96], 0

; 373  :     _ChannelsCount = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+100], 1

; 374  :     // NB: Do not clear channels so our allocations are re-used after the first frame.
; 375  : }

	add	rsp, 88					; 00000058H
	ret	0
?Clear@ImDrawList@@QEAAXXZ ENDP				; ImDrawList::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
dst$ = 40
$T2 = 48
tv81 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
?CloneOutput@ImDrawList@@QEBAPEAU1@XZ PROC		; ImDrawList::CloneOutput

; 400  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 401  :     ImDrawList* dst = IM_NEW(ImDrawList(NULL));

	mov	ecx, 168				; 000000a8H
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	r8, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR $T4[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 168				; 000000a8H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN3@CloneOutpu
	xor	edx, edx
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ; ImDrawList::ImDrawList
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN4@CloneOutpu
$LN3@CloneOutpu:
	mov	QWORD PTR tv81[rsp], 0
$LN4@CloneOutpu:
	mov	rax, QWORD PTR tv81[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 402  :     dst->CmdBuffer = CmdBuffer;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, 24
	mov	rdx, rax
	call	??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z ; ImVector<ImDrawCmd>::operator=

; 403  :     dst->IdxBuffer = IdxBuffer;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, 40					; 00000028H
	mov	rdx, rax
	call	??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z	; ImVector<unsigned short>::operator=

; 404  :     dst->VtxBuffer = VtxBuffer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	rdx, rax
	call	??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z ; ImVector<ImDrawVert>::operator=

; 405  :     dst->Flags = Flags;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx

; 406  :     return dst;

	mov	rax, QWORD PTR dst$[rsp]

; 407  : }

	add	rsp, 104				; 00000068H
	ret	0
?CloneOutput@ImDrawList@@QEBAPEAU1@XZ ENDP		; ImDrawList::CloneOutput
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
dst$ = 40
$T2 = 48
tv81 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA PROC ; `ImDrawList::CloneOutput'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??CloneOutput@ImDrawList@@QEBAPEAU1@XZ@4HA ENDP ; `ImDrawList::CloneOutput'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv79 = 32
tv93 = 40
$T1 = 48
tv130 = 56
draw_cmd$ = 64
this$ = 144
?AddDrawCmd@ImDrawList@@QEAAXXZ PROC			; ImDrawList::AddDrawCmd

; 414  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 415  :     ImDrawCmd draw_cmd;

	lea	rcx, QWORD PTR draw_cmd$[rsp]
	call	??0ImDrawCmd@@QEAA@XZ			; ImDrawCmd::ImDrawCmd
	npad	1

; 416  :     draw_cmd.ClipRect = GetCurrentClipRect();

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+120], 0
	je	SHORT $LN3@AddDrawCmd
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+120]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+128]
	mov	QWORD PTR tv79[rsp], rax
	jmp	SHORT $LN4@AddDrawCmd
$LN3@AddDrawCmd:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, 24
	mov	QWORD PTR tv79[rsp], rax
$LN4@AddDrawCmd:
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rax, QWORD PTR draw_cmd$[rsp+12]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T1[rsp]
	mov	ecx, 16
	rep movsb

; 417  :     draw_cmd.TextureId = GetCurrentTextureId();

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+136], 0
	je	SHORT $LN5@AddDrawCmd
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+136]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+144]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv93[rsp], rax
	jmp	SHORT $LN6@AddDrawCmd
$LN5@AddDrawCmd:
	mov	QWORD PTR tv93[rsp], 0
$LN6@AddDrawCmd:
	mov	rax, QWORD PTR tv93[rsp]
	mov	QWORD PTR draw_cmd$[rsp], rax

; 418  : 
; 419  :     IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
; 420  :     CmdBuffer.push_back(draw_cmd);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv130[rsp], rax
	lea	rdx, QWORD PTR draw_cmd$[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
	npad	1

; 421  : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?AddDrawCmd@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::AddDrawCmd
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
current_cmd$ = 32
tv70 = 40
this$ = 64
callback$ = 72
callback_data$ = 80
?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z PROC ; ImDrawList::AddCallback

; 424  : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :     ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN5@AddCallbac
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN6@AddCallbac
$LN5@AddCallbac:
	mov	QWORD PTR tv70[rsp], 0
$LN6@AddCallbac:
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR current_cmd$[rsp], rax

; 426  :     if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)

	cmp	QWORD PTR current_cmd$[rsp], 0
	je	SHORT $LN3@AddCallbac
	mov	rax, QWORD PTR current_cmd$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN3@AddCallbac
	mov	rax, QWORD PTR current_cmd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN2@AddCallbac
$LN3@AddCallbac:

; 427  :     {
; 428  :         AddDrawCmd();

	mov	rcx, QWORD PTR this$[rsp]
	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd

; 429  :         current_cmd = &CmdBuffer.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
	mov	QWORD PTR current_cmd$[rsp], rax
$LN2@AddCallbac:

; 430  :     }
; 431  :     current_cmd->UserCallback = callback;

	mov	rax, QWORD PTR current_cmd$[rsp]
	mov	rcx, QWORD PTR callback$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 432  :     current_cmd->UserCallbackData = callback_data;

	mov	rax, QWORD PTR current_cmd$[rsp]
	mov	rcx, QWORD PTR callback_data$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 433  : 
; 434  :     AddDrawCmd(); // Force a new command after us (see comment below)

	mov	rcx, QWORD PTR this$[rsp]
	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
	npad	1

; 435  : }

	add	rsp, 56					; 00000038H
	ret	0
?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z ENDP ; ImDrawList::AddCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
idx$ = 56
?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z PROC		; ImDrawList::ChannelsSetCurrent

; 592  : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 593  :     IM_ASSERT(idx < _ChannelsCount);
; 594  :     if (_ChannelsCurrent == idx) return;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR idx$[rsp]
	cmp	DWORD PTR [rax+96], ecx
	jne	SHORT $LN2@ChannelsSe
	jmp	$LN1@ChannelsSe
$LN2@ChannelsSe:

; 595  :     memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR [rcx+96]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8d, 16
	mov	rdx, rax
	call	memcpy

; 596  :     memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR [rcx+96]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	lea	rcx, QWORD PTR [rdx+rcx+16]
	mov	r8d, 16
	mov	rdx, rax
	call	memcpy

; 597  :     _ChannelsCurrent = idx;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR idx$[rsp]
	mov	DWORD PTR [rax+96], ecx

; 598  :     memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+96]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 24
	mov	r8d, 16
	mov	rdx, rax
	call	memcpy

; 599  :     memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+96]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	lea	rax, QWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 40					; 00000028H
	mov	r8d, 16
	mov	rdx, rax
	call	memcpy

; 600  :     _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax
$LN1@ChannelsSe:

; 601  : }

	add	rsp, 40					; 00000028H
	ret	0
?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z ENDP		; ImDrawList::ChannelsSetCurrent
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
new_cmd_buffer_count$ = 36
new_idx_buffer_count$ = 40
i$2 = 44
sz$3 = 48
sz$4 = 52
ch$5 = 56
ch$6 = 64
cmd_write$ = 72
tv86 = 80
tv142 = 88
tv150 = 96
tv180 = 104
this$ = 128
?ChannelsMerge@ImDrawList@@QEAAXXZ PROC			; ImDrawList::ChannelsMerge

; 558  : {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 559  :     // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
; 560  :     if (_ChannelsCount <= 1)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+100], 1
	jg	SHORT $LN8@ChannelsMe

; 561  :         return;

	jmp	$LN1@ChannelsMe
$LN8@ChannelsMe:

; 562  : 
; 563  :     ChannelsSetCurrent(0);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z ; ImDrawList::ChannelsSetCurrent
	npad	1

; 564  :     if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN9@ChannelsMe
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN9@ChannelsMe

; 565  :         CmdBuffer.pop_back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
	npad	1
$LN9@ChannelsMe:

; 566  : 
; 567  :     int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;

	mov	DWORD PTR new_cmd_buffer_count$[rsp], 0
	mov	DWORD PTR new_idx_buffer_count$[rsp], 0

; 568  :     for (int i = 1; i < _ChannelsCount; i++)

	mov	DWORD PTR i$1[rsp], 1
	jmp	SHORT $LN4@ChannelsMe
$LN2@ChannelsMe:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ChannelsMe:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+100]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@ChannelsMe

; 569  :     {
; 570  :         ImDrawChannel& ch = _Channels[i];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv86[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	QWORD PTR ch$5[rsp], rax

; 571  :         if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)

	mov	rax, QWORD PTR ch$5[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN10@ChannelsMe
	mov	rax, QWORD PTR ch$5[rsp]
	mov	rcx, rax
	call	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN10@ChannelsMe

; 572  :             ch.CmdBuffer.pop_back();

	mov	rax, QWORD PTR ch$5[rsp]
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
	npad	1
$LN10@ChannelsMe:

; 573  :         new_cmd_buffer_count += ch.CmdBuffer.Size;

	mov	rax, QWORD PTR ch$5[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR new_cmd_buffer_count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR new_cmd_buffer_count$[rsp], eax

; 574  :         new_idx_buffer_count += ch.IdxBuffer.Size;

	mov	rax, QWORD PTR ch$5[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR new_idx_buffer_count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR new_idx_buffer_count$[rsp], eax

; 575  :     }

	jmp	$LN2@ChannelsMe
$LN3@ChannelsMe:

; 576  :     CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	add	eax, DWORD PTR new_cmd_buffer_count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv142[rsp]
	call	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::resize

; 577  :     IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv150[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+40]
	add	eax, DWORD PTR new_idx_buffer_count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv150[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 578  : 
; 579  :     ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR new_cmd_buffer_count$[rsp]
	imul	rcx, rcx, 48				; 00000030H
	sub	rax, rcx
	mov	QWORD PTR cmd_write$[rsp], rax

; 580  :     _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	lea	rax, QWORD PTR [rcx+rax*2]
	movsxd	rcx, DWORD PTR new_idx_buffer_count$[rsp]
	shl	rcx, 1
	sub	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 581  :     for (int i = 1; i < _ChannelsCount; i++)

	mov	DWORD PTR i$2[rsp], 1
	jmp	SHORT $LN7@ChannelsMe
$LN5@ChannelsMe:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@ChannelsMe:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+100]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN6@ChannelsMe

; 582  :     {
; 583  :         ImDrawChannel& ch = _Channels[i];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv180[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR tv180[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	QWORD PTR ch$6[rsp], rax

; 584  :         if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }

	mov	rax, QWORD PTR ch$6[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR sz$3[rsp], eax
	cmp	DWORD PTR sz$3[rsp], 0
	je	SHORT $LN11@ChannelsMe
	movsxd	rax, DWORD PTR sz$3[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	r8, rax
	mov	rax, QWORD PTR ch$6[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR cmd_write$[rsp]
	call	memcpy
	movsxd	rax, DWORD PTR sz$3[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR cmd_write$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cmd_write$[rsp], rax
$LN11@ChannelsMe:

; 585  :         if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }

	mov	rax, QWORD PTR ch$6[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR sz$4[rsp], eax
	cmp	DWORD PTR sz$4[rsp], 0
	je	SHORT $LN12@ChannelsMe
	movsxd	rax, DWORD PTR sz$4[rsp]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR ch$6[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+88]
	call	memcpy
	movsxd	rax, DWORD PTR sz$4[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax
$LN12@ChannelsMe:

; 586  :     }

	jmp	$LN5@ChannelsMe
$LN6@ChannelsMe:

; 587  :     UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.

	mov	rcx, QWORD PTR this$[rsp]
	call	?UpdateClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::UpdateClipRect

; 588  :     _ChannelsCount = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+100], 1
$LN1@ChannelsMe:

; 589  : }

	add	rsp, 120				; 00000078H
	ret	0
?ChannelsMerge@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::ChannelsMerge
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
$T2 = 36
old_channels_count$ = 40
$T3 = 48
tv135 = 56
tv71 = 64
tv81 = 72
tv93 = 80
$T4 = 88
$T5 = 96
tv146 = 104
tv151 = 112
tv157 = 120
tv162 = 128
tv168 = 136
tv185 = 144
tv190 = 152
$T6 = 160
draw_cmd$7 = 168
this$ = 256
channels_count$ = 264
?ChannelsSplit@ImDrawList@@QEAAXH@Z PROC		; ImDrawList::ChannelsSplit

; 525  : {

$LN13:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 526  :     IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);
; 527  :     int old_channels_count = _Channels.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+104]
	mov	DWORD PTR old_channels_count$[rsp], eax

; 528  :     if (old_channels_count < channels_count)

	mov	eax, DWORD PTR channels_count$[rsp]
	cmp	DWORD PTR old_channels_count$[rsp], eax
	jge	SHORT $LN5@ChannelsSp

; 529  :         _Channels.resize(channels_count);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv71[rsp], rax
	mov	edx, DWORD PTR channels_count$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::resize
	npad	1
$LN5@ChannelsSp:

; 530  :     _ChannelsCount = channels_count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR channels_count$[rsp]
	mov	DWORD PTR [rax+100], ecx

; 531  : 
; 532  :     // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer
; 533  :     // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
; 534  :     // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer
; 535  :     memset(&_Channels[0], 0, sizeof(ImDrawChannel));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv81[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv81[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 536  :     for (int i = 1; i < channels_count; i++)

	mov	DWORD PTR i$1[rsp], 1
	jmp	SHORT $LN4@ChannelsSp
$LN2@ChannelsSp:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ChannelsSp:
	mov	eax, DWORD PTR channels_count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@ChannelsSp

; 537  :     {
; 538  :         if (i >= old_channels_count)

	mov	eax, DWORD PTR old_channels_count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jl	$LN6@ChannelsSp

; 539  :         {
; 540  :             IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv93[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv93[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	QWORD PTR $T4[rsp], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	r8, QWORD PTR $T4[rsp]
	mov	rax, QWORD PTR $T5[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T3[rsp], rax
	cmp	QWORD PTR $T3[rsp], 0
	je	SHORT $LN10@ChannelsSp
	mov	rdi, QWORD PTR $T3[rsp]
	xor	eax, eax
	mov	ecx, 32					; 00000020H
	rep stosb
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0ImDrawChannel@@QEAA@XZ
	mov	QWORD PTR tv135[rsp], rax
	jmp	SHORT $LN11@ChannelsSp
$LN10@ChannelsSp:
	mov	QWORD PTR tv135[rsp], 0
$LN11@ChannelsSp:
	mov	rax, QWORD PTR tv135[rsp]
	mov	QWORD PTR $T6[rsp], rax

; 541  :         }

	jmp	SHORT $LN7@ChannelsSp
$LN6@ChannelsSp:

; 542  :         else
; 543  :         {
; 544  :             _Channels[i].CmdBuffer.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv146[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv146[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	QWORD PTR tv151[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv151[rsp]
	call	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::resize

; 545  :             _Channels[i].IdxBuffer.resize(0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv157[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv157[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	add	rax, 16
	mov	QWORD PTR tv162[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv162[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
	npad	1
$LN7@ChannelsSp:

; 546  :         }
; 547  :         if (_Channels[i].CmdBuffer.Size == 0)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv168[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv168[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	cmp	DWORD PTR [rax], 0
	jne	$LN8@ChannelsSp

; 548  :         {
; 549  :             ImDrawCmd draw_cmd;

	lea	rcx, QWORD PTR draw_cmd$7[rsp]
	call	??0ImDrawCmd@@QEAA@XZ			; ImDrawCmd::ImDrawCmd

; 550  :             draw_cmd.ClipRect = _ClipRectStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ; ImVector<ImVec4>::back
	lea	rcx, QWORD PTR draw_cmd$7[rsp+12]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 551  :             draw_cmd.TextureId = _TextureIdStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ	; ImVector<void *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR draw_cmd$7[rsp], rax

; 552  :             _Channels[i].CmdBuffer.push_back(draw_cmd);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv185[rsp], rax
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
	mov	QWORD PTR tv190[rsp], rax
	lea	rdx, QWORD PTR draw_cmd$7[rsp]
	mov	rcx, QWORD PTR tv190[rsp]
	call	?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
	npad	1
$LN8@ChannelsSp:

; 553  :         }
; 554  :     }

	jmp	$LN2@ChannelsSp
$LN3@ChannelsSp:

; 555  : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?ChannelsSplit@ImDrawList@@QEAAXH@Z ENDP		; ImDrawList::ChannelsSplit
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
$T2 = 36
old_channels_count$ = 40
$T3 = 48
tv135 = 56
tv71 = 64
tv81 = 72
tv93 = 80
$T4 = 88
$T5 = 96
tv146 = 104
tv151 = 112
tv157 = 120
tv162 = 128
tv168 = 136
tv185 = 144
tv190 = 152
$T6 = 160
draw_cmd$7 = 168
this$ = 256
channels_count$ = 264
?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA PROC	; `ImDrawList::ChannelsSplit'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T4[rbp]
	mov	rdx, QWORD PTR $T5[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ChannelsSplit@ImDrawList@@QEAAXH@Z@4HA ENDP	; `ImDrawList::ChannelsSplit'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
rounding_tl$1 = 48
rounding_tr$2 = 52
rounding_br$3 = 56
rounding_bl$4 = 60
tv74 = 64
tv89 = 68
tv150 = 72
tv153 = 76
tv156 = 80
tv159 = 84
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
$T10 = 128
this$ = 160
a$ = 168
b$ = 176
rounding$ = 184
rounding_corners$ = 192
?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z PROC	; ImDrawList::PathRect

; 1023 : {

$LN18:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 1024 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((rounding_corners & ImDrawCornerFlags_Top) == ImDrawCornerFlags_Top) || ((rounding_corners & ImDrawCornerFlags_Bot) == ImDrawCornerFlags_Bot) ? 0.5f : 1.0f) - 1.0f);

	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 3
	cmp	eax, 3
	je	SHORT $LN6@PathRect
	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 12
	cmp	eax, 12
	je	SHORT $LN6@PathRect
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN7@PathRect
$LN6@PathRect:
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv74[rsp], xmm0
$LN7@PathRect:
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	call	?ImFabs@@YAMM@Z				; ImFabs
	mulss	xmm0, DWORD PTR tv74[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR rounding$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR rounding$[rsp], xmm0

; 1025 :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f) - 1.0f);

	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 5
	cmp	eax, 5
	je	SHORT $LN8@PathRect
	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 10
	cmp	eax, 10
	je	SHORT $LN8@PathRect
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv89[rsp], xmm0
	jmp	SHORT $LN9@PathRect
$LN8@PathRect:
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv89[rsp], xmm0
$LN9@PathRect:
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	call	?ImFabs@@YAMM@Z				; ImFabs
	mulss	xmm0, DWORD PTR tv89[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR rounding$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR rounding$[rsp], xmm0

; 1026 : 
; 1027 :     if (rounding <= 0.0f || rounding_corners == 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR rounding$[rsp]
	jae	SHORT $LN4@PathRect
	cmp	DWORD PTR rounding_corners$[rsp], 0
	jne	$LN2@PathRect
$LN4@PathRect:

; 1028 :     {
; 1029 :         PathLineTo(a);

	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1030 :         PathLineTo(ImVec2(b.x, a.y));

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1031 :         PathLineTo(b);

	mov	rdx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1032 :         PathLineTo(ImVec2(a.x, b.y));

	mov	rax, QWORD PTR b$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1033 :     }

	jmp	$LN3@PathRect
$LN2@PathRect:

; 1034 :     else
; 1035 :     {
; 1036 :         const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;

	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@PathRect
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR tv150[rsp], xmm0
	jmp	SHORT $LN11@PathRect
$LN10@PathRect:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv150[rsp], xmm0
$LN11@PathRect:
	movss	xmm0, DWORD PTR tv150[rsp]
	movss	DWORD PTR rounding_tl$1[rsp], xmm0

; 1037 :         const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;

	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN12@PathRect
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR tv153[rsp], xmm0
	jmp	SHORT $LN13@PathRect
$LN12@PathRect:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv153[rsp], xmm0
$LN13@PathRect:
	movss	xmm0, DWORD PTR tv153[rsp]
	movss	DWORD PTR rounding_tr$2[rsp], xmm0

; 1038 :         const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;

	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN14@PathRect
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR tv156[rsp], xmm0
	jmp	SHORT $LN15@PathRect
$LN14@PathRect:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv156[rsp], xmm0
$LN15@PathRect:
	movss	xmm0, DWORD PTR tv156[rsp]
	movss	DWORD PTR rounding_br$3[rsp], xmm0

; 1039 :         const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;

	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN16@PathRect
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR tv159[rsp], xmm0
	jmp	SHORT $LN17@PathRect
$LN16@PathRect:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv159[rsp], xmm0
$LN17@PathRect:
	movss	xmm0, DWORD PTR tv159[rsp]
	movss	DWORD PTR rounding_bl$4[rsp], xmm0

; 1040 :         PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR rounding_tl$1[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR rounding_tl$1[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 9
	mov	r9d, 6
	movss	xmm2, DWORD PTR rounding_tl$1[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 1041 :         PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR rounding_tr$2[rsp]
	mov	rax, QWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR rounding_tr$2[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, 9
	movss	xmm2, DWORD PTR rounding_tr$2[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 1042 :         PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);

	mov	rax, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR rounding_br$3[rsp]
	mov	rax, QWORD PTR b$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR rounding_br$3[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	movss	xmm2, DWORD PTR rounding_br$3[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 1043 :         PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);

	mov	rax, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR rounding_bl$4[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR rounding_bl$4[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 6
	mov	r9d, 3
	movss	xmm2, DWORD PTR rounding_bl$4[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1
$LN3@PathRect:

; 1044 :     }
; 1045 : }

	add	rsp, 152				; 00000098H
	ret	0
?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ENDP	; ImDrawList::PathRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
t$1 = 96
u$2 = 100
i_step$3 = 104
w1$4 = 108
w2$5 = 112
w3$6 = 116
w4$7 = 120
p1$ = 128
t_step$8 = 136
tv166 = 144
$T9 = 152
this$ = 176
p2$ = 184
p3$ = 192
p4$ = 200
num_segments$ = 208
?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z PROC ; ImDrawList::PathBezierCurveTo

; 999  : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1000 :     ImVec2 p1 = _Path.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	?back@?$ImVector@UImVec2@@@@QEAAAEAUImVec2@@XZ ; ImVector<ImVec2>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p1$[rsp], rax

; 1001 :     if (num_segments == 0)

	cmp	DWORD PTR num_segments$[rsp], 0
	jne	$LN5@PathBezier

; 1002 :     {
; 1003 :         // Auto-tessellated
; 1004 :         PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 152				; 00000098H
	mov	DWORD PTR [rsp+80], 0
	movss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR [rsp+72], xmm0
	mov	rax, QWORD PTR p4$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR p4$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR p3$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR p3$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR p2$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR p2$[rsp]
	movss	xmm3, DWORD PTR [rax]
	movss	xmm2, DWORD PTR p1$[rsp+4]
	movss	xmm1, DWORD PTR p1$[rsp]
	call	?PathBezierToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
	npad	1

; 1005 :     }

	jmp	$LN6@PathBezier
$LN5@PathBezier:

; 1006 :     else
; 1007 :     {
; 1008 :         float t_step = 1.0f / (float)num_segments;

	cvtsi2ss xmm0, DWORD PTR num_segments$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR t_step$8[rsp], xmm0

; 1009 :         for (int i_step = 1; i_step <= num_segments; i_step++)

	mov	DWORD PTR i_step$3[rsp], 1
	jmp	SHORT $LN4@PathBezier
$LN2@PathBezier:
	mov	eax, DWORD PTR i_step$3[rsp]
	inc	eax
	mov	DWORD PTR i_step$3[rsp], eax
$LN4@PathBezier:
	mov	eax, DWORD PTR num_segments$[rsp]
	cmp	DWORD PTR i_step$3[rsp], eax
	jg	$LN3@PathBezier

; 1010 :         {
; 1011 :             float t = t_step * i_step;

	cvtsi2ss xmm0, DWORD PTR i_step$3[rsp]
	movss	xmm1, DWORD PTR t_step$8[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR t$1[rsp], xmm0

; 1012 :             float u = 1.0f - t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR t$1[rsp]
	movss	DWORD PTR u$2[rsp], xmm0

; 1013 :             float w1 = u * u * u;

	movss	xmm0, DWORD PTR u$2[rsp]
	mulss	xmm0, DWORD PTR u$2[rsp]
	mulss	xmm0, DWORD PTR u$2[rsp]
	movss	DWORD PTR w1$4[rsp], xmm0

; 1014 :             float w2 = 3 * u * u * t;

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR u$2[rsp]
	mulss	xmm0, DWORD PTR u$2[rsp]
	mulss	xmm0, DWORD PTR t$1[rsp]
	movss	DWORD PTR w2$5[rsp], xmm0

; 1015 :             float w3 = 3 * u * t * t;

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR u$2[rsp]
	mulss	xmm0, DWORD PTR t$1[rsp]
	mulss	xmm0, DWORD PTR t$1[rsp]
	movss	DWORD PTR w3$6[rsp], xmm0

; 1016 :             float w4 = t * t * t;

	movss	xmm0, DWORD PTR t$1[rsp]
	mulss	xmm0, DWORD PTR t$1[rsp]
	mulss	xmm0, DWORD PTR t$1[rsp]
	movss	DWORD PTR w4$7[rsp], xmm0

; 1017 :             _Path.push_back(ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv166[rsp], rax
	movss	xmm0, DWORD PTR w1$4[rsp]
	mulss	xmm0, DWORD PTR p1$[rsp+4]
	mov	rax, QWORD PTR p2$[rsp]
	movss	xmm1, DWORD PTR w2$5[rsp]
	mulss	xmm1, DWORD PTR [rax+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR p3$[rsp]
	movss	xmm1, DWORD PTR w3$6[rsp]
	mulss	xmm1, DWORD PTR [rax+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR p4$[rsp]
	movss	xmm1, DWORD PTR w4$7[rsp]
	mulss	xmm1, DWORD PTR [rax+4]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR w1$4[rsp]
	mulss	xmm1, DWORD PTR p1$[rsp]
	mov	rax, QWORD PTR p2$[rsp]
	movss	xmm2, DWORD PTR w2$5[rsp]
	mulss	xmm2, DWORD PTR [rax]
	addss	xmm1, xmm2
	mov	rax, QWORD PTR p3$[rsp]
	movss	xmm2, DWORD PTR w3$6[rsp]
	mulss	xmm2, DWORD PTR [rax]
	addss	xmm1, xmm2
	mov	rax, QWORD PTR p4$[rsp]
	movss	xmm2, DWORD PTR w4$7[rsp]
	mulss	xmm2, DWORD PTR [rax]
	addss	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR tv166[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1

; 1018 :         }

	jmp	$LN2@PathBezier
$LN3@PathBezier:
$LN6@PathBezier:

; 1019 :     }
; 1020 : }

	add	rsp, 168				; 000000a8H
	ret	0
?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ENDP ; ImDrawList::PathBezierCurveTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
a$1 = 32
c$2 = 40
tv70 = 48
tv80 = 56
tv138 = 64
tv137 = 72
$T3 = 80
this$ = 112
centre$ = 120
radius$ = 128
a_min_of_12$ = 136
a_max_of_12$ = 144
?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z PROC	; ImDrawList::PathArcToFast

; 940  : {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 941  :     if (radius == 0.0f || a_min_of_12 > a_max_of_12)

	movss	xmm0, DWORD PTR radius$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN8@PathArcToF
	je	SHORT $LN6@PathArcToF
$LN8@PathArcToF:
	mov	eax, DWORD PTR a_max_of_12$[rsp]
	cmp	DWORD PTR a_min_of_12$[rsp], eax
	jle	SHORT $LN5@PathArcToF
$LN6@PathArcToF:

; 942  :     {
; 943  :         _Path.push_back(centre);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR centre$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1

; 944  :         return;

	jmp	$LN1@PathArcToF
$LN5@PathArcToF:

; 945  :     }
; 946  :     _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv80[rsp], rax
	mov	eax, DWORD PTR a_min_of_12$[rsp]
	mov	ecx, DWORD PTR a_max_of_12$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+152]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	edx, eax
	mov	rcx, QWORD PTR tv80[rsp]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	npad	1

; 947  :     for (int a = a_min_of_12; a <= a_max_of_12; a++)

	mov	eax, DWORD PTR a_min_of_12$[rsp]
	mov	DWORD PTR a$1[rsp], eax
	jmp	SHORT $LN4@PathArcToF
$LN2@PathArcToF:
	mov	eax, DWORD PTR a$1[rsp]
	inc	eax
	mov	DWORD PTR a$1[rsp], eax
$LN4@PathArcToF:
	mov	eax, DWORD PTR a_max_of_12$[rsp]
	cmp	DWORD PTR a$1[rsp], eax
	jg	$LN3@PathArcToF

; 948  :     {
; 949  :         const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR tv138[rsp], rax
	mov	eax, DWORD PTR a$1[rsp]
	cdq
	mov	ecx, 12
	idiv	ecx
	mov	eax, edx
	cdqe
	mov	rcx, QWORD PTR tv138[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+40]
	mov	QWORD PTR c$2[rsp], rax

; 950  :         _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR c$2[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR radius$[rsp]
	mov	rax, QWORD PTR centre$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR c$2[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR radius$[rsp]
	mov	rax, QWORD PTR centre$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR tv137[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1

; 951  :     }

	jmp	$LN2@PathArcToF
$LN3@PathArcToF:
$LN1@PathArcToF:

; 952  : }

	add	rsp, 104				; 00000068H
	ret	0
?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ENDP	; ImDrawList::PathArcToFast
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$1 = 32
a$2 = 36
tv138 = 40
tv136 = 44
tv69 = 48
tv78 = 56
tv141 = 64
$T3 = 72
this$ = 96
centre$ = 104
radius$ = 112
a_min$ = 120
a_max$ = 128
num_segments$ = 136
?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z PROC	; ImDrawList::PathArcTo

; 955  : {

$LN7:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 956  :     if (radius == 0.0f)

	movss	xmm0, DWORD PTR radius$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN5@PathArcTo
	jne	SHORT $LN5@PathArcTo

; 957  :     {
; 958  :         _Path.push_back(centre);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR centre$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1

; 959  :         return;

	jmp	$LN1@PathArcTo
$LN5@PathArcTo:

; 960  :     }
; 961  : 
; 962  :     // Note that we are adding a point at both a_min and a_max.
; 963  :     // If you are trying to draw a full closed circle you don't want the overlapping points!
; 964  :     _Path.reserve(_Path.Size + (num_segments + 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+152]
	mov	ecx, DWORD PTR num_segments$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	edx, eax
	mov	rcx, QWORD PTR tv78[rsp]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	npad	1

; 965  :     for (int i = 0; i <= num_segments; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@PathArcTo
$LN2@PathArcTo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@PathArcTo:
	mov	eax, DWORD PTR num_segments$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jg	$LN3@PathArcTo

; 966  :     {
; 967  :         const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);

	cvtsi2ss xmm0, DWORD PTR i$1[rsp]
	cvtsi2ss xmm1, DWORD PTR num_segments$[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR a_max$[rsp]
	subss	xmm1, DWORD PTR a_min$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR a_min$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$2[rsp], xmm0

; 968  :         _Path.push_back(ImVec2(centre.x + ImCos(a) * radius, centre.y + ImSin(a) * radius));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv141[rsp], rax
	movss	xmm0, DWORD PTR a$2[rsp]
	call	?ImSin@@YAMM@Z				; ImSin
	mulss	xmm0, DWORD PTR radius$[rsp]
	mov	rax, QWORD PTR centre$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv138[rsp], xmm0
	movss	xmm0, DWORD PTR a$2[rsp]
	call	?ImCos@@YAMM@Z				; ImCos
	mulss	xmm0, DWORD PTR radius$[rsp]
	mov	rax, QWORD PTR centre$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv136[rsp], xmm0
	movss	xmm2, DWORD PTR tv138[rsp]
	movss	xmm1, DWORD PTR tv136[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR tv141[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1

; 969  :     }

	jmp	$LN2@PathArcTo
$LN3@PathArcTo:
$LN1@PathArcTo:

; 970  : }

	add	rsp, 88					; 00000058H
	ret	0
?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ENDP	; ImDrawList::PathArcTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QEAAXI_NM@Z
_TEXT	SEGMENT
this$ = 64
col$ = 72
closed$ = 80
thickness$ = 88
?PathStroke@ImDrawList@@QEAAXI_NM@Z PROC		; ImDrawList::PathStroke, COMDAT

; 1894 : 	inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movss	xmm0, DWORD PTR thickness$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movzx	eax, BYTE PTR closed$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR col$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rax+152]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+160]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	add	rsp, 56					; 00000038H
	ret	0
?PathStroke@ImDrawList@@QEAAXI_NM@Z ENDP		; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathFillConvex@ImDrawList@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 48
col$ = 56
?PathFillConvex@ImDrawList@@QEAAXI@Z PROC		; ImDrawList::PathFillConvex, COMDAT

; 1893 : 	inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9d, DWORD PTR col$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rax+152]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+160]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	add	rsp, 40					; 00000028H
	ret	0
?PathFillConvex@ImDrawList@@QEAAXI@Z ENDP		; ImDrawList::PathFillConvex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
tv68 = 32
this$ = 64
pos$ = 72
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z PROC	; ImDrawList::PathLineTo, COMDAT

; 1891 : 	inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv68[rsp], rax
	mov	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ENDP	; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
cpu_fine_clip_rect$ = 0
text_size$ = 8
drawList$ = 16
tv185 = 24
tv208 = 28
tv231 = 32
tv254 = 36
va_alist$ = 40
tv154 = 48
tv155 = 56
tv183 = 64
tv206 = 72
tv229 = 80
tv252 = 88
$T1 = 96
$T2 = 104
$T3 = 112
$T4 = 120
$T5 = 128
$T6 = 136
$T7 = 144
$T8 = 152
buf$ = 160
__$ArrayPad$ = 1184
this$ = 1216
__$ReturnUdt$ = 1224
font$ = 1232
fontSize$ = 1240
clip_w$ = 1248
pos$ = 1256
col$ = 1264
outlineCol$ = 1272
alignment$ = 1280
text$ = 1288
?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ PROC ; ImDrawList::DrawTextOutline

; 1365 : {

$LN14:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 1280				; 00000500H
	lea	rbp, QWORD PTR [rsp+80]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 1366 :     auto drawList = ImGui::GetOverlayDrawList();

	call	?GetOverlayDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetOverlayDrawList
	mov	QWORD PTR drawList$[rbp], rax

; 1367 : 
; 1368 :     va_list va_alist;
; 1369 :     char buf[1024];
; 1370 :     va_start(va_alist, text);

	lea	rax, QWORD PTR text$[rbp+8]
	mov	QWORD PTR va_alist$[rbp], rax

; 1371 :     _vsnprintf_s(buf, sizeof(buf), text, va_alist);

	mov	r9, QWORD PTR va_alist$[rbp]
	mov	r8, QWORD PTR text$[rbp]
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rbp]
	call	??$_vsnprintf_s@$0EAA@@@YAHAEAY0EAA@D_KPEBDPEAD@Z ; _vsnprintf_s<1024>

; 1372 :     va_end(va_alist);

	mov	QWORD PTR va_alist$[rbp], 0

; 1373 : 
; 1374 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1375 :     if (font == NULL)

	cmp	QWORD PTR font$[rbp], 0
	jne	SHORT $LN2@DrawTextOu

; 1376 :         font = drawList->_Data->Font;

	mov	rax, QWORD PTR drawList$[rbp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR font$[rbp], rax
$LN2@DrawTextOu:

; 1377 :     if (fontSize == 0.0f)

	movss	xmm0, DWORD PTR fontSize$[rbp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@DrawTextOu
	jne	SHORT $LN3@DrawTextOu

; 1378 :         fontSize = font->FontSize;

	mov	rax, QWORD PTR font$[rbp]
	movss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR fontSize$[rbp], xmm0
$LN3@DrawTextOu:

; 1379 : 
; 1380 : 
; 1381 :     ImVec2 text_size = font->CalcTextSizeA(fontSize, FLT_MAX, -1.0f, buf, nullptr, NULL);

	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], 0
	lea	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@7f7fffff
	movss	xmm2, DWORD PTR fontSize$[rbp]
	lea	rdx, QWORD PTR text_size$[rbp]
	mov	rcx, QWORD PTR font$[rbp]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 1382 :     // Round
; 1383 :     text_size.x = (float)(int)(text_size.x + 0.95f);

	movss	xmm0, DWORD PTR text_size$[rbp]
	addss	xmm0, DWORD PTR __real@3f733333
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR text_size$[rbp], xmm0

; 1384 : 
; 1385 :     if (alignment & 1)

	mov	eax, DWORD PTR alignment$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@DrawTextOu

; 1386 :         pos.x -= text_size.x;

	movss	xmm0, DWORD PTR pos$[rbp]
	subss	xmm0, DWORD PTR text_size$[rbp]
	movss	DWORD PTR pos$[rbp], xmm0
$LN4@DrawTextOu:

; 1387 :     if (alignment & 2)

	mov	eax, DWORD PTR alignment$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN5@DrawTextOu

; 1388 :         pos.x -= text_size.x / 2;

	movss	xmm0, DWORD PTR text_size$[rbp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR pos$[rbp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$[rbp], xmm0
$LN5@DrawTextOu:

; 1389 : 
; 1390 :     pos.y -= text_size.y / 2;

	movss	xmm0, DWORD PTR text_size$[rbp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR pos$[rbp+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$[rbp+4], xmm0

; 1391 :     ImVec4* cpu_fine_clip_rect = nullptr;

	mov	QWORD PTR cpu_fine_clip_rect$[rbp], 0

; 1392 :     if (clip_w > 0)

	movss	xmm0, DWORD PTR clip_w$[rbp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN6@DrawTextOu

; 1393 :     {
; 1394 :         cpu_fine_clip_rect = reinterpret_cast<ImVec4*>(_malloca(sizeof(ImVec4)));

	mov	ecx, 16
	call	_MallocaComputeSize
	test	rax, rax
	je	$LN11@DrawTextOu
	mov	ecx, 16
	call	_MallocaComputeSize
	cmp	rax, 1024				; 00000400H
	ja	SHORT $LN9@DrawTextOu
	mov	ecx, 16
	call	_MallocaComputeSize
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN13@DrawTextOu
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN13@DrawTextOu:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+80]
	mov	edx, 52428				; 0000ccccH
	mov	rcx, rax
	call	_MarkAllocaS
	mov	QWORD PTR tv154[rbp], rax
	jmp	SHORT $LN10@DrawTextOu
$LN9@DrawTextOu:
	mov	ecx, 16
	call	_MallocaComputeSize
	mov	rcx, rax
	call	malloc
	mov	edx, 56797				; 0000ddddH
	mov	rcx, rax
	call	_MarkAllocaS
	mov	QWORD PTR tv154[rbp], rax
$LN10@DrawTextOu:
	mov	rax, QWORD PTR tv154[rbp]
	mov	QWORD PTR tv155[rbp], rax
	jmp	SHORT $LN12@DrawTextOu
$LN11@DrawTextOu:
	mov	QWORD PTR tv155[rbp], 0
$LN12@DrawTextOu:
	mov	rax, QWORD PTR tv155[rbp]
	mov	QWORD PTR cpu_fine_clip_rect$[rbp], rax

; 1395 :         cpu_fine_clip_rect->x = 0;

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0

; 1396 :         cpu_fine_clip_rect->y = 0;

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 1397 :         cpu_fine_clip_rect->z = pos.x + clip_w;

	movss	xmm0, DWORD PTR pos$[rbp]
	addss	xmm0, DWORD PTR clip_w$[rbp]
	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	movss	DWORD PTR [rax+8], xmm0

; 1398 :         cpu_fine_clip_rect->w = pos.y + text_size.y;

	movss	xmm0, DWORD PTR pos$[rbp+4]
	addss	xmm0, DWORD PTR text_size$[rbp+4]
	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	movss	DWORD PTR [rax+12], xmm0
$LN6@DrawTextOu:

; 1399 :     }
; 1400 :     if (outlineCol != 0)

	cmp	DWORD PTR outlineCol$[rbp], 0
	je	$LN7@DrawTextOu

; 1401 :     {
; 1402 :         drawList->AddText(font, fontSize, pos - ImVec2(1.0f, 0.0f), ImGui::GetColorU32(outlineCol), buf, nullptr, 0, cpu_fine_clip_rect);

	mov	ecx, DWORD PTR outlineCol$[rbp]
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv185[rbp], eax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rbp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rbp]
	lea	rcx, QWORD PTR $T2[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv183[rbp], rax
	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	mov	QWORD PTR [rsp+64], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], 0
	lea	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv185[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv183[rbp]
	movss	xmm2, DWORD PTR fontSize$[rbp]
	mov	rdx, QWORD PTR font$[rbp]
	mov	rcx, QWORD PTR drawList$[rbp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1403 :         drawList->AddText(font, fontSize, pos - ImVec2(0.0f, 1.0f), ImGui::GetColorU32(outlineCol), buf, nullptr, 0, cpu_fine_clip_rect);

	mov	ecx, DWORD PTR outlineCol$[rbp]
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv208[rbp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rbp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rbp]
	lea	rcx, QWORD PTR $T4[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv206[rbp], rax
	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	mov	QWORD PTR [rsp+64], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], 0
	lea	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv208[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv206[rbp]
	movss	xmm2, DWORD PTR fontSize$[rbp]
	mov	rdx, QWORD PTR font$[rbp]
	mov	rcx, QWORD PTR drawList$[rbp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1404 :         drawList->AddText(font, fontSize, pos + ImVec2(1.0f, 0.0f), ImGui::GetColorU32(outlineCol), buf, nullptr, 0, cpu_fine_clip_rect);

	mov	ecx, DWORD PTR outlineCol$[rbp]
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv231[rbp], eax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T5[rbp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rbp]
	lea	rcx, QWORD PTR $T6[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv229[rbp], rax
	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	mov	QWORD PTR [rsp+64], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], 0
	lea	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv231[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv229[rbp]
	movss	xmm2, DWORD PTR fontSize$[rbp]
	mov	rdx, QWORD PTR font$[rbp]
	mov	rcx, QWORD PTR drawList$[rbp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1405 :         drawList->AddText(font, fontSize, pos + ImVec2(0.0f, 1.0f), ImGui::GetColorU32(outlineCol), buf, nullptr, 0, cpu_fine_clip_rect);

	mov	ecx, DWORD PTR outlineCol$[rbp]
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv254[rbp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rbp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rbp]
	lea	rcx, QWORD PTR $T8[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv252[rbp], rax
	mov	rax, QWORD PTR cpu_fine_clip_rect$[rbp]
	mov	QWORD PTR [rsp+64], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], 0
	lea	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv254[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv252[rbp]
	movss	xmm2, DWORD PTR fontSize$[rbp]
	mov	rdx, QWORD PTR font$[rbp]
	mov	rcx, QWORD PTR drawList$[rbp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN7@DrawTextOu:

; 1406 :     }
; 1407 :     drawList->AddText(font, fontSize, pos, ImGui::GetColorU32(col), buf, nullptr, 0, cpu_fine_clip_rect);

	mov	ecx, DWORD PTR col$[rbp]
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	rcx, QWORD PTR cpu_fine_clip_rect$[rbp]
	mov	QWORD PTR [rsp+64], rcx
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], 0
	lea	rcx, QWORD PTR buf$[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rbp]
	movss	xmm2, DWORD PTR fontSize$[rbp]
	mov	rdx, QWORD PTR font$[rbp]
	mov	rcx, QWORD PTR drawList$[rbp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText

; 1408 :     return text_size;

	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	mov	rcx, QWORD PTR text_size$[rbp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1409 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+1200]
	pop	rbp
	ret	0
?DrawTextOutline@ImDrawList@@QEAA?AUImVec2@@PEBUImFont@@MMU2@IIKPEBDZZ ENDP ; ImDrawList::DrawTextOutline
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
pos0$ = 72
cp0$ = 80
cp1$ = 88
pos1$ = 96
col$ = 104
thickness$ = 112
num_segments$ = 120
?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z PROC ; ImDrawList::AddBezierCurve

; 1264 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1265 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddBezierC

; 1266 :         return;

	jmp	SHORT $LN1@AddBezierC
$LN2@AddBezierC:

; 1267 : 
; 1268 :     PathLineTo(pos0);

	mov	rdx, QWORD PTR pos0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1269 :     PathBezierCurveTo(cp0, cp1, pos1, num_segments);

	mov	eax, DWORD PTR num_segments$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR pos1$[rsp]
	mov	r8, QWORD PTR cp1$[rsp]
	mov	rdx, QWORD PTR cp0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ; ImDrawList::PathBezierCurveTo

; 1270 :     PathStroke(col, false, thickness);

	movss	xmm3, DWORD PTR thickness$[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN1@AddBezierC:

; 1271 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z ENDP ; ImDrawList::AddBezierCurve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i1$1 = 0
dm_x$2 = 4
dm_y$3 = 8
vtx_inner_idx$4 = 12
i$5 = 16
i1$6 = 20
dy$7 = 24
dx$8 = 28
i0$9 = 32
i$10 = 36
i0$11 = 40
inv_len$12 = 44
i$13 = 48
vtx_outer_idx$14 = 52
vtx_count$15 = 56
d2$16 = 60
inv_len$17 = 64
d2$18 = 68
vtx_count$19 = 72
temp_normals$20 = 80
idx_count$21 = 88
tv143 = 92
tv178 = 96
col_trans$22 = 100
idx_count$23 = 104
uv$ = 112
p1$24 = 120
p0$25 = 128
n0$26 = 136
n1$27 = 144
AA_SIZE$28 = 152
__$ArrayPad$ = 160
this$ = 192
points$ = 200
points_count$ = 208
col$ = 216
?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z PROC ; ImDrawList::AddConvexPolyFilled

; 859  : {

$LN25:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 860  :     if (points_count < 3)

	cmp	DWORD PTR points_count$[rbp], 3
	jge	SHORT $LN17@AddConvexP

; 861  :         return;

	jmp	$LN1@AddConvexP
$LN17@AddConvexP:

; 862  : 
; 863  :     const ImVec2 uv = _Data->TexUvWhitePixel;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR uv$[rbp], rax

; 864  : 
; 865  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 2
	test	eax, eax
	je	$LN18@AddConvexP

; 866  :     {
; 867  :         // Anti-aliased Fill
; 868  :         const float AA_SIZE = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR AA_SIZE$28[rbp], xmm0

; 869  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

	mov	eax, DWORD PTR col$[rbp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_trans$22[rbp], eax

; 870  :         const int idx_count = (points_count - 2) * 3 + points_count * 6;

	mov	eax, DWORD PTR points_count$[rbp]
	sub	eax, 2
	imul	eax, eax, 3
	imul	ecx, DWORD PTR points_count$[rbp], 6
	add	eax, ecx
	mov	DWORD PTR idx_count$21[rbp], eax

; 871  :         const int vtx_count = (points_count * 2);

	mov	eax, DWORD PTR points_count$[rbp]
	shl	eax, 1
	mov	DWORD PTR vtx_count$19[rbp], eax

; 872  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, DWORD PTR vtx_count$19[rbp]
	mov	edx, DWORD PTR idx_count$21[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 873  : 
; 874  :         // Add indexes for fill
; 875  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR vtx_inner_idx$4[rbp], eax

; 876  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	DWORD PTR vtx_outer_idx$14[rbp], eax

; 877  :         for (int i = 2; i < points_count; i++)

	mov	DWORD PTR i$5[rbp], 2
	jmp	SHORT $LN4@AddConvexP
$LN2@AddConvexP:
	mov	eax, DWORD PTR i$5[rbp]
	inc	eax
	mov	DWORD PTR i$5[rbp], eax
$LN4@AddConvexP:
	mov	eax, DWORD PTR points_count$[rbp]
	cmp	DWORD PTR i$5[rbp], eax
	jge	SHORT $LN3@AddConvexP

; 878  :         {
; 879  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR vtx_inner_idx$4[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, DWORD PTR vtx_inner_idx$4[rbp]
	mov	ecx, DWORD PTR i$5[rbp]
	lea	eax, DWORD PTR [rax+rcx*2-2]
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR vtx_inner_idx$4[rbp]
	mov	ecx, DWORD PTR i$5[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 880  :             _IdxWritePtr += 3;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 6
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 881  :         }

	jmp	$LN2@AddConvexP
$LN3@AddConvexP:

; 882  : 
; 883  :         // Compute normals
; 884  :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630

	movsxd	rax, DWORD PTR points_count$[rbp]
	shl	rax, 3
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN24@AddConvexP
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN24@AddConvexP:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+32]
	mov	QWORD PTR temp_normals$20[rbp], rax

; 885  :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	mov	DWORD PTR i0$11[rbp], eax
	mov	DWORD PTR i1$6[rbp], 0
	jmp	SHORT $LN7@AddConvexP
$LN5@AddConvexP:
	mov	eax, DWORD PTR i1$6[rbp]
	mov	DWORD PTR tv143[rbp], eax
	mov	eax, DWORD PTR i1$6[rbp]
	inc	eax
	mov	DWORD PTR i1$6[rbp], eax
	mov	eax, DWORD PTR tv143[rbp]
	mov	DWORD PTR i0$11[rbp], eax
$LN7@AddConvexP:
	mov	eax, DWORD PTR points_count$[rbp]
	cmp	DWORD PTR i1$6[rbp], eax
	jge	$LN6@AddConvexP

; 886  :         {
; 887  :             const ImVec2& p0 = points[i0];

	movsxd	rax, DWORD PTR i0$11[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p0$25[rbp], rax

; 888  :             const ImVec2& p1 = points[i1];

	movsxd	rax, DWORD PTR i1$6[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p1$24[rbp], rax

; 889  :             float dx = p1.x - p0.x;

	mov	rax, QWORD PTR p1$24[rbp]
	mov	rcx, QWORD PTR p0$25[rbp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR dx$8[rbp], xmm0

; 890  :             float dy = p1.y - p0.y;

	mov	rax, QWORD PTR p1$24[rbp]
	mov	rcx, QWORD PTR p0$25[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR dy$7[rbp], xmm0

; 891  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movss	xmm0, DWORD PTR dx$8[rbp]
	mulss	xmm0, DWORD PTR dx$8[rbp]
	movss	xmm1, DWORD PTR dy$7[rbp]
	mulss	xmm1, DWORD PTR dy$7[rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR d2$16[rbp], xmm0
	movss	xmm0, DWORD PTR d2$16[rbp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN20@AddConvexP
	movss	xmm0, DWORD PTR d2$16[rbp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR inv_len$17[rbp], xmm0
	movss	xmm0, DWORD PTR dx$8[rbp]
	mulss	xmm0, DWORD PTR inv_len$17[rbp]
	movss	DWORD PTR dx$8[rbp], xmm0
	movss	xmm0, DWORD PTR dy$7[rbp]
	mulss	xmm0, DWORD PTR inv_len$17[rbp]
	movss	DWORD PTR dy$7[rbp], xmm0
$LN20@AddConvexP:

; 892  :             temp_normals[i0].x = dy;

	movsxd	rax, DWORD PTR i0$11[rbp]
	mov	rcx, QWORD PTR temp_normals$20[rbp]
	movss	xmm0, DWORD PTR dy$7[rbp]
	movss	DWORD PTR [rcx+rax*8], xmm0

; 893  :             temp_normals[i0].y = -dx;

	movss	xmm0, DWORD PTR dx$8[rbp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movsxd	rax, DWORD PTR i0$11[rbp]
	mov	rcx, QWORD PTR temp_normals$20[rbp]
	movss	DWORD PTR [rcx+rax*8+4], xmm0

; 894  :         }

	jmp	$LN5@AddConvexP
$LN6@AddConvexP:

; 895  : 
; 896  :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	mov	DWORD PTR i0$9[rbp], eax
	mov	DWORD PTR i1$1[rbp], 0
	jmp	SHORT $LN10@AddConvexP
$LN8@AddConvexP:
	mov	eax, DWORD PTR i1$1[rbp]
	mov	DWORD PTR tv178[rbp], eax
	mov	eax, DWORD PTR i1$1[rbp]
	inc	eax
	mov	DWORD PTR i1$1[rbp], eax
	mov	eax, DWORD PTR tv178[rbp]
	mov	DWORD PTR i0$9[rbp], eax
$LN10@AddConvexP:
	mov	eax, DWORD PTR points_count$[rbp]
	cmp	DWORD PTR i1$1[rbp], eax
	jge	$LN9@AddConvexP

; 897  :         {
; 898  :             // Average normals
; 899  :             const ImVec2& n0 = temp_normals[i0];

	movsxd	rax, DWORD PTR i0$9[rbp]
	mov	rcx, QWORD PTR temp_normals$20[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR n0$26[rbp], rax

; 900  :             const ImVec2& n1 = temp_normals[i1];

	movsxd	rax, DWORD PTR i1$1[rbp]
	mov	rcx, QWORD PTR temp_normals$20[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR n1$27[rbp], rax

; 901  :             float dm_x = (n0.x + n1.x) * 0.5f;

	mov	rax, QWORD PTR n0$26[rbp]
	mov	rcx, QWORD PTR n1$27[rbp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_x$2[rbp], xmm0

; 902  :             float dm_y = (n0.y + n1.y) * 0.5f;

	mov	rax, QWORD PTR n0$26[rbp]
	mov	rcx, QWORD PTR n1$27[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_y$3[rbp], xmm0

; 903  :             IM_NORMALIZE2F_OVER_EPSILON_CLAMP(dm_x, dm_y, 0.000001f, 100.0f);

	movss	xmm0, DWORD PTR dm_x$2[rbp]
	mulss	xmm0, DWORD PTR dm_x$2[rbp]
	movss	xmm1, DWORD PTR dm_y$3[rbp]
	mulss	xmm1, DWORD PTR dm_y$3[rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR d2$18[rbp], xmm0
	movss	xmm0, DWORD PTR d2$18[rbp]
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN21@AddConvexP
	movss	xmm0, DWORD PTR d2$18[rbp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR inv_len$12[rbp], xmm0
	movss	xmm0, DWORD PTR inv_len$12[rbp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN22@AddConvexP
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR inv_len$12[rbp], xmm0
$LN22@AddConvexP:
	movss	xmm0, DWORD PTR dm_x$2[rbp]
	mulss	xmm0, DWORD PTR inv_len$12[rbp]
	movss	DWORD PTR dm_x$2[rbp], xmm0
	movss	xmm0, DWORD PTR dm_y$3[rbp]
	mulss	xmm0, DWORD PTR inv_len$12[rbp]
	movss	DWORD PTR dm_y$3[rbp], xmm0
$LN21@AddConvexP:

; 904  :             dm_x *= AA_SIZE * 0.5f;

	movss	xmm0, DWORD PTR dm_x$2[rbp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_x$2[rbp], xmm0

; 905  :             dm_y *= AA_SIZE * 0.5f;

	movss	xmm0, DWORD PTR dm_y$3[rbp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_y$3[rbp], xmm0

; 906  : 
; 907  :             // Add vertices
; 908  :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movsxd	rax, DWORD PTR i1$1[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	subss	xmm0, DWORD PTR dm_x$2[rbp]
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax], xmm0
	movsxd	rax, DWORD PTR i1$1[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	subss	xmm0, DWORD PTR dm_y$3[rbp]
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 909  :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer

	movsxd	rax, DWORD PTR i1$1[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	addss	xmm0, DWORD PTR dm_x$2[rbp]
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax], xmm0
	movsxd	rax, DWORD PTR i1$1[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	addss	xmm0, DWORD PTR dm_y$3[rbp]
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col_trans$22[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 910  :             _VtxWritePtr += 2;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 911  : 
; 912  :             // Add indexes for fringes
; 913  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	mov	eax, DWORD PTR vtx_inner_idx$4[rbp]
	mov	ecx, DWORD PTR i1$1[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR vtx_inner_idx$4[rbp]
	mov	ecx, DWORD PTR i0$9[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR vtx_outer_idx$14[rbp]
	mov	ecx, DWORD PTR i0$9[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 914  :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	mov	eax, DWORD PTR vtx_outer_idx$14[rbp]
	mov	ecx, DWORD PTR i0$9[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR vtx_outer_idx$14[rbp]
	mov	ecx, DWORD PTR i1$1[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR vtx_inner_idx$4[rbp]
	mov	ecx, DWORD PTR i1$1[rbp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 915  :             _IdxWritePtr += 6;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 12
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 916  :         }

	jmp	$LN8@AddConvexP
$LN9@AddConvexP:

; 917  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$19[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	eax, DWORD PTR [rcx+64]
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+64], eax

; 918  :     }

	jmp	$LN19@AddConvexP
$LN18@AddConvexP:

; 919  :     else
; 920  :     {
; 921  :         // Non Anti-aliased Fill
; 922  :         const int idx_count = (points_count - 2) * 3;

	mov	eax, DWORD PTR points_count$[rbp]
	sub	eax, 2
	imul	eax, eax, 3
	mov	DWORD PTR idx_count$23[rbp], eax

; 923  :         const int vtx_count = points_count;

	mov	eax, DWORD PTR points_count$[rbp]
	mov	DWORD PTR vtx_count$15[rbp], eax

; 924  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, DWORD PTR vtx_count$15[rbp]
	mov	edx, DWORD PTR idx_count$23[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	npad	1

; 925  :         for (int i = 0; i < vtx_count; i++)

	mov	DWORD PTR i$13[rbp], 0
	jmp	SHORT $LN13@AddConvexP
$LN11@AddConvexP:
	mov	eax, DWORD PTR i$13[rbp]
	inc	eax
	mov	DWORD PTR i$13[rbp], eax
$LN13@AddConvexP:
	mov	eax, DWORD PTR vtx_count$15[rbp]
	cmp	DWORD PTR i$13[rbp], eax
	jge	$LN12@AddConvexP

; 926  :         {
; 927  :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	movsxd	rax, DWORD PTR i$13[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 928  :             _VtxWritePtr++;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 20
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 929  :         }

	jmp	$LN11@AddConvexP
$LN12@AddConvexP:

; 930  :         for (int i = 2; i < points_count; i++)

	mov	DWORD PTR i$10[rbp], 2
	jmp	SHORT $LN16@AddConvexP
$LN14@AddConvexP:
	mov	eax, DWORD PTR i$10[rbp]
	inc	eax
	mov	DWORD PTR i$10[rbp], eax
$LN16@AddConvexP:
	mov	eax, DWORD PTR points_count$[rbp]
	cmp	DWORD PTR i$10[rbp], eax
	jge	$LN15@AddConvexP

; 931  :         {
; 932  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, WORD PTR [rdx+64]
	mov	WORD PTR [rax+rcx], dx
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	ecx, DWORD PTR i$10[rbp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, DWORD PTR i$10[rbp]
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 933  :             _IdxWritePtr += 3;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 6
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 934  :         }

	jmp	$LN14@AddConvexP
$LN15@AddConvexP:

; 935  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$15[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	eax, DWORD PTR [rcx+64]
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+64], eax
$LN19@AddConvexP:
$LN1@AddConvexP:

; 936  :     }
; 937  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ENDP ; ImDrawList::AddConvexPolyFilled
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
thick_line$ = 0
half_inner_thickness$1 = 4
temp_normals$2 = 8
tv72 = 16
i2$3 = 20
idx1$4 = 24
idx2$5 = 28
dy$6 = 32
dx$7 = 36
temp_points$8 = 40
i1$9 = 48
count$ = 52
i1$10 = 56
dm_x$11 = 60
dm_y$12 = 64
idx1$13 = 68
i1$14 = 72
i$15 = 76
i2$16 = 80
idx2$17 = 84
dm_y$18 = 88
i1$19 = 92
i$20 = 96
dm_x$21 = 100
dy$22 = 104
dx$23 = 108
uv$ = 112
inv_len$24 = 120
inv_len$25 = 124
col_trans$26 = 128
out_vtx$27 = 136
p2$28 = 144
p1$29 = 152
inv_len$30 = 160
tv272 = 164
tv277 = 168
d2$31 = 172
tv656 = 176
tv661 = 180
d2$32 = 184
dm_in_x$33 = 188
dm_in_y$34 = 192
dm_out_x$35 = 196
dm_out_y$36 = 200
vtx_count$37 = 204
tv976 = 208
d2$38 = 212
inv_len$39 = 216
tv81 = 220
tv86 = 224
tv93 = 228
tv138 = 232
i2$40 = 236
d2$41 = 240
out_vtx$42 = 248
vtx_count$43 = 256
idx_count$44 = 260
i2$45 = 264
idx_count$46 = 268
AA_SIZE$47 = 272
$T48 = 276
$T49 = 284
$T50 = 292
$T51 = 300
$T52 = 308
$T53 = 316
$T54 = 324
$T55 = 332
$T56 = 340
$T57 = 348
$T58 = 356
$T59 = 364
$T60 = 372
$T61 = 380
$T62 = 388
$T63 = 396
$T64 = 404
$T65 = 412
$T66 = 420
$T67 = 428
$T68 = 436
$T69 = 444
$T70 = 452
$T71 = 460
__$ArrayPad$ = 472
this$ = 496
points$ = 504
points_count$ = 512
col$ = 520
closed$ = 528
thickness$ = 536
?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z PROC	; ImDrawList::AddPolyline

; 671  : {

$LN57:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 512				; 00000200H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 672  :     if (points_count < 2)

	cmp	DWORD PTR points_count$[rbp], 2
	jge	SHORT $LN20@AddPolylin

; 673  :         return;

	jmp	$LN1@AddPolylin
$LN20@AddPolylin:

; 674  : 
; 675  :     const ImVec2 uv = _Data->TexUvWhitePixel;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR uv$[rbp], rax

; 676  : 
; 677  :     int count = points_count;

	mov	eax, DWORD PTR points_count$[rbp]
	mov	DWORD PTR count$[rbp], eax

; 678  :     if (!closed)

	movzx	eax, BYTE PTR closed$[rbp]
	test	eax, eax
	jne	SHORT $LN21@AddPolylin

; 679  :         count = points_count - 1;

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	mov	DWORD PTR count$[rbp], eax
$LN21@AddPolylin:

; 680  : 
; 681  :     const bool thick_line = thickness > 1.0f;

	movss	xmm0, DWORD PTR thickness$[rbp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN36@AddPolylin
	mov	BYTE PTR tv72[rbp], 1
	jmp	SHORT $LN37@AddPolylin
$LN36@AddPolylin:
	mov	BYTE PTR tv72[rbp], 0
$LN37@AddPolylin:
	movzx	eax, BYTE PTR tv72[rbp]
	mov	BYTE PTR thick_line$[rbp], al

; 682  :     if (Flags & ImDrawListFlags_AntiAliasedLines)

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1
	test	eax, eax
	je	$LN22@AddPolylin

; 683  :     {
; 684  :         // Anti-aliased stroke
; 685  :         const float AA_SIZE = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR AA_SIZE$47[rbp], xmm0

; 686  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

	mov	eax, DWORD PTR col$[rbp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_trans$26[rbp], eax

; 687  : 
; 688  :         const int idx_count = thick_line ? count * 18 : count * 12;

	movzx	eax, BYTE PTR thick_line$[rbp]
	test	eax, eax
	je	SHORT $LN38@AddPolylin
	imul	eax, DWORD PTR count$[rbp], 18
	mov	DWORD PTR tv81[rbp], eax
	jmp	SHORT $LN39@AddPolylin
$LN38@AddPolylin:
	imul	eax, DWORD PTR count$[rbp], 12
	mov	DWORD PTR tv81[rbp], eax
$LN39@AddPolylin:
	mov	eax, DWORD PTR tv81[rbp]
	mov	DWORD PTR idx_count$46[rbp], eax

; 689  :         const int vtx_count = thick_line ? points_count * 4 : points_count * 3;

	movzx	eax, BYTE PTR thick_line$[rbp]
	test	eax, eax
	je	SHORT $LN40@AddPolylin
	mov	eax, DWORD PTR points_count$[rbp]
	shl	eax, 2
	mov	DWORD PTR tv86[rbp], eax
	jmp	SHORT $LN41@AddPolylin
$LN40@AddPolylin:
	imul	eax, DWORD PTR points_count$[rbp], 3
	mov	DWORD PTR tv86[rbp], eax
$LN41@AddPolylin:
	mov	eax, DWORD PTR tv86[rbp]
	mov	DWORD PTR vtx_count$37[rbp], eax

; 690  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, DWORD PTR vtx_count$37[rbp]
	mov	edx, DWORD PTR idx_count$46[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	npad	1

; 691  : 
; 692  :         // Temporary buffer
; 693  :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2)); //-V630

	movzx	eax, BYTE PTR thick_line$[rbp]
	test	eax, eax
	je	SHORT $LN42@AddPolylin
	mov	DWORD PTR tv93[rbp], 5
	jmp	SHORT $LN43@AddPolylin
$LN42@AddPolylin:
	mov	DWORD PTR tv93[rbp], 3
$LN43@AddPolylin:
	mov	eax, DWORD PTR points_count$[rbp]
	imul	eax, DWORD PTR tv93[rbp]
	cdqe
	shl	rax, 3
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN56@AddPolylin
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN56@AddPolylin:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+32]
	mov	QWORD PTR temp_normals$2[rbp], rax

; 694  :         ImVec2* temp_points = temp_normals + points_count;

	movsxd	rax, DWORD PTR points_count$[rbp]
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR temp_points$8[rbp], rax

; 695  : 
; 696  :         for (int i1 = 0; i1 < count; i1++)

	mov	DWORD PTR i1$9[rbp], 0
	jmp	SHORT $LN4@AddPolylin
$LN2@AddPolylin:
	mov	eax, DWORD PTR i1$9[rbp]
	inc	eax
	mov	DWORD PTR i1$9[rbp], eax
$LN4@AddPolylin:
	mov	eax, DWORD PTR count$[rbp]
	cmp	DWORD PTR i1$9[rbp], eax
	jge	$LN3@AddPolylin

; 697  :         {
; 698  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;

	mov	eax, DWORD PTR i1$9[rbp]
	inc	eax
	cmp	eax, DWORD PTR points_count$[rbp]
	jne	SHORT $LN44@AddPolylin
	mov	DWORD PTR tv138[rbp], 0
	jmp	SHORT $LN45@AddPolylin
$LN44@AddPolylin:
	mov	eax, DWORD PTR i1$9[rbp]
	inc	eax
	mov	DWORD PTR tv138[rbp], eax
$LN45@AddPolylin:
	mov	eax, DWORD PTR tv138[rbp]
	mov	DWORD PTR i2$40[rbp], eax

; 699  :             float dx = points[i2].x - points[i1].x;

	movsxd	rax, DWORD PTR i2$40[rbp]
	movsxd	rcx, DWORD PTR i1$9[rbp]
	mov	rdx, QWORD PTR points$[rbp]
	mov	r8, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rdx+rax*8]
	subss	xmm0, DWORD PTR [r8+rcx*8]
	movss	DWORD PTR dx$23[rbp], xmm0

; 700  :             float dy = points[i2].y - points[i1].y;

	movsxd	rax, DWORD PTR i2$40[rbp]
	movsxd	rcx, DWORD PTR i1$9[rbp]
	mov	rdx, QWORD PTR points$[rbp]
	mov	r8, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rdx+rax*8+4]
	subss	xmm0, DWORD PTR [r8+rcx*8+4]
	movss	DWORD PTR dy$22[rbp], xmm0

; 701  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movss	xmm0, DWORD PTR dx$23[rbp]
	mulss	xmm0, DWORD PTR dx$23[rbp]
	movss	xmm1, DWORD PTR dy$22[rbp]
	mulss	xmm1, DWORD PTR dy$22[rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR d2$41[rbp], xmm0
	movss	xmm0, DWORD PTR d2$41[rbp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN24@AddPolylin
	movss	xmm0, DWORD PTR d2$41[rbp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR inv_len$30[rbp], xmm0
	movss	xmm0, DWORD PTR dx$23[rbp]
	mulss	xmm0, DWORD PTR inv_len$30[rbp]
	movss	DWORD PTR dx$23[rbp], xmm0
	movss	xmm0, DWORD PTR dy$22[rbp]
	mulss	xmm0, DWORD PTR inv_len$30[rbp]
	movss	DWORD PTR dy$22[rbp], xmm0
$LN24@AddPolylin:

; 702  :             temp_normals[i1].x = dy;

	movsxd	rax, DWORD PTR i1$9[rbp]
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	movss	xmm0, DWORD PTR dy$22[rbp]
	movss	DWORD PTR [rcx+rax*8], xmm0

; 703  :             temp_normals[i1].y = -dx;

	movss	xmm0, DWORD PTR dx$23[rbp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movsxd	rax, DWORD PTR i1$9[rbp]
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	movss	DWORD PTR [rcx+rax*8+4], xmm0

; 704  :         }

	jmp	$LN2@AddPolylin
$LN3@AddPolylin:

; 705  :         if (!closed)

	movzx	eax, BYTE PTR closed$[rbp]
	test	eax, eax
	jne	SHORT $LN25@AddPolylin

; 706  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

	mov	eax, DWORD PTR points_count$[rbp]
	sub	eax, 2
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_normals$2[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax
$LN25@AddPolylin:

; 707  : 
; 708  :         if (!thick_line)

	movzx	eax, BYTE PTR thick_line$[rbp]
	test	eax, eax
	jne	$LN26@AddPolylin

; 709  :         {
; 710  :             if (!closed)

	movzx	eax, BYTE PTR closed$[rbp]
	test	eax, eax
	jne	$LN28@AddPolylin

; 711  :             {
; 712  :                 temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	movss	xmm2, DWORD PTR __real@3f800000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T48[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR points$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T49[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 713  :                 temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	movss	xmm2, DWORD PTR __real@3f800000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T50[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR points$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T51[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 714  :                 temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * AA_SIZE;

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	movss	xmm2, DWORD PTR __real@3f800000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T52[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR points$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T53[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR points_count$[rbp]
	lea	ecx, DWORD PTR [rcx+rcx-2]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 715  :                 temp_points[(points_count - 1) * 2 + 1] = points[points_count - 1] - temp_normals[points_count - 1] * AA_SIZE;

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	movss	xmm2, DWORD PTR __real@3f800000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T54[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR points$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T55[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR points_count$[rbp]
	lea	ecx, DWORD PTR [rcx+rcx-1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax
$LN28@AddPolylin:

; 716  :             }
; 717  : 
; 718  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 719  :             unsigned int idx1 = _VtxCurrentIdx;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR idx1$13[rbp], eax

; 720  :             for (int i1 = 0; i1 < count; i1++)

	mov	DWORD PTR i1$10[rbp], 0
	jmp	SHORT $LN7@AddPolylin
$LN5@AddPolylin:
	mov	eax, DWORD PTR i1$10[rbp]
	inc	eax
	mov	DWORD PTR i1$10[rbp], eax
$LN7@AddPolylin:
	mov	eax, DWORD PTR count$[rbp]
	cmp	DWORD PTR i1$10[rbp], eax
	jge	$LN6@AddPolylin

; 721  :             {
; 722  :                 const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;

	mov	eax, DWORD PTR i1$10[rbp]
	inc	eax
	cmp	eax, DWORD PTR points_count$[rbp]
	jne	SHORT $LN46@AddPolylin
	mov	DWORD PTR tv272[rbp], 0
	jmp	SHORT $LN47@AddPolylin
$LN46@AddPolylin:
	mov	eax, DWORD PTR i1$10[rbp]
	inc	eax
	mov	DWORD PTR tv272[rbp], eax
$LN47@AddPolylin:
	mov	eax, DWORD PTR tv272[rbp]
	mov	DWORD PTR i2$16[rbp], eax

; 723  :                 unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : idx1 + 3;

	mov	eax, DWORD PTR i1$10[rbp]
	inc	eax
	cmp	eax, DWORD PTR points_count$[rbp]
	jne	SHORT $LN48@AddPolylin
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR tv277[rbp], eax
	jmp	SHORT $LN49@AddPolylin
$LN48@AddPolylin:
	mov	eax, DWORD PTR idx1$13[rbp]
	add	eax, 3
	mov	DWORD PTR tv277[rbp], eax
$LN49@AddPolylin:
	mov	eax, DWORD PTR tv277[rbp]
	mov	DWORD PTR idx2$17[rbp], eax

; 724  : 
; 725  :                 // Average normals
; 726  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

	movsxd	rax, DWORD PTR i1$10[rbp]
	movsxd	rcx, DWORD PTR i2$16[rbp]
	mov	rdx, QWORD PTR temp_normals$2[rbp]
	mov	r8, QWORD PTR temp_normals$2[rbp]
	movss	xmm0, DWORD PTR [rdx+rax*8]
	addss	xmm0, DWORD PTR [r8+rcx*8]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_x$11[rbp], xmm0

; 727  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

	movsxd	rax, DWORD PTR i1$10[rbp]
	movsxd	rcx, DWORD PTR i2$16[rbp]
	mov	rdx, QWORD PTR temp_normals$2[rbp]
	mov	r8, QWORD PTR temp_normals$2[rbp]
	movss	xmm0, DWORD PTR [rdx+rax*8+4]
	addss	xmm0, DWORD PTR [r8+rcx*8+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_y$12[rbp], xmm0

; 728  :                 IM_NORMALIZE2F_OVER_EPSILON_CLAMP(dm_x, dm_y, 0.000001f, 100.0f)

	movss	xmm0, DWORD PTR dm_x$11[rbp]
	mulss	xmm0, DWORD PTR dm_x$11[rbp]
	movss	xmm1, DWORD PTR dm_y$12[rbp]
	mulss	xmm1, DWORD PTR dm_y$12[rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR d2$31[rbp], xmm0
	movss	xmm0, DWORD PTR d2$31[rbp]
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN29@AddPolylin
	movss	xmm0, DWORD PTR d2$31[rbp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR inv_len$24[rbp], xmm0
	movss	xmm0, DWORD PTR inv_len$24[rbp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN30@AddPolylin
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR inv_len$24[rbp], xmm0
$LN30@AddPolylin:
	movss	xmm0, DWORD PTR dm_x$11[rbp]
	mulss	xmm0, DWORD PTR inv_len$24[rbp]
	movss	DWORD PTR dm_x$11[rbp], xmm0
	movss	xmm0, DWORD PTR dm_y$12[rbp]
	mulss	xmm0, DWORD PTR inv_len$24[rbp]
	movss	DWORD PTR dm_y$12[rbp], xmm0
$LN29@AddPolylin:

; 729  :                     dm_x *= AA_SIZE;

	movss	xmm0, DWORD PTR dm_x$11[rbp]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR dm_x$11[rbp], xmm0

; 730  :                 dm_y *= AA_SIZE;

	movss	xmm0, DWORD PTR dm_y$12[rbp]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR dm_y$12[rbp], xmm0

; 731  : 
; 732  :                 // Add temporary vertexes
; 733  :                 ImVec2* out_vtx = &temp_points[i2 * 2];

	mov	eax, DWORD PTR i2$16[rbp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR out_vtx$42[rbp], rax

; 734  :                 out_vtx[0].x = points[i2].x + dm_x;

	movsxd	rax, DWORD PTR i2$16[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	addss	xmm0, DWORD PTR dm_x$11[rbp]
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out_vtx$42[rbp]
	movss	DWORD PTR [rcx+rax], xmm0

; 735  :                 out_vtx[0].y = points[i2].y + dm_y;

	movsxd	rax, DWORD PTR i2$16[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	addss	xmm0, DWORD PTR dm_y$12[rbp]
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out_vtx$42[rbp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 736  :                 out_vtx[1].x = points[i2].x - dm_x;

	movsxd	rax, DWORD PTR i2$16[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	subss	xmm0, DWORD PTR dm_x$11[rbp]
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out_vtx$42[rbp]
	movss	DWORD PTR [rcx+rax], xmm0

; 737  :                 out_vtx[1].y = points[i2].y - dm_y;

	movsxd	rax, DWORD PTR i2$16[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	subss	xmm0, DWORD PTR dm_y$12[rbp]
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out_vtx$42[rbp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 738  : 
; 739  :                 // Add indexes
; 740  :                 _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx2$17[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx1$13[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, DWORD PTR idx1$13[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 741  :                 _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0);

	mov	eax, DWORD PTR idx1$13[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx2$17[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, 2
	imul	rax, rax, 5
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx2$17[rbp]
	mov	WORD PTR [rax+rcx], dx

; 742  :                 _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0);

	mov	eax, DWORD PTR idx2$17[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx1$13[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, 2
	imul	rax, rax, 8
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx1$13[rbp]
	mov	WORD PTR [rax+rcx], dx

; 743  :                 _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);

	mov	eax, 2
	imul	rax, rax, 9
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx1$13[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, 2
	imul	rax, rax, 10
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx2$17[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, DWORD PTR idx2$17[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 744  :                 _IdxWritePtr += 12;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 24
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 745  : 
; 746  :                 idx1 = idx2;

	mov	eax, DWORD PTR idx2$17[rbp]
	mov	DWORD PTR idx1$13[rbp], eax

; 747  :             }

	jmp	$LN5@AddPolylin
$LN6@AddPolylin:

; 748  : 
; 749  :             // Add vertexes
; 750  :             for (int i = 0; i < points_count; i++)

	mov	DWORD PTR i$20[rbp], 0
	jmp	SHORT $LN10@AddPolylin
$LN8@AddPolylin:
	mov	eax, DWORD PTR i$20[rbp]
	inc	eax
	mov	DWORD PTR i$20[rbp], eax
$LN10@AddPolylin:
	mov	eax, DWORD PTR points_count$[rbp]
	cmp	DWORD PTR i$20[rbp], eax
	jge	$LN9@AddPolylin

; 751  :             {
; 752  :                 _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 753  :                 _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;

	mov	eax, DWORD PTR i$20[rbp]
	add	eax, eax
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col_trans$26[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 754  :                 _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;

	mov	eax, DWORD PTR i$20[rbp]
	lea	eax, DWORD PTR [rax+rax+1]
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col_trans$26[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 755  :                 _VtxWritePtr += 3;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 60					; 0000003cH
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 756  :             }

	jmp	$LN8@AddPolylin
$LN9@AddPolylin:

; 757  :         }

	jmp	$LN27@AddPolylin
$LN26@AddPolylin:

; 758  :         else
; 759  :         {
; 760  :             const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

	movss	xmm0, DWORD PTR thickness$[rbp]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR half_inner_thickness$1[rbp], xmm0

; 761  :             if (!closed)

	movzx	eax, BYTE PTR closed$[rbp]
	test	eax, eax
	jne	$LN31@AddPolylin

; 762  :             {
; 763  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

	movss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T56[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR points$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T57[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 764  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	movss	xmm2, DWORD PTR half_inner_thickness$1[rbp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T58[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR points$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T59[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 765  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	movss	xmm2, DWORD PTR half_inner_thickness$1[rbp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T60[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR points$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T61[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 766  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

	movss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T62[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR points$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T63[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 767  :                 temp_points[(points_count - 1) * 4 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * (half_inner_thickness + AA_SIZE);

	movss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T64[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR points$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T65[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR points_count$[rbp]
	lea	ecx, DWORD PTR [rcx*4-4]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 768  :                 temp_points[(points_count - 1) * 4 + 1] = points[points_count - 1] + temp_normals[points_count - 1] * (half_inner_thickness);

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	movss	xmm2, DWORD PTR half_inner_thickness$1[rbp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T66[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR points$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T67[rbp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR points_count$[rbp]
	lea	ecx, DWORD PTR [rcx*4-3]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 769  :                 temp_points[(points_count - 1) * 4 + 2] = points[points_count - 1] - temp_normals[points_count - 1] * (half_inner_thickness);

	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	movss	xmm2, DWORD PTR half_inner_thickness$1[rbp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T68[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR points$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T69[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR points_count$[rbp]
	lea	ecx, DWORD PTR [rcx*4-2]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 770  :                 temp_points[(points_count - 1) * 4 + 3] = points[points_count - 1] - temp_normals[points_count - 1] * (half_inner_thickness + AA_SIZE);

	movss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR points_count$[rbp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR temp_normals$2[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T70[rbp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	ecx, DWORD PTR points_count$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR points$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*8]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T71[rbp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR points_count$[rbp]
	lea	ecx, DWORD PTR [rcx*4-1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR temp_points$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax
$LN31@AddPolylin:

; 771  :             }
; 772  : 
; 773  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 774  :             unsigned int idx1 = _VtxCurrentIdx;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR idx1$4[rbp], eax

; 775  :             for (int i1 = 0; i1 < count; i1++)

	mov	DWORD PTR i1$14[rbp], 0
	jmp	SHORT $LN13@AddPolylin
$LN11@AddPolylin:
	mov	eax, DWORD PTR i1$14[rbp]
	inc	eax
	mov	DWORD PTR i1$14[rbp], eax
$LN13@AddPolylin:
	mov	eax, DWORD PTR count$[rbp]
	cmp	DWORD PTR i1$14[rbp], eax
	jge	$LN12@AddPolylin

; 776  :             {
; 777  :                 const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;

	mov	eax, DWORD PTR i1$14[rbp]
	inc	eax
	cmp	eax, DWORD PTR points_count$[rbp]
	jne	SHORT $LN50@AddPolylin
	mov	DWORD PTR tv656[rbp], 0
	jmp	SHORT $LN51@AddPolylin
$LN50@AddPolylin:
	mov	eax, DWORD PTR i1$14[rbp]
	inc	eax
	mov	DWORD PTR tv656[rbp], eax
$LN51@AddPolylin:
	mov	eax, DWORD PTR tv656[rbp]
	mov	DWORD PTR i2$3[rbp], eax

; 778  :                 unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : idx1 + 4;

	mov	eax, DWORD PTR i1$14[rbp]
	inc	eax
	cmp	eax, DWORD PTR points_count$[rbp]
	jne	SHORT $LN52@AddPolylin
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR tv661[rbp], eax
	jmp	SHORT $LN53@AddPolylin
$LN52@AddPolylin:
	mov	eax, DWORD PTR idx1$4[rbp]
	add	eax, 4
	mov	DWORD PTR tv661[rbp], eax
$LN53@AddPolylin:
	mov	eax, DWORD PTR tv661[rbp]
	mov	DWORD PTR idx2$5[rbp], eax

; 779  : 
; 780  :                 // Average normals
; 781  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

	movsxd	rax, DWORD PTR i1$14[rbp]
	movsxd	rcx, DWORD PTR i2$3[rbp]
	mov	rdx, QWORD PTR temp_normals$2[rbp]
	mov	r8, QWORD PTR temp_normals$2[rbp]
	movss	xmm0, DWORD PTR [rdx+rax*8]
	addss	xmm0, DWORD PTR [r8+rcx*8]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_x$21[rbp], xmm0

; 782  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

	movsxd	rax, DWORD PTR i1$14[rbp]
	movsxd	rcx, DWORD PTR i2$3[rbp]
	mov	rdx, QWORD PTR temp_normals$2[rbp]
	mov	r8, QWORD PTR temp_normals$2[rbp]
	movss	xmm0, DWORD PTR [rdx+rax*8+4]
	addss	xmm0, DWORD PTR [r8+rcx*8+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dm_y$18[rbp], xmm0

; 783  :                 IM_NORMALIZE2F_OVER_EPSILON_CLAMP(dm_x, dm_y, 0.000001f, 100.0f);

	movss	xmm0, DWORD PTR dm_x$21[rbp]
	mulss	xmm0, DWORD PTR dm_x$21[rbp]
	movss	xmm1, DWORD PTR dm_y$18[rbp]
	mulss	xmm1, DWORD PTR dm_y$18[rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR d2$32[rbp], xmm0
	movss	xmm0, DWORD PTR d2$32[rbp]
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN32@AddPolylin
	movss	xmm0, DWORD PTR d2$32[rbp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR inv_len$25[rbp], xmm0
	movss	xmm0, DWORD PTR inv_len$25[rbp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN33@AddPolylin
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR inv_len$25[rbp], xmm0
$LN33@AddPolylin:
	movss	xmm0, DWORD PTR dm_x$21[rbp]
	mulss	xmm0, DWORD PTR inv_len$25[rbp]
	movss	DWORD PTR dm_x$21[rbp], xmm0
	movss	xmm0, DWORD PTR dm_y$18[rbp]
	mulss	xmm0, DWORD PTR inv_len$25[rbp]
	movss	DWORD PTR dm_y$18[rbp], xmm0
$LN32@AddPolylin:

; 784  :                 float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);

	movss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR dm_x$21[rbp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dm_out_x$35[rbp], xmm0

; 785  :                 float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);

	movss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR dm_y$18[rbp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dm_out_y$36[rbp], xmm0

; 786  :                 float dm_in_x = dm_x * half_inner_thickness;

	movss	xmm0, DWORD PTR dm_x$21[rbp]
	mulss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	movss	DWORD PTR dm_in_x$33[rbp], xmm0

; 787  :                 float dm_in_y = dm_y * half_inner_thickness;

	movss	xmm0, DWORD PTR dm_y$18[rbp]
	mulss	xmm0, DWORD PTR half_inner_thickness$1[rbp]
	movss	DWORD PTR dm_in_y$34[rbp], xmm0

; 788  : 
; 789  :                 // Add temporary vertexes
; 790  :                 ImVec2* out_vtx = &temp_points[i2 * 4];

	mov	eax, DWORD PTR i2$3[rbp]
	shl	eax, 2
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR out_vtx$27[rbp], rax

; 791  :                 out_vtx[0].x = points[i2].x + dm_out_x;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	addss	xmm0, DWORD PTR dm_out_x$35[rbp]
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax], xmm0

; 792  :                 out_vtx[0].y = points[i2].y + dm_out_y;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	addss	xmm0, DWORD PTR dm_out_y$36[rbp]
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 793  :                 out_vtx[1].x = points[i2].x + dm_in_x;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	addss	xmm0, DWORD PTR dm_in_x$33[rbp]
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax], xmm0

; 794  :                 out_vtx[1].y = points[i2].y + dm_in_y;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	addss	xmm0, DWORD PTR dm_in_y$34[rbp]
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 795  :                 out_vtx[2].x = points[i2].x - dm_in_x;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	subss	xmm0, DWORD PTR dm_in_x$33[rbp]
	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax], xmm0

; 796  :                 out_vtx[2].y = points[i2].y - dm_in_y;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	subss	xmm0, DWORD PTR dm_in_y$34[rbp]
	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 797  :                 out_vtx[3].x = points[i2].x - dm_out_x;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8]
	subss	xmm0, DWORD PTR dm_out_x$35[rbp]
	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax], xmm0

; 798  :                 out_vtx[3].y = points[i2].y - dm_out_y;

	movsxd	rax, DWORD PTR i2$3[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	movss	xmm0, DWORD PTR [rcx+rax*8+4]
	subss	xmm0, DWORD PTR dm_out_y$36[rbp]
	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR out_vtx$27[rbp]
	movss	DWORD PTR [rcx+rax+4], xmm0

; 799  : 
; 800  :                 // Add indexes
; 801  :                 _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2);

	mov	eax, DWORD PTR idx2$5[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx1$4[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx1$4[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 802  :                 _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 1);

	mov	eax, DWORD PTR idx1$4[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx2$5[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx2$5[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 803  :                 _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0);

	mov	eax, DWORD PTR idx2$5[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx1$4[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, 2
	imul	rax, rax, 8
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx1$4[rbp]
	mov	WORD PTR [rax+rcx], dx

; 804  :                 _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);

	mov	eax, 2
	imul	rax, rax, 9
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx1$4[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, 2
	imul	rax, rax, 10
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, WORD PTR idx2$5[rbp]
	mov	WORD PTR [rax+rcx], dx
	mov	eax, DWORD PTR idx2$5[rbp]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 805  :                 _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);

	mov	eax, DWORD PTR idx2$5[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx1$4[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx1$4[rbp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 806  :                 _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);

	mov	eax, DWORD PTR idx1$4[rbp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx2$5[rbp]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	eax, DWORD PTR idx2$5[rbp]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 807  :                 _IdxWritePtr += 18;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 36					; 00000024H
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 808  : 
; 809  :                 idx1 = idx2;

	mov	eax, DWORD PTR idx2$5[rbp]
	mov	DWORD PTR idx1$4[rbp], eax

; 810  :             }

	jmp	$LN11@AddPolylin
$LN12@AddPolylin:

; 811  : 
; 812  :             // Add vertexes
; 813  :             for (int i = 0; i < points_count; i++)

	mov	DWORD PTR i$15[rbp], 0
	jmp	SHORT $LN16@AddPolylin
$LN14@AddPolylin:
	mov	eax, DWORD PTR i$15[rbp]
	inc	eax
	mov	DWORD PTR i$15[rbp], eax
$LN16@AddPolylin:
	mov	eax, DWORD PTR points_count$[rbp]
	cmp	DWORD PTR i$15[rbp], eax
	jge	$LN15@AddPolylin

; 814  :             {
; 815  :                 _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;

	mov	eax, DWORD PTR i$15[rbp]
	shl	eax, 2
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col_trans$26[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 816  :                 _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	eax, DWORD PTR i$15[rbp]
	lea	eax, DWORD PTR [rax*4+1]
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 817  :                 _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	mov	eax, DWORD PTR i$15[rbp]
	lea	eax, DWORD PTR [rax*4+2]
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 818  :                 _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;

	mov	eax, DWORD PTR i$15[rbp]
	lea	eax, DWORD PTR [rax*4+3]
	cdqe
	mov	rcx, QWORD PTR temp_points$8[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 20
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col_trans$26[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 819  :                 _VtxWritePtr += 4;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 820  :             }

	jmp	$LN14@AddPolylin
$LN15@AddPolylin:
$LN27@AddPolylin:

; 821  :         }
; 822  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$37[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	eax, DWORD PTR [rcx+64]
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+64], eax

; 823  :     }

	jmp	$LN23@AddPolylin
$LN22@AddPolylin:

; 824  :     else
; 825  :     {
; 826  :         // Non Anti-aliased Stroke
; 827  :         const int idx_count = count * 6;

	imul	eax, DWORD PTR count$[rbp], 6
	mov	DWORD PTR idx_count$44[rbp], eax

; 828  :         const int vtx_count = count * 4;      // FIXME-OPT: Not sharing edges

	mov	eax, DWORD PTR count$[rbp]
	shl	eax, 2
	mov	DWORD PTR vtx_count$43[rbp], eax

; 829  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, DWORD PTR vtx_count$43[rbp]
	mov	edx, DWORD PTR idx_count$44[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	npad	1

; 830  : 
; 831  :         for (int i1 = 0; i1 < count; i1++)

	mov	DWORD PTR i1$19[rbp], 0
	jmp	SHORT $LN19@AddPolylin
$LN17@AddPolylin:
	mov	eax, DWORD PTR i1$19[rbp]
	inc	eax
	mov	DWORD PTR i1$19[rbp], eax
$LN19@AddPolylin:
	mov	eax, DWORD PTR count$[rbp]
	cmp	DWORD PTR i1$19[rbp], eax
	jge	$LN18@AddPolylin

; 832  :         {
; 833  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;

	mov	eax, DWORD PTR i1$19[rbp]
	inc	eax
	cmp	eax, DWORD PTR points_count$[rbp]
	jne	SHORT $LN54@AddPolylin
	mov	DWORD PTR tv976[rbp], 0
	jmp	SHORT $LN55@AddPolylin
$LN54@AddPolylin:
	mov	eax, DWORD PTR i1$19[rbp]
	inc	eax
	mov	DWORD PTR tv976[rbp], eax
$LN55@AddPolylin:
	mov	eax, DWORD PTR tv976[rbp]
	mov	DWORD PTR i2$45[rbp], eax

; 834  :             const ImVec2& p1 = points[i1];

	movsxd	rax, DWORD PTR i1$19[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p1$29[rbp], rax

; 835  :             const ImVec2& p2 = points[i2];

	movsxd	rax, DWORD PTR i2$45[rbp]
	mov	rcx, QWORD PTR points$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p2$28[rbp], rax

; 836  : 
; 837  :             float dx = p2.x - p1.x;

	mov	rax, QWORD PTR p2$28[rbp]
	mov	rcx, QWORD PTR p1$29[rbp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR dx$7[rbp], xmm0

; 838  :             float dy = p2.y - p1.y;

	mov	rax, QWORD PTR p2$28[rbp]
	mov	rcx, QWORD PTR p1$29[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR dy$6[rbp], xmm0

; 839  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movss	xmm0, DWORD PTR dx$7[rbp]
	mulss	xmm0, DWORD PTR dx$7[rbp]
	movss	xmm1, DWORD PTR dy$6[rbp]
	mulss	xmm1, DWORD PTR dy$6[rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR d2$38[rbp], xmm0
	movss	xmm0, DWORD PTR d2$38[rbp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN34@AddPolylin
	movss	xmm0, DWORD PTR d2$38[rbp]
	call	?ImSqrt@@YAMM@Z				; ImSqrt
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR inv_len$39[rbp], xmm0
	movss	xmm0, DWORD PTR dx$7[rbp]
	mulss	xmm0, DWORD PTR inv_len$39[rbp]
	movss	DWORD PTR dx$7[rbp], xmm0
	movss	xmm0, DWORD PTR dy$6[rbp]
	mulss	xmm0, DWORD PTR inv_len$39[rbp]
	movss	DWORD PTR dy$6[rbp], xmm0
$LN34@AddPolylin:

; 840  :             dx *= (thickness * 0.5f);

	movss	xmm0, DWORD PTR thickness$[rbp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR dx$7[rbp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dx$7[rbp], xmm0

; 841  :             dy *= (thickness * 0.5f);

	movss	xmm0, DWORD PTR thickness$[rbp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR dy$6[rbp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dy$6[rbp], xmm0

; 842  : 
; 843  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR p1$29[rbp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR dy$6[rbp]
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	rax, QWORD PTR p1$29[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR dx$7[rbp]
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 844  :             _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	rax, QWORD PTR p2$28[rbp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR dy$6[rbp]
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	rax, QWORD PTR p2$28[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR dx$7[rbp]
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 845  :             _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	mov	rax, QWORD PTR p2$28[rbp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR dy$6[rbp]
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	rax, QWORD PTR p2$28[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR dx$7[rbp]
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 846  :             _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

	mov	rax, QWORD PTR p1$29[rbp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR dy$6[rbp]
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax], xmm0
	mov	rax, QWORD PTR p1$29[rbp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR dx$7[rbp]
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movss	DWORD PTR [rcx+rax+4], xmm0
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR uv$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 20
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	edx, DWORD PTR col$[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 847  :             _VtxWritePtr += 4;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 848  : 
; 849  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, WORD PTR [rdx+64]
	mov	WORD PTR [rax+rcx], dx
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 850  :             _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);

	mov	eax, 2
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, WORD PTR [rdx+64]
	mov	WORD PTR [rax+rcx], dx
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 2
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 3
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	WORD PTR [rcx+rdx], ax

; 851  :             _IdxWritePtr += 6;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 12
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 852  :             _VtxCurrentIdx += 4;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 4
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+64], eax

; 853  :         }

	jmp	$LN17@AddPolylin
$LN18@AddPolylin:
$LN23@AddPolylin:
$LN1@AddPolylin:

; 854  :     }
; 855  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+480]
	pop	rbp
	ret	0
?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z ENDP	; ImDrawList::AddPolyline
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv85 = 64
push_texture_id$ = 65
vert_end_idx$ = 68
vert_start_idx$ = 72
this$ = 96
user_texture_id$ = 104
a$ = 112
b$ = 120
uv_a$ = 128
uv_b$ = 136
col$ = 144
rounding$ = 152
rounding_corners$ = 160
?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z PROC ; ImDrawList::AddImageRounded

; 1340 : {

$LN10:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1341 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddImageRo

; 1342 :         return;

	jmp	$LN1@AddImageRo
$LN2@AddImageRo:

; 1343 : 
; 1344 :     if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR rounding$[rsp]
	jae	SHORT $LN4@AddImageRo
	mov	eax, DWORD PTR rounding_corners$[rsp]
	and	eax, 15
	test	eax, eax
	jne	SHORT $LN3@AddImageRo
$LN4@AddImageRo:

; 1345 :     {
; 1346 :         AddImage(user_texture_id, a, b, uv_a, uv_b, col);

	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR uv_b$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR uv_a$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR b$[rsp]
	mov	r8, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1

; 1347 :         return;

	jmp	$LN1@AddImageRo
$LN3@AddImageRo:

; 1348 :     }
; 1349 : 
; 1350 :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?empty@?$ImVector@PEAX@@QEBA_NXZ	; ImVector<void *>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@AddImageRo
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ	; ImVector<void *>::back
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR user_texture_id$[rsp], rax
	jne	SHORT $LN8@AddImageRo
	mov	BYTE PTR tv85[rsp], 0
	jmp	SHORT $LN9@AddImageRo
$LN8@AddImageRo:
	mov	BYTE PTR tv85[rsp], 1
$LN9@AddImageRo:
	movzx	eax, BYTE PTR tv85[rsp]
	mov	BYTE PTR push_texture_id$[rsp], al

; 1351 :     if (push_texture_id)

	movzx	eax, BYTE PTR push_texture_id$[rsp]
	test	eax, eax
	je	SHORT $LN5@AddImageRo

; 1352 :         PushTextureID(user_texture_id);

	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
	npad	1
$LN5@AddImageRo:

; 1353 : 
; 1354 :     int vert_start_idx = VtxBuffer.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR vert_start_idx$[rsp], eax

; 1355 :     PathRect(a, b, rounding, rounding_corners);

	mov	eax, DWORD PTR rounding_corners$[rsp]
	mov	DWORD PTR [rsp+32], eax
	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect

; 1356 :     PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex

; 1357 :     int vert_end_idx = VtxBuffer.Size;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR vert_end_idx$[rsp], eax

; 1358 :     ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, true);

	mov	BYTE PTR [rsp+56], 1
	mov	rax, QWORD PTR uv_b$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR uv_a$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR b$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR a$[rsp]
	mov	r8d, DWORD PTR vert_end_idx$[rsp]
	mov	edx, DWORD PTR vert_start_idx$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z ; ImGui::ShadeVertsLinearUV
	npad	1

; 1359 : 
; 1360 :     if (push_texture_id)

	movzx	eax, BYTE PTR push_texture_id$[rsp]
	test	eax, eax
	je	SHORT $LN6@AddImageRo

; 1361 :         PopTextureID();

	mov	rcx, QWORD PTR this$[rsp]
	call	?PopTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::PopTextureID
	npad	1
$LN6@AddImageRo:
$LN1@AddImageRo:

; 1362 : }

	add	rsp, 88					; 00000058H
	ret	0
?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z ENDP ; ImDrawList::AddImageRounded
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv75 = 80
push_texture_id$ = 81
this$ = 112
user_texture_id$ = 120
a$ = 128
b$ = 136
c$ = 144
d$ = 152
uv_a$ = 160
uv_b$ = 168
uv_c$ = 176
uv_d$ = 184
col$ = 192
?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z PROC ; ImDrawList::AddImageQuad

; 1324 : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1325 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddImageQu

; 1326 :         return;

	jmp	$LN1@AddImageQu
$LN2@AddImageQu:

; 1327 : 
; 1328 :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?empty@?$ImVector@PEAX@@QEBA_NXZ	; ImVector<void *>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@AddImageQu
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ	; ImVector<void *>::back
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR user_texture_id$[rsp], rax
	jne	SHORT $LN6@AddImageQu
	mov	BYTE PTR tv75[rsp], 0
	jmp	SHORT $LN7@AddImageQu
$LN6@AddImageQu:
	mov	BYTE PTR tv75[rsp], 1
$LN7@AddImageQu:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR push_texture_id$[rsp], al

; 1329 :     if (push_texture_id)

	movzx	eax, BYTE PTR push_texture_id$[rsp]
	test	eax, eax
	je	SHORT $LN3@AddImageQu

; 1330 :         PushTextureID(user_texture_id);

	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
	npad	1
$LN3@AddImageQu:

; 1331 : 
; 1332 :     PrimReserve(6, 4);

	mov	r8d, 4
	mov	edx, 6
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1333 :     PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);

	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	rax, QWORD PTR uv_d$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR uv_c$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR uv_b$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR uv_a$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR d$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR c$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z ; ImDrawList::PrimQuadUV
	npad	1

; 1334 : 
; 1335 :     if (push_texture_id)

	movzx	eax, BYTE PTR push_texture_id$[rsp]
	test	eax, eax
	je	SHORT $LN4@AddImageQu

; 1336 :         PopTextureID();

	mov	rcx, QWORD PTR this$[rsp]
	call	?PopTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::PopTextureID
	npad	1
$LN4@AddImageQu:
$LN1@AddImageQu:

; 1337 : }

	add	rsp, 104				; 00000068H
	ret	0
?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z ENDP ; ImDrawList::AddImageQuad
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv75 = 48
push_texture_id$ = 49
this$ = 80
user_texture_id$ = 88
a$ = 96
b$ = 104
uv_a$ = 112
uv_b$ = 120
col$ = 128
?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z PROC	; ImDrawList::AddImage

; 1308 : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1309 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddImage

; 1310 :         return;

	jmp	$LN1@AddImage
$LN2@AddImage:

; 1311 : 
; 1312 :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?empty@?$ImVector@PEAX@@QEBA_NXZ	; ImVector<void *>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@AddImage
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ	; ImVector<void *>::back
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR user_texture_id$[rsp], rax
	jne	SHORT $LN6@AddImage
	mov	BYTE PTR tv75[rsp], 0
	jmp	SHORT $LN7@AddImage
$LN6@AddImage:
	mov	BYTE PTR tv75[rsp], 1
$LN7@AddImage:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR push_texture_id$[rsp], al

; 1313 :     if (push_texture_id)

	movzx	eax, BYTE PTR push_texture_id$[rsp]
	test	eax, eax
	je	SHORT $LN3@AddImage

; 1314 :         PushTextureID(user_texture_id);

	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
	npad	1
$LN3@AddImage:

; 1315 : 
; 1316 :     PrimReserve(6, 4);

	mov	r8d, 4
	mov	edx, 6
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1317 :     PrimRectUV(a, b, uv_a, uv_b, col);

	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR uv_b$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR uv_a$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV
	npad	1

; 1318 : 
; 1319 :     if (push_texture_id)

	movzx	eax, BYTE PTR push_texture_id$[rsp]
	test	eax, eax
	je	SHORT $LN4@AddImage

; 1320 :         PopTextureID();

	mov	rcx, QWORD PTR this$[rsp]
	call	?PopTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::PopTextureID
	npad	1
$LN4@AddImage:
$LN1@AddImage:

; 1321 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ENDP	; ImDrawList::AddImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv132 = 80
clip_rect$ = 88
this$ = 144
font$ = 152
font_size$ = 160
pos$ = 168
col$ = 176
text_begin$ = 184
text_end$ = 192
wrap_width$ = 200
cpu_fine_clip_rect$ = 208
?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z PROC ; ImDrawList::AddText

; 1274 : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 1275 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddText

; 1276 :         return;

	jmp	$LN1@AddText
$LN2@AddText:

; 1277 : 
; 1278 :     if (text_end == NULL)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN3@AddText

; 1279 :         text_end = text_begin + strlen(text_begin);

	mov	rcx, QWORD PTR text_begin$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text_begin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN3@AddText:

; 1280 :     if (text_begin == text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR text_begin$[rsp], rax
	jne	SHORT $LN4@AddText

; 1281 :         return;

	jmp	$LN1@AddText
$LN4@AddText:

; 1282 : 
; 1283 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1284 :     if (font == NULL)

	cmp	QWORD PTR font$[rsp], 0
	jne	SHORT $LN5@AddText

; 1285 :         font = _Data->Font;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR font$[rsp], rax
$LN5@AddText:

; 1286 :     if (font_size == 0.0f)

	movss	xmm0, DWORD PTR font_size$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN6@AddText
	jne	SHORT $LN6@AddText

; 1287 :         font_size = _Data->FontSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR font_size$[rsp], xmm0
$LN6@AddText:

; 1288 : 
; 1289 :     IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1290 : 
; 1291 :     ImVec4 clip_rect = _ClipRectStack.back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ; ImVector<ImVec4>::back
	lea	rcx, QWORD PTR clip_rect$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1292 :     if (cpu_fine_clip_rect)

	cmp	QWORD PTR cpu_fine_clip_rect$[rsp], 0
	je	SHORT $LN7@AddText

; 1293 :     {
; 1294 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax]
	movss	xmm0, DWORD PTR clip_rect$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR clip_rect$[rsp], xmm0

; 1295 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	movss	xmm0, DWORD PTR clip_rect$[rsp+4]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR clip_rect$[rsp+4], xmm0

; 1296 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	movss	xmm0, DWORD PTR clip_rect$[rsp+8]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR clip_rect$[rsp+8], xmm0

; 1297 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	movss	xmm0, DWORD PTR clip_rect$[rsp+12]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR clip_rect$[rsp+12], xmm0
$LN7@AddText:

; 1298 :     }
; 1299 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	cmp	QWORD PTR cpu_fine_clip_rect$[rsp], 0
	je	SHORT $LN9@AddText
	mov	BYTE PTR tv132[rsp], 1
	jmp	SHORT $LN10@AddText
$LN9@AddText:
	mov	BYTE PTR tv132[rsp], 0
$LN10@AddText:
	movzx	eax, BYTE PTR tv132[rsp]
	mov	BYTE PTR [rsp+72], al
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR text_begin$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR clip_rect$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	r9, QWORD PTR [rax]
	movss	xmm2, DWORD PTR font_size$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
	npad	1
$LN1@AddText:

; 1300 : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ENDP ; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 96
pos$ = 104
col$ = 112
text_begin$ = 120
text_end$ = 128
?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z PROC	; ImDrawList::AddText

; 1303 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1304 :     AddText(NULL, 0.0f, pos, col, text_begin, text_end);

	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text_begin$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR col$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR pos$[rsp]
	xorps	xmm2, xmm2
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 1305 : }

	add	rsp, 88					; 00000058H
	ret	0
?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z ENDP	; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
a_max$ = 48
this$ = 80
centre$ = 88
radius$ = 96
col$ = 104
num_segments$ = 112
?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z PROC ; ImDrawList::AddCircleFilled

; 1253 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1254 :     if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	je	SHORT $LN3@AddCircleF
	cmp	DWORD PTR num_segments$[rsp], 2
	jg	SHORT $LN2@AddCircleF
$LN3@AddCircleF:

; 1255 :         return;

	jmp	SHORT $LN1@AddCircleF
$LN2@AddCircleF:

; 1256 : 
; 1257 :     // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1258 :     const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;

	cvtsi2ss xmm0, DWORD PTR num_segments$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@40c90fdb
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR num_segments$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a_max$[rsp], xmm0

; 1259 :     PathArcTo(centre, radius, 0.0f, a_max, num_segments - 1);

	mov	eax, DWORD PTR num_segments$[rsp]
	dec	eax
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR a_max$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR radius$[rsp]
	mov	rdx, QWORD PTR centre$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 1260 :     PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1
$LN1@AddCircleF:

; 1261 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ENDP ; ImDrawList::AddCircleFilled
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
a_max$ = 48
this$ = 80
centre$ = 88
radius$ = 96
col$ = 104
num_segments$ = 112
thickness$ = 120
?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z PROC	; ImDrawList::AddCircle

; 1242 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1243 :     if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	je	SHORT $LN3@AddCircle
	cmp	DWORD PTR num_segments$[rsp], 2
	jg	SHORT $LN2@AddCircle
$LN3@AddCircle:

; 1244 :         return;

	jmp	SHORT $LN1@AddCircle
$LN2@AddCircle:

; 1245 : 
; 1246 :     // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1247 :     const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;

	cvtsi2ss xmm0, DWORD PTR num_segments$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@40c90fdb
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR num_segments$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a_max$[rsp], xmm0

; 1248 :     PathArcTo(centre, radius - 0.5f, 0.0f, a_max, num_segments - 1);

	mov	eax, DWORD PTR num_segments$[rsp]
	dec	eax
	movss	xmm0, DWORD PTR radius$[rsp]
	subss	xmm0, DWORD PTR __real@3f000000
	mov	DWORD PTR [rsp+40], eax
	movss	xmm1, DWORD PTR a_max$[rsp]
	movss	DWORD PTR [rsp+32], xmm1
	xorps	xmm3, xmm3
	movaps	xmm2, xmm0
	mov	rdx, QWORD PTR centre$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 1249 :     PathStroke(col, true, thickness);

	movss	xmm3, DWORD PTR thickness$[rsp]
	mov	r8b, 1
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN1@AddCircle:

; 1250 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ENDP	; ImDrawList::AddCircle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
a$ = 56
b$ = 64
c$ = 72
col$ = 80
?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z PROC ; ImDrawList::AddTriangleFilled

; 1231 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1232 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddTriangl

; 1233 :         return;

	jmp	SHORT $LN1@AddTriangl
$LN2@AddTriangl:

; 1234 : 
; 1235 :     PathLineTo(a);

	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1236 :     PathLineTo(b);

	mov	rdx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1237 :     PathLineTo(c);

	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1238 :     PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1
$LN1@AddTriangl:

; 1239 : }

	add	rsp, 40					; 00000028H
	ret	0
?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ENDP ; ImDrawList::AddTriangleFilled
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
a$ = 56
b$ = 64
c$ = 72
col$ = 80
thickness$ = 88
?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z PROC	; ImDrawList::AddTriangle

; 1220 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1221 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddTriangl

; 1222 :         return;

	jmp	SHORT $LN1@AddTriangl
$LN2@AddTriangl:

; 1223 : 
; 1224 :     PathLineTo(a);

	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1225 :     PathLineTo(b);

	mov	rdx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1226 :     PathLineTo(c);

	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1227 :     PathStroke(col, true, thickness);

	movss	xmm3, DWORD PTR thickness$[rsp]
	mov	r8b, 1
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN1@AddTriangl:

; 1228 : }

	add	rsp, 40					; 00000028H
	ret	0
?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ENDP	; ImDrawList::AddTriangle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
a$ = 56
b$ = 64
c$ = 72
d$ = 80
col$ = 88
?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z PROC	; ImDrawList::AddQuadFilled

; 1208 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1209 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddQuadFil

; 1210 :         return;

	jmp	SHORT $LN1@AddQuadFil
$LN2@AddQuadFil:

; 1211 : 
; 1212 :     PathLineTo(a);

	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1213 :     PathLineTo(b);

	mov	rdx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1214 :     PathLineTo(c);

	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1215 :     PathLineTo(d);

	mov	rdx, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1216 :     PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1
$LN1@AddQuadFil:

; 1217 : }

	add	rsp, 40					; 00000028H
	ret	0
?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ENDP	; ImDrawList::AddQuadFilled
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
a$ = 56
b$ = 64
c$ = 72
d$ = 80
col$ = 88
thickness$ = 96
?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z PROC	; ImDrawList::AddQuad

; 1196 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1197 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddQuad

; 1198 :         return;

	jmp	SHORT $LN1@AddQuad
$LN2@AddQuad:

; 1199 : 
; 1200 :     PathLineTo(a);

	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1201 :     PathLineTo(b);

	mov	rdx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1202 :     PathLineTo(c);

	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1203 :     PathLineTo(d);

	mov	rdx, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1204 :     PathStroke(col, true, thickness);

	movss	xmm3, DWORD PTR thickness$[rsp]
	mov	r8b, 1
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN1@AddQuad:

; 1205 : }

	add	rsp, 40					; 00000028H
	ret	0
?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z ENDP	; ImDrawList::AddQuad
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
uv$ = 32
$T1 = 40
$T2 = 48
this$ = 80
a$ = 88
c$ = 96
col_upr_left$ = 104
col_upr_right$ = 112
col_bot_right$ = 120
col_bot_left$ = 128
?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z PROC ; ImDrawList::AddRectFilledMultiColor

; 1181 : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1182 :     if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col_upr_right$[rsp]
	mov	ecx, DWORD PTR col_upr_left$[rsp]
	or	ecx, eax
	mov	eax, ecx
	or	eax, DWORD PTR col_bot_right$[rsp]
	or	eax, DWORD PTR col_bot_left$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddRectFil

; 1183 :         return;

	jmp	$LN1@AddRectFil
$LN2@AddRectFil:

; 1184 : 
; 1185 :     const ImVec2 uv = _Data->TexUvWhitePixel;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR uv$[rsp], rax

; 1186 :     PrimReserve(6, 4);

	mov	r8d, 4
	mov	edx, 6
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1187 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));

	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, WORD PTR [rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	movzx	edx, ax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 2
	movzx	edx, ax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx

; 1188 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));

	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, WORD PTR [rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 2
	movzx	edx, ax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, 3
	movzx	edx, ax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx

; 1189 :     PrimWriteVtx(a, uv, col_upr_left);

	mov	r9d, DWORD PTR col_upr_left$[rsp]
	lea	r8, QWORD PTR uv$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
	npad	1

; 1190 :     PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR c$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9d, DWORD PTR col_upr_right$[rsp]
	lea	r8, QWORD PTR uv$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
	npad	1

; 1191 :     PrimWriteVtx(c, uv, col_bot_right);

	mov	r9d, DWORD PTR col_bot_right$[rsp]
	lea	r8, QWORD PTR uv$[rsp]
	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
	npad	1

; 1192 :     PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);

	mov	rax, QWORD PTR c$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9d, DWORD PTR col_bot_left$[rsp]
	lea	r8, QWORD PTR uv$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
	npad	1
$LN1@AddRectFil:

; 1193 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ENDP ; ImDrawList::AddRectFilledMultiColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
a$ = 72
b$ = 80
col$ = 88
rounding$ = 96
rounding_corners_flags$ = 104
?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z PROC	; ImDrawList::AddRectFilled

; 1165 : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1166 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddRectFil

; 1167 :         return;

	jmp	SHORT $LN1@AddRectFil
$LN2@AddRectFil:

; 1168 :     if (rounding > 0.0f)

	movss	xmm0, DWORD PTR rounding$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@AddRectFil

; 1169 :     {
; 1170 :         PathRect(a, b, rounding, rounding_corners_flags);

	mov	eax, DWORD PTR rounding_corners_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect

; 1171 :         PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1

; 1172 :     }

	jmp	SHORT $LN4@AddRectFil
$LN3@AddRectFil:

; 1173 :     else
; 1174 :     {
; 1175 :         PrimReserve(6, 4);

	mov	r8d, 4
	mov	edx, 6
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1176 :         PrimRect(a, b, col);

	mov	r9d, DWORD PTR col$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimRect
	npad	1
$LN4@AddRectFil:
$LN1@AddRectFil:

; 1177 :     }
; 1178 : }

	add	rsp, 56					; 00000038H
	ret	0
?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ENDP	; ImDrawList::AddRectFilled
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv93 = 48
tv91 = 56
tv150 = 64
tv148 = 72
$T1 = 80
$T2 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
$T8 = 136
this$ = 160
a$ = 168
b$ = 176
col$ = 184
rounding$ = 192
rounding_corners_flags$ = 200
thickness$ = 208
?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z PROC	; ImDrawList::AddRect

; 1154 : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 1155 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddRect

; 1156 :         return;

	jmp	$LN1@AddRect
$LN2@AddRect:

; 1157 :     if (Flags & ImDrawListFlags_AntiAliasedLines)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1
	test	eax, eax
	je	$LN3@AddRect

; 1158 :         PathRect(a + ImVec2(0.5f, 0.5f), b - ImVec2(0.50f, 0.50f), rounding, rounding_corners_flags);

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv93[rsp], rax
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR a$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv91[rsp], rax
	mov	eax, DWORD PTR rounding_corners_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	r8, QWORD PTR tv93[rsp]
	mov	rdx, QWORD PTR tv91[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
	npad	1
	jmp	$LN4@AddRect
$LN3@AddRect:

; 1159 :     else
; 1160 :         PathRect(a + ImVec2(0.5f, 0.5f), b - ImVec2(0.49f, 0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.

	movss	xmm2, DWORD PTR __real@3efae148
	movss	xmm1, DWORD PTR __real@3efae148
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv150[rsp], rax
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR a$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv148[rsp], rax
	mov	eax, DWORD PTR rounding_corners_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	r8, QWORD PTR tv150[rsp]
	mov	rdx, QWORD PTR tv148[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
	npad	1
$LN4@AddRect:

; 1161 :     PathStroke(col, true, thickness);

	movss	xmm3, DWORD PTR thickness$[rsp]
	mov	r8b, 1
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN1@AddRect:

; 1162 : }

	add	rsp, 152				; 00000098H
	ret	0
?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ENDP	; ImDrawList::AddRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
$T4 = 56
this$ = 80
a$ = 88
b$ = 96
col$ = 104
thickness$ = 112
?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z PROC	; ImDrawList::AddLine

; 1048 : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1049 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	test	eax, eax
	jne	SHORT $LN2@AddLine

; 1050 :         return;

	jmp	$LN1@AddLine
$LN2@AddLine:

; 1051 :     PathLineTo(a + ImVec2(0.5f, 0.5f));

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR a$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1052 :     PathLineTo(b + ImVec2(0.5f, 0.5f));

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR b$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 1053 :     PathStroke(col, false, thickness);

	movss	xmm3, DWORD PTR thickness$[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN1@AddLine:

; 1054 : }

	add	rsp, 72					; 00000048H
	ret	0
?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ENDP	; ImDrawList::AddLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
j$1 = 48
j$2 = 52
PerFrame$ = 56
Color$ = 60
tv136 = 64
tv137 = 68
tv138 = 72
tv140 = 76
A$3 = 80
tv245 = 84
tv312 = 88
T$4 = 92
tv173 = 96
tv171 = 104
tv206 = 112
tv204 = 120
tv244 = 128
tv242 = 136
tv277 = 144
tv275 = 152
tv310 = 160
tv308 = 168
$T5 = 176
$T6 = 184
$T7 = 192
$T8 = 200
$T9 = 208
$T10 = 216
$T11 = 224
$T12 = 232
$T13 = 240
$T14 = 248
$T15 = 256
$T16 = 272
$T17 = 288
$T18 = 304
$T19 = 320
this$ = 352
pos$ = 360
headPosition$ = 368
Health$ = 376
HealthMax$ = 384
?DrawHealthBar@ImDrawList@@QEAAXAEBUImVec2@@0MM@Z PROC	; ImDrawList::DrawHealthBar

; 1121 : {

$LN28:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 344				; 00000158H

; 1122 :     //AddRectFilled(pos, ImVec2(pos.x + headPosition.x * (Health / HealthMax), pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)));
; 1123 :     //AddRectFilled(pos, ImVec2(pos.x + headPosition.x, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0.2, 0.2, 0.2, 1)));
; 1124 :     float PerFrame = headPosition.x / 10.f;

	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR PerFrame$[rsp], xmm0

; 1125 :     ImU32 Color = false ? IM_COL32(213, 43, 77, 150) : Health / HealthMax >= 0.75f ? ImGui::GetColorU32(ImVec4(0, 1, 0, 1)) : Health / HealthMax >= 0.5f ? ImGui::GetColorU32(ImVec4(1.f, 1.f, 0.f, 1.f)) : Health / HealthMax >= 0.25f ? ImGui::GetColorU32(ImVec4(0.1f, 0.5f, 0.31f, 1.f)) : ImGui::GetColorU32(ImVec4(1, 0, 0, 1));

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN25@DrawHealth
	mov	DWORD PTR tv140[rsp], -1773327403	; 964d2bd5H
	jmp	$LN26@DrawHealth
$LN25@DrawHealth:
	movss	xmm0, DWORD PTR Health$[rsp]
	divss	xmm0, DWORD PTR HealthMax$[rsp]
	comiss	xmm0, DWORD PTR __real@3f400000
	jb	SHORT $LN23@DrawHealth
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv138[rsp], eax
	jmp	$LN24@DrawHealth
$LN23@DrawHealth:
	movss	xmm0, DWORD PTR Health$[rsp]
	divss	xmm0, DWORD PTR HealthMax$[rsp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jb	SHORT $LN21@DrawHealth
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv137[rsp], eax
	jmp	$LN22@DrawHealth
$LN21@DrawHealth:
	movss	xmm0, DWORD PTR Health$[rsp]
	divss	xmm0, DWORD PTR HealthMax$[rsp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jb	SHORT $LN19@DrawHealth
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e9eb852
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3dcccccd
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv136[rsp], eax
	jmp	SHORT $LN20@DrawHealth
$LN19@DrawHealth:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv136[rsp], eax
$LN20@DrawHealth:
	mov	eax, DWORD PTR tv136[rsp]
	mov	DWORD PTR tv137[rsp], eax
$LN22@DrawHealth:
	mov	eax, DWORD PTR tv137[rsp]
	mov	DWORD PTR tv138[rsp], eax
$LN24@DrawHealth:
	mov	eax, DWORD PTR tv138[rsp]
	mov	DWORD PTR tv140[rsp], eax
$LN26@DrawHealth:
	mov	eax, DWORD PTR tv140[rsp]
	mov	DWORD PTR Color$[rsp], eax

; 1126 :     if (int(PerFrame) > 1)

	cvttss2si eax, DWORD PTR PerFrame$[rsp]
	cmp	eax, 1
	jle	$LN8@DrawHealth

; 1127 :     {
; 1128 :         for (float j = 0; j <= headPosition.x * (Health / HealthMax); j++)

	xorps	xmm0, xmm0
	movss	DWORD PTR j$2[rsp], xmm0
	jmp	SHORT $LN4@DrawHealth
$LN2@DrawHealth:
	movss	xmm0, DWORD PTR j$2[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR j$2[rsp], xmm0
$LN4@DrawHealth:
	movss	xmm0, DWORD PTR Health$[rsp]
	divss	xmm0, DWORD PTR HealthMax$[rsp]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	comiss	xmm0, DWORD PTR j$2[rsp]
	jb	$LN3@DrawHealth

; 1129 :         {
; 1130 :             if (j == 0)

	movss	xmm0, DWORD PTR j$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	$LN10@DrawHealth
	jne	$LN10@DrawHealth

; 1131 :                 AddLine(ImVec2(pos.x + j, pos.y), ImVec2(pos.x + j, pos.y + headPosition.y), Color, 1);

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR j$2[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv173[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv171[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR Color$[rsp]
	mov	r8, QWORD PTR tv173[rsp]
	mov	rdx, QWORD PTR tv171[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
	jmp	$LN11@DrawHealth
$LN10@DrawHealth:

; 1132 :             else if ((int(j) % int(PerFrame)) != 0 || int(j) == int(PerFrame * 10.f))

	cvttss2si eax, DWORD PTR j$2[rsp]
	cvttss2si ecx, DWORD PTR PerFrame$[rsp]
	cdq
	idiv	ecx
	mov	eax, edx
	test	eax, eax
	jne	SHORT $LN13@DrawHealth
	cvttss2si eax, DWORD PTR j$2[rsp]
	movss	xmm0, DWORD PTR PerFrame$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	cmp	eax, ecx
	jne	$LN12@DrawHealth
$LN13@DrawHealth:

; 1133 :                 AddLine(ImVec2(pos.x + j, pos.y), ImVec2(pos.x + j, pos.y + headPosition.y), Color, 1);

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR j$2[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv206[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv204[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR Color$[rsp]
	mov	r8, QWORD PTR tv206[rsp]
	mov	rdx, QWORD PTR tv204[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
$LN12@DrawHealth:
$LN11@DrawHealth:

; 1134 :         }

	jmp	$LN2@DrawHealth
$LN3@DrawHealth:

; 1135 :     }

	jmp	$LN9@DrawHealth
$LN8@DrawHealth:

; 1136 :     else
; 1137 :     {
; 1138 :         for (float j = 0; j <= headPosition.y * (Health / HealthMax); j += PerFrame / 10.f)

	xorps	xmm0, xmm0
	movss	DWORD PTR j$1[rsp], xmm0
	jmp	SHORT $LN7@DrawHealth
$LN5@DrawHealth:
	movss	xmm0, DWORD PTR PerFrame$[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR j$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR j$1[rsp], xmm0
$LN7@DrawHealth:
	movss	xmm0, DWORD PTR Health$[rsp]
	divss	xmm0, DWORD PTR HealthMax$[rsp]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	comiss	xmm0, DWORD PTR j$1[rsp]
	jb	$LN6@DrawHealth

; 1139 :         {
; 1140 :             float A = ceilf(j);

	movss	xmm0, DWORD PTR j$1[rsp]
	call	ceilf
	movss	DWORD PTR A$3[rsp], xmm0

; 1141 :             int T = int(A - round(j));

	movss	xmm0, DWORD PTR j$1[rsp]
	call	?round@@YAMM@Z				; round
	movss	xmm1, DWORD PTR A$3[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR T$4[rsp], eax

; 1142 :             if (j == 0)

	movss	xmm0, DWORD PTR j$1[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	$LN14@DrawHealth
	jne	$LN14@DrawHealth

; 1143 :                 AddLine(ImVec2(pos.x + j, pos.y), ImVec2(pos.x + j, pos.y + headPosition.y), Color, 1);

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR j$1[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv244[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR j$1[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv242[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR Color$[rsp]
	mov	r8, QWORD PTR tv244[rsp]
	mov	rdx, QWORD PTR tv242[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
	jmp	$LN15@DrawHealth
$LN14@DrawHealth:

; 1144 :             else if (int(ceilf(j) - round(j)) != 1.f)

	movss	xmm0, DWORD PTR j$1[rsp]
	call	ceilf
	movss	DWORD PTR tv245[rsp], xmm0
	movss	xmm0, DWORD PTR j$1[rsp]
	call	?round@@YAMM@Z				; round
	movss	xmm1, DWORD PTR tv245[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN27@DrawHealth
	je	$LN16@DrawHealth
$LN27@DrawHealth:

; 1145 :                 AddLine(ImVec2(pos.x + j, pos.y), ImVec2(pos.x + j, pos.y + headPosition.y), Color, 1);

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR j$1[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv277[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR j$1[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv275[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR Color$[rsp]
	mov	r8, QWORD PTR tv277[rsp]
	mov	rdx, QWORD PTR tv275[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
	jmp	$LN17@DrawHealth
$LN16@DrawHealth:

; 1146 :             else
; 1147 :                 AddLine(ImVec2(pos.x + j, pos.y), ImVec2(pos.x + j, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), 1);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv312[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR j$1[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv310[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR j$1[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv308[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv312[rsp]
	mov	r8, QWORD PTR tv310[rsp]
	mov	rdx, QWORD PTR tv308[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
$LN17@DrawHealth:
$LN15@DrawHealth:

; 1148 :         }

	jmp	$LN5@DrawHealth
$LN6@DrawHealth:
$LN9@DrawHealth:

; 1149 :     }
; 1150 : }

	add	rsp, 344				; 00000158H
	ret	0
?DrawHealthBar@ImDrawList@@QEAAXAEBUImVec2@@0MM@Z ENDP	; ImDrawList::DrawHealthBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv131 = 48
tv167 = 52
tv203 = 56
tv239 = 60
tv279 = 64
tv319 = 68
tv359 = 72
tv399 = 76
tv467 = 80
tv503 = 84
tv539 = 88
tv575 = 92
tv615 = 96
tv655 = 100
tv695 = 104
tv735 = 108
tv775 = 112
tv815 = 116
tv855 = 120
tv927 = 124
tv971 = 128
tv1015 = 132
tv1059 = 136
tv1103 = 140
tv1143 = 144
tv1183 = 148
tv1223 = 152
tv1263 = 156
tv1307 = 160
tv1383 = 164
tv1427 = 168
tv1470 = 172
tv129 = 176
tv95 = 184
tv165 = 192
tv163 = 200
tv201 = 208
tv199 = 216
tv237 = 224
tv235 = 232
tv277 = 240
tv275 = 248
tv317 = 256
tv315 = 264
tv357 = 272
tv355 = 280
tv397 = 288
tv395 = 296
tv465 = 304
tv463 = 312
tv501 = 320
tv499 = 328
tv537 = 336
tv535 = 344
tv573 = 352
tv571 = 360
tv613 = 368
tv611 = 376
tv653 = 384
tv651 = 392
tv693 = 400
tv691 = 408
tv733 = 416
tv731 = 424
tv773 = 432
tv771 = 440
tv813 = 448
tv811 = 456
tv853 = 464
tv851 = 472
tv925 = 480
tv923 = 488
tv969 = 496
tv967 = 504
tv1013 = 512
tv1011 = 520
tv1057 = 528
tv1055 = 536
tv1101 = 544
tv1099 = 552
tv1141 = 560
tv1139 = 568
tv1181 = 576
tv1179 = 584
tv1221 = 592
tv1219 = 600
tv1261 = 608
tv1259 = 616
tv1305 = 624
tv1303 = 632
tv1381 = 640
tv1379 = 648
tv1425 = 656
tv1423 = 664
tv1468 = 672
tv1466 = 680
tv1494 = 688
tv1492 = 696
tv1522 = 704
tv1520 = 712
tv1546 = 720
tv1544 = 728
tv1574 = 736
tv1572 = 744
tv1602 = 752
tv1600 = 760
tv1634 = 768
tv1632 = 776
tv1662 = 784
tv1660 = 792
tv1695 = 800
tv1693 = 808
$T1 = 816
$T2 = 824
$T3 = 832
$T4 = 840
$T5 = 848
$T6 = 856
$T7 = 864
$T8 = 872
$T9 = 880
$T10 = 888
$T11 = 896
$T12 = 904
$T13 = 912
$T14 = 920
$T15 = 928
$T16 = 936
$T17 = 944
$T18 = 952
$T19 = 960
$T20 = 968
$T21 = 976
$T22 = 984
$T23 = 992
$T24 = 1000
$T25 = 1008
$T26 = 1016
$T27 = 1024
$T28 = 1032
$T29 = 1040
$T30 = 1048
$T31 = 1056
$T32 = 1064
$T33 = 1072
$T34 = 1080
$T35 = 1088
$T36 = 1096
$T37 = 1104
$T38 = 1112
$T39 = 1120
$T40 = 1128
$T41 = 1136
$T42 = 1144
$T43 = 1152
$T44 = 1160
$T45 = 1168
$T46 = 1176
$T47 = 1184
$T48 = 1192
$T49 = 1200
$T50 = 1208
$T51 = 1216
$T52 = 1224
$T53 = 1232
$T54 = 1240
$T55 = 1248
$T56 = 1256
$T57 = 1264
$T58 = 1272
$T59 = 1280
$T60 = 1288
$T61 = 1296
$T62 = 1304
$T63 = 1312
$T64 = 1320
$T65 = 1328
$T66 = 1336
$T67 = 1344
$T68 = 1352
$T69 = 1360
$T70 = 1368
$T71 = 1376
$T72 = 1384
$T73 = 1392
$T74 = 1400
$T75 = 1408
$T76 = 1416
$T77 = 1424
$T78 = 1432
$T79 = 1440
$T80 = 1448
$T81 = 1456
$T82 = 1472
$T83 = 1488
$T84 = 1504
$T85 = 1520
$T86 = 1536
$T87 = 1552
$T88 = 1568
$T89 = 1584
$T90 = 1600
$T91 = 1616
$T92 = 1632
$T93 = 1648
$T94 = 1664
$T95 = 1680
$T96 = 1696
$T97 = 1712
$T98 = 1728
$T99 = 1744
$T100 = 1760
$T101 = 1776
$T102 = 1792
$T103 = 1808
$T104 = 1824
$T105 = 1840
$T106 = 1856
$T107 = 1872
$T108 = 1888
$T109 = 1904
$T110 = 1920
$T111 = 1936
$T112 = 1952
this$ = 1984
pos$ = 1992
headPosition$ = 2000
color$ = 2008
Div$ = 2016
Siz$ = 2024
?DrawBox_S@ImDrawList@@QEAAXAEBUImVec2@@0IMM@Z PROC	; ImDrawList::DrawBox_S

; 1057 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1976				; 000007b8H

; 1058 :     AddLine(ImVec2(pos.x + 1.f, pos.y), ImVec2(pos.x + (headPosition.x / Div) + 1.f, pos.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T81[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv131[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv129[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv95[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv131[rsp]
	mov	r8, QWORD PTR tv129[rsp]
	mov	rdx, QWORD PTR tv95[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1059 :     AddLine(ImVec2(pos.x - 1.f, pos.y), ImVec2(pos.x + (headPosition.x / Div) - 1.f, pos.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T82[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv167[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv165[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv163[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv167[rsp]
	mov	r8, QWORD PTR tv165[rsp]
	mov	rdx, QWORD PTR tv163[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1060 :     AddLine(ImVec2(pos.x, pos.y + 1.f), ImVec2(pos.x + (headPosition.x / Div), pos.y + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T83[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv203[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv201[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv199[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv203[rsp]
	mov	r8, QWORD PTR tv201[rsp]
	mov	rdx, QWORD PTR tv199[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1061 :     AddLine(ImVec2(pos.x, pos.y - 1.f), ImVec2(pos.x + (headPosition.x / Div), pos.y - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T84[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv239[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv237[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv235[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv239[rsp]
	mov	r8, QWORD PTR tv237[rsp]
	mov	rdx, QWORD PTR tv235[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1062 : 
; 1063 : 
; 1064 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div) + 1.f, pos.y), ImVec2(pos.x + headPosition.x + 1.f, pos.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T85[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv279[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv277[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv275[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv279[rsp]
	mov	r8, QWORD PTR tv277[rsp]
	mov	rdx, QWORD PTR tv275[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1065 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div) - 1.f, pos.y), ImVec2(pos.x + headPosition.x - 1.f, pos.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T86[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv319[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv317[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv315[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv319[rsp]
	mov	r8, QWORD PTR tv317[rsp]
	mov	rdx, QWORD PTR tv315[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1066 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div), pos.y + 1.f), ImVec2(pos.x + headPosition.x, pos.y + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T87[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv359[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv357[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv355[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv359[rsp]
	mov	r8, QWORD PTR tv357[rsp]
	mov	rdx, QWORD PTR tv355[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1067 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div), pos.y - 1.f), ImVec2(pos.x + headPosition.x, pos.y - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//--

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T88[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv399[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv397[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv395[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv399[rsp]
	mov	r8, QWORD PTR tv397[rsp]
	mov	rdx, QWORD PTR tv395[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1068 : 
; 1069 : 
; 1070 : 
; 1071 :     AddLine(ImVec2(pos.x + 1.f, pos.y), ImVec2(pos.x + 1.f, pos.y + (headPosition.y / Div)), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T89[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv467[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv465[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv463[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv467[rsp]
	mov	r8, QWORD PTR tv465[rsp]
	mov	rdx, QWORD PTR tv463[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1072 :     AddLine(ImVec2(pos.x - 1.f, pos.y), ImVec2(pos.x - 1.f, pos.y + (headPosition.y / Div)), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T90[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv503[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv501[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv499[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv503[rsp]
	mov	r8, QWORD PTR tv501[rsp]
	mov	rdx, QWORD PTR tv499[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1073 :     AddLine(ImVec2(pos.x, pos.y + 1.f), ImVec2(pos.x, pos.y + (headPosition.y / Div) + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T91[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv539[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv537[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv535[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv539[rsp]
	mov	r8, QWORD PTR tv537[rsp]
	mov	rdx, QWORD PTR tv535[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1074 :     AddLine(ImVec2(pos.x, pos.y - 1.f), ImVec2(pos.x, pos.y + (headPosition.y / Div) - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T92[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv575[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv573[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv571[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv575[rsp]
	mov	r8, QWORD PTR tv573[rsp]
	mov	rdx, QWORD PTR tv571[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1075 : 
; 1076 : 
; 1077 :     AddLine(ImVec2(pos.x + 1.f, pos.y + headPosition.y - (headPosition.y / Div)), ImVec2(pos.x + 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T93[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv615[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv613[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv611[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv615[rsp]
	mov	r8, QWORD PTR tv613[rsp]
	mov	rdx, QWORD PTR tv611[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1078 :     AddLine(ImVec2(pos.x - 1.f, pos.y + headPosition.y - (headPosition.y / Div)), ImVec2(pos.x - 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T94[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv655[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv653[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv651[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv655[rsp]
	mov	r8, QWORD PTR tv653[rsp]
	mov	rdx, QWORD PTR tv651[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1079 :     AddLine(ImVec2(pos.x, pos.y + headPosition.y - (headPosition.y / Div) + 1.f), ImVec2(pos.x, pos.y + headPosition.y + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T95[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv695[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv693[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv691[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv695[rsp]
	mov	r8, QWORD PTR tv693[rsp]
	mov	rdx, QWORD PTR tv691[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1080 :     AddLine(ImVec2(pos.x, pos.y + headPosition.y - (headPosition.y / Div) - 1.f), ImVec2(pos.x, pos.y + headPosition.y - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//|

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T96[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv735[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv733[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv731[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv735[rsp]
	mov	r8, QWORD PTR tv733[rsp]
	mov	rdx, QWORD PTR tv731[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1081 : 
; 1082 : 
; 1083 :     AddLine(ImVec2(pos.x + 1.f, pos.y + headPosition.y), ImVec2(pos.x + (headPosition.x / Div) + 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T97[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv775[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv773[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T34[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv771[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv775[rsp]
	mov	r8, QWORD PTR tv773[rsp]
	mov	rdx, QWORD PTR tv771[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1084 :     AddLine(ImVec2(pos.x - 1.f, pos.y + headPosition.y), ImVec2(pos.x + (headPosition.x / Div) - 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T98[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv815[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T35[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv813[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T36[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv811[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv815[rsp]
	mov	r8, QWORD PTR tv813[rsp]
	mov	rdx, QWORD PTR tv811[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1085 :     AddLine(ImVec2(pos.x, pos.y + headPosition.y + 1.f), ImVec2(pos.x + (headPosition.x / Div), pos.y + headPosition.y + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T99[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv855[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv853[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv851[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv855[rsp]
	mov	r8, QWORD PTR tv853[rsp]
	mov	rdx, QWORD PTR tv851[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1086 :     AddLine(ImVec2(pos.x, pos.y + headPosition.y - 1.f), ImVec2(pos.x + (headPosition.x / Div), pos.y + headPosition.y - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T100[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv927[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T39[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv925[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv923[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv927[rsp]
	mov	r8, QWORD PTR tv925[rsp]
	mov	rdx, QWORD PTR tv923[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1087 : 
; 1088 : 
; 1089 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div) + 1.f, pos.y + headPosition.y), ImVec2(pos.x + headPosition.x + 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T101[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv971[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv969[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv967[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv971[rsp]
	mov	r8, QWORD PTR tv969[rsp]
	mov	rdx, QWORD PTR tv967[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1090 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div) - 1.f, pos.y + headPosition.y), ImVec2(pos.x + headPosition.x - 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T102[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1015[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T43[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1013[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T44[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1011[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1015[rsp]
	mov	r8, QWORD PTR tv1013[rsp]
	mov	rdx, QWORD PTR tv1011[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1091 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div), pos.y + headPosition.y + 1.f), ImVec2(pos.x + headPosition.x, pos.y + headPosition.y + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T103[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1059[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1057[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T46[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1055[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1059[rsp]
	mov	r8, QWORD PTR tv1057[rsp]
	mov	rdx, QWORD PTR tv1055[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1092 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div), pos.y + headPosition.y - 1.f), ImVec2(pos.x + headPosition.x, pos.y + headPosition.y - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);//

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T104[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1103[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T47[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1101[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T48[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1099[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1103[rsp]
	mov	r8, QWORD PTR tv1101[rsp]
	mov	rdx, QWORD PTR tv1099[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1093 : 
; 1094 : 
; 1095 :     AddLine(ImVec2(pos.x + headPosition.x + 1.f, pos.y), ImVec2(pos.x + headPosition.x + 1.f, pos.y + (headPosition.y / Div)), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T105[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1143[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T49[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1141[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T50[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1139[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1143[rsp]
	mov	r8, QWORD PTR tv1141[rsp]
	mov	rdx, QWORD PTR tv1139[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1096 :     AddLine(ImVec2(pos.x + headPosition.x - 1.f, pos.y), ImVec2(pos.x + headPosition.x - 1.f, pos.y + (headPosition.y / Div)), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T106[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1183[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T51[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1181[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T52[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1179[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1183[rsp]
	mov	r8, QWORD PTR tv1181[rsp]
	mov	rdx, QWORD PTR tv1179[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1097 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y + 1.f), ImVec2(pos.x + headPosition.x, pos.y + (headPosition.y / Div) + 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T107[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1223[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T53[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1221[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T54[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1219[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1223[rsp]
	mov	r8, QWORD PTR tv1221[rsp]
	mov	rdx, QWORD PTR tv1219[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1098 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y - 1.f), ImVec2(pos.x + headPosition.x, pos.y + (headPosition.y / Div) - 1.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T108[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1263[rsp], eax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T55[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1261[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T56[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1259[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1263[rsp]
	mov	r8, QWORD PTR tv1261[rsp]
	mov	rdx, QWORD PTR tv1259[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1099 : 
; 1100 : 
; 1101 :     AddLine(ImVec2(pos.x + headPosition.x + 1.f, pos.y + headPosition.y - (headPosition.y / Div)), ImVec2(pos.x + headPosition.x + 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T109[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1307[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T57[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1305[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T58[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1303[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1307[rsp]
	mov	r8, QWORD PTR tv1305[rsp]
	mov	rdx, QWORD PTR tv1303[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1102 :     AddLine(ImVec2(pos.x + headPosition.x - 1.f, pos.y + headPosition.y - (headPosition.y / Div)), ImVec2(pos.x + headPosition.x - 1.f, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T110[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1383[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T59[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1381[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T60[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1379[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1383[rsp]
	mov	r8, QWORD PTR tv1381[rsp]
	mov	rdx, QWORD PTR tv1379[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1103 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y + headPosition.y - (headPosition.y / Div) + 1.f), ImVec2(pos.x + headPosition.x, pos.y + headPosition.y + 2.f), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T111[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1427[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T61[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1425[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T62[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1423[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1427[rsp]
	mov	r8, QWORD PTR tv1425[rsp]
	mov	rdx, QWORD PTR tv1423[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1104 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y + headPosition.y - (headPosition.y / Div) - 1.f), ImVec2(pos.x + headPosition.x, pos.y + headPosition.y), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), Siz);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T112[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv1470[rsp], eax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T63[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1468[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T64[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1466[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv1470[rsp]
	mov	r8, QWORD PTR tv1468[rsp]
	mov	rdx, QWORD PTR tv1466[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1105 : 
; 1106 : 
; 1107 :     AddLine(ImVec2(pos.x, pos.y), ImVec2(pos.x + (headPosition.x / Div), pos.y), color, Siz);//--

	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T65[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1494[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T66[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1492[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1494[rsp]
	mov	rdx, QWORD PTR tv1492[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1108 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y), ImVec2(pos.x + headPosition.x - (headPosition.x / Div), pos.y), color, Siz);//--

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	subss	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T67[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1522[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T68[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1520[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1522[rsp]
	mov	rdx, QWORD PTR tv1520[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1109 : 
; 1110 :     AddLine(ImVec2(pos.x, pos.y), ImVec2(pos.x, pos.y + (headPosition.y / Div)), color, Siz);//|

	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T69[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1546[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T70[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1544[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1546[rsp]
	mov	rdx, QWORD PTR tv1544[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1111 :     AddLine(ImVec2(pos.x, pos.y + headPosition.y - (headPosition.y / Div)), ImVec2(pos.x, pos.y + headPosition.y), color, Siz);//|

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T71[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1574[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T72[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1572[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1574[rsp]
	mov	rdx, QWORD PTR tv1572[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1112 : 
; 1113 :     AddLine(ImVec2(pos.x, pos.y + headPosition.y), ImVec2(pos.x + (headPosition.x / Div), pos.y + headPosition.y), color, Siz);//

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T73[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1602[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T74[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1600[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1602[rsp]
	mov	rdx, QWORD PTR tv1600[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1114 :     AddLine(ImVec2(pos.x + headPosition.x - (headPosition.x / Div), pos.y + headPosition.y), ImVec2(pos.x + headPosition.x, pos.y + headPosition.y), color, Siz);//

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T75[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1634[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	divss	xmm1, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T76[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1632[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1634[rsp]
	mov	rdx, QWORD PTR tv1632[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1115 : 
; 1116 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y), ImVec2(pos.x + headPosition.x, pos.y + (headPosition.y / Div)), color, Siz);

	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T77[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1662[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T78[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1660[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1662[rsp]
	mov	rdx, QWORD PTR tv1660[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1117 :     AddLine(ImVec2(pos.x + headPosition.x, pos.y + headPosition.y - (headPosition.y / Div)), ImVec2(pos.x + headPosition.x, pos.y + headPosition.y + 1), color, Siz);

	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T79[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1695[rsp], rax
	mov	rax, QWORD PTR headPosition$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	divss	xmm0, DWORD PTR Div$[rsp]
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR headPosition$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T80[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1693[rsp], rax
	movss	xmm0, DWORD PTR Siz$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR color$[rsp]
	mov	r8, QWORD PTR tv1695[rsp]
	mov	rdx, QWORD PTR tv1693[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1118 : }

	add	rsp, 1976				; 000007b8H
	ret	0
?DrawBox_S@ImDrawList@@QEAAXAEBUImVec2@@0IMM@Z ENDP	; ImDrawList::DrawBox_S
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?PopTextureID@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PopTextureID

; 518  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 519  :     IM_ASSERT(_TextureIdStack.Size > 0);
; 520  :     _TextureIdStack.pop_back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?pop_back@?$ImVector@PEAX@@QEAAXXZ	; ImVector<void *>::pop_back

; 521  :     UpdateTextureID();

	mov	rcx, QWORD PTR this$[rsp]
	call	?UpdateTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::UpdateTextureID
	npad	1

; 522  : }

	add	rsp, 40					; 00000028H
	ret	0
?PopTextureID@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PopTextureID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv68 = 32
this$ = 64
texture_id$ = 72
?PushTextureID@ImDrawList@@QEAAXPEAX@Z PROC		; ImDrawList::PushTextureID

; 512  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 513  :     _TextureIdStack.push_back(texture_id);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	QWORD PTR tv68[rsp], rax
	lea	rdx, QWORD PTR texture_id$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	call	?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z ; ImVector<void *>::push_back

; 514  :     UpdateTextureID();

	mov	rcx, QWORD PTR this$[rsp]
	call	?UpdateTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::UpdateTextureID
	npad	1

; 515  : }

	add	rsp, 56					; 00000038H
	ret	0
?PushTextureID@ImDrawList@@QEAAXPEAX@Z ENDP		; ImDrawList::PushTextureID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?PopClipRect@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PopClipRect

; 505  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 506  :     IM_ASSERT(_ClipRectStack.Size > 0);
; 507  :     _ClipRectStack.pop_back();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ	; ImVector<ImVec4>::pop_back

; 508  :     UpdateClipRect();

	mov	rcx, QWORD PTR this$[rsp]
	call	?UpdateClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::UpdateClipRect
	npad	1

; 509  : }

	add	rsp, 40					; 00000028H
	ret	0
?PopClipRect@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PopClipRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
$T4 = 56
this$ = 80
?PushClipRectFullScreen@ImDrawList@@QEAAXXZ PROC	; ImDrawList::PushClipRectFullScreen

; 500  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 501  :     PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	movss	xmm2, DWORD PTR [rax+36]
	movss	xmm1, DWORD PTR [rcx+32]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	movss	xmm2, DWORD PTR [rax+28]
	movss	xmm1, DWORD PTR [rcx+24]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z ; ImDrawList::PushClipRect
	npad	1

; 502  : }

	add	rsp, 72					; 00000048H
	ret	0
?PushClipRectFullScreen@ImDrawList@@QEAAXXZ ENDP	; ImDrawList::PushClipRectFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv130 = 48
cr$ = 56
current$1 = 72
this$ = 128
cr_min$ = 136
cr_max$ = 144
intersect_with_current_clip_rect$ = 152
?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z PROC	; ImDrawList::PushClipRect

; 482  : {

$LN8:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 483  :     ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);

	movss	xmm0, DWORD PTR cr_max$[rsp+4]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR cr_max$[rsp]
	movss	xmm2, DWORD PTR cr_min$[rsp+4]
	movss	xmm1, DWORD PTR cr_min$[rsp]
	lea	rcx, QWORD PTR cr$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	npad	1

; 484  :     if (intersect_with_current_clip_rect && _ClipRectStack.Size)

	movzx	eax, BYTE PTR intersect_with_current_clip_rect$[rsp]
	test	eax, eax
	je	$LN2@PushClipRe
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+120], 0
	je	$LN2@PushClipRe

; 485  :     {
; 486  :         ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size - 1];

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+120]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+128]
	lea	rdx, QWORD PTR current$1[rsp]
	mov	rdi, rdx
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 487  :         if (cr.x < current.x) cr.x = current.x;

	movss	xmm0, DWORD PTR current$1[rsp]
	comiss	xmm0, DWORD PTR cr$[rsp]
	jbe	SHORT $LN3@PushClipRe
	movss	xmm0, DWORD PTR current$1[rsp]
	movss	DWORD PTR cr$[rsp], xmm0
$LN3@PushClipRe:

; 488  :         if (cr.y < current.y) cr.y = current.y;

	movss	xmm0, DWORD PTR current$1[rsp+4]
	comiss	xmm0, DWORD PTR cr$[rsp+4]
	jbe	SHORT $LN4@PushClipRe
	movss	xmm0, DWORD PTR current$1[rsp+4]
	movss	DWORD PTR cr$[rsp+4], xmm0
$LN4@PushClipRe:

; 489  :         if (cr.z > current.z) cr.z = current.z;

	movss	xmm0, DWORD PTR cr$[rsp+8]
	comiss	xmm0, DWORD PTR current$1[rsp+8]
	jbe	SHORT $LN5@PushClipRe
	movss	xmm0, DWORD PTR current$1[rsp+8]
	movss	DWORD PTR cr$[rsp+8], xmm0
$LN5@PushClipRe:

; 490  :         if (cr.w > current.w) cr.w = current.w;

	movss	xmm0, DWORD PTR cr$[rsp+12]
	comiss	xmm0, DWORD PTR current$1[rsp+12]
	jbe	SHORT $LN6@PushClipRe
	movss	xmm0, DWORD PTR current$1[rsp+12]
	movss	DWORD PTR cr$[rsp+12], xmm0
$LN6@PushClipRe:
$LN2@PushClipRe:

; 491  :     }
; 492  :     cr.z = ImMax(cr.x, cr.z);

	movss	xmm1, DWORD PTR cr$[rsp+8]
	movss	xmm0, DWORD PTR cr$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR cr$[rsp+8], xmm0

; 493  :     cr.w = ImMax(cr.y, cr.w);

	movss	xmm1, DWORD PTR cr$[rsp+12]
	movss	xmm0, DWORD PTR cr$[rsp+4]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR cr$[rsp+12], xmm0

; 494  : 
; 495  :     _ClipRectStack.push_back(cr);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv130[rsp], rax
	lea	rdx, QWORD PTR cr$[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ; ImVector<ImVec4>::push_back

; 496  :     UpdateClipRect();

	mov	rcx, QWORD PTR this$[rsp]
	call	?UpdateClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::UpdateClipRect
	npad	1

; 497  : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z ENDP	; ImDrawList::PushClipRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z
_TEXT	SEGMENT
this$ = 48
shared_data$ = 56
??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z PROC	; ImDrawList::ImDrawList, COMDAT

; 1855 : 	ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::ImVector<ImDrawVert>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??0?$ImVector@UImDrawChannel@@@@QEAA@XZ	; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	rcx, rax
	call	??0?$ImVector@UImVec4@@@@QEAA@XZ	; ImVector<ImVec4>::ImVector<ImVec4>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	??0?$ImVector@PEAX@@QEAA@XZ		; ImVector<void *>::ImVector<void *>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	??0?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::ImVector<ImVec2>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR shared_data$[rsp]
	mov	QWORD PTR [rax+72], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0
	mov	rcx, QWORD PTR this$[rsp]
	call	?Clear@ImDrawList@@QEAAXXZ		; ImDrawList::Clear
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z ENDP	; ImDrawList::ImDrawList
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UImDrawVert@@@@QEAA@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ	; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 120				; 00000078H
	call	??1?$ImVector@UImVec4@@@@QEAA@XZ	; ImVector<ImVec4>::~ImVector<ImVec4>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 136				; 00000088H
	call	??1?$ImVector@PEAX@@QEAA@XZ		; ImVector<void *>::~ImVector<void *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
shared_data$ = 56
?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA PROC ; `ImDrawList::ImDrawList'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	??1?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::~ImVector<ImVec2>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z@4HA ENDP ; `ImDrawList::ImDrawList'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z PROC ; ImVector<ImVec2>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ; ImVector<ImVec2>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ENDP ; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec2@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImVec2@@@@QEAAXH@Z PROC		; ImVector<ImVec2>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ; ImVector<ImVec2>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImVec2@@@@QEAAXH@Z ENDP		; ImVector<ImVec2>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec2@@@@QEAAAEAUImVec2@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImVec2@@@@QEAAAEAUImVec2@@XZ PROC	; ImVector<ImVec2>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
?back@?$ImVector@UImVec2@@@@QEAAAEAUImVec2@@XZ ENDP	; ImVector<ImVec2>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec2@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImVec2@@@@QEAAXXZ PROC		; ImVector<ImVec2>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImVec2@@@@QEAAXXZ ENDP		; ImVector<ImVec2>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec2@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImVec2@@@@QEAA@XZ PROC			; ImVector<ImVec2>::~ImVector<ImVec2>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImVec2@@@@QEAA@XZ ENDP			; ImVector<ImVec2>::~ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec2@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImVec2@@@@QEAA@XZ PROC			; ImVector<ImVec2>::ImVector<ImVec2>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImVec2@@@@QEAA@XZ ENDP			; ImVector<ImVec2>::ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PEAX@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@PEAX@@QEAAXXZ PROC			; ImVector<void *>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@PEAX@@QEAAXXZ ENDP			; ImVector<void *>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z PROC		; ImVector<void *>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z ; ImVector<void *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z ENDP		; ImVector<void *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAX@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@PEAX@@QEAAXH@Z PROC			; ImVector<void *>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@PEAX@@QEAAXH@Z ENDP			; ImVector<void *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PEAX@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@PEAX@@QEAAXH@Z PROC			; ImVector<void *>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z ; ImVector<void *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@PEAX@@QEAAXH@Z ENDP			; ImVector<void *>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z PROC		; ImVector<void *>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z ENDP		; ImVector<void *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ PROC		; ImVector<void *>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
?back@?$ImVector@PEAX@@QEAAAEAPEAXXZ ENDP		; ImVector<void *>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAX@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAX@@QEAAXXZ PROC			; ImVector<void *>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@PEAX@@QEAAXXZ ENDP			; ImVector<void *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PEAX@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@PEAX@@QEBA_NXZ PROC			; ImVector<void *>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@PEAX@@QEBA_NXZ ENDP			; ImVector<void *>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@PEAX@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@PEAX@@QEAA@XZ PROC			; ImVector<void *>::~ImVector<void *>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@PEAX@@QEAA@XZ ENDP			; ImVector<void *>::~ImVector<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@PEAX@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@PEAX@@QEAA@XZ PROC			; ImVector<void *>::ImVector<void *>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@PEAX@@QEAA@XZ ENDP			; ImVector<void *>::ImVector<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ PROC		; ImVector<ImVec4>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ ENDP		; ImVector<ImVec4>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z PROC ; ImVector<ImVec4>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z ; ImVector<ImVec4>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 16
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ENDP ; ImVector<ImVec4>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z PROC		; ImVector<ImVec4>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 16
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 16
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ENDP		; ImVector<ImVec4>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec4@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImVec4@@@@QEAAXH@Z PROC		; ImVector<ImVec4>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z ; ImVector<ImVec4>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImVec4@@@@QEAAXH@Z ENDP		; ImVector<ImVec4>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z PROC	; ImVector<ImVec4>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z ENDP	; ImVector<ImVec4>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ PROC	; ImVector<ImVec4>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ENDP	; ImVector<ImVec4>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec4@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImVec4@@@@QEAAXXZ PROC		; ImVector<ImVec4>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImVec4@@@@QEAAXXZ ENDP		; ImVector<ImVec4>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec4@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImVec4@@@@QEAA@XZ PROC			; ImVector<ImVec4>::~ImVector<ImVec4>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImVec4@@@@QEAA@XZ ENDP			; ImVector<ImVec4>::~ImVector<ImVec4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec4@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImVec4@@@@QEAA@XZ PROC			; ImVector<ImVec4>::ImVector<ImVec4>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImVec4@@@@QEAA@XZ ENDP			; ImVector<ImVec4>::ImVector<ImVec4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z PROC	; ImVector<ImDrawChannel>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ENDP	; ImVector<ImDrawChannel>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z PROC	; ImVector<ImDrawChannel>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ENDP	; ImVector<ImDrawChannel>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z PROC ; ImVector<ImDrawChannel>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ENDP ; ImVector<ImDrawChannel>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ PROC	; ImVector<ImDrawChannel>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImDrawChannel@@@@QEAAXXZ ENDP	; ImVector<ImDrawChannel>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z PROC ; ImVector<ImDrawChannel>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ENDP ; ImVector<ImDrawChannel>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImDrawChannel@@@@QEAA@XZ PROC		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImDrawChannel@@@@QEAA@XZ ENDP		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawChannel@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImDrawChannel@@@@QEAA@XZ PROC		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImDrawChannel@@@@QEAA@XZ ENDP		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z PROC	; ImVector<ImDrawVert>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 20
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 20
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ENDP	; ImVector<ImDrawVert>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z PROC		; ImVector<ImDrawVert>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ; ImVector<ImDrawVert>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ENDP		; ImVector<ImDrawVert>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z PROC	; ImVector<ImDrawVert>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ENDP	; ImVector<ImDrawVert>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z
_TEXT	SEGMENT
rhs_size$ = 0
rhs_cap$ = 4
rhs_data$ = 8
this$ = 32
rhs$ = 40
?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z PROC	; ImVector<ImDrawVert>::swap, COMDAT

; 1240 : 	inline void         swap(ImVector<T>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR rhs$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR rhs_size$[rsp], eax
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR rhs_size$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR rhs$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR rhs_cap$[rsp], eax
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+4], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR rhs_cap$[rsp]
	mov	DWORD PTR [rax+4], ecx
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR rhs_data$[rsp], rax
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR rhs_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	add	rsp, 24
	ret	0
?swap@?$ImVector@UImDrawVert@@@@QEAAXAEAU1@@Z ENDP	; ImVector<ImDrawVert>::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ PROC		; ImVector<ImDrawVert>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ ENDP		; ImVector<ImDrawVert>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z PROC ; ImVector<ImDrawVert>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawVert@@@@QEAAAEAUImDrawVert@@H@Z ENDP ; ImVector<ImDrawVert>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawVert@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImDrawVert@@@@QEAA@XZ PROC		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImDrawVert@@@@QEAA@XZ ENDP		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z PROC	; ImVector<ImDrawVert>::operator=, COMDAT

; 1221 : 	inline ImVector<T>& operator=(const ImVector<T>& src) { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ ; ImVector<ImDrawVert>::clear
	mov	rax, QWORD PTR src$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::resize
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 20
	mov	r8, rax
	mov	rax, QWORD PTR src$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4?$ImVector@UImDrawVert@@@@QEAAAEAU0@AEBU0@@Z ENDP	; ImVector<ImDrawVert>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawVert@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImDrawVert@@@@QEAA@XZ PROC		; ImVector<ImDrawVert>::ImVector<ImDrawVert>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImDrawVert@@@@QEAA@XZ ENDP		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImDrawChannel@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImDrawChannel@@QEAA@XZ PROC				; ImDrawChannel::ImDrawChannel, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::ImVector<unsigned short>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImDrawChannel@@QEAA@XZ ENDP				; ImDrawChannel::ImDrawChannel
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA PROC		; `ImDrawChannel::ImDrawChannel'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@UImDrawCmd@@@@QEAA@XZ	; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImDrawChannel@@QEAA@XZ@4HA ENDP		; `ImDrawChannel::ImDrawChannel'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA PROC		; `ImDrawChannel::ImDrawChannel'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImDrawChannel@@QEAA@XZ@4HA ENDP		; `ImDrawChannel::ImDrawChannel'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ PROC		; ImVector<ImDrawCmd>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ENDP		; ImVector<ImDrawCmd>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z PROC ; ImVector<ImDrawCmd>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 48					; 00000030H
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImDrawCmd@@@@QEAAXAEBUImDrawCmd@@@Z ENDP ; ImVector<ImDrawCmd>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z PROC		; ImVector<ImDrawCmd>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ENDP		; ImVector<ImDrawCmd>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z PROC		; ImVector<ImDrawCmd>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ENDP		; ImVector<ImDrawCmd>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z PROC	; ImVector<ImDrawCmd>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImDrawCmd@@@@QEBAHH@Z ENDP	; ImVector<ImDrawCmd>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ PROC ; ImVector<ImDrawCmd>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ENDP ; ImVector<ImDrawCmd>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ PROC		; ImVector<ImDrawCmd>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ ENDP		; ImVector<ImDrawCmd>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawCmd@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImDrawCmd@@@@QEAA@XZ PROC		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImDrawCmd@@@@QEAA@XZ ENDP		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z PROC	; ImVector<ImDrawCmd>::operator=, COMDAT

; 1221 : 	inline ImVector<T>& operator=(const ImVector<T>& src) { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ	; ImVector<ImDrawCmd>::clear
	mov	rax, QWORD PTR src$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::resize
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 48				; 00000030H
	mov	r8, rax
	mov	rax, QWORD PTR src$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4?$ImVector@UImDrawCmd@@@@QEAAAEAU0@AEBU0@@Z ENDP	; ImVector<ImDrawCmd>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawCmd@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImDrawCmd@@@@QEAA@XZ PROC		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImDrawCmd@@@@QEAA@XZ ENDP		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImDrawCmd@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImDrawCmd@@QEAA@XZ PROC				; ImDrawCmd::ImDrawCmd, COMDAT

; 1773 : 	ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12
	mov	rcx, rax
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+24], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImDrawCmd@@QEAA@XZ ENDP				; ImDrawCmd::ImDrawCmd
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??3@YAXPEAXUImNewDummy@@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
__formal$ = 24
??3@YAXPEAXUImNewDummy@@0@Z PROC			; operator delete, COMDAT

; 1563 : inline void  operator delete(void*, ImNewDummy, void*) {} // This is only required so we can use the symetrical new()

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	ret	0
??3@YAXPEAXUImNewDummy@@0@Z ENDP			; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??2@YAPEAX_KUImNewDummy@@PEAX@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
ptr$ = 24
??2@YAPEAX_KUImNewDummy@@PEAX@Z PROC			; operator new, COMDAT

; 1562 : inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR ptr$[rsp]
	ret	0
??2@YAPEAX_KUImNewDummy@@PEAX@Z ENDP			; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@G@@QEAAXAEBG@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@G@@QEAAXAEBG@Z PROC		; ImVector<unsigned short>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@G@@QEBAHH@Z	; ImVector<unsigned short>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	r8d, 2
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@G@@QEAAXAEBG@Z ENDP		; ImVector<unsigned short>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 1
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXHAEBG@Z
_TEXT	SEGMENT
n$1 = 32
this$ = 64
new_size$ = 72
v$ = 80
?resize@?$ImVector@G@@QEAAXHAEBG@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 1244 : 	inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN5@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@G@@QEBAHH@Z	; ImVector<unsigned short>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	npad	1
$LN5@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN6@resize
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR n$1[rsp], eax
	jmp	SHORT $LN4@resize
$LN2@resize:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@resize:
	mov	eax, DWORD PTR new_size$[rsp]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@resize
	movsxd	rax, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	r8d, 2
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	npad	1
	jmp	SHORT $LN2@resize
$LN3@resize:
$LN6@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 56					; 00000038H
	ret	0
?resize@?$ImVector@G@@QEAAXHAEBG@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@G@@QEBAHH@Z	; ImVector<unsigned short>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@G@@QEBAHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@G@@QEBAHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@G@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@G@@QEAAXXZ PROC			; ImVector<unsigned short>::clear, COMDAT

; 1231 : 	inline void         clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@clear
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN2@clear:
	add	rsp, 40					; 00000028H
	ret	0
?clear@?$ImVector@G@@QEAAXXZ ENDP			; ImVector<unsigned short>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QEAAAEAGH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@G@@QEAAAEAGH@Z PROC			; ImVector<unsigned short>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	ret	0
??A?$ImVector@G@@QEAAAEAGH@Z ENDP			; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@G@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@G@@QEBA_NXZ PROC			; ImVector<unsigned short>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@G@@QEBA_NXZ ENDP			; ImVector<unsigned short>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@G@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@G@@QEAA@XZ PROC				; ImVector<unsigned short>::~ImVector<unsigned short>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@G@@QEAA@XZ ENDP				; ImVector<unsigned short>::~ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z PROC		; ImVector<unsigned short>::operator=, COMDAT

; 1221 : 	inline ImVector<T>& operator=(const ImVector<T>& src) { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$ImVector@G@@QEAAXXZ		; ImVector<unsigned short>::clear
	mov	rax, QWORD PTR src$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR src$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z ENDP		; ImVector<unsigned short>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@G@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@G@@QEAA@XZ PROC				; ImVector<unsigned short>::ImVector<unsigned short>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@G@@QEAA@XZ ENDP				; ImVector<unsigned short>::ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
colors$ = 48
tv66 = 56
style$ = 64
tv828 = 72
tv930 = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 200
$T9 = 216
$T10 = 232
$T11 = 248
$T12 = 264
$T13 = 280
$T14 = 296
$T15 = 312
$T16 = 328
$T17 = 344
$T18 = 360
$T19 = 376
$T20 = 392
$T21 = 408
$T22 = 424
$T23 = 440
$T24 = 456
$T25 = 472
$T26 = 488
$T27 = 504
$T28 = 520
$T29 = 536
$T30 = 552
$T31 = 568
$T32 = 584
$T33 = 600
$T34 = 616
$T35 = 632
$T36 = 648
$T37 = 664
$T38 = 680
$T39 = 696
$T40 = 712
$T41 = 728
$T42 = 744
$T43 = 760
$T44 = 776
$T45 = 792
$T46 = 808
dst$ = 864
?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsLight

; 287  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 840				; 00000348H

; 288  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

	cmp	QWORD PTR dst$[rsp], 0
	je	SHORT $LN3@StyleColor
	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@StyleColor
$LN3@StyleColor:
	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR tv66[rsp], rax
$LN4@StyleColor:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR style$[rsp], rax

; 289  :     ImVec4* colors = style->Colors;

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 168				; 000000a8H
	mov	QWORD PTR colors$[rsp], rax

; 290  : 
; 291  :     colors[ImGuiCol_Text] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 292  :     colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f19999a
	movss	xmm2, DWORD PTR __real@3f19999a
	movss	xmm1, DWORD PTR __real@3f19999a
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 293  :     colors[ImGuiCol_WindowBg] = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f70a3d7
	movss	xmm2, DWORD PTR __real@3f70a3d7
	movss	xmm1, DWORD PTR __real@3f70a3d7
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 294  :     colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 295  :     colors[ImGuiCol_PopupBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);

	movss	xmm0, DWORD PTR __real@3f7ae148
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 296  :     colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);

	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 297  :     colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 298  :     colors[ImGuiCol_FrameBg] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 299  :     colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 300  :     colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 301  :     colors[ImGuiCol_TitleBg] = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f75c28f
	movss	xmm2, DWORD PTR __real@3f75c28f
	movss	xmm1, DWORD PTR __real@3f75c28f
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 302  :     colors[ImGuiCol_TitleBgActive] = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f51eb85
	movss	xmm2, DWORD PTR __real@3f51eb85
	movss	xmm1, DWORD PTR __real@3f51eb85
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 303  :     colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);

	movss	xmm0, DWORD PTR __real@3f028f5c
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 304  :     colors[ImGuiCol_MenuBarBg] = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f5c28f6
	movss	xmm2, DWORD PTR __real@3f5c28f6
	movss	xmm1, DWORD PTR __real@3f5c28f6
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 305  :     colors[ImGuiCol_ScrollbarBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);

	movss	xmm0, DWORD PTR __real@3f07ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f7ae148
	movss	xmm1, DWORD PTR __real@3f7ae148
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 306  :     colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f30a3d7
	movss	xmm2, DWORD PTR __real@3f30a3d7
	movss	xmm1, DWORD PTR __real@3f30a3d7
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 307  :     colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3efae148
	movss	xmm2, DWORD PTR __real@3efae148
	movss	xmm1, DWORD PTR __real@3efae148
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 308  :     colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3efae148
	movss	xmm2, DWORD PTR __real@3efae148
	movss	xmm1, DWORD PTR __real@3efae148
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 309  :     colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 310  :     colors[ImGuiCol_SliderGrab] = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);

	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 311  :     colors[ImGuiCol_SliderGrabActive] = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3f0a3d71
	movss	xmm1, DWORD PTR __real@3eeb851f
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 312  :     colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 313  :     colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 314  :     colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f07ae14
	movss	xmm1, DWORD PTR __real@3d75c28f
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 315  :     colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);

	movss	xmm0, DWORD PTR __real@3e9eb852
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 316  :     colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 317  :     colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 318  :     colors[ImGuiCol_Separator] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ec7ae14
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ec7ae14
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 319  :     colors[ImGuiCol_SeparatorHovered] = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);

	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ee147ae
	movss	xmm1, DWORD PTR __real@3e0f5c29
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 320  :     colors[ImGuiCol_SeparatorActive] = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ee147ae
	movss	xmm1, DWORD PTR __real@3e0f5c29
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 321  :     colors[ImGuiCol_ResizeGrip] = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);

	movss	xmm0, DWORD PTR __real@3f0f5c29
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR __real@3f4ccccd
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 322  :     colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 323  :     colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 324  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.90f);

	mov	eax, 16
	imul	rax, rax, 11
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f666666
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T34[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 33				; 00000021H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 325  :     colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];

	mov	eax, 16
	imul	rax, rax, 25
	mov	ecx, 16
	imul	rcx, rcx, 34				; 00000022H
	mov	rdx, QWORD PTR colors$[rsp]
	mov	rdi, QWORD PTR colors$[rsp]
	mov	QWORD PTR tv828[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv828[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 326  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

	mov	eax, 16
	imul	rax, rax, 11
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f19999a
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T35[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 35				; 00000023H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 327  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

	mov	eax, 16
	imul	rax, rax, 10
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 33				; 00000021H
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f4ccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T36[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 36				; 00000024H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 328  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

	mov	eax, 16
	imul	rax, rax, 10
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 35				; 00000023H
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3ecccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T37[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 37				; 00000025H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 329  :     colors[ImGuiCol_PlotLines] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ec7ae14
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ec7ae14
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 38				; 00000026H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 330  :     colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3eb33333
	movss	xmm2, DWORD PTR __real@3edc28f6
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T39[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 39				; 00000027H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 331  :     colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR __real@3f666666
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 40				; 00000028H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 332  :     colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3ee66666
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 41				; 00000029H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 333  :     colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 42				; 0000002aH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 334  :     colors[ImGuiCol_DragDropTarget] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T43[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 43				; 0000002bH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 335  :     colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];

	mov	eax, 16
	imul	rax, rax, 25
	mov	ecx, 16
	imul	rcx, rcx, 44				; 0000002cH
	mov	rdx, QWORD PTR colors$[rsp]
	mov	rdi, QWORD PTR colors$[rsp]
	mov	QWORD PTR tv930[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv930[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 336  :     colors[ImGuiCol_NavWindowingHighlight] = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f333333
	movss	xmm2, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR __real@3f333333
	lea	rcx, QWORD PTR $T44[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 45				; 0000002dH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 337  :     colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);

	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e4ccccd
	movss	xmm2, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3e4ccccd
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 46				; 0000002eH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 338  :     colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e4ccccd
	movss	xmm2, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3e4ccccd
	lea	rcx, QWORD PTR $T46[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 47				; 0000002fH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 339  : }

	add	rsp, 840				; 00000348H
	pop	rdi
	pop	rsi
	ret	0
?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
colors$ = 48
tv66 = 56
style$ = 64
tv860 = 72
tv930 = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 200
$T9 = 216
$T10 = 232
$T11 = 248
$T12 = 264
$T13 = 280
$T14 = 296
$T15 = 312
$T16 = 328
$T17 = 344
$T18 = 360
$T19 = 376
$T20 = 392
$T21 = 408
$T22 = 424
$T23 = 440
$T24 = 456
$T25 = 472
$T26 = 488
$T27 = 504
$T28 = 520
$T29 = 536
$T30 = 552
$T31 = 568
$T32 = 584
$T33 = 600
$T34 = 616
$T35 = 632
$T36 = 648
$T37 = 664
$T38 = 680
$T39 = 696
$T40 = 712
$T41 = 728
$T42 = 744
$T43 = 760
$T44 = 776
$T45 = 792
$T46 = 808
dst$ = 864
?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsClassic

; 231  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 840				; 00000348H

; 232  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

	cmp	QWORD PTR dst$[rsp], 0
	je	SHORT $LN3@StyleColor
	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@StyleColor
$LN3@StyleColor:
	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR tv66[rsp], rax
$LN4@StyleColor:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR style$[rsp], rax

; 233  :     ImVec4* colors = style->Colors;

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 168				; 000000a8H
	mov	QWORD PTR colors$[rsp], rax

; 234  : 
; 235  :     colors[ImGuiCol_Text] = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f666666
	movss	xmm2, DWORD PTR __real@3f666666
	movss	xmm1, DWORD PTR __real@3f666666
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 236  :     colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f19999a
	movss	xmm2, DWORD PTR __real@3f19999a
	movss	xmm1, DWORD PTR __real@3f19999a
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 237  :     colors[ImGuiCol_WindowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 238  :     colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 239  :     colors[ImGuiCol_PopupBg] = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);

	movss	xmm0, DWORD PTR __real@3f6b851f
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e0f5c29
	movss	xmm2, DWORD PTR __real@3de147ae
	movss	xmm1, DWORD PTR __real@3de147ae
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 240  :     colors[ImGuiCol_Border] = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 241  :     colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 242  :     colors[ImGuiCol_FrameBg] = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);

	movss	xmm0, DWORD PTR __real@3ec7ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3edc28f6
	movss	xmm2, DWORD PTR __real@3edc28f6
	movss	xmm1, DWORD PTR __real@3edc28f6
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 243  :     colors[ImGuiCol_FrameBgHovered] = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);

	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f30a3d7
	movss	xmm2, DWORD PTR __real@3ef0a3d7
	movss	xmm1, DWORD PTR __real@3ef0a3d7
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 244  :     colors[ImGuiCol_FrameBgActive] = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);

	movss	xmm0, DWORD PTR __real@3f30a3d7
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f23d70a
	movss	xmm2, DWORD PTR __real@3ed1eb85
	movss	xmm1, DWORD PTR __real@3ed70a3d
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 245  :     colors[ImGuiCol_TitleBg] = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);

	movss	xmm0, DWORD PTR __real@3f547ae1
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f0a3d71
	movss	xmm2, DWORD PTR __real@3e8a3d71
	movss	xmm1, DWORD PTR __real@3e8a3d71
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 246  :     colors[ImGuiCol_TitleBgActive] = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);

	movss	xmm0, DWORD PTR __real@3f5eb852
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f2147ae
	movss	xmm2, DWORD PTR __real@3ea3d70a
	movss	xmm1, DWORD PTR __real@3ea3d70a
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 247  :     colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);

	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3ecccccd
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 248  :     colors[ImGuiCol_MenuBarBg] = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f0ccccd
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3ecccccd
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 249  :     colors[ImGuiCol_ScrollbarBg] = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e99999a
	movss	xmm2, DWORD PTR __real@3e800000
	movss	xmm1, DWORD PTR __real@3e4ccccd
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 250  :     colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);

	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3ecccccd
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 251  :     colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);

	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3ecccccd
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 252  :     colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ed1eb85
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 253  :     colors[ImGuiCol_CheckMark] = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f666666
	movss	xmm2, DWORD PTR __real@3f666666
	movss	xmm1, DWORD PTR __real@3f666666
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 254  :     colors[ImGuiCol_SliderGrab] = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);

	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 255  :     colors[ImGuiCol_SliderGrabActive] = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ed1eb85
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 256  :     colors[ImGuiCol_Button] = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);

	movss	xmm0, DWORD PTR __real@3f1eb852
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f1c28f6
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3eb33333
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 257  :     colors[ImGuiCol_ButtonHovered] = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);

	movss	xmm0, DWORD PTR __real@3f4a3d71
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f35c28f
	movss	xmm2, DWORD PTR __real@3ef5c28f
	movss	xmm1, DWORD PTR __real@3ecccccd
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 258  :     colors[ImGuiCol_ButtonActive] = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3f0a3d71
	movss	xmm1, DWORD PTR __real@3eeb851f
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 259  :     colors[ImGuiCol_Header] = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);

	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f666666
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3ecccccd
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 260  :     colors[ImGuiCol_HeaderHovered] = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f666666
	movss	xmm2, DWORD PTR __real@3ee66666
	movss	xmm1, DWORD PTR __real@3ee66666
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 261  :     colors[ImGuiCol_HeaderActive] = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f5eb852
	movss	xmm2, DWORD PTR __real@3f07ae14
	movss	xmm1, DWORD PTR __real@3f07ae14
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 262  :     colors[ImGuiCol_Separator] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 263  :     colors[ImGuiCol_SeparatorHovered] = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f333333
	movss	xmm2, DWORD PTR __real@3f19999a
	movss	xmm1, DWORD PTR __real@3f19999a
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 264  :     colors[ImGuiCol_SeparatorActive] = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f666666
	movss	xmm2, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR __real@3f333333
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 265  :     colors[ImGuiCol_ResizeGrip] = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);

	movss	xmm0, DWORD PTR __real@3e23d70a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 266  :     colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f51eb85
	movss	xmm1, DWORD PTR __real@3f47ae14
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 267  :     colors[ImGuiCol_ResizeGripActive] = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f51eb85
	movss	xmm1, DWORD PTR __real@3f47ae14
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 268  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);

	mov	eax, 16
	imul	rax, rax, 11
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f4ccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T34[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 33				; 00000021H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 269  :     colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];

	mov	eax, 16
	imul	rax, rax, 25
	mov	ecx, 16
	imul	rcx, rcx, 34				; 00000022H
	mov	rdx, QWORD PTR colors$[rsp]
	mov	rdi, QWORD PTR colors$[rsp]
	mov	QWORD PTR tv860[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv860[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 270  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

	mov	eax, 16
	imul	rax, rax, 11
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f19999a
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T35[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 35				; 00000023H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 271  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

	mov	eax, 16
	imul	rax, rax, 10
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 33				; 00000021H
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f4ccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T36[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 36				; 00000024H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 272  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

	mov	eax, 16
	imul	rax, rax, 10
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 35				; 00000023H
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3ecccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T37[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 37				; 00000025H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 273  :     colors[ImGuiCol_PlotLines] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 38				; 00000026H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 274  :     colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR __real@3f666666
	lea	rcx, QWORD PTR $T39[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 39				; 00000027H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 275  :     colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR __real@3f666666
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 40				; 00000028H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 276  :     colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f19999a
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 41				; 00000029H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 277  :     colors[ImGuiCol_TextSelectedBg] = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 42				; 0000002aH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 278  :     colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T43[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 43				; 0000002bH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 279  :     colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];

	mov	eax, 16
	imul	rax, rax, 25
	mov	ecx, 16
	imul	rcx, rcx, 44				; 0000002cH
	mov	rdx, QWORD PTR colors$[rsp]
	mov	rdi, QWORD PTR colors$[rsp]
	mov	QWORD PTR tv930[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv930[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 280  :     colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T44[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 45				; 0000002dH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 281  :     colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);

	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR __real@3f4ccccd
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 46				; 0000002eH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 282  :     colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e4ccccd
	movss	xmm2, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3e4ccccd
	lea	rcx, QWORD PTR $T46[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 47				; 0000002fH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 283  : }

	add	rsp, 840				; 00000348H
	pop	rdi
	pop	rsi
	ret	0
?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsClassic
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
colors$ = 48
tv66 = 56
style$ = 64
tv783 = 72
tv829 = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 200
$T9 = 216
$T10 = 232
$T11 = 248
$T12 = 264
$T13 = 280
$T14 = 296
$T15 = 312
$T16 = 328
$T17 = 344
$T18 = 360
$T19 = 376
$T20 = 392
$T21 = 408
$T22 = 424
$T23 = 440
$T24 = 456
$T25 = 472
$T26 = 488
$T27 = 504
$T28 = 520
$T29 = 536
$T30 = 552
$T31 = 568
$T32 = 584
$T33 = 600
$T34 = 616
$T35 = 632
$T36 = 648
$T37 = 664
$T38 = 680
$T39 = 696
$T40 = 712
$T41 = 728
$T42 = 744
$T43 = 760
$T44 = 776
$T45 = 792
$T46 = 808
dst$ = 864
?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsDark

; 176  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 840				; 00000348H

; 177  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

	cmp	QWORD PTR dst$[rsp], 0
	je	SHORT $LN3@StyleColor
	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@StyleColor
$LN3@StyleColor:
	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR tv66[rsp], rax
$LN4@StyleColor:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR style$[rsp], rax

; 178  :     ImVec4* colors = style->Colors;

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 168				; 000000a8H
	mov	QWORD PTR colors$[rsp], rax

; 179  : 
; 180  :     colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 181  :     colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 182  :     colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);

	movss	xmm0, DWORD PTR __real@3f70a3d7
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3d75c28f
	movss	xmm2, DWORD PTR __real@3d75c28f
	movss	xmm1, DWORD PTR __real@3d75c28f
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 183  :     colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 184  :     colors[ImGuiCol_PopupBg] = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);

	movss	xmm0, DWORD PTR __real@3f70a3d7
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3da3d70a
	movss	xmm2, DWORD PTR __real@3da3d70a
	movss	xmm1, DWORD PTR __real@3da3d70a
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 185  :     colors[ImGuiCol_Border] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR __real@3edc28f6
	movss	xmm1, DWORD PTR __real@3edc28f6
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 186  :     colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 187  :     colors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);

	movss	xmm0, DWORD PTR __real@3f0a3d71
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ef5c28f
	movss	xmm2, DWORD PTR __real@3e947ae1
	movss	xmm1, DWORD PTR __real@3e23d70a
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 188  :     colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 189  :     colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 190  :     colors[ImGuiCol_TitleBg] = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3d23d70a
	movss	xmm2, DWORD PTR __real@3d23d70a
	movss	xmm1, DWORD PTR __real@3d23d70a
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 191  :     colors[ImGuiCol_TitleBgActive] = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ef5c28f
	movss	xmm2, DWORD PTR __real@3e947ae1
	movss	xmm1, DWORD PTR __real@3e23d70a
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 192  :     colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);

	movss	xmm0, DWORD PTR __real@3f028f5c
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 193  :     colors[ImGuiCol_MenuBarBg] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e0f5c29
	movss	xmm2, DWORD PTR __real@3e0f5c29
	movss	xmm1, DWORD PTR __real@3e0f5c29
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 194  :     colors[ImGuiCol_ScrollbarBg] = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);

	movss	xmm0, DWORD PTR __real@3f07ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ca3d70a
	movss	xmm2, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR __real@3ca3d70a
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 195  :     colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e9eb852
	movss	xmm2, DWORD PTR __real@3e9eb852
	movss	xmm1, DWORD PTR __real@3e9eb852
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 196  :     colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ed1eb85
	movss	xmm2, DWORD PTR __real@3ed1eb85
	movss	xmm1, DWORD PTR __real@3ed1eb85
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 197  :     colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f028f5c
	movss	xmm2, DWORD PTR __real@3f028f5c
	movss	xmm1, DWORD PTR __real@3f028f5c
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 198  :     colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 199  :     colors[ImGuiCol_SliderGrab] = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f6147ae
	movss	xmm2, DWORD PTR __real@3f051eb8
	movss	xmm1, DWORD PTR __real@3e75c28f
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 200  :     colors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 201  :     colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 202  :     colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 203  :     colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f07ae14
	movss	xmm1, DWORD PTR __real@3d75c28f
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 204  :     colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);

	movss	xmm0, DWORD PTR __real@3e9eb852
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 205  :     colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 206  :     colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 207  :     colors[ImGuiCol_Separator] = colors[ImGuiCol_Border];

	mov	eax, 16
	imul	rax, rax, 5
	mov	ecx, 16
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR colors$[rsp]
	mov	rdi, QWORD PTR colors$[rsp]
	mov	QWORD PTR tv783[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv783[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 208  :     colors[ImGuiCol_SeparatorHovered] = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);

	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f400000
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3dcccccd
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 209  :     colors[ImGuiCol_SeparatorActive] = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f400000
	movss	xmm2, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR __real@3dcccccd
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 210  :     colors[ImGuiCol_ResizeGrip] = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 211  :     colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 212  :     colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 213  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);

	mov	eax, 16
	imul	rax, rax, 11
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f4ccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T33[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 33				; 00000021H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 214  :     colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];

	mov	eax, 16
	imul	rax, rax, 25
	mov	ecx, 16
	imul	rcx, rcx, 34				; 00000022H
	mov	rdx, QWORD PTR colors$[rsp]
	mov	rdi, QWORD PTR colors$[rsp]
	mov	QWORD PTR tv829[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv829[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 16
	rep movsb

; 215  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

	mov	eax, 16
	imul	rax, rax, 11
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f19999a
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T34[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 35				; 00000023H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 216  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

	mov	eax, 16
	imul	rax, rax, 10
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 33				; 00000021H
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3f4ccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T35[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 36				; 00000024H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 217  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

	mov	eax, 16
	imul	rax, rax, 10
	mov	rcx, QWORD PTR colors$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 35				; 00000023H
	mov	rdx, QWORD PTR colors$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	xmm3, DWORD PTR __real@3ecccccd
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T36[rsp]
	call	?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z	; ImLerp
	mov	ecx, 16
	imul	rcx, rcx, 37				; 00000025H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 218  :     colors[ImGuiCol_PlotLines] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f1c28f6
	movss	xmm2, DWORD PTR __real@3f1c28f6
	movss	xmm1, DWORD PTR __real@3f1c28f6
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 38				; 00000026H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 219  :     colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3eb33333
	movss	xmm2, DWORD PTR __real@3edc28f6
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 39				; 00000027H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 220  :     colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR __real@3f666666
	lea	rcx, QWORD PTR $T39[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 40				; 00000028H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 221  :     colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f19999a
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 41				; 00000029H
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 222  :     colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 42				; 0000002aH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 223  :     colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 43				; 0000002bH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 224  :     colors[ImGuiCol_NavHighlight] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f7ae148
	movss	xmm2, DWORD PTR __real@3f170a3d
	movss	xmm1, DWORD PTR __real@3e851eb8
	lea	rcx, QWORD PTR $T43[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 44				; 0000002cH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 225  :     colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T44[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 45				; 0000002dH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 226  :     colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);

	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR __real@3f4ccccd
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 46				; 0000002eH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 227  :     colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f4ccccd
	movss	xmm2, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR __real@3f4ccccd
	lea	rcx, QWORD PTR $T46[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 47				; 0000002fH
	mov	rdx, QWORD PTR colors$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 228  : }

	add	rsp, 840				; 00000348H
	pop	rdi
	pop	rsi
	ret	0
?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsDark
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
??0ImVec4@@QEAA@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT

; 190  : 	ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _z$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _w$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec4@@QEAA@XZ PROC					; ImVec4::ImVec4, COMDAT

; 189  : 	ImVec4() { x = y = z = w = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 175  : 	ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec2@@QEAA@XZ PROC					; ImVec2::ImVec2, COMDAT

; 173  : 	ImVec2() { x = y = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\cmath
;	COMDAT ?round@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?round@@YAMM@Z PROC					; round, COMDAT

; 239  : _NODISCARD _Check_return_ inline float round(_In_ float _Xx) noexcept /* strengthened */ {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 240  : #if _HAS_CMATH_INTRINSICS
; 241  :     return __roundf(_Xx);

	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	roundf

; 242  : #elif defined(__clang__)
; 243  :     return __builtin_roundf(_Xx);
; 244  : #else // ^^^ defined(__clang__) / intrinsics unavailable vvv
; 245  :     return _CSTD roundf(_Xx);
; 246  : #endif // ^^^ intrinsics unavailable ^^^
; 247  : }

	add	rsp, 40					; 00000028H
	ret	0
?round@@YAMM@Z ENDP					; round
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 48
fabsf	PROC						; COMDAT

; 719  :         {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 720  :             return (float)fabs(_X);

	cvtss2sd xmm0, DWORD PTR _X$[rsp]
	call	fabs
	cvtsd2ss xmm0, xmm0

; 721  :         }

	add	rsp, 40					; 00000028H
	ret	0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\malloc.h
;	COMDAT _MallocaComputeSize
_TEXT	SEGMENT
_MarkedSize$ = 0
tv66 = 8
_Size$ = 32
_MallocaComputeSize PROC				; COMDAT

; 104  :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 105  :         size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;

	mov	rax, QWORD PTR _Size$[rsp]
	add	rax, 16
	mov	QWORD PTR _MarkedSize$[rsp], rax

; 106  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	mov	rax, QWORD PTR _Size$[rsp]
	cmp	QWORD PTR _MarkedSize$[rsp], rax
	jbe	SHORT $LN3@MallocaCom
	mov	rax, QWORD PTR _MarkedSize$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@MallocaCom
$LN3@MallocaCom:
	mov	QWORD PTR tv66[rsp], 0
$LN4@MallocaCom:
	mov	rax, QWORD PTR tv66[rsp]

; 107  :     }

	add	rsp, 24
	ret	0
_MallocaComputeSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\malloc.h
;	COMDAT _MarkAllocaS
_TEXT	SEGMENT
_Ptr$ = 8
_Marker$ = 16
_MarkAllocaS PROC					; COMDAT

; 94   :     {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 95   :         if (_Ptr)

	cmp	QWORD PTR _Ptr$[rsp], 0
	je	SHORT $LN2@MarkAlloca

; 96   :         {
; 97   :             *((unsigned int*)_Ptr) = _Marker;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	ecx, DWORD PTR _Marker$[rsp]
	mov	DWORD PTR [rax], ecx

; 98   :             _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	QWORD PTR _Ptr$[rsp], rax
$LN2@MarkAlloca:

; 99   :         }
; 100  :         return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 101  :     }

	ret	0
_MarkAllocaS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _MaxCount$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_s_l

; 1600 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Format$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _MaxCount$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vsnprintf_s
	mov	DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1583 :     }

	add	rsp, 88					; 00000058H
	ret	0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
